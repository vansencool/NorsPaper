From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: vansencool <vansencool@gmail.com>
Date: Sat, 25 Jan 2025 18:06:29 +0530
Subject: [PATCH] Adapt to DynamicObjectArrayList.java, an experimental list


diff --git a/src/main/java/ca/spottedleaf/concurrentutil/collection/MultiThreadedQueue.java b/src/main/java/ca/spottedleaf/concurrentutil/collection/MultiThreadedQueue.java
index f84a622dc29750139ac280f480b7cd132b036287..ace240b3ce80dd45e372e4393810a6f9f4e1f3fd 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/collection/MultiThreadedQueue.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/collection/MultiThreadedQueue.java
@@ -591,7 +591,7 @@ public class MultiThreadedQueue<E> implements Queue<E> {
      */
     @Override
     public Object[] toArray() {
-        final List<E> ret = new ArrayList<>();
+        final List<E> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (LinkedNode<E> curr = this.getHeadOpaque();;) {
             final LinkedNode<E> next = curr.getNextVolatile();
@@ -615,7 +615,7 @@ public class MultiThreadedQueue<E> implements Queue<E> {
      */
     @Override
     public <T> T[] toArray(final T[] array) {
-        final List<T> ret = new ArrayList<>();
+        final List<T> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (LinkedNode<E> curr = this.getHeadOpaque();;) {
             final LinkedNode<E> next = curr.getNextVolatile();
@@ -642,7 +642,7 @@ public class MultiThreadedQueue<E> implements Queue<E> {
     public <T> T[] toArray(final IntFunction<T[]> generator) {
         Validate.notNull(generator, "Null generator");
 
-        final List<T> ret = new ArrayList<>();
+        final List<T> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (LinkedNode<E> curr = this.getHeadOpaque();;) {
             final LinkedNode<E> next = curr.getNextVolatile();
diff --git a/src/main/java/ca/spottedleaf/dataconverter/minecraft/converters/helpers/RenameHelper.java b/src/main/java/ca/spottedleaf/dataconverter/minecraft/converters/helpers/RenameHelper.java
index 28dcc6f1425a46c6c76dd16a67aeab0ec72d1d6a..8a8979ba78248914d7b95c153a2cae94597298f7 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/minecraft/converters/helpers/RenameHelper.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/minecraft/converters/helpers/RenameHelper.java
@@ -22,8 +22,8 @@ public final class RenameHelper {
         for (final String key : data.keys()) {
             final String renamed = renamer.apply(key);
             if (renamed != null) {
-                newKeys = new ArrayList<>();
-                newValues = new ArrayList<>();
+                newKeys = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+                newValues = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 newValues.add(data.getGeneric(key));
                 newKeys.add(renamed);
                 data.remove(key);
diff --git a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/DynamicDataType.java b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/DynamicDataType.java
index dfa750bdaef7d7b6dadbc5665c1461f7e6df08ca..8c456dda35383375098f2843310b7c2e077c0efc 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/DynamicDataType.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/DynamicDataType.java
@@ -13,7 +13,7 @@ public class DynamicDataType extends DataType<Object, Object> {
 
     public final String name;
 
-    protected final ArrayList<DataConverter<Object, Object>> structureConverters = new ArrayList<>();
+    protected final ArrayList<DataConverter<Object, Object>> structureConverters = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     protected final Long2ObjectArraySortedMap<List<DataWalker<Object>>> structureWalkers = new Long2ObjectArraySortedMap<>();
     protected final Long2ObjectArraySortedMap<List<DataHook<Object, Object>>> structureHooks = new Long2ObjectArraySortedMap<>();
 
@@ -33,7 +33,7 @@ public class DynamicDataType extends DataType<Object, Object> {
 
     public void addStructureWalker(final int minVersion, final int versionStep, final DataWalker<Object> walker) {
         this.structureWalkers.computeIfAbsent(DataConverter.encodeVersions(minVersion, versionStep), (final long keyInMap) -> {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }).add(walker);
     }
 
@@ -43,7 +43,7 @@ public class DynamicDataType extends DataType<Object, Object> {
 
     public void addStructureHook(final int minVersion, final int versionStep, final DataHook<Object, Object> hook) {
         this.structureHooks.computeIfAbsent(DataConverter.encodeVersions(minVersion, versionStep), (final long keyInMap) -> {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }).add(hook);
     }
 
diff --git a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/IDDataType.java b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/IDDataType.java
index b093a9eeeea3f7c1c220485b7144d22c6fd504a0..db023e74159f11d594487a5a584be8dc986f3809 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/IDDataType.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/IDDataType.java
@@ -40,7 +40,7 @@ public class IDDataType extends MCDataType {
         this.walkersById.computeIfAbsent(id, (final String keyInMap) -> {
             return new Long2ObjectArraySortedMap<>();
         }).computeIfAbsent(DataConverter.encodeVersions(minVersion, versionStep), (final long keyInMap) -> {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }).add(walker);
     }
 
diff --git a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCDataType.java b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCDataType.java
index 075574f33476882ddc6787e3b8bac8643a414eb0..64eda5ea74745322503e8276d15fba4f953b432d 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCDataType.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCDataType.java
@@ -14,7 +14,7 @@ public class MCDataType extends DataType<MapType<String>, MapType<String>> {
 
     public final String name;
 
-    protected final ArrayList<DataConverter<MapType<String>, MapType<String>>> structureConverters = new ArrayList<>();
+    protected final ArrayList<DataConverter<MapType<String>, MapType<String>>> structureConverters = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     protected final Long2ObjectArraySortedMap<List<DataWalker<MapType<String>>>> structureWalkers = new Long2ObjectArraySortedMap<>();
     protected final Long2ObjectArraySortedMap<List<DataHook<MapType<String>, MapType<String>>>> structureHooks = new Long2ObjectArraySortedMap<>();
 
@@ -34,7 +34,7 @@ public class MCDataType extends DataType<MapType<String>, MapType<String>> {
 
     public void addStructureWalker(final int minVersion, final int versionStep, final DataWalker<MapType<String>> walker) {
         this.structureWalkers.computeIfAbsent(DataConverter.encodeVersions(minVersion, versionStep), (final long keyInMap) -> {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }).add(walker);
     }
 
@@ -44,7 +44,7 @@ public class MCDataType extends DataType<MapType<String>, MapType<String>> {
 
     public void addStructureHook(final int minVersion, final int versionStep, final DataHook<MapType<String>, MapType<String>> hook) {
         this.structureHooks.computeIfAbsent(DataConverter.encodeVersions(minVersion, versionStep), (final long keyInMap) -> {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }).add(hook);
     }
 
diff --git a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCValueType.java b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCValueType.java
index 13c1381261909ef672fbeb665907f01f2d5c1ced..fb8ed93656a450af02005e74b721b46883e809bb 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCValueType.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/minecraft/datatypes/MCValueType.java
@@ -5,6 +5,7 @@ import ca.spottedleaf.dataconverter.converters.datatypes.DataHook;
 import ca.spottedleaf.dataconverter.converters.datatypes.DataType;
 import ca.spottedleaf.dataconverter.minecraft.MCVersionRegistry;
 import ca.spottedleaf.dataconverter.util.Long2ObjectArraySortedMap;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -12,7 +13,7 @@ public class MCValueType extends DataType<Object, Object> {
 
     public final String name;
 
-    protected final ArrayList<DataConverter<Object, Object>> converters = new ArrayList<>();
+    protected final ArrayList<DataConverter<Object, Object>> converters = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     protected final Long2ObjectArraySortedMap<List<DataHook<Object, Object>>> structureHooks = new Long2ObjectArraySortedMap<>();
 
     public MCValueType(final String name) {
@@ -25,7 +26,7 @@ public class MCValueType extends DataType<Object, Object> {
 
     public void addStructureHook(final int minVersion, final int versionStep, final DataHook<Object, Object> hook) {
         this.structureHooks.computeIfAbsent(DataConverter.encodeVersions(minVersion, versionStep), (final long keyInMap) -> {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }).add(hook);
     }
 
diff --git a/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V1506.java b/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V1506.java
index ce87995961605c80f24371c9c64706ae76e3edea..0d10f85195a344426ae4e74e20677cee3f7e0221 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V1506.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/minecraft/versions/V1506.java
@@ -9,7 +9,6 @@ import ca.spottedleaf.dataconverter.types.json.JsonTypeUtil;
 import ca.spottedleaf.dataconverter.types.nbt.NBTMapType;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.serialization.Dynamic;
@@ -18,13 +17,8 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.Tag;
 import net.minecraft.util.GsonHelper;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+
+import java.util.*;
 import java.util.stream.Collectors;
 
 public final class V1506 {
@@ -32,6 +26,7 @@ public final class V1506 {
     private static final int VERSION = MCVersions.V1_13_PRE4 + 2;
 
     static final Map<String, String> MAP = new HashMap<>();
+
     static {
         MAP.put("0", "minecraft:ocean");
         MAP.put("1", "minecraft:plains");
@@ -127,7 +122,7 @@ public final class V1506 {
     private static MapType<String> convert(final String param0) {
         final Dynamic<Tag> dynamic = convert(param0, NbtOps.INSTANCE);
 
-        return new NBTMapType((CompoundTag)dynamic.getValue());
+        return new NBTMapType((CompoundTag) dynamic.getValue());
     }
 
     // Yeah I ain't touching that. This is basically magic value hell.
@@ -170,7 +165,7 @@ public final class V1506 {
                 }
             }
         } else {
-            layers = Lists.newArrayList();
+            layers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             layers.add(Pair.of(1, "minecraft:bedrock"));
             layers.add(Pair.of(2, "minecraft:dirt"));
             layers.add(Pair.of(1, "minecraft:grass_block"));
@@ -200,7 +195,7 @@ public final class V1506 {
     }
 
     private static List<Pair<Integer, String>> getLayersInfoFromString(final String layersString) {
-        final List<Pair<Integer, String>> ret = new ArrayList<>();
+        final List<Pair<Integer, String>> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         final String[] layers = layersString.split(",");
 
         for (final String layerString : layers) {
@@ -215,5 +210,6 @@ public final class V1506 {
         return ret;
     }
 
-    private V1506() {}
+    private V1506() {
+    }
 }
diff --git a/src/main/java/ca/spottedleaf/dataconverter/util/CommandArgumentUpgrader.java b/src/main/java/ca/spottedleaf/dataconverter/util/CommandArgumentUpgrader.java
index 6f2a30eed4e9741a128b5a171edef6abedab7362..e31f7aa4dfc857408f5bc42895820466dbccd361 100644
--- a/src/main/java/ca/spottedleaf/dataconverter/util/CommandArgumentUpgrader.java
+++ b/src/main/java/ca/spottedleaf/dataconverter/util/CommandArgumentUpgrader.java
@@ -101,7 +101,7 @@ public final class CommandArgumentUpgrader {
         final CommandBuildContext context = makeDummyCommandBuildContext();
         this.dispatcher = new CommandDispatcher<>();
         this.context = context;
-        final List<CommandNode<CommandSourceStack>> aliases = new ArrayList<>();
+        final List<CommandNode<CommandSourceStack>> aliases = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final CommandNode<CommandSourceStack> child : dispatcher.getRoot().getChildren()) {
             final CopyResult result = this.copyCommand(this.dispatcher.getRoot(), child, null);
             if (result.replaced()) {
@@ -147,7 +147,7 @@ public final class CommandArgumentUpgrader {
     public static final class ReplacementsBuilder {
         private final Map<Class<?>, BiFunction<ArgumentType<?>, CommandBuildContext, ArgumentType<?>>> replacements =
             new HashMap<>();
-        private final List<Consumer<CommandDispatcher<CommandSourceStack>>> extra = new ArrayList<>();
+        private final List<Consumer<CommandDispatcher<CommandSourceStack>>> extra = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         private ReplacementsBuilder() {
         }
@@ -267,7 +267,7 @@ public final class CommandArgumentUpgrader {
             return command;
         }
         final Map<StringRange, String> replacements = new LinkedHashMap<>();
-        final List<Pair<String, ParsedArgument<CommandSourceStack, ?>>> mergedArguments = new ArrayList<>();
+        final List<Pair<String, ParsedArgument<CommandSourceStack, ?>>> mergedArguments = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         addArguments(mergedArguments, parseResult.getContext());
         for (int i = 0; i < mergedArguments.size(); i++) {
             final Pair<String, ParsedArgument<CommandSourceStack, ?>> pair = mergedArguments.get(i);
@@ -352,13 +352,13 @@ public final class CommandArgumentUpgrader {
         final boolean replaced;
         if (node instanceof LiteralCommandNode<?> literal) {
             if (node.getName().equals("execute") || node.getName().equals("return")) {
-                return new CopyResult(parent, false, new ArrayList<>());
+                return new CopyResult(parent, false, new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
             }
             if (node.getRedirect() != null) {
                 if (result != null) {
                     throw new IllegalStateException("Cannot handle non-root redirects");
                 }
-                final List<CommandNode<CommandSourceStack>> aliases = new ArrayList<>();
+                final List<CommandNode<CommandSourceStack>> aliases = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 aliases.add(node);
                 return new CopyResult(parent, false, aliases);
             }
@@ -390,7 +390,7 @@ public final class CommandArgumentUpgrader {
             throw new UnsupportedOperationException();
         }
         if (result == null) {
-            result = new CopyResult(copy, false, new ArrayList<>());
+            result = new CopyResult(copy, false, new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
         }
         if (replaced) {
             result = result.replacedResult();
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index 7be7963dc0a59ed64ef635a2e94adb6c534a53e8..c02ccb9d4acc0d25684e7039372c1364502c93a2 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -21,12 +21,13 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.entity.Visibility;
 import net.minecraft.world.phys.AABB;
+import org.bukkit.event.entity.EntityRemoveEvent;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.function.Predicate;
-import org.bukkit.event.entity.EntityRemoveEvent;
 
 public final class ChunkEntitySlices {
 
@@ -143,7 +144,7 @@ public final class ChunkEntitySlices {
             return null;
         }
 
-        return saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), (ServerLevel)this.world);
+        return saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), (ServerLevel) this.world);
     }
 
     // returns true if this chunk has transient entities remaining
@@ -202,7 +203,7 @@ public final class ChunkEntitySlices {
     private List<Entity> getAllEntities() {
         final int len = this.entities.size();
         if (len == 0) {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
 
         final Entity[] rawData = this.entities.getRawData();
@@ -222,11 +223,12 @@ public final class ChunkEntitySlices {
         final Entity[] entities = this.entities.getRawData();
         for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
             final Entity entity = entities[i];
-            slices.addEntity(entity, ((ChunkSystemEntity)entity).moonrise$getSectionY());
+            slices.addEntity(entity, ((ChunkSystemEntity) entity).moonrise$getSectionY());
         }
     }
 
     private boolean preventStatusUpdates;
+
     public boolean startPreventingStatusUpdates() {
         final boolean ret = this.preventStatusUpdates;
         this.preventStatusUpdates = true;
@@ -250,7 +252,7 @@ public final class ChunkEntitySlices {
             final Entity entity = entities[i];
 
             final Visibility oldVisibility = EntityLookup.getEntityStatus(entity);
-            ((ChunkSystemEntity)entity).moonrise$setChunkStatus(status);
+            ((ChunkSystemEntity) entity).moonrise$setChunkStatus(status);
             final Visibility newVisibility = EntityLookup.getEntityStatus(entity);
 
             lookup.entityStatusChange(entity, this, oldVisibility, newVisibility, false, false, false);
@@ -261,17 +263,17 @@ public final class ChunkEntitySlices {
         if (!this.entities.add(entity)) {
             return false;
         }
-        ((ChunkSystemEntity)entity).moonrise$setChunkStatus(this.status);
+        ((ChunkSystemEntity) entity).moonrise$setChunkStatus(this.status);
         final int sectionIndex = chunkSection - this.minSection;
 
         this.allEntities.addEntity(entity, sectionIndex);
 
-        if (((ChunkSystemEntity)entity).moonrise$isHardColliding()) {
+        if (((ChunkSystemEntity) entity).moonrise$isHardColliding()) {
             this.hardCollidingEntities.addEntity(entity, sectionIndex);
         }
 
         for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext(); ) {
             final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
 
             if (entry.getKey().isInstance(entity)) {
@@ -294,17 +296,17 @@ public final class ChunkEntitySlices {
         if (!this.entities.remove(entity)) {
             return false;
         }
-        ((ChunkSystemEntity)entity).moonrise$setChunkStatus(null);
+        ((ChunkSystemEntity) entity).moonrise$setChunkStatus(null);
         final int sectionIndex = chunkSection - this.minSection;
 
         this.allEntities.removeEntity(entity, sectionIndex);
 
-        if (((ChunkSystemEntity)entity).moonrise$isHardColliding()) {
+        if (((ChunkSystemEntity) entity).moonrise$isHardColliding()) {
             this.hardCollidingEntities.removeEntity(entity, sectionIndex);
         }
 
         for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext(); ) {
             final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
 
             if (entry.getKey().isInstance(entity)) {
@@ -332,7 +334,7 @@ public final class ChunkEntitySlices {
 
 
     public boolean getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate,
-                            final int maxCount) {
+                               final int maxCount) {
         return this.allEntities.getEntitiesWithEnderDragonPartsLimited(except, box, into, predicate, maxCount);
     }
 
@@ -346,16 +348,16 @@ public final class ChunkEntitySlices {
         final EntityCollectionBySection byType = this.entitiesByType.get(type);
 
         if (byType != null) {
-            byType.getEntities((Entity)null, box, (List)into, (Predicate) predicate);
+            byType.getEntities((Entity) null, box, (List) into, (Predicate) predicate);
         }
     }
 
     public <T extends Entity> boolean getEntities(final EntityType<?> type, final AABB box, final List<? super T> into,
-                                               final Predicate<? super T> predicate, final int maxCount) {
+                                                  final Predicate<? super T> predicate, final int maxCount) {
         final EntityCollectionBySection byType = this.entitiesByType.get(type);
 
         if (byType != null) {
-            return byType.getEntitiesLimited((Entity)null, box, (List)into, (Predicate)predicate, maxCount);
+            return byType.getEntitiesLimited((Entity) null, box, (List) into, (Predicate) predicate, maxCount);
         }
 
         return false;
@@ -388,21 +390,21 @@ public final class ChunkEntitySlices {
                                                final Predicate<? super T> predicate) {
         EntityCollectionBySection collection = this.entitiesByClass.get(clazz);
         if (collection != null) {
-            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
+            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List) into, (Predicate) predicate);
         } else {
             this.entitiesByClass.put(clazz, collection = this.initClass(clazz));
-            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
+            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List) into, (Predicate) predicate);
         }
     }
 
     public <T extends Entity> boolean getEntities(final Class<? extends T> clazz, final Entity except, final AABB box, final List<? super T> into,
-                                               final Predicate<? super T> predicate, final int maxCount) {
+                                                  final Predicate<? super T> predicate, final int maxCount) {
         EntityCollectionBySection collection = this.entitiesByClass.get(clazz);
         if (collection != null) {
-            return collection.getEntitiesWithEnderDragonPartsLimited(except, clazz, box, (List)into, (Predicate)predicate, maxCount);
+            return collection.getEntitiesWithEnderDragonPartsLimited(except, clazz, box, (List) into, (Predicate) predicate, maxCount);
         } else {
             this.entitiesByClass.put(clazz, collection = this.initClass(clazz));
-            return collection.getEntitiesWithEnderDragonPartsLimited(except, clazz, box, (List)into, (Predicate)predicate, maxCount);
+            return collection.getEntitiesWithEnderDragonPartsLimited(except, clazz, box, (List) into, (Predicate) predicate, maxCount);
         }
     }
 
@@ -419,7 +421,7 @@ public final class ChunkEntitySlices {
         }
 
         public BasicEntityList(final int cap) {
-            this.storage = (E[])(cap <= 0 ? EMPTY : new Entity[cap]);
+            this.storage = (E[]) (cap <= 0 ? EMPTY : new Entity[cap]);
         }
 
         public boolean isEmpty() {
@@ -432,7 +434,7 @@ public final class ChunkEntitySlices {
 
         private void resize() {
             if (this.storage == EMPTY) {
-                this.storage = (E[])new Entity[DEFAULT_CAPACITY];
+                this.storage = (E[]) new Entity[DEFAULT_CAPACITY];
             } else {
                 this.storage = Arrays.copyOf(this.storage, this.storage.length * 2);
             }
@@ -642,7 +644,7 @@ public final class ChunkEntitySlices {
                     } // else: continue to test the ender dragon parts
 
                     if (entity instanceof EnderDragon) {
-                        for (final EnderDragonPart part : ((EnderDragon)entity).getSubEntities()) {
+                        for (final EnderDragonPart part : ((EnderDragon) entity).getSubEntities()) {
                             if (part == except || !part.getBoundingBox().intersects(box)) {
                                 continue;
                             }
@@ -696,7 +698,7 @@ public final class ChunkEntitySlices {
                     } // else: continue to test the ender dragon parts
 
                     if (entity instanceof EnderDragon) {
-                        for (final EnderDragonPart part : ((EnderDragon)entity).getSubEntities()) {
+                        for (final EnderDragonPart part : ((EnderDragon) entity).getSubEntities()) {
                             if (part == except || !part.getBoundingBox().intersects(box)) {
                                 continue;
                             }
@@ -752,7 +754,7 @@ public final class ChunkEntitySlices {
                     } // else: continue to test the ender dragon parts
 
                     if (entity instanceof EnderDragon) {
-                        for (final EnderDragonPart part : ((EnderDragon)entity).getSubEntities()) {
+                        for (final EnderDragonPart part : ((EnderDragon) entity).getSubEntities()) {
                             if (part == except || !part.getBoundingBox().intersects(box) || !clazz.isInstance(part)) {
                                 continue;
                             }
@@ -806,7 +808,7 @@ public final class ChunkEntitySlices {
                     } // else: continue to test the ender dragon parts
 
                     if (entity instanceof EnderDragon) {
-                        for (final EnderDragonPart part : ((EnderDragon)entity).getSubEntities()) {
+                        for (final EnderDragonPart part : ((EnderDragon) entity).getSubEntities()) {
                             if (part == except || !part.getBoundingBox().intersects(box) || !clazz.isInstance(part)) {
                                 continue;
                             }
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
index efc0c1acc8239dd7b00211a1d3bfd3fc3b2c810c..9b7fd047441d1b44ffa09387b2a77aa2711fd94f 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/EntityLookup.java
@@ -14,22 +14,13 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
-import net.minecraft.world.level.entity.EntityInLevelCallback;
-import net.minecraft.world.level.entity.EntityTypeTest;
-import net.minecraft.world.level.entity.LevelCallback;
-import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.Visibility;
+import net.minecraft.world.level.entity.*;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.Objects;
-import java.util.UUID;
+
+import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -103,7 +94,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
 
     @Override
     public Entity get(final int id) {
-        return maskNonAccessible(this.entityById.get((long)id));
+        return maskNonAccessible(this.entityById.get((long) id));
     }
 
     @Override
@@ -197,7 +188,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
 
     @Override
     public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AbortableIterationConsumer<U> action) {
-        for (final Iterator<Entity> iterator = this.entityById.valueIterator(); iterator.hasNext();) {
+        for (final Iterator<Entity> iterator = this.entityById.valueIterator(); iterator.hasNext(); ) {
             final Entity entity = iterator.next();
             final Visibility visibility = EntityLookup.getEntityStatus(entity);
             if (!visibility.isAccessible()) {
@@ -212,7 +203,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
 
     @Override
     public void get(final AABB box, final Consumer<Entity> action) {
-        List<Entity> entities = new ArrayList<>();
+        List<Entity> entities = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.getEntitiesWithoutDragonParts(null, box, entities, null);
         for (int i = 0, len = entities.size(); i < len; ++i) {
             action.accept(entities.get(i));
@@ -221,7 +212,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
 
     @Override
     public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AABB box, final AbortableIterationConsumer<U> action) {
-        List<Entity> entities = new ArrayList<>();
+        List<Entity> entities = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.getEntitiesWithoutDragonParts(null, box, entities, null);
         for (int i = 0, len = entities.size(); i < len; ++i) {
             final U casted = filter.tryCast(entities.get(i));
@@ -235,7 +226,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
                                    final boolean created, final boolean destroyed) {
         this.checkThread(entity, "Entity status change must only happen on the main thread");
 
-        if (((ChunkSystemEntity)entity).moonrise$isUpdatingSectionStatus()) {
+        if (((ChunkSystemEntity) entity).moonrise$isUpdatingSectionStatus()) {
             // recursive status update
             LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
             return;
@@ -251,7 +242,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         try {
             final Boolean ticketBlockBefore = this.blockTicketUpdates();
             try {
-                ((ChunkSystemEntity)entity).moonrise$setUpdatingSectionStatus(true);
+                ((ChunkSystemEntity) entity).moonrise$setUpdatingSectionStatus(true);
                 try {
                     if (created) {
                         if (EntityLookup.this.worldCallback != null) {
@@ -318,7 +309,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
                         }
                     }
                 } finally {
-                    ((ChunkSystemEntity)entity).moonrise$setUpdatingSectionStatus(false);
+                    ((ChunkSystemEntity) entity).moonrise$setUpdatingSectionStatus(false);
                 }
             } finally {
                 this.setBlockTicketUpdates(ticketBlockBefore);
@@ -382,7 +373,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             }
 
             this.addRecursivelySafe(entity, fromDisk);
-         }
+        }
     }
 
     public boolean addNewEntity(final Entity entity) {
@@ -393,7 +384,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         if (entity.isAlwaysTicking()) {
             return Visibility.TICKING;
         }
-        final FullChunkStatus entityStatus = ((ChunkSystemEntity)entity).moonrise$getChunkStatus();
+        final FullChunkStatus entityStatus = ((ChunkSystemEntity) entity).moonrise$getChunkStatus();
         return Visibility.fromFullChunkStatus(entityStatus == null ? FullChunkStatus.INACCESSIBLE : entityStatus);
     }
 
@@ -409,7 +400,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             return false;
         }
 
-        if (((ChunkSystemEntity)entity).moonrise$isUpdatingSectionStatus()) {
+        if (((ChunkSystemEntity) entity).moonrise$isUpdatingSectionStatus()) {
             LOGGER.warn("Entity " + entity + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
             return false;
         }
@@ -418,7 +409,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             return false;
         }
 
-        Entity currentlyMapped = this.entityById.putIfAbsent((long)entity.getId(), entity);
+        Entity currentlyMapped = this.entityById.putIfAbsent((long) entity.getId(), entity);
         if (currentlyMapped != null) {
             LOGGER.warn("Entity id already exists: " + entity.getId() + ", mapped to " + currentlyMapped + ", can't add " + entity);
             return false;
@@ -427,14 +418,14 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         currentlyMapped = this.entityByUUID.putIfAbsent(entity.getUUID(), entity);
         if (currentlyMapped != null) {
             // need to remove mapping for id
-            this.entityById.remove((long)entity.getId(), entity);
+            this.entityById.remove((long) entity.getId(), entity);
             LOGGER.warn("Entity uuid already exists: " + entity.getUUID() + ", mapped to " + currentlyMapped + ", can't add " + entity);
             return false;
         }
 
-        ((ChunkSystemEntity)entity).moonrise$setSectionX(sectionX);
-        ((ChunkSystemEntity)entity).moonrise$setSectionY(sectionY);
-        ((ChunkSystemEntity)entity).moonrise$setSectionZ(sectionZ);
+        ((ChunkSystemEntity) entity).moonrise$setSectionX(sectionX);
+        ((ChunkSystemEntity) entity).moonrise$setSectionY(sectionY);
+        ((ChunkSystemEntity) entity).moonrise$setSectionZ(sectionZ);
         final ChunkEntitySlices slices = this.getOrCreateChunk(sectionX, sectionZ);
         if (!slices.addEntity(entity, sectionY)) {
             LOGGER.warn("Entity " + entity + " added to world '" + WorldUtil.getWorldName(this.world) + "', but was already contained in entity chunk (" + sectionX + "," + sectionZ + ")");
@@ -450,20 +441,20 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
     }
 
     public boolean canRemoveEntity(final Entity entity) {
-        if (((ChunkSystemEntity)entity).moonrise$isUpdatingSectionStatus()) {
+        if (((ChunkSystemEntity) entity).moonrise$isUpdatingSectionStatus()) {
             return false;
         }
 
-        final int sectionX = ((ChunkSystemEntity)entity).moonrise$getSectionX();
-        final int sectionZ = ((ChunkSystemEntity)entity).moonrise$getSectionZ();
+        final int sectionX = ((ChunkSystemEntity) entity).moonrise$getSectionX();
+        final int sectionZ = ((ChunkSystemEntity) entity).moonrise$getSectionZ();
         final ChunkEntitySlices slices = this.getChunk(sectionX, sectionZ);
         return slices == null || !slices.isPreventingStatusUpdates();
     }
 
     protected void removeEntity(final Entity entity) {
-        final int sectionX = ((ChunkSystemEntity)entity).moonrise$getSectionX();
-        final int sectionY = ((ChunkSystemEntity)entity).moonrise$getSectionY();
-        final int sectionZ = ((ChunkSystemEntity)entity).moonrise$getSectionZ();
+        final int sectionX = ((ChunkSystemEntity) entity).moonrise$getSectionX();
+        final int sectionY = ((ChunkSystemEntity) entity).moonrise$getSectionY();
+        final int sectionZ = ((ChunkSystemEntity) entity).moonrise$getSectionZ();
         this.checkThread(sectionX, sectionZ, "Cannot remove entity off-main");
         if (!entity.isRemoved()) {
             throw new IllegalStateException("Only call Entity#setRemoved to remove an entity");
@@ -480,9 +471,9 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
                 LOGGER.warn("Failed to remove entity " + entity + " from entity slices (" + sectionX + "," + sectionZ + ")");
             }
         }
-        ((ChunkSystemEntity)entity).moonrise$setSectionX(Integer.MIN_VALUE);
-        ((ChunkSystemEntity)entity).moonrise$setSectionY(Integer.MIN_VALUE);
-        ((ChunkSystemEntity)entity).moonrise$setSectionZ(Integer.MIN_VALUE);
+        ((ChunkSystemEntity) entity).moonrise$setSectionX(Integer.MIN_VALUE);
+        ((ChunkSystemEntity) entity).moonrise$setSectionY(Integer.MIN_VALUE);
+        ((ChunkSystemEntity) entity).moonrise$setSectionZ(Integer.MIN_VALUE);
 
 
         Entity currentlyMapped;
@@ -514,9 +505,9 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         // ensure we own the entity
         this.checkThread(entity, "Cannot move entity off-main");
 
-        final int sectionX = ((ChunkSystemEntity)entity).moonrise$getSectionX();
-        final int sectionY = ((ChunkSystemEntity)entity).moonrise$getSectionY();
-        final int sectionZ = ((ChunkSystemEntity)entity).moonrise$getSectionZ();
+        final int sectionX = ((ChunkSystemEntity) entity).moonrise$getSectionX();
+        final int sectionY = ((ChunkSystemEntity) entity).moonrise$getSectionY();
+        final int sectionZ = ((ChunkSystemEntity) entity).moonrise$getSectionZ();
         final BlockPos newPos = entity.blockPosition();
         final int newSectionX = newPos.getX() >> 4;
         final int newSectionY = Mth.clamp(newPos.getY() >> 4, this.minSection, this.maxSection);
@@ -543,9 +534,9 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
             LOGGER.warn("Could not add entity " + entity + " to its new chunk section (" + newSectionX + "," + newSectionY + "," + newSectionZ + ") as it is already contained in the section");
         }
 
-        ((ChunkSystemEntity)entity).moonrise$setSectionX(newSectionX);
-        ((ChunkSystemEntity)entity).moonrise$setSectionY(newSectionY);
-        ((ChunkSystemEntity)entity).moonrise$setSectionZ(newSectionZ);
+        ((ChunkSystemEntity) entity).moonrise$setSectionX(newSectionX);
+        ((ChunkSystemEntity) entity).moonrise$setSectionY(newSectionY);
+        ((ChunkSystemEntity) entity).moonrise$setSectionZ(newSectionZ);
 
         if (old.isEmpty()) {
             this.onEmptySlices(sectionX, sectionZ);
@@ -710,7 +701,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
                             continue;
                         }
 
-                        chunk.getEntities(type, box, (List)into, (Predicate)predicate);
+                        chunk.getEntities(type, box, (List) into, (Predicate) predicate);
                     }
                 }
             }
@@ -876,7 +867,7 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
                             continue;
                         }
 
-                        if (chunk.getEntities(type, box, (List)into, (Predicate)predicate, maxCount)) {
+                        if (chunk.getEntities(type, box, (List) into, (Predicate) predicate, maxCount)) {
                             return;
                         }
                     }
@@ -1075,9 +1066,11 @@ public abstract class EntityLookup implements LevelEntityGetter<Entity> {
         public static final NoOpCallback INSTANCE = new NoOpCallback();
 
         @Override
-        public void onMove() {}
+        public void onMove() {
+        }
 
         @Override
-        public void onRemove(final Entity.RemovalReason reason) {}
+        public void onRemove(final Entity.RemovalReason reason) {
+        }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
index 7eafc5b7cba23d8dec92ecc1050afe3fd8c9e309..d9c2064e69b8c0e2ff943818b474b1beaceb5fde 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/queue/ChunkUnloadQueue.java
@@ -30,7 +30,7 @@ public final class ChunkUnloadQueue {
     public static record SectionToUnload(int sectionX, int sectionZ, long order, int count) {}
 
     public List<SectionToUnload> retrieveForAllRegions() {
-        final List<SectionToUnload> ret = new ArrayList<>();
+        final List<SectionToUnload> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (final Iterator<ConcurrentLong2ReferenceChainedHashTable.TableEntry<UnloadSection>> iterator = this.unloadSections.entryIterator(); iterator.hasNext();) {
             final ConcurrentLong2ReferenceChainedHashTable.TableEntry<UnloadSection> entry = iterator.next();
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 58d3d1a47e9f2423c467bb329c2d5f4b58a8b5ef..4a83d94b08495d6a4aa09bd1ca955f88f8ee59da 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -112,8 +112,8 @@ public final class ChunkHolderManager {
     public boolean processTicketUpdates(final int posX, final int posZ) {
         final int ticketShift = ThreadedTicketLevelPropagator.SECTION_SHIFT;
         final int ticketMask = (1 << ticketShift) - 1;
-        final List<ChunkProgressionTask> scheduledTasks = new ArrayList<>();
-        final List<NewChunkHolder> changedFullStatus = new ArrayList<>();
+        final List<ChunkProgressionTask> scheduledTasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        final List<NewChunkHolder> changedFullStatus = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         final boolean ret;
         final ReentrantAreaLock.Node ticketLock = this.ticketLockArea.lock(
                             ((posX >> ticketShift) - 1) << ticketShift,
@@ -228,7 +228,7 @@ public final class ChunkHolderManager {
     }
 
     public void autoSave() {
-        final List<NewChunkHolder> reschedule = new ArrayList<>();
+        final List<NewChunkHolder> reschedule = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         final long currentTick = this.currentTick;
         final long maxSaveTime = currentTick - Math.max(1L, this.world.paperConfig().chunks.autoSaveInterval.value());
         final int maxToSave = this.world.paperConfig().chunks.maxAutoSaveChunksPerTick;
@@ -1072,8 +1072,8 @@ public final class ChunkHolderManager {
         int processedCount = 0;
 
         for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
-            final List<NewChunkHolder> stage1 = new ArrayList<>();
-            final List<NewChunkHolder.UnloadState> stage2 = new ArrayList<>();
+            final List<NewChunkHolder> stage1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+            final List<NewChunkHolder.UnloadState> stage2 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             final int sectionLowerX = sectionRef.sectionX() << sectionShift;
             final int sectionLowerZ = sectionRef.sectionZ() << sectionShift;
@@ -1324,9 +1324,9 @@ public final class ChunkHolderManager {
 
         if (this.ticketLevelPropagator.hasPendingUpdates()) {
             if (scheduledTasks == null) {
-                scheduledTasks = new ArrayList<>();
+                scheduledTasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             }
-            changedFullStatus = new ArrayList<>();
+            changedFullStatus = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             ret |= this.ticketLevelPropagator.performUpdates(
                 this.ticketLockArea, this.taskScheduler.schedulingLockArea,
@@ -1357,7 +1357,7 @@ public final class ChunkHolderManager {
 
         boolean ret = false;
 
-        final List<NewChunkHolder> changedFullStatus = new ArrayList<>();
+        final List<NewChunkHolder> changedFullStatus = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         NewChunkHolder holder;
         while ((holder = pendingFullLoadUpdate.poll()) != null) {
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
index 85b0e17758a40f799256445dda617c9dd60c82a3..b330936f02a1abb1e8943e80688b64fe48e53cda 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
@@ -507,7 +507,7 @@ public final class ChunkTaskScheduler {
         final int accessRadius = getAccessRadius(toStatus);
         final long chunkKey = CoordinateUtils.getChunkKey(chunkX, chunkZ);
         final int minLevel = ChunkTaskScheduler.getTicketLevel(toStatus);
-        final List<ChunkProgressionTask> tasks = new ArrayList<>();
+        final List<ChunkProgressionTask> tasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         final ReentrantAreaLock.Node ticketLock = this.chunkHolderManager.ticketLockArea.lock(chunkX, chunkZ, accessRadius); // Folia - use area based lock to reduce contention
         try {
             final ReentrantAreaLock.Node schedulingLock = this.schedulingLockArea.lock(chunkX, chunkZ, accessRadius); // Folia - use area based lock to reduce contention
@@ -619,7 +619,7 @@ public final class ChunkTaskScheduler {
             }
         };
 
-        final List<ChunkProgressionTask> tasks = new ArrayList<>();
+        final List<ChunkProgressionTask> tasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         final boolean scheduled;
         final ChunkAccess chunk;
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
index 45eda96fd8a1acb87dbb69ce5495fec7e451416f..f1d839d5ffa0953d04d4a650218e8d8327c6b277 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -6,10 +6,10 @@ import ca.spottedleaf.concurrentutil.executor.standard.DelayedPrioritisedTask;
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
 import ca.spottedleaf.concurrentutil.lock.ReentrantAreaLock;
 import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
+import ca.spottedleaf.moonrise.common.util.ChunkSystem;
 import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
 import ca.spottedleaf.moonrise.common.util.TickThread;
 import ca.spottedleaf.moonrise.common.util.WorldUtil;
-import ca.spottedleaf.moonrise.common.util.ChunkSystem;
 import ca.spottedleaf.moonrise.patches.chunk_system.ChunkSystemFeatures;
 import ca.spottedleaf.moonrise.patches.chunk_system.async_save.AsyncChunkSaveData;
 import ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread;
@@ -22,11 +22,7 @@ import ca.spottedleaf.moonrise.patches.chunk_system.level.poi.PoiChunk;
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.task.ChunkLoadTask;
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.task.ChunkProgressionTask;
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.task.GenericDataLoadTask;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonNull;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
+import com.google.gson.*;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
@@ -45,12 +41,9 @@ import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+
 import java.lang.invoke.VarHandle;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
+import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
@@ -88,13 +81,13 @@ public final class NewChunkHolder {
 
             if (this.entityChunk == null) {
                 ret = this.entityChunk = new ChunkEntitySlices(
-                    this.world, this.chunkX, this.chunkZ, this.getChunkStatus(),
-                    WorldUtil.getMinSection(this.world), WorldUtil.getMaxSection(this.world)
+                        this.world, this.chunkX, this.chunkZ, this.getChunkStatus(),
+                        WorldUtil.getMinSection(this.world), WorldUtil.getMaxSection(this.world)
                 );
 
                 ret.setTransient(transientChunk);
 
-                ((ChunkSystemServerLevel)this.world).moonrise$getEntityLookup().entitySectionLoad(this.chunkX, this.chunkZ, ret);
+                ((ChunkSystemServerLevel) this.world).moonrise$getEntityLookup().entitySectionLoad(this.chunkX, this.chunkZ, ret);
             } else {
                 // transientChunk = false here
                 ret = this.entityChunk;
@@ -115,7 +108,7 @@ public final class NewChunkHolder {
             if (entityChunk != null) {
                 final List<Entity> entities = ChunkEntitySlices.readEntities(this.world, entityChunk);
 
-                ((ChunkSystemServerLevel)this.world).moonrise$getEntityLookup().addEntityChunkEntities(entities, new ChunkPos(this.chunkX, this.chunkZ));
+                ((ChunkSystemServerLevel) this.world).moonrise$getEntityLookup().addEntityChunkEntities(entities, new ChunkPos(this.chunkX, this.chunkZ));
             }
         }
 
@@ -173,7 +166,7 @@ public final class NewChunkHolder {
                     // no tasks to schedule _for_
                 } else {
                     entityDataLoadTask = this.entityDataLoadTask = new ChunkLoadTask.EntityDataLoadTask(
-                        this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
+                            this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
                     );
                     entityDataLoadTask.addCallback(this::completeEntityLoad);
                     // need one schedule() per waiter
@@ -216,14 +209,14 @@ public final class NewChunkHolder {
             throw new IllegalStateException("Must hold scheduling lock");
         }
 
-        final GenericDataLoadTaskCallback ret = new EntityDataLoadTaskCallback((Consumer)consumer, this);
+        final GenericDataLoadTaskCallback ret = new EntityDataLoadTaskCallback((Consumer) consumer, this);
 
         if (this.entityDataLoadTask == null) {
             this.entityDataLoadTask = new ChunkLoadTask.EntityDataLoadTask(
-                this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
+                    this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
             );
             this.entityDataLoadTask.addCallback(this::completeEntityLoad);
-            this.entityDataLoadTaskWaiters = new ArrayList<>();
+            this.entityDataLoadTaskWaiters = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
         this.entityDataLoadTaskWaiters.add(ret);
         if (this.entityDataLoadTask.schedule(true)) {
@@ -294,7 +287,7 @@ public final class NewChunkHolder {
                     // no tasks to schedule _for_
                 } else {
                     poiDataLoadTask = this.poiDataLoadTask = new ChunkLoadTask.PoiDataLoadTask(
-                        this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
+                            this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
                     );
                     poiDataLoadTask.addCallback(this::completePoiLoad);
                     // need one schedule() per waiter
@@ -336,14 +329,14 @@ public final class NewChunkHolder {
             throw new IllegalStateException("Must hold scheduling lock");
         }
 
-        final GenericDataLoadTaskCallback ret = new PoiDataLoadTaskCallback((Consumer)consumer, this);
+        final GenericDataLoadTaskCallback ret = new PoiDataLoadTaskCallback((Consumer) consumer, this);
 
         if (this.poiDataLoadTask == null) {
             this.poiDataLoadTask = new ChunkLoadTask.PoiDataLoadTask(
-                this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
+                    this.scheduler, this.world, this.chunkX, this.chunkZ, this.getEffectivePriority(PrioritisedExecutor.Priority.NORMAL)
             );
             this.poiDataLoadTask.addCallback(this::completePoiLoad);
-            this.poiDataLoadTaskWaiters = new ArrayList<>();
+            this.poiDataLoadTaskWaiters = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
         this.poiDataLoadTaskWaiters.add(ret);
         if (this.poiDataLoadTask.schedule(true)) {
@@ -455,7 +448,9 @@ public final class NewChunkHolder {
     // This allows lockless access to the chunk and last gen status
     private static final ChunkStatus[] ALL_STATUSES = ChunkStatus.getStatusList().toArray(new ChunkStatus[0]);
 
-    public static final record ChunkCompletion(ChunkAccess chunk, ChunkStatus genStatus) {};
+    public static final record ChunkCompletion(ChunkAccess chunk, ChunkStatus genStatus) {
+    }
+
     private static final VarHandle CHUNK_COMPLETION_ARRAY_HANDLE = ConcurrentUtil.getArrayHandle(ChunkCompletion[].class);
     private final ChunkCompletion[] chunkCompletions = new ChunkCompletion[ALL_STATUSES.length];
 
@@ -466,7 +461,7 @@ public final class NewChunkHolder {
     }
 
     public ChunkAccess getChunkIfPresentUnchecked(final ChunkStatus status) {
-        final ChunkCompletion completion = (ChunkCompletion)CHUNK_COMPLETION_ARRAY_HANDLE.getVolatile(this.chunkCompletions, status.getIndex());
+        final ChunkCompletion completion = (ChunkCompletion) CHUNK_COMPLETION_ARRAY_HANDLE.getVolatile(this.chunkCompletions, status.getIndex());
         return completion == null ? null : completion.chunk;
     }
 
@@ -650,7 +645,7 @@ public final class NewChunkHolder {
                 new ChunkPos(chunkX, chunkZ), ChunkHolderManager.MAX_TICKET_LEVEL, world,
                 world.getLightEngine(), null, world.getChunkSource().chunkMap
         );
-        ((ChunkSystemChunkHolder)this.vanillaChunkHolder).moonrise$setRealChunkHolder(this);
+        ((ChunkSystemChunkHolder) this.vanillaChunkHolder).moonrise$setRealChunkHolder(this);
     }
 
     public ChunkAccess getCurrentChunk() {
@@ -747,7 +742,9 @@ public final class NewChunkHolder {
         return null;
     }
 
-    /** Unloaded from chunk map */
+    /**
+     * Unloaded from chunk map
+     */
     private boolean unloaded;
 
     void markUnloaded() {
@@ -780,7 +777,9 @@ public final class NewChunkHolder {
         }
     }
 
-    static final record UnloadState(NewChunkHolder holder, ChunkAccess chunk, ChunkEntitySlices entityChunk, PoiChunk poiChunk) {};
+    static final record UnloadState(NewChunkHolder holder, ChunkAccess chunk, ChunkEntitySlices entityChunk,
+                                    PoiChunk poiChunk) {
+    }
 
     // note: these are completed with null to indicate that no write occurred
     // they are also completed with null to indicate a null write occurred
@@ -788,7 +787,8 @@ public final class NewChunkHolder {
     private UnloadTask entityDataUnload;
     private UnloadTask poiDataUnload;
 
-    public static final record UnloadTask(Completable<CompoundTag> completable, DelayedPrioritisedTask task) {}
+    public static final record UnloadTask(Completable<CompoundTag> completable, DelayedPrioritisedTask task) {
+    }
 
     public UnloadTask getUnloadTask(final RegionFileIOThread.RegionFileType type) {
         switch (type) {
@@ -838,7 +838,7 @@ public final class NewChunkHolder {
         this.currentGenStatus = null;
         this.lastChunkCompletion = null;
         for (int i = 0; i < this.chunkCompletions.length; ++i) {
-            CHUNK_COMPLETION_ARRAY_HANDLE.setVolatile(this.chunkCompletions, i, (ChunkCompletion)null);
+            CHUNK_COMPLETION_ARRAY_HANDLE.setVolatile(this.chunkCompletions, i, (ChunkCompletion) null);
         }
         // entity chunk state
         this.entityChunk = null;
@@ -921,7 +921,7 @@ public final class NewChunkHolder {
                     this.scheduler.schedulingLockArea.unlock(schedulingLock);
                 }
             } else {
-                ((ChunkSystemServerLevel)this.world).moonrise$getEntityLookup().entitySectionUnload(this.chunkX, this.chunkZ);
+                ((ChunkSystemServerLevel) this.world).moonrise$getEntityLookup().entitySectionUnload(this.chunkX, this.chunkZ);
             }
             // we need to delay the callback until after determining transience, otherwise a potential loader could
             // set entityChunk before we do
@@ -937,7 +937,7 @@ public final class NewChunkHolder {
             }
 
             if (poiChunk.isLoaded()) {
-                ((ChunkSystemPoiManager)this.world.getPoiManager()).moonrise$onUnload(CoordinateUtils.getChunkKey(this.chunkX, this.chunkZ));
+                ((ChunkSystemPoiManager) this.world.getPoiManager()).moonrise$onUnload(CoordinateUtils.getChunkKey(this.chunkX, this.chunkZ));
             }
         }
     }
@@ -1005,7 +1005,7 @@ public final class NewChunkHolder {
                 this.requestedGenStatus = null;
                 this.cancelGenTask();
             } else {
-                final ChunkStatus toCancel = ((ChunkSystemChunkStatus)maxGenerationStatusNew).moonrise$getNextStatus();
+                final ChunkStatus toCancel = ((ChunkSystemChunkStatus) maxGenerationStatusNew).moonrise$getNextStatus();
                 final ChunkStatus currentRequestedStatus = this.requestedGenStatus;
 
                 if (currentRequestedStatus.isOrAfter(toCancel)) {
@@ -1038,7 +1038,7 @@ public final class NewChunkHolder {
                             this.requestedGenStatus = ChunkStatus.FULL;
                         } else {
                             this.scheduler.schedule(
-                                this.chunkX, this.chunkZ, ChunkStatus.FULL, this, scheduledTasks
+                                    this.chunkX, this.chunkZ, ChunkStatus.FULL, this, scheduledTasks
                             );
                         }
                     }
@@ -1076,6 +1076,7 @@ public final class NewChunkHolder {
         // optimised variant of the above by moving some of the ops to compile time
         return relativeX + (relativeZ * (NEIGHBOUR_RADIUS * 2 + 1)) + (NEIGHBOUR_RADIUS + NEIGHBOUR_RADIUS * ((NEIGHBOUR_RADIUS * 2 + 1)));
     }
+
     public final boolean isNeighbourFullLoaded(final int relativeX, final int relativeZ) {
         return (this.fullNeighbourChunksLoadedBitset & (1L << getFullNeighbourIndex(relativeX, relativeZ))) != 0;
     }
@@ -1213,7 +1214,7 @@ public final class NewChunkHolder {
     }
 
     private void changeEntityChunkStatus(final FullChunkStatus toStatus) {
-        ((ChunkSystemServerLevel)this.world).moonrise$getEntityLookup().chunkStatusChange(this.chunkX, this.chunkZ, toStatus);
+        ((ChunkSystemServerLevel) this.world).moonrise$getEntityLookup().chunkStatusChange(this.chunkX, this.chunkZ, toStatus);
     }
 
     private boolean processingFullStatus = false;
@@ -1235,7 +1236,7 @@ public final class NewChunkHolder {
 
         this.processingFullStatus = true;
         try {
-            for (;;) {
+            for (; ; ) {
                 // check if we have any remaining work to do
 
                 // we do not need to hold the scheduling lock to read pending, as changes to pending
@@ -1264,7 +1265,7 @@ public final class NewChunkHolder {
 
                 // chunks cannot downgrade state while status is pending a change
                 // note: currentChunk must be LevelChunk, as current != pending which means that at least one is not ACCESSIBLE
-                final LevelChunk chunk = (LevelChunk)this.currentChunk;
+                final LevelChunk chunk = (LevelChunk) this.currentChunk;
 
                 // Note: we assume that only load/unload contain plugin logic
                 // plugin logic is anything stupid enough to possibly change the chunk status while it is already
@@ -1366,7 +1367,7 @@ public final class NewChunkHolder {
         // need to tell future statuses to complete if cancelled
         do {
             this.completeStatusConsumers0(status, chunk);
-        } while (chunk == null && status != (status = ((ChunkSystemChunkStatus)status).moonrise$getNextStatus()));
+        } while (chunk == null && status != (status = ((ChunkSystemChunkStatus) status).moonrise$getNextStatus()));
     }
 
     private void completeStatusConsumers0(final ChunkStatus status, final ChunkAccess chunk) {
@@ -1441,7 +1442,7 @@ public final class NewChunkHolder {
             if (requestedGenStatus != null) {
                 // it looks like it has been requested, so we must reschedule
                 if (!this.neighboursWaitingForUs.isEmpty()) {
-                    for (final Iterator<Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus>> iterator = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+                    for (final Iterator<Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus>> iterator = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext(); ) {
                         final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry = iterator.next();
 
                         final NewChunkHolder chunkHolder = entry.getKey();
@@ -1463,7 +1464,7 @@ public final class NewChunkHolder {
 
                 // note: only after generationTask -> null, generationTaskStatus -> null, and requestedGenStatus -> null
                 this.scheduler.schedule(
-                    this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
+                        this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
                 );
 
                 // return, can't do anything further
@@ -1498,7 +1499,7 @@ public final class NewChunkHolder {
         List<NewChunkHolder> needsScheduling = null;
         boolean recalculatePriority = false;
         for (final Iterator<Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus>> iterator
-             = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
+             = this.neighboursWaitingForUs.reference2ObjectEntrySet().fastIterator(); iterator.hasNext(); ) {
             final Reference2ObjectMap.Entry<NewChunkHolder, ChunkStatus> entry = iterator.next();
             final NewChunkHolder neighbour = entry.getKey();
             final ChunkStatus requiredStatus = entry.getValue();
@@ -1528,7 +1529,7 @@ public final class NewChunkHolder {
             if (neighbour.neighboursBlockingGenTask.isEmpty()) {
                 if (neighbour.requestedGenStatus != null) {
                     if (needsScheduling == null) {
-                        needsScheduling = new ArrayList<>();
+                        needsScheduling = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                     }
                     needsScheduling.add(neighbour);
                 } else {
@@ -1557,7 +1558,7 @@ public final class NewChunkHolder {
 
             // we need to schedule more tasks now
             this.scheduler.schedule(
-                this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
+                    this.chunkX, this.chunkZ, requestedGenStatus, this, scheduleList
             );
         } else {
             // we're done now
@@ -1578,7 +1579,7 @@ public final class NewChunkHolder {
                 final NewChunkHolder neighbour = needsScheduling.get(i);
 
                 this.scheduler.schedule(
-                    neighbour.chunkX, neighbour.chunkZ, neighbour.requestedGenStatus, neighbour, scheduleList
+                        neighbour.chunkX, neighbour.chunkZ, neighbour.requestedGenStatus, neighbour, scheduleList
                 );
             }
         }
@@ -1604,7 +1605,7 @@ public final class NewChunkHolder {
         generationTask.onComplete((final ChunkAccess access, final Throwable thr) -> {
             if (generationTask != this.generationTask) {
                 throw new IllegalStateException(
-                    "Cannot complete generation task '" + generationTask + "' because we are waiting on '" + this.generationTask + "' instead!"
+                        "Cannot complete generation task '" + generationTask + "' because we are waiting on '" + this.generationTask + "' instead!"
                 );
             }
             if (thr != null) {
@@ -1620,8 +1621,8 @@ public final class NewChunkHolder {
                 this.genTaskFailedThread = Thread.currentThread();
 
                 this.scheduler.unrecoverableChunkSystemFailure(this.chunkX, this.chunkZ, Map.of(
-                    "Generation task", ChunkTaskScheduler.stringIfNull(generationTask),
-                    "Task to status", ChunkTaskScheduler.stringIfNull(taskStatus)
+                        "Generation task", ChunkTaskScheduler.stringIfNull(generationTask),
+                        "Task to status", ChunkTaskScheduler.stringIfNull(taskStatus)
                 ), thr);
                 return;
             }
@@ -1630,13 +1631,13 @@ public final class NewChunkHolder {
             List<ChunkProgressionTask> tasks = ChunkHolderManager.getCurrentTicketUpdateScheduling();
             if (tasks == null) {
                 scheduleTasks = true;
-                tasks = new ArrayList<>();
+                tasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             } else {
                 scheduleTasks = false;
                 // we are currently updating ticket levels, so we already hold the schedule lock
                 // this means we have to leave the ticket level update to handle the scheduling
             }
-            final List<NewChunkHolder> changedLoadStatus = new ArrayList<>();
+            final List<NewChunkHolder> changedLoadStatus = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             // theoretically, we could schedule a chunk at the max radius which performs another max radius access. So we need to double the radius.
             final ReentrantAreaLock.Node schedulingLock = this.scheduler.schedulingLockArea.lock(this.chunkX, this.chunkZ, 2 * ChunkTaskScheduler.getMaxAccessRadius());
             try {
@@ -1668,7 +1669,8 @@ public final class NewChunkHolder {
 
     public long lastAutoSave;
 
-    public static final record SaveStat(boolean savedChunk, boolean savedEntityChunk, boolean savedPoiChunk) {}
+    public static final record SaveStat(boolean savedChunk, boolean savedEntityChunk, boolean savedPoiChunk) {
+    }
 
     public SaveStat save(final boolean shutdown) {
         TickThread.ensureTickThread(this.world, this.chunkX, this.chunkZ, "Cannot save data off-main");
@@ -1717,7 +1719,7 @@ public final class NewChunkHolder {
             }
         }
 
-        return executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI ? new SaveStat(executedUnloadTask || canSaveChunk, canSaveEntities, canSavePOI): null;
+        return executedUnloadTask | canSaveChunk | canSaveEntities | canSavePOI ? new SaveStat(executedUnloadTask || canSaveChunk, canSaveEntities, canSavePOI) : null;
     }
 
     static final class AsyncChunkSerializeTask implements Runnable {
@@ -1743,7 +1745,7 @@ public final class NewChunkHolder {
             } catch (final Throwable throwable) {
                 LOGGER.error("Failed to asynchronously save chunk " + this.chunk.getPos() + " for world '" + WorldUtil.getWorldName(this.world) + "', falling back to synchronous save", throwable);
                 final ChunkPos pos = this.chunk.getPos();
-                ((ChunkSystemServerLevel)this.world).moonrise$getChunkTaskScheduler().scheduleChunkTask(pos.x, pos.z, () -> {
+                ((ChunkSystemServerLevel) this.world).moonrise$getChunkTaskScheduler().scheduleChunkTask(pos.x, pos.z, () -> {
                     final CompoundTag synchronousSave;
                     try {
                         synchronousSave = ChunkSystemFeatures.saveChunkAsync(AsyncChunkSerializeTask.this.world, AsyncChunkSerializeTask.this.chunk, AsyncChunkSerializeTask.this.asyncSaveData);
@@ -1765,8 +1767,8 @@ public final class NewChunkHolder {
         @Override
         public String toString() {
             return "AsyncChunkSerializeTask{" +
-                "chunk={pos=" + this.chunk.getPos() + ",world=\"" + WorldUtil.getWorldName(this.world) + "\"}" +
-                "}";
+                    "chunk={pos=" + this.chunk.getPos() + ",world=\"" + WorldUtil.getWorldName(this.world) + "\"}" +
+                    "}";
         }
     }
 
@@ -1824,6 +1826,7 @@ public final class NewChunkHolder {
 
     private boolean lastEntitySaveNull;
     private CompoundTag lastEntityUnload;
+
     private boolean saveEntities(final ChunkEntitySlices entities, final boolean unloading) {
         try {
             CompoundTag mergeFrom = null;
@@ -1866,6 +1869,7 @@ public final class NewChunkHolder {
     }
 
     private boolean lastPoiSaveNull;
+
     private boolean savePOI(final PoiChunk poi, final boolean unloading) {
         try {
             final CompoundTag save = poi.save();
@@ -1896,28 +1900,28 @@ public final class NewChunkHolder {
         final FullChunkStatus pendingFullStatus = this.pendingFullChunkStatus;
         final FullChunkStatus currentFullStatus = this.currentFullChunkStatus;
         return "NewChunkHolder{" +
-            "world=" + WorldUtil.getWorldName(this.world) +
-            ", chunkX=" + this.chunkX +
-            ", chunkZ=" + this.chunkZ +
-            ", entityChunkFromDisk=" + (entityChunk != null && !entityChunk.isTransient()) +
-            ", lastChunkCompletion={chunk_class=" + (lastCompletion == null || lastCompletion.chunk() == null ? "null" : lastCompletion.chunk().getClass().getName()) + ",status=" + (lastCompletion == null ? "null" : lastCompletion.genStatus()) + "}" +
-            ", currentGenStatus=" + this.currentGenStatus +
-            ", requestedGenStatus=" + this.requestedGenStatus +
-            ", generationTask=" + this.generationTask +
-            ", generationTaskStatus=" + this.generationTaskStatus +
-            ", priority=" + this.priority +
-            ", priorityLocked=" + this.priorityLocked +
-            ", neighbourRequestedPriority=" + this.neighbourRequestedPriority +
-            ", effective_priority=" + this.getEffectivePriority(null) +
-            ", oldTicketLevel=" + this.oldTicketLevel +
-            ", currentTicketLevel=" + this.currentTicketLevel +
-            ", totalNeighboursUsingThisChunk=" + this.totalNeighboursUsingThisChunk +
-            ", fullNeighbourChunksLoadedBitset=" + this.fullNeighbourChunksLoadedBitset +
-            ", currentChunkStatus=" + currentFullStatus +
-            ", pendingChunkStatus=" + pendingFullStatus +
-            ", is_unload_safe=" + this.isSafeToUnload() +
-            ", killed=" + this.unloaded +
-            '}';
+                "world=" + WorldUtil.getWorldName(this.world) +
+                ", chunkX=" + this.chunkX +
+                ", chunkZ=" + this.chunkZ +
+                ", entityChunkFromDisk=" + (entityChunk != null && !entityChunk.isTransient()) +
+                ", lastChunkCompletion={chunk_class=" + (lastCompletion == null || lastCompletion.chunk() == null ? "null" : lastCompletion.chunk().getClass().getName()) + ",status=" + (lastCompletion == null ? "null" : lastCompletion.genStatus()) + "}" +
+                ", currentGenStatus=" + this.currentGenStatus +
+                ", requestedGenStatus=" + this.requestedGenStatus +
+                ", generationTask=" + this.generationTask +
+                ", generationTaskStatus=" + this.generationTaskStatus +
+                ", priority=" + this.priority +
+                ", priorityLocked=" + this.priorityLocked +
+                ", neighbourRequestedPriority=" + this.neighbourRequestedPriority +
+                ", effective_priority=" + this.getEffectivePriority(null) +
+                ", oldTicketLevel=" + this.oldTicketLevel +
+                ", currentTicketLevel=" + this.currentTicketLevel +
+                ", totalNeighboursUsingThisChunk=" + this.totalNeighboursUsingThisChunk +
+                ", fullNeighbourChunksLoadedBitset=" + this.fullNeighbourChunksLoadedBitset +
+                ", currentChunkStatus=" + currentFullStatus +
+                ", pendingChunkStatus=" + pendingFullStatus +
+                ", is_unload_safe=" + this.isSafeToUnload() +
+                ", killed=" + this.unloaded +
+                '}';
     }
 
     private static JsonElement serializeStacktraceElement(final StackTraceElement element) {
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java
index 310a8f80debadd64c2d962ebf83b7d0505ce6e42..6a428fa064391118ac99e5d5507276730c87be56 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ThreadedTicketLevelPropagator.java
@@ -469,7 +469,7 @@ public abstract class ThreadedTicketLevelPropagator {
         }
 
         public UpdateQueueNode acquireNextOrWait(final long maxOrder) {
-            final List<UpdateQueueNode> blocking = new ArrayList<>();
+            final List<UpdateQueueNode> blocking = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             node_search:
             for (UpdateQueueNode curr = this.peek(); curr != null && curr.order <= maxOrder; curr = curr.getNextVolatile()) {
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/executor/RadiusAwarePrioritisedExecutor.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/executor/RadiusAwarePrioritisedExecutor.java
index e0b26ccb63596748b80fc6a5e47e373ba811ba8b..f5c890f1a977d4cac520dcce4da460f70d448621 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/executor/RadiusAwarePrioritisedExecutor.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/executor/RadiusAwarePrioritisedExecutor.java
@@ -5,7 +5,6 @@ import ca.spottedleaf.moonrise.common.util.CoordinateUtils;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 
-import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
 import java.util.PriorityQueue;
@@ -212,7 +211,7 @@ public class RadiusAwarePrioritisedExecutor {
                         if (parents.add(dependency)) {
                             // added a dependency, so we need to add as a child to the dependency
                             if (dependency.children == null) {
-                                dependency.children = new ArrayList<>();
+                                dependency.children = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                             }
                             dependency.children.add(node);
                         }
@@ -263,7 +262,7 @@ public class RadiusAwarePrioritisedExecutor {
             PrioritisedExecutor.PrioritisedTask pushedTask;
             while ((pushedTask = this.tryPushTask()) != null) {
                 if (ret == null) {
-                    ret = new ArrayList<>();
+                    ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 }
                 ret.add(pushedTask);
             }
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/BlockStarLightEngine.java b/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/BlockStarLightEngine.java
index 154443ac1ee1d6d18b8ff0f40a307d638b213aeb..f51ef7c2cb6bf7889587729ef3179433d9687f80 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/BlockStarLightEngine.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/BlockStarLightEngine.java
@@ -200,7 +200,7 @@ public final class BlockStarLightEngine extends StarLightEngine {
     }
 
     protected List<BlockPos> getSources(final LightChunkGetter lightAccess, final ChunkAccess chunk) {
-        final List<BlockPos> sources = new ArrayList<>();
+        final List<BlockPos> sources = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         final int offX = chunk.getPos().x << 4;
         final int offZ = chunk.getPos().z << 4;
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightEngine.java b/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightEngine.java
index 382c9e445af0d6ad2428fc22d0f63017c58191e2..df908a85cb8effb7e05554c8a49fd195098d4b95 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightEngine.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightEngine.java
@@ -10,11 +10,7 @@ import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.SectionPos;
-import net.minecraft.world.level.BlockGetter;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.LevelHeightAccessor;
-import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.*;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkAccess;
@@ -22,7 +18,7 @@ import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.LightChunkGetter;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
-import java.util.ArrayList;
+
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
@@ -35,7 +31,7 @@ public abstract class StarLightEngine {
 
     protected static final AxisDirection[] DIRECTIONS = AxisDirection.values();
     protected static final AxisDirection[] AXIS_DIRECTIONS = DIRECTIONS;
-    protected static final AxisDirection[] ONLY_HORIZONTAL_DIRECTIONS = new AxisDirection[] {
+    protected static final AxisDirection[] ONLY_HORIZONTAL_DIRECTIONS = new AxisDirection[]{
             AxisDirection.POSITIVE_X, AxisDirection.NEGATIVE_X,
             AxisDirection.POSITIVE_Z, AxisDirection.NEGATIVE_Z
     };
@@ -48,9 +44,12 @@ public abstract class StarLightEngine {
         POSITIVE_Y(0, 1, 0), NEGATIVE_Y(0, -1, 0);
 
         static {
-            POSITIVE_X.opposite = NEGATIVE_X; NEGATIVE_X.opposite = POSITIVE_X;
-            POSITIVE_Z.opposite = NEGATIVE_Z; NEGATIVE_Z.opposite = POSITIVE_Z;
-            POSITIVE_Y.opposite = NEGATIVE_Y; NEGATIVE_Y.opposite = POSITIVE_Y;
+            POSITIVE_X.opposite = NEGATIVE_X;
+            NEGATIVE_X.opposite = POSITIVE_X;
+            POSITIVE_Z.opposite = NEGATIVE_Z;
+            NEGATIVE_Z.opposite = POSITIVE_Z;
+            POSITIVE_Y.opposite = NEGATIVE_Y;
+            NEGATIVE_Y.opposite = POSITIVE_Y;
         }
 
         protected AxisDirection opposite;
@@ -67,9 +66,9 @@ public abstract class StarLightEngine {
             this.y = y;
             this.z = z;
             this.nms = Direction.fromDelta(x, y, z);
-            this.everythingButThisDirection = (long)(ALL_DIRECTIONS_BITSET ^ (1 << this.ordinal()));
+            this.everythingButThisDirection = (long) (ALL_DIRECTIONS_BITSET ^ (1 << this.ordinal()));
             // positive is always even, negative is always odd. Flip the 1 bit to get the negative direction.
-            this.everythingButTheOppositeDirection = (long)(ALL_DIRECTIONS_BITSET ^ (1 << (this.ordinal() ^ 1)));
+            this.everythingButTheOppositeDirection = (long) (ALL_DIRECTIONS_BITSET ^ (1 << (this.ordinal() ^ 1)));
         }
 
         public AxisDirection getOpposite() {
@@ -184,7 +183,7 @@ public abstract class StarLightEngine {
                 final int cx = centerChunkX + dx;
                 final int cz = centerChunkZ + dz;
                 final boolean isTwoRadius = Math.max(IntegerUtil.branchlessAbs(dx), IntegerUtil.branchlessAbs(dz)) == 2;
-                final ChunkAccess chunk = (ChunkAccess)chunkProvider.getChunkForLighting(cx, cz);
+                final ChunkAccess chunk = (ChunkAccess) chunkProvider.getChunkForLighting(cx, cz);
 
                 if (chunk == null) {
                     if (relaxed | isTwoRadius) {
@@ -208,19 +207,19 @@ public abstract class StarLightEngine {
     }
 
     protected final ChunkAccess getChunkInCache(final int chunkX, final int chunkZ) {
-        return this.chunkCache[chunkX + 5*chunkZ + this.chunkIndexOffset];
+        return this.chunkCache[chunkX + 5 * chunkZ + this.chunkIndexOffset];
     }
 
     protected final void setChunkInCache(final int chunkX, final int chunkZ, final ChunkAccess chunk) {
-        this.chunkCache[chunkX + 5*chunkZ + this.chunkIndexOffset] = chunk;
+        this.chunkCache[chunkX + 5 * chunkZ + this.chunkIndexOffset] = chunk;
     }
 
     protected final LevelChunkSection getChunkSection(final int chunkX, final int chunkY, final int chunkZ) {
-        return this.sectionCache[chunkX + 5*chunkZ + (5 * 5) * chunkY + this.chunkSectionIndexOffset];
+        return this.sectionCache[chunkX + 5 * chunkZ + (5 * 5) * chunkY + this.chunkSectionIndexOffset];
     }
 
     protected final void setChunkSectionInCache(final int chunkX, final int chunkY, final int chunkZ, final LevelChunkSection section) {
-        this.sectionCache[chunkX + 5*chunkZ + 5*5*chunkY + this.chunkSectionIndexOffset] = section;
+        this.sectionCache[chunkX + 5 * chunkZ + 5 * 5 * chunkY + this.chunkSectionIndexOffset] = section;
     }
 
     protected final void setBlocksForChunkInCache(final int chunkX, final int chunkZ, final LevelChunkSection[] sections) {
@@ -231,21 +230,21 @@ public abstract class StarLightEngine {
     }
 
     protected final SWMRNibbleArray getNibbleFromCache(final int chunkX, final int chunkY, final int chunkZ) {
-        return this.nibbleCache[chunkX + 5*chunkZ + (5 * 5) * chunkY + this.chunkSectionIndexOffset];
+        return this.nibbleCache[chunkX + 5 * chunkZ + (5 * 5) * chunkY + this.chunkSectionIndexOffset];
     }
 
     protected final SWMRNibbleArray[] getNibblesForChunkFromCache(final int chunkX, final int chunkZ) {
         final SWMRNibbleArray[] ret = new SWMRNibbleArray[this.maxLightSection - this.minLightSection + 1];
 
         for (int cy = this.minLightSection; cy <= this.maxLightSection; ++cy) {
-            ret[cy - this.minLightSection] = this.nibbleCache[chunkX + 5*chunkZ + (cy * (5 * 5)) + this.chunkSectionIndexOffset];
+            ret[cy - this.minLightSection] = this.nibbleCache[chunkX + 5 * chunkZ + (cy * (5 * 5)) + this.chunkSectionIndexOffset];
         }
 
         return ret;
     }
 
     protected final void setNibbleInCache(final int chunkX, final int chunkY, final int chunkZ, final SWMRNibbleArray nibble) {
-        this.nibbleCache[chunkX + 5*chunkZ + (5 * 5) * chunkY + this.chunkSectionIndexOffset] = nibble;
+        this.nibbleCache[chunkX + 5 * chunkZ + (5 * 5) * chunkY + this.chunkSectionIndexOffset] = nibble;
     }
 
     protected final void setNibblesForChunkInCache(final int chunkX, final int chunkZ, final SWMRNibbleArray[] nibbles) {
@@ -264,7 +263,7 @@ public abstract class StarLightEngine {
             final int chunkX = (index % 5) - this.chunkOffsetX;
             final int chunkZ = ((index / 5) % 5) - this.chunkOffsetZ;
             final int ySections = this.maxSection - this.minSection + 1;
-            final int chunkY = ((index / (5*5)) % (ySections + 2 + 2)) - this.chunkOffsetY;
+            final int chunkY = ((index / (5 * 5)) % (ySections + 2 + 2)) - this.chunkOffsetY;
             if ((nibble != null && nibble.updateVisible()) || this.notifyUpdateCache[index]) {
                 lightAccess.onLightUpdate(this.skylightPropagator ? LightLayer.SKY : LightLayer.BLOCK, SectionPos.of(chunkX, chunkY, chunkZ));
             }
@@ -379,11 +378,11 @@ public abstract class StarLightEngine {
     }
 
     protected final boolean[] getEmptinessMap(final int chunkX, final int chunkZ) {
-        return this.emptinessMapCache[chunkX + 5*chunkZ + this.chunkIndexOffset];
+        return this.emptinessMapCache[chunkX + 5 * chunkZ + this.chunkIndexOffset];
     }
 
     protected final void setEmptinessMapCache(final int chunkX, final int chunkZ, final boolean[] emptinessMap) {
-        this.emptinessMapCache[chunkX + 5*chunkZ + this.chunkIndexOffset] = emptinessMap;
+        this.emptinessMapCache[chunkX + 5 * chunkZ + this.chunkIndexOffset] = emptinessMap;
     }
 
     public static SWMRNibbleArray[] getFilledEmptyLight(final LevelHeightAccessor world) {
@@ -517,8 +516,8 @@ public abstract class StarLightEngine {
 
                     final int neighbourIndex =
                             (neighbourX & 15) |
-                            ((neighbourZ & 15)) << 4 |
-                            ((currY & 15) << 8);
+                                    ((neighbourZ & 15)) << 4 |
+                                    ((currY & 15) << 8);
                     final int neighbourLevel = neighbourNibble.getUpdating(neighbourIndex);
 
                     // the checks are delayed because the checkBlock method clobbers light values - which then
@@ -564,7 +563,7 @@ public abstract class StarLightEngine {
         final int chunkX = chunkPos.x;
         final int chunkZ = chunkPos.z;
 
-        for (final ShortIterator iterator = sections.iterator(); iterator.hasNext();) {
+        for (final ShortIterator iterator = sections.iterator(); iterator.hasNext(); ) {
             this.checkChunkEdge(lightAccess, chunk, chunkX, iterator.nextShort(), chunkZ);
         }
 
@@ -736,7 +735,7 @@ public abstract class StarLightEngine {
     // rets non-null when the emptiness map changed and needs to be updated
     protected final boolean[] handleEmptySectionChanges(final LightChunkGetter lightAccess, final ChunkAccess chunk,
                                                         final Boolean[] emptinessChanges, final boolean unlit) {
-        final Level world = (Level)lightAccess.getLevel();
+        final Level world = (Level) lightAccess.getLevel();
         final int chunkX = chunk.getPos().x;
         final int chunkZ = chunk.getPos().z;
 
@@ -920,7 +919,7 @@ public abstract class StarLightEngine {
         final Long2ObjectOpenHashMap<SWMRNibbleArray[]> nibblesByChunk = new Long2ObjectOpenHashMap<>();
         final Long2ObjectOpenHashMap<boolean[]> emptinessMapByChunk = new Long2ObjectOpenHashMap<>();
 
-        final int[] neighbourLightOrder = new int[] {
+        final int[] neighbourLightOrder = new int[]{
                 // d = 0
                 0, 0,
                 // d = 1
@@ -940,7 +939,7 @@ public abstract class StarLightEngine {
         for (final ChunkPos chunkPos : chunks) {
             final int chunkX = chunkPos.x;
             final int chunkZ = chunkPos.z;
-            final ChunkAccess chunk = (ChunkAccess)lightAccess.getChunkForLighting(chunkX, chunkZ);
+            final ChunkAccess chunk = (ChunkAccess) lightAccess.getChunkForLighting(chunkX, chunkZ);
             if (chunk == null || !this.canUseChunk(chunk)) {
                 throw new IllegalStateException();
             }
@@ -951,7 +950,7 @@ public abstract class StarLightEngine {
                 final int neighbourX = dx + chunkX;
                 final int neighbourZ = dz + chunkZ;
 
-                final ChunkAccess neighbour = (ChunkAccess)lightAccess.getChunkForLighting(neighbourX, neighbourZ);
+                final ChunkAccess neighbour = (ChunkAccess) lightAccess.getChunkForLighting(neighbourX, neighbourZ);
                 if (neighbour == null || !this.canUseChunk(neighbour)) {
                     continue;
                 }
@@ -970,7 +969,7 @@ public abstract class StarLightEngine {
                             final int neighbourX2 = neighbourX + dx2;
                             final int neighbourZ2 = neighbourZ + dz2;
                             final long key = CoordinateUtils.getChunkKey(neighbourX2, neighbourZ2);
-                            final ChunkAccess neighbour2 = (ChunkAccess)lightAccess.getChunkForLighting(neighbourX2, neighbourZ2);
+                            final ChunkAccess neighbour2 = (ChunkAccess) lightAccess.getChunkForLighting(neighbourX2, neighbourZ2);
                             if (neighbour2 == null || !this.canUseChunk(neighbour2)) {
                                 continue;
                             }
@@ -1089,9 +1088,10 @@ public abstract class StarLightEngine {
 
     protected static final AxisDirection[][] OLD_CHECK_DIRECTIONS = new AxisDirection[1 << 6][];
     protected static final int ALL_DIRECTIONS_BITSET = (1 << 6) - 1;
+
     static {
         for (int i = 0; i < OLD_CHECK_DIRECTIONS.length; ++i) {
-            final List<AxisDirection> directions = new ArrayList<>();
+            final List<AxisDirection> directions = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (int bitset = i, len = Integer.bitCount(i), index = 0; index < len; ++index, bitset ^= IntegerUtil.getTrailingBit(bitset)) {
                 directions.add(AXIS_DIRECTIONS[IntegerUtil.trailingZeros(bitset)]);
             }
@@ -1114,11 +1114,11 @@ public abstract class StarLightEngine {
         while (queueReadIndex < queueLength) {
             final long queueValue = queue[queueReadIndex++];
 
-            final int posX = ((int)queueValue & 63) + decodeOffsetX;
-            final int posZ = (((int)queueValue >>> 6) & 63) + decodeOffsetZ;
-            final int posY = (((int)queueValue >>> 12) & ((1 << 16) - 1)) + decodeOffsetY;
-            final int propagatedLightLevel = (int)((queueValue >>> (6 + 6 + 16)) & 0xFL);
-            final AxisDirection[] checkDirections = OLD_CHECK_DIRECTIONS[(int)((queueValue >>> (6 + 6 + 16 + 4)) & 63L)];
+            final int posX = ((int) queueValue & 63) + decodeOffsetX;
+            final int posZ = (((int) queueValue >>> 6) & 63) + decodeOffsetZ;
+            final int posY = (((int) queueValue >>> 12) & ((1 << 16) - 1)) + decodeOffsetY;
+            final int propagatedLightLevel = (int) ((queueValue >>> (6 + 6 + 16)) & 0xFL);
+            final AxisDirection[] checkDirections = OLD_CHECK_DIRECTIONS[(int) ((queueValue >>> (6 + 6 + 16 + 4)) & 63L)];
 
             if ((queueValue & FLAG_RECHECK_LEVEL) != 0L) {
                 if (this.getLightLevel(posX, posY, posZ) != propagatedLightLevel) {
@@ -1150,7 +1150,7 @@ public abstract class StarLightEngine {
                     if (blockState == null) {
                         continue;
                     }
-                    final int opacityCached = ((StarlightAbstractBlockState)blockState).starlight$getOpacityIfCached();
+                    final int opacityCached = ((StarlightAbstractBlockState) blockState).starlight$getOpacityIfCached();
                     if (opacityCached != -1) {
                         final int targetLevel = propagatedLightLevel - Math.max(1, opacityCached);
                         if (targetLevel > currentLevel) {
@@ -1172,7 +1172,7 @@ public abstract class StarLightEngine {
                     } else {
                         this.mutablePos1.set(offX, offY, offZ);
                         long flags = 0;
-                        if (((StarlightAbstractBlockState)blockState).starlight$isConditionallyFullOpaque()) {
+                        if (((StarlightAbstractBlockState) blockState).starlight$isConditionallyFullOpaque()) {
                             final VoxelShape cullingFace = blockState.getFaceOcclusionShape(world, this.mutablePos1, propagate.getOpposite().nms);
 
                             if (Shapes.faceShapeOccludes(Shapes.empty(), cullingFace)) {
@@ -1212,7 +1212,7 @@ public abstract class StarLightEngine {
                     final int offY = posY + propagate.y;
                     final int offZ = posZ + propagate.z;
 
-                    final VoxelShape fromShape = (((StarlightAbstractBlockState)fromBlock).starlight$isConditionallyFullOpaque()) ? fromBlock.getFaceOcclusionShape(world, this.mutablePos2, propagate.nms) : Shapes.empty();
+                    final VoxelShape fromShape = (((StarlightAbstractBlockState) fromBlock).starlight$isConditionallyFullOpaque()) ? fromBlock.getFaceOcclusionShape(world, this.mutablePos2, propagate.nms) : Shapes.empty();
 
                     if (fromShape != Shapes.empty() && Shapes.faceShapeOccludes(Shapes.empty(), fromShape)) {
                         continue;
@@ -1232,7 +1232,7 @@ public abstract class StarLightEngine {
                     if (blockState == null) {
                         continue;
                     }
-                    final int opacityCached = ((StarlightAbstractBlockState)blockState).starlight$getOpacityIfCached();
+                    final int opacityCached = ((StarlightAbstractBlockState) blockState).starlight$getOpacityIfCached();
                     if (opacityCached != -1) {
                         final int targetLevel = propagatedLightLevel - Math.max(1, opacityCached);
                         if (targetLevel > currentLevel) {
@@ -1254,7 +1254,7 @@ public abstract class StarLightEngine {
                     } else {
                         this.mutablePos1.set(offX, offY, offZ);
                         long flags = 0;
-                        if (((StarlightAbstractBlockState)blockState).starlight$isConditionallyFullOpaque()) {
+                        if (((StarlightAbstractBlockState) blockState).starlight$isConditionallyFullOpaque()) {
                             final VoxelShape cullingFace = blockState.getFaceOcclusionShape(world, this.mutablePos1, propagate.getOpposite().nms);
 
                             if (Shapes.faceShapeOccludes(fromShape, cullingFace)) {
@@ -1307,11 +1307,11 @@ public abstract class StarLightEngine {
         while (queueReadIndex < queueLength) {
             final long queueValue = queue[queueReadIndex++];
 
-            final int posX = ((int)queueValue & 63) + decodeOffsetX;
-            final int posZ = (((int)queueValue >>> 6) & 63) + decodeOffsetZ;
-            final int posY = (((int)queueValue >>> 12) & ((1 << 16) - 1)) + decodeOffsetY;
-            final int propagatedLightLevel = (int)((queueValue >>> (6 + 6 + 16)) & 0xF);
-            final AxisDirection[] checkDirections = OLD_CHECK_DIRECTIONS[(int)((queueValue >>> (6 + 6 + 16 + 4)) & 63)];
+            final int posX = ((int) queueValue & 63) + decodeOffsetX;
+            final int posZ = (((int) queueValue >>> 6) & 63) + decodeOffsetZ;
+            final int posY = (((int) queueValue >>> 12) & ((1 << 16) - 1)) + decodeOffsetY;
+            final int propagatedLightLevel = (int) ((queueValue >>> (6 + 6 + 16)) & 0xF);
+            final AxisDirection[] checkDirections = OLD_CHECK_DIRECTIONS[(int) ((queueValue >>> (6 + 6 + 16 + 4)) & 63)];
 
             if ((queueValue & FLAG_HAS_SIDED_TRANSPARENT_BLOCKS) == 0L) {
                 // we don't need to worry about our state here.
@@ -1335,7 +1335,7 @@ public abstract class StarLightEngine {
                     if (blockState == null) {
                         continue;
                     }
-                    final int opacityCached = ((StarlightAbstractBlockState)blockState).starlight$getOpacityIfCached();
+                    final int opacityCached = ((StarlightAbstractBlockState) blockState).starlight$getOpacityIfCached();
                     if (opacityCached != -1) {
                         final int targetLevel = Math.max(0, propagatedLightLevel - Math.max(1, opacityCached));
                         if (lightLevel > targetLevel) {
@@ -1346,7 +1346,7 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((lightLevel & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
                                             | FLAG_RECHECK_LEVEL;
                             continue;
                         }
@@ -1360,8 +1360,8 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((emittedLight & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
-                                            | (((StarlightAbstractBlockState)blockState).starlight$isConditionallyFullOpaque() ? (FLAG_WRITE_LEVEL | FLAG_HAS_SIDED_TRANSPARENT_BLOCKS) : FLAG_WRITE_LEVEL);
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((StarlightAbstractBlockState) blockState).starlight$isConditionallyFullOpaque() ? (FLAG_WRITE_LEVEL | FLAG_HAS_SIDED_TRANSPARENT_BLOCKS) : FLAG_WRITE_LEVEL);
                         }
 
                         currentNibble.set(localIndex, 0);
@@ -1381,7 +1381,7 @@ public abstract class StarLightEngine {
                     } else {
                         this.mutablePos1.set(offX, offY, offZ);
                         long flags = 0;
-                        if (((StarlightAbstractBlockState)blockState).starlight$isConditionallyFullOpaque()) {
+                        if (((StarlightAbstractBlockState) blockState).starlight$isConditionallyFullOpaque()) {
                             final VoxelShape cullingFace = blockState.getFaceOcclusionShape(world, this.mutablePos1, propagate.getOpposite().nms);
 
                             if (Shapes.faceShapeOccludes(Shapes.empty(), cullingFace)) {
@@ -1400,7 +1400,7 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((lightLevel & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
                                             | (FLAG_RECHECK_LEVEL | flags);
                             continue;
                         }
@@ -1414,7 +1414,7 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((emittedLight & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
                                             | (flags | FLAG_WRITE_LEVEL);
                         }
 
@@ -1446,7 +1446,7 @@ public abstract class StarLightEngine {
                     final int sectionIndex = (offX >> 4) + 5 * (offZ >> 4) + (5 * 5) * (offY >> 4) + sectionOffset;
                     final int localIndex = (offX & 15) | ((offZ & 15) << 4) | ((offY & 15) << 8);
 
-                    final VoxelShape fromShape = (((StarlightAbstractBlockState)fromBlock).starlight$isConditionallyFullOpaque()) ? fromBlock.getFaceOcclusionShape(world, this.mutablePos2, propagate.nms) : Shapes.empty();
+                    final VoxelShape fromShape = (((StarlightAbstractBlockState) fromBlock).starlight$isConditionallyFullOpaque()) ? fromBlock.getFaceOcclusionShape(world, this.mutablePos2, propagate.nms) : Shapes.empty();
 
                     if (fromShape != Shapes.empty() && Shapes.faceShapeOccludes(Shapes.empty(), fromShape)) {
                         continue;
@@ -1464,7 +1464,7 @@ public abstract class StarLightEngine {
                     if (blockState == null) {
                         continue;
                     }
-                    final int opacityCached = ((StarlightAbstractBlockState)blockState).starlight$getOpacityIfCached();
+                    final int opacityCached = ((StarlightAbstractBlockState) blockState).starlight$getOpacityIfCached();
                     if (opacityCached != -1) {
                         final int targetLevel = Math.max(0, propagatedLightLevel - Math.max(1, opacityCached));
                         if (lightLevel > targetLevel) {
@@ -1475,7 +1475,7 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((lightLevel & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
                                             | FLAG_RECHECK_LEVEL;
                             continue;
                         }
@@ -1489,8 +1489,8 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((emittedLight & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
-                                            | (((StarlightAbstractBlockState)blockState).starlight$isConditionallyFullOpaque() ? (FLAG_WRITE_LEVEL | FLAG_HAS_SIDED_TRANSPARENT_BLOCKS) : FLAG_WRITE_LEVEL);
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((StarlightAbstractBlockState) blockState).starlight$isConditionallyFullOpaque() ? (FLAG_WRITE_LEVEL | FLAG_HAS_SIDED_TRANSPARENT_BLOCKS) : FLAG_WRITE_LEVEL);
                         }
 
                         currentNibble.set(localIndex, 0);
@@ -1510,7 +1510,7 @@ public abstract class StarLightEngine {
                     } else {
                         this.mutablePos1.set(offX, offY, offZ);
                         long flags = 0;
-                        if (((StarlightAbstractBlockState)blockState).starlight$isConditionallyFullOpaque()) {
+                        if (((StarlightAbstractBlockState) blockState).starlight$isConditionallyFullOpaque()) {
                             final VoxelShape cullingFace = blockState.getFaceOcclusionShape(world, this.mutablePos1, propagate.getOpposite().nms);
 
                             if (Shapes.faceShapeOccludes(fromShape, cullingFace)) {
@@ -1529,7 +1529,7 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((lightLevel & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
                                             | (FLAG_RECHECK_LEVEL | flags);
                             continue;
                         }
@@ -1543,7 +1543,7 @@ public abstract class StarLightEngine {
                             increaseQueue[increaseQueueLength++] =
                                     ((offX + (offZ << 6) + (offY << 12) + encodeOffset) & ((1L << (6 + 6 + 16)) - 1))
                                             | ((emittedLight & 0xFL) << (6 + 6 + 16))
-                                            | (((long)ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
+                                            | (((long) ALL_DIRECTIONS_BITSET) << (6 + 6 + 16 + 4))
                                             | (flags | FLAG_WRITE_LEVEL);
                         }
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightInterface.java b/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightInterface.java
index c64ab41198a5e0c7cbcbe6452af11f82f5938862..e909e89de02ec860bc16ddc6141dfdfe14201c8f 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightInterface.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/starlight/light/StarLightInterface.java
@@ -26,8 +26,8 @@ import net.minecraft.world.level.chunk.LightChunkGetter;
 import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.lighting.LayerLightEventListener;
 import net.minecraft.world.level.lighting.LevelLightEngine;
+
 import java.util.ArrayDeque;
-import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -70,7 +70,7 @@ public final class StarLightInterface {
 
     public StarLightInterface(final LightChunkGetter lightAccess, final boolean hasSkyLight, final boolean hasBlockLight, final LevelLightEngine lightEngine) {
         this.lightAccess = lightAccess;
-        this.world = lightAccess == null ? null : (Level)lightAccess.getLevel();
+        this.world = lightAccess == null ? null : (Level) lightAccess.getLevel();
         this.cachedSkyPropagators = hasSkyLight && lightAccess != null ? new ArrayDeque<>() : null;
         this.cachedBlockPropagators = hasBlockLight && lightAccess != null ? new ArrayDeque<>() : null;
         this.isClientSide = !(this.world instanceof ServerLevel);
@@ -135,11 +135,11 @@ public final class StarLightInterface {
                     return null;
                 }
 
-                if (((StarlightChunk)chunk).starlight$getSkyEmptinessMap() == null) {
+                if (((StarlightChunk) chunk).starlight$getSkyEmptinessMap() == null) {
                     return null;
                 }
 
-                return ((StarlightChunk)chunk).starlight$getSkyNibbles()[sectionY - StarLightInterface.this.minLightSection].toVanillaNibble();
+                return ((StarlightChunk) chunk).starlight$getSkyNibbles()[sectionY - StarLightInterface.this.minLightSection].toVanillaNibble();
             }
 
             @Override
@@ -187,7 +187,7 @@ public final class StarLightInterface {
                     return null;
                 }
 
-                return ((StarlightChunk)chunk).starlight$getBlockNibbles()[pos.getY() - StarLightInterface.this.minLightSection].toVanillaNibble();
+                return ((StarlightChunk) chunk).starlight$getBlockNibbles()[pos.getY() - StarLightInterface.this.minLightSection].toVanillaNibble();
             }
 
             @Override
@@ -252,14 +252,14 @@ public final class StarLightInterface {
             y = sectionY << 4;
         }
 
-        final SWMRNibbleArray[] nibbles = ((StarlightChunk)chunk).starlight$getSkyNibbles();
+        final SWMRNibbleArray[] nibbles = ((StarlightChunk) chunk).starlight$getSkyNibbles();
         final SWMRNibbleArray immediate = nibbles[sectionY - minLightSection];
 
         if (!immediate.isNullNibbleVisible()) {
             return immediate.getVisible(x, y, z);
         }
 
-        final boolean[] emptinessMap = ((StarlightChunk)chunk).starlight$getSkyEmptinessMap();
+        final boolean[] emptinessMap = ((StarlightChunk) chunk).starlight$getSkyEmptinessMap();
 
         if (emptinessMap == null) {
             return 15;
@@ -312,7 +312,7 @@ public final class StarLightInterface {
             return 0;
         }
 
-        final SWMRNibbleArray nibble = ((StarlightChunk)chunk).starlight$getBlockNibbles()[cy - minLightSection];
+        final SWMRNibbleArray nibble = ((StarlightChunk) chunk).starlight$getBlockNibbles()[cy - minLightSection];
         return nibble.getVisible(blockPos.getX(), y, blockPos.getZ());
     }
 
@@ -345,7 +345,7 @@ public final class StarLightInterface {
             // empty world
             return null;
         }
-        return ((ChunkSystemLevel)this.world).moonrise$getAnyChunkIfLoaded(chunkX, chunkZ);
+        return ((ChunkSystemLevel) this.world).moonrise$getAnyChunkIfLoaded(chunkX, chunkZ);
     }
 
     public boolean hasUpdates() {
@@ -588,7 +588,7 @@ public final class StarLightInterface {
 
             protected void addLightTask(final BooleanSupplier lightTask) {
                 if (this.lightTasks == null) {
-                    this.lightTasks = new ArrayList<>();
+                    this.lightTasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 }
                 this.lightTasks.add(lightTask);
             }
@@ -885,9 +885,9 @@ public final class StarLightInterface {
             public ServerChunkTasks(final long chunkCoordinate, final StarLightInterface lightEngine,
                                     final ServerLightQueue queue, final PrioritisedExecutor.Priority priority) {
                 super(chunkCoordinate, lightEngine, queue);
-                this.task = ((ChunkSystemServerLevel)(ServerLevel)lightEngine.getWorld()).moonrise$getChunkTaskScheduler().radiusAwareScheduler.createTask(
+                this.task = ((ChunkSystemServerLevel) (ServerLevel) lightEngine.getWorld()).moonrise$getChunkTaskScheduler().radiusAwareScheduler.createTask(
                         CoordinateUtils.getChunkX(chunkCoordinate), CoordinateUtils.getChunkZ(chunkCoordinate),
-                        ((ChunkSystemChunkStatus)ChunkStatus.LIGHT).moonrise$getWriteRadius(), this, priority
+                        ((ChunkSystemChunkStatus) ChunkStatus.LIGHT).moonrise$getWriteRadius(), this, priority
                 );
             }
 
@@ -921,7 +921,7 @@ public final class StarLightInterface {
 
             @Override
             public void run() {
-                ((ServerLightQueue)this.queue).chunkTasks.remove(this.chunkCoordinate, this);
+                ((ServerLightQueue) this.queue).chunkTasks.remove(this.chunkCoordinate, this);
 
                 this.runTasks();
             }
diff --git a/src/main/java/com/destroystokyo/paper/Metrics.java b/src/main/java/com/destroystokyo/paper/Metrics.java
index 6c5c0cc59ff9901b22288f3cd62228c1e52794c5..06a5c46dba0fa9bd70c4fa3099e3ac9f3af3d8ce 100644
--- a/src/main/java/com/destroystokyo/paper/Metrics.java
+++ b/src/main/java/com/destroystokyo/paper/Metrics.java
@@ -5,7 +5,6 @@ import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.plugin.Plugin;
-
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
 
@@ -15,7 +14,10 @@ import java.io.DataOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
-import java.util.*;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
@@ -28,7 +30,7 @@ import java.util.zip.GZIPOutputStream;
 
 /**
  * bStats collects some data for plugin authors.
- *
+ * <p>
  * Check out https://bStats.org/ to learn more about bStats!
  */
 public class Metrics {
@@ -56,7 +58,7 @@ public class Metrics {
     private final String serverUUID;
 
     // A list with all custom charts
-    private final List<CustomChart> charts = new ArrayList<>();
+    private final List<CustomChart> charts = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     /**
      * Class constructor.
@@ -713,12 +715,14 @@ public class Metrics {
                     String vmVendor = null;
                     try {
                         vmVendor = System.getProperty("java.vm.vendor");
-                    } catch (Exception ignored) {}
+                    } catch (Exception ignored) {
+                    }
                     entry.put(vmVendor == null ? "Unknown" : vmVendor, 1);
                     String vmName = null;
                     try {
                         vmName = System.getProperty("java.vm.name");
-                    } catch (Exception ignored) {}
+                    } catch (Exception ignored) {
+                    }
                     javaVirtualMachineMap.put(vmName == null ? "Unknown" : vmName, entry);
                 }
                 metrics.addCustomChart(new Metrics.DrilldownPie("java_virtual_machine", () -> javaVirtualMachineMap));
@@ -805,7 +809,8 @@ public class Metrics {
                     // Try to get the number of Netty threads from the system property
                     try {
                         return System.getProperty("io.netty.eventLoopThreads");
-                    } catch (Exception ignored) {}
+                    } catch (Exception ignored) {
+                    }
                     // Otherwise, we fall back to nothing currently (reading from the Spigot configuration causes a re-read which is undesirable)
                     return null;
                 }));
@@ -820,7 +825,8 @@ public class Metrics {
                         if (physicalProcessorCount > 0) {
                             return String.valueOf(physicalProcessorCount);
                         }
-                    } catch (Exception ignored) {}
+                    } catch (Exception ignored) {
+                    }
                     return null;
                 }));
                 // Gale end - metrics - physical cores
@@ -861,7 +867,8 @@ public class Metrics {
                             return map;
 
                         }
-                    } catch (Exception ignored) {}
+                    } catch (Exception ignored) {
+                    }
                     return null;
                 }));
                 // Gale end - metrics - processor frequency
@@ -886,7 +893,8 @@ public class Metrics {
                             return map;
 
                         }
-                    } catch (Exception ignored) {}
+                    } catch (Exception ignored) {
+                    }
                     return null;
                 }));
                 // Gale end - metrics - physical memory
@@ -954,7 +962,8 @@ public class Metrics {
                                 try {
                                     var javaVersion = gg.pufferfish.pufferfish.simd.SIMDDetection.getJavaVersion();
                                     details += " (" + javaVersion + ")";
-                                } catch (Throwable ignored) {}
+                                } catch (Throwable ignored) {
+                                }
                             } else if (!gg.pufferfish.pufferfish.simd.SIMDDetection.testRunCompleted()) {
                                 details = "test failed";
                             } else if (gg.pufferfish.pufferfish.simd.SIMDDetection.unsupportingLaneSize()) {
diff --git a/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java b/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
index 946cbc955683e81933e0f3c0db5f8cc4ec437a76..53fedb2fd73e9828cfdc8957483f6be5cd3dfa72 100644
--- a/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
+++ b/src/main/java/com/destroystokyo/paper/entity/PaperPathfinder.java
@@ -1,15 +1,15 @@
 package com.destroystokyo.paper.entity;
 
+import net.minecraft.world.level.pathfinder.Node;
+import net.minecraft.world.level.pathfinder.Path;
 import org.apache.commons.lang.Validate;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftLivingEntity;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Mob;
+
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
-import net.minecraft.world.level.pathfinder.Node;
-import net.minecraft.world.level.pathfinder.Path;
-import java.util.ArrayList;
 import java.util.List;
 
 public class PaperPathfinder implements com.destroystokyo.paper.entity.Pathfinder {
@@ -102,6 +102,7 @@ public class PaperPathfinder implements com.destroystokyo.paper.entity.Pathfinde
     public class PaperPathResult implements com.destroystokyo.paper.entity.PaperPathfinder.PathResult {
 
         private final Path path;
+
         PaperPathResult(Path path) {
             this.path = path;
         }
@@ -120,7 +121,7 @@ public class PaperPathfinder implements com.destroystokyo.paper.entity.Pathfinde
 
         @Override
         public List<Location> getPoints() {
-            List<Location> points = new ArrayList<>();
+            List<Location> points = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (Node point : path.nodes) {
                 points.add(toLoc(point));
             }
diff --git a/src/main/java/com/destroystokyo/paper/io/SyncLoadFinder.java b/src/main/java/com/destroystokyo/paper/io/SyncLoadFinder.java
index 605a4a83d0a098a9977da00c710e798396dc5256..c5acdf40acb1af80b240353f28e1ac20a60b6fe9 100644
--- a/src/main/java/com/destroystokyo/paper/io/SyncLoadFinder.java
+++ b/src/main/java/com/destroystokyo/paper/io/SyncLoadFinder.java
@@ -73,7 +73,7 @@ public class SyncLoadFinder {
 
             worldData.addProperty("name", world.getWorld().getName());
 
-            final List<Pair<ThrowableWithEquals, SyncLoadInformation>> data = new ArrayList<>();
+            final List<Pair<ThrowableWithEquals, SyncLoadInformation>> data = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             entry.getValue().forEach((ThrowableWithEquals stacktrace, SyncLoadInformation times) -> {
                 data.add(new Pair<>(stacktrace, times));
diff --git a/src/main/java/com/destroystokyo/paper/network/StandardPaperServerListPingEventImpl.java b/src/main/java/com/destroystokyo/paper/network/StandardPaperServerListPingEventImpl.java
index 30a19d10869f73d67b794e8e4c035bc5c10209e6..e8b109c54435af91cc1c3bb9875ad169a1859c18 100644
--- a/src/main/java/com/destroystokyo/paper/network/StandardPaperServerListPingEventImpl.java
+++ b/src/main/java/com/destroystokyo/paper/network/StandardPaperServerListPingEventImpl.java
@@ -3,11 +3,6 @@ package com.destroystokyo.paper.network;
 import com.destroystokyo.paper.profile.PlayerProfile;
 import com.mojang.authlib.GameProfile;
 import io.papermc.paper.adventure.AdventureComponent;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Optional;
-import javax.annotation.Nonnull;
 import net.minecraft.network.Connection;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.protocol.status.ClientboundStatusResponsePacket;
@@ -16,6 +11,11 @@ import net.minecraft.server.MinecraftServer;
 import org.bukkit.craftbukkit.util.CraftIconCache;
 import org.jetbrains.annotations.NotNull;
 
+import javax.annotation.Nonnull;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+
 public final class StandardPaperServerListPingEventImpl extends PaperServerListPingEventImpl {
 
     private List<GameProfile> originalSample;
@@ -56,7 +56,7 @@ public final class StandardPaperServerListPingEventImpl extends PaperServerListP
             return Collections.emptyList();
         }
 
-        final List<GameProfile> profiles = new ArrayList<>();
+        final List<GameProfile> profiles = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (ListedPlayerInfo playerInfo : entries) {
             profiles.add(new GameProfile(playerInfo.id(), playerInfo.name()));
         }
diff --git a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
index 5886e395f0b3b5837088bf97bf20ce13781cc5d3..d7547c4ad74a6fdb86b709fb84fa7eecf8758bb3 100644
--- a/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
+++ b/src/main/java/com/destroystokyo/paper/profile/CraftPlayerProfile.java
@@ -1,13 +1,13 @@
 package com.destroystokyo.paper.profile;
 
-import com.google.common.base.Preconditions;
-import com.mojang.authlib.yggdrasil.ProfileResult;
-import io.papermc.paper.configuration.GlobalConfiguration;
 import com.google.common.base.Charsets;
+import com.google.common.base.Preconditions;
 import com.google.common.collect.Iterables;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.properties.Property;
 import com.mojang.authlib.properties.PropertyMap;
+import com.mojang.authlib.yggdrasil.ProfileResult;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.Util;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.players.GameProfileCache;
@@ -208,10 +208,12 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
         return completeFromCache(false, GlobalConfiguration.get().proxies.isProxyOnlineMode());
     }
 
+    @Override
     public boolean completeFromCache(boolean onlineMode) {
         return completeFromCache(false, onlineMode);
     }
 
+    @Override
     public boolean completeFromCache(boolean lookupUUID, boolean onlineMode) {
         MinecraftServer server = MinecraftServer.getServer();
         String name = profile.getName();
@@ -249,10 +251,12 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
         return this.isComplete();
     }
 
+    @Override
     public boolean complete(boolean textures) {
         return complete(textures, GlobalConfiguration.get().proxies.isProxyOnlineMode());
     }
 
+    @Override
     public boolean complete(boolean textures, boolean onlineMode) {
         if (this.isComplete() && (!textures || hasTextures())) { // Don't do lookup if we already have everything
             return true;
@@ -297,8 +301,8 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
         Preconditions.checkArgument(name == null || name.length() <= 16, "Name cannot be longer than 16 characters");
         Preconditions.checkArgument(name == null || org.dreeam.leaf.config.modules.misc.RemoveVanillaUsernameCheck.enabled || StringUtil.isValidPlayerName(name), "The name of the profile contains invalid characters: %s", name); // Leaf - Remove Vanilla username check
         return new GameProfile(
-            uniqueId != null ? uniqueId : Util.NIL_UUID,
-            name != null ? name : ""
+                uniqueId != null ? uniqueId : Util.NIL_UUID,
+                name != null ? name : ""
         );
     }
 
@@ -344,7 +348,7 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
             map.put("name", getName());
         }
         if (!this.properties.isEmpty()) {
-            List<Object> propertiesData = new ArrayList<>();
+            List<Object> propertiesData = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (ProfileProperty property : properties) {
                 propertiesData.add(CraftProfileProperty.serialize(new Property(property.getName(), property.getValue(), property.getSignature())));
             }
@@ -389,9 +393,9 @@ public class CraftPlayerProfile implements PlayerProfile, SharedPlayerProfile {
     @Override
     public String toString() {
         return "CraftPlayerProfile [uniqueId=" + getId() +
-            ", name=" + getName() +
-            ", properties=" + org.bukkit.craftbukkit.profile.CraftPlayerProfile.toString(this.profile.getProperties()) +
-            "]";
+                ", name=" + getName() +
+                ", properties=" + org.bukkit.craftbukkit.profile.CraftPlayerProfile.toString(this.profile.getProperties()) +
+                "]";
     }
 
     private class PropertySet extends AbstractSet<ProfileProperty> {
diff --git a/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java b/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java
index 9f17170179cc99d84ad25a1e838aff3d8cc66f93..36e0f19d3ed3da22c20c20cd374f6792c2fb4a9e 100644
--- a/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java
+++ b/src/main/java/com/destroystokyo/paper/util/RedstoneWireTurbo.java
@@ -1,8 +1,6 @@
 package com.destroystokyo.paper.util;
 
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ThreadLocalRandom;
+import com.google.common.collect.Maps;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.world.item.ItemStack;
@@ -14,14 +12,15 @@ import net.minecraft.world.level.block.state.BlockState;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockRedstoneEvent;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ThreadLocalRandom;
 
 /**
  * Used for the faster redstone algorithm.
  * Original author: theosib
  * Original license: MIT
- *
+ * <p>
  * Ported to Paper and updated to 1.13 by egg82
  */
 public class RedstoneWireTurbo {
@@ -115,9 +114,9 @@ public class RedstoneWireTurbo {
      * information flow.  This makes the implementation non-orientational.  Only when
      * this direction is ambiguous is randomness applied (intentionally).
      */
-    private List<UpdateNode> updateQueue0 = Lists.newArrayList();
-    private List<UpdateNode> updateQueue1 = Lists.newArrayList();
-    private List<UpdateNode> updateQueue2 = Lists.newArrayList();
+    private List<UpdateNode> updateQueue0 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private List<UpdateNode> updateQueue1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private List<UpdateNode> updateQueue2 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     public RedstoneWireTurbo(RedStoneWireBlock wire) {
         this.wire = wire;
@@ -133,7 +132,7 @@ public class RedstoneWireTurbo {
      * Note that this ordering is only used to create the initial list of neighbors.  Once
      * the direction of signal flow is identified, the ordering of updates is completely
      * reorganized.
-    */
+     */
     public static BlockPos[] computeAllNeighbors(final BlockPos pos) {
         final int x = pos.getX();
         final int y = pos.getY();
@@ -184,10 +183,10 @@ public class RedstoneWireTurbo {
      * in any of the 24 neighboring positions.
      */
     private static final boolean[] update_redstone = {
-        true, true, false, false, true, true, // 0 to 5
-        false, true, true, false, false, false, // 6 to 11
-        true, true, false, false, false, true, // 12 to 17
-        true, false, true, true, false, false // 18 to 23
+            true, true, false, false, true, true, // 0 to 5
+            false, true, true, false, false, false, // 6 to 11
+            true, true, false, false, false, true, // 12 to 17
+            true, false, true, true, false, false // 18 to 23
     };
 
     // Internal numbering for cardinal directions
@@ -202,9 +201,9 @@ public class RedstoneWireTurbo {
      * See below for more explanation.
      */
     private static final int[] forward_is_north = {2, 3, 16, 19, 0, 4, 1, 5, 7, 8, 17, 20, 12, 13, 18, 21, 6, 9, 22, 14, 11, 10, 23, 15};
-    private static final int[] forward_is_east  = {2, 3, 16, 19, 4, 1, 5, 0, 17, 20, 12, 13, 18, 21, 7, 8, 22, 14, 11, 15, 23, 9, 6, 10};
+    private static final int[] forward_is_east = {2, 3, 16, 19, 4, 1, 5, 0, 17, 20, 12, 13, 18, 21, 7, 8, 22, 14, 11, 15, 23, 9, 6, 10};
     private static final int[] forward_is_south = {2, 3, 16, 19, 1, 5, 0, 4, 12, 13, 18, 21, 7, 8, 17, 20, 11, 15, 23, 10, 6, 14, 22, 9};
-    private static final int[] forward_is_west =  {2, 3, 16, 19, 5, 0, 4, 1, 18, 21, 7, 8, 17, 20, 12, 13, 23, 10, 6, 9, 22, 15, 11, 14};
+    private static final int[] forward_is_west = {2, 3, 16, 19, 5, 0, 4, 1, 18, 21, 7, 8, 17, 20, 12, 13, 23, 10, 6, 9, 22, 15, 11, 14};
 
     /* For any orientation, we end up with the update order defined below.  This order is relative to any redstone wire block
      * that is itself having an update computed, and this center position is marked with C.
@@ -250,7 +249,7 @@ public class RedstoneWireTurbo {
      */
 
     // This allows the above remapping tables to be looked up by cardial direction index
-    private static final int[][] reordering = { forward_is_north, forward_is_east, forward_is_south, forward_is_west };
+    private static final int[][] reordering = {forward_is_north, forward_is_east, forward_is_south, forward_is_west};
 
     /*
      * Input:  Array of UpdateNode objects in an order corresponding to the positions
@@ -352,56 +351,56 @@ public class RedstoneWireTurbo {
         // to determine the heading.
         final int code = (rx + 1) + 3 * (rz + 1);
         switch (code) {
-        case 0: {
-            // Both rx and rz are -1 (northwest)
-            // Randomly choose one to be forward.
-            final int j = ThreadLocalRandom.current().nextInt(0, 1);
-            return (j == 0) ? North : West;
-        }
-        case 1: {
-            // rx=0, rz=-1
-            // Definitively North
-            return North;
-        }
-        case 2: {
-            // rx=1, rz=-1 (northeast)
-            // Choose randomly between north and east
-            final int j = ThreadLocalRandom.current().nextInt(0, 1);
-            return (j == 0) ? North : East;
-        }
-        case 3: {
-            // rx=-1, rz=0
-            // Definitively West
-            return West;
-        }
-        case 4: {
-            // rx=0, rz=0
-            // Heading is completely ambiguous. Choose
-            // randomly among the four cardinal directions.
-            return ThreadLocalRandom.current().nextInt(0, 4);
-        }
-        case 5: {
-            // rx=1, rz=0
-            // Definitively East
-            return East;
-        }
-        case 6: {
-            // rx=-1, rz=1 (southwest)
-            // Choose randomly between south and west
-            final int j = ThreadLocalRandom.current().nextInt(0, 1);
-            return (j == 0) ? South : West;
-        }
-        case 7: {
-            // rx=0, rz=1
-            // Definitively South
-            return South;
-        }
-        case 8: {
-            // rx=1, rz=1 (southeast)
-            // Choose randomly between south and east
-            final int j = ThreadLocalRandom.current().nextInt(0, 1);
-            return (j == 0) ? South : East;
-        }
+            case 0: {
+                // Both rx and rz are -1 (northwest)
+                // Randomly choose one to be forward.
+                final int j = ThreadLocalRandom.current().nextInt(0, 1);
+                return (j == 0) ? North : West;
+            }
+            case 1: {
+                // rx=0, rz=-1
+                // Definitively North
+                return North;
+            }
+            case 2: {
+                // rx=1, rz=-1 (northeast)
+                // Choose randomly between north and east
+                final int j = ThreadLocalRandom.current().nextInt(0, 1);
+                return (j == 0) ? North : East;
+            }
+            case 3: {
+                // rx=-1, rz=0
+                // Definitively West
+                return West;
+            }
+            case 4: {
+                // rx=0, rz=0
+                // Heading is completely ambiguous. Choose
+                // randomly among the four cardinal directions.
+                return ThreadLocalRandom.current().nextInt(0, 4);
+            }
+            case 5: {
+                // rx=1, rz=0
+                // Definitively East
+                return East;
+            }
+            case 6: {
+                // rx=-1, rz=1 (southwest)
+                // Choose randomly between south and west
+                final int j = ThreadLocalRandom.current().nextInt(0, 1);
+                return (j == 0) ? South : West;
+            }
+            case 7: {
+                // rx=0, rz=1
+                // Definitively South
+                return South;
+            }
+            case 8: {
+                // rx=1, rz=1 (southeast)
+                // Choose randomly between south and east
+                final int j = ThreadLocalRandom.current().nextInt(0, 1);
+                return (j == 0) ? South : East;
+            }
         }
 
         // We should never get here
@@ -472,7 +471,7 @@ public class RedstoneWireTurbo {
         // Target array of neighbors sorted left-to-right
         upd1.neighbor_nodes = new UpdateNode[24];
 
-        for (int i=0; i<24; i++) {
+        for (int i = 0; i < 24; i++) {
             // Look up each neighbor in the node cache
             final BlockPos pos2 = neighbors[i];
             UpdateNode upd2 = nodeCache.get(pos2);
@@ -511,12 +510,12 @@ public class RedstoneWireTurbo {
         if (fromSouth) cz -= 1;
 
         int heading;
-        if (cx==0 && cz==0) {
+        if (cx == 0 && cz == 0) {
             // If there is no clear direction, try to inherit the heading from ancestor nodes.
             heading = computeHeading(upd1.xbias, upd1.zbias);
 
             // Propagate that heading to descendant nodes.
-            for (int i=0; i<24; i++) {
+            for (int i = 0; i < 24; i++) {
                 final UpdateNode nn = neighbor_nodes[i];
                 if (nn != null) {
                     nn.xbias = upd1.xbias;
@@ -533,7 +532,7 @@ public class RedstoneWireTurbo {
             heading = computeHeading(cx, cz);
 
             // Propagate that heading to descendant nodes.
-            for (int i=0; i<24; i++) {
+            for (int i = 0; i < 24; i++) {
                 final UpdateNode nn = neighbor_nodes[i];
                 if (nn != null) {
                     nn.xbias = cx;
@@ -623,7 +622,7 @@ public class RedstoneWireTurbo {
         currentWalkLayer = 1;
 
         // Loop over all layers
-        while (updateQueue0.size()>0 || updateQueue1.size()>0) {
+        while (updateQueue0.size() > 0 || updateQueue1.size() > 0) {
             // Get the set of blocks in this layer
             final List<UpdateNode> thisLayer = updateQueue0;
 
@@ -729,7 +728,7 @@ public class RedstoneWireTurbo {
         // Therefore we clear the cached block info about all neighbors of
         // the position receiving the update and then re-identify what they are.
         if (upd.neighbor_nodes != null) {
-            for (int i=0; i<24; i++) {
+            for (int i = 0; i < 24; i++) {
                 final UpdateNode upd2 = upd.neighbor_nodes[i];
                 if (upd2 == null) continue;
                 upd2.type = UpdateNode.Type.UNKNOWN;
@@ -795,7 +794,7 @@ public class RedstoneWireTurbo {
         // already performs the update to the block at 'pos', so it is not added to the schedule.
         final UpdateNode upd = new UpdateNode();
         upd.self = pos;
-        upd.parent = source!=null ? source : pos;
+        upd.parent = source != null ? source : pos;
         upd.currentState = newState;
         upd.type = UpdateNode.Type.REDSTONE;
         upd.visited = true;
@@ -817,7 +816,7 @@ public class RedstoneWireTurbo {
 
     // For any array of neighbors in an UpdateNode object, these are always
     // the indices of the four immediate neighbors at the same Y coordinate.
-    private static final int[] rs_neighbors =    {4, 5, 6, 7};
+    private static final int[] rs_neighbors = {4, 5, 6, 7};
     private static final int[] rs_neighbors_up = {9, 11, 13, 15};
     private static final int[] rs_neighbors_dn = {8, 10, 12, 14};
 
@@ -876,8 +875,7 @@ public class RedstoneWireTurbo {
                 if (!neighbor_is_cube) {
                     UpdateNode neighbor_down = upd.neighbor_nodes[rs_neighbors_dn[m]];
                     l = getMaxCurrentStrength(neighbor_down, l);
-                } else
-                if (!center_up_is_cube) {
+                } else if (!center_up_is_cube) {
                     UpdateNode neighbor_up = upd.neighbor_nodes[rs_neighbors_up[m]];
                     l = getMaxCurrentStrength(neighbor_up, l);
                 }
@@ -919,7 +917,7 @@ public class RedstoneWireTurbo {
         return state;
     }
 
-    private static final Direction[] UPDATE_SHAPE_ORDER = { Direction.WEST, Direction.EAST, Direction.NORTH, Direction.SOUTH, Direction.DOWN, Direction.UP };
+    private static final Direction[] UPDATE_SHAPE_ORDER = {Direction.WEST, Direction.EAST, Direction.NORTH, Direction.SOUTH, Direction.DOWN, Direction.UP};
 
     /*
      * [Space Walker]
diff --git a/src/main/java/com/mojang/brigadier/CommandDispatcher.java b/src/main/java/com/mojang/brigadier/CommandDispatcher.java
index 770aec1976bd391eb5712b57b6c6a0290b4723a8..4713792e5f42c480311de30af24d71b2d18cc02d 100644
--- a/src/main/java/com/mojang/brigadier/CommandDispatcher.java
+++ b/src/main/java/com/mojang/brigadier/CommandDispatcher.java
@@ -400,7 +400,7 @@ public class CommandDispatcher<S> {
      * @return array of full usage strings under the target node
      */
     public String[] getAllUsage(final CommandNode<S> node, final S source, final boolean restricted) {
-        final ArrayList<String> result = new ArrayList<>();
+        final ArrayList<String> result = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.getAllUsage(node, source, result, "", restricted);
         return result.toArray(new String[result.size()]);
     }
@@ -558,7 +558,7 @@ public class CommandDispatcher<S> {
 
         final CompletableFuture<Suggestions> result = new CompletableFuture<>();
         CompletableFuture.allOf(futures).thenRun(() -> {
-            final List<Suggestions> suggestions = new ArrayList<>();
+            final List<Suggestions> suggestions = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (final CompletableFuture<Suggestions> future : futures) {
                 suggestions.add(future.join());
             }
@@ -596,8 +596,8 @@ public class CommandDispatcher<S> {
      * @return a path to the resulting node, or an empty list if it was not found
      */
     public Collection<String> getPath(final CommandNode<S> target) {
-        final List<List<CommandNode<S>>> nodes = new ArrayList<>();
-        this.addPaths(this.root, nodes, new ArrayList<>());
+        final List<List<CommandNode<S>>> nodes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        this.addPaths(this.root, nodes, new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
 
         for (final List<CommandNode<S>> list : nodes) {
             if (list.get(list.size() - 1) == target) {
diff --git a/src/main/java/com/mojang/datafixers/DataFixerBuilder.java b/src/main/java/com/mojang/datafixers/DataFixerBuilder.java
index 2cce259c738de2680e219d30dc3020458f4442d6..e0d63dc6b2978511949a69824d907ebd49310ff7 100644
--- a/src/main/java/com/mojang/datafixers/DataFixerBuilder.java
+++ b/src/main/java/com/mojang/datafixers/DataFixerBuilder.java
@@ -27,7 +27,7 @@ public class DataFixerBuilder {
 
     private final int dataVersion;
     private final Int2ObjectSortedMap<Schema> schemas = new Int2ObjectAVLTreeMap<>();
-    private final List<DataFix> globalList = new ArrayList<>();
+    private final List<DataFix> globalList = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final IntSortedSet fixerVersions = new IntAVLTreeSet();
     private final int minDataFixPrecacheVersion; // Paper - Perf: Cache DataFixerUpper Rewrite Rules on demand
 
@@ -82,8 +82,8 @@ public class DataFixerBuilder {
 
         public CompletableFuture<?> optimize(final Set<DSL.TypeReference> requiredTypes, final Executor executor) {
             final Instant started = Instant.now();
-            final List<CompletableFuture<?>> doneFutures = new ArrayList<>();
-            final List<CompletableFuture<?>> failFutures = new ArrayList<>();
+            final List<CompletableFuture<?>> doneFutures = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+            final List<CompletableFuture<?>> failFutures = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             final Set<String> requiredTypeNames = requiredTypes.stream().map(DSL.TypeReference::typeName).collect(Collectors.toSet());
 
diff --git a/src/main/java/io/papermc/paper/command/CommandUtil.java b/src/main/java/io/papermc/paper/command/CommandUtil.java
index 953c30500892e5f0c55b8597bc708ea85bf56d6e..d658e98ab65ae02df8ccc922dd5d4c7921ff23b6 100644
--- a/src/main/java/io/papermc/paper/command/CommandUtil.java
+++ b/src/main/java/io/papermc/paper/command/CommandUtil.java
@@ -2,17 +2,13 @@ package io.papermc.paper.command;
 
 import com.google.common.base.Functions;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
 import net.minecraft.resources.ResourceLocation;
 import org.bukkit.command.CommandSender;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
+import java.util.*;
+
 @DefaultQualifier(NonNull.class)
 public final class CommandUtil {
     private CommandUtil() {
@@ -20,9 +16,9 @@ public final class CommandUtil {
 
     // Code from Mojang - copyright them
     public static List<String> getListMatchingLast(
-        final CommandSender sender,
-        final String[] args,
-        final String... matches
+            final CommandSender sender,
+            final String[] args,
+            final String... matches
     ) {
         return getListMatchingLast(sender, args, Arrays.asList(matches));
     }
@@ -32,12 +28,12 @@ public final class CommandUtil {
     }
 
     public static List<String> getListMatchingLast(
-        final CommandSender sender,
-        final String[] strings,
-        final Collection<?> collection
+            final CommandSender sender,
+            final String[] strings,
+            final Collection<?> collection
     ) {
         String last = strings[strings.length - 1];
-        ArrayList<String> results = Lists.newArrayList();
+        ArrayList<String> results = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         if (!collection.isEmpty()) {
             Iterator iterator = Iterables.transform(collection, Functions.toStringFunction()).iterator();
diff --git a/src/main/java/io/papermc/paper/command/MSPTCommand.java b/src/main/java/io/papermc/paper/command/MSPTCommand.java
index 8b5293b0c696ef21d0101493ffa41b60bf0bc86b..5919ee3a8ca7f7f478ba080dc9594f57f88c41c9 100644
--- a/src/main/java/io/papermc/paper/command/MSPTCommand.java
+++ b/src/main/java/io/papermc/paper/command/MSPTCommand.java
@@ -44,7 +44,7 @@ public final class MSPTCommand extends Command {
 
         MinecraftServer server = MinecraftServer.getServer();
 
-        List<Component> times = new ArrayList<>();
+        List<Component> times = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         times.addAll(eval(server.tickTimes5s.getTimes()));
         times.addAll(eval(server.tickTimes10s.getTimes()));
         times.addAll(eval(server.tickTimes60s.getTimes()));
diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 362765d977aaa1996f9cef3404c0676d7bbddf38..3584e1fe54dd8a149cfb17e4b2b73ffe4600fd19 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -65,7 +65,7 @@ public final class PaperCommand extends Command {
         super(name);
         this.description = "Paper related commands";
         this.usageMessage = "/paper [" + String.join(" | ", SUBCOMMANDS.keySet()) + "]";
-        final List<String> permissions = new ArrayList<>();
+        final List<String> permissions = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         permissions.add("bukkit.command.paper");
         permissions.addAll(SUBCOMMANDS.keySet().stream().map(s -> BASE_PERM + s).toList());
         this.setPermission(String.join(";", permissions));
diff --git a/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java b/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java
index 865dc183276720d54d31d2a54d1bb5c845e80598..23a185e30b2aaa43dc1671313b8c99a46c946b04 100644
--- a/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java
@@ -85,7 +85,7 @@ public class PaperPluginsCommand extends BukkitCommand {
         }
 
         boolean isFirst = true;
-        List<Component> formattedSublists = new ArrayList<>();
+        List<Component> formattedSublists = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         /*
         Split up the plugin list for each 10 plugins to get size down
 
diff --git a/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitCommandNode.java b/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitCommandNode.java
index 5a2a4f69995f23e799370c05f28f9353aa1a1d39..508b01cd190d8ae3d165316ae2bd0abee54433c6 100644
--- a/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitCommandNode.java
+++ b/src/main/java/io/papermc/paper/command/brigadier/bukkit/BukkitCommandNode.java
@@ -9,8 +9,6 @@ import com.mojang.brigadier.suggestion.Suggestions;
 import com.mojang.brigadier.suggestion.SuggestionsBuilder;
 import com.mojang.brigadier.tree.LiteralCommandNode;
 import io.papermc.paper.command.brigadier.CommandSourceStack;
-import java.util.ArrayList;
-import java.util.Collections;
 import net.minecraft.commands.CommandSource;
 import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
@@ -18,14 +16,13 @@ import org.bukkit.Location;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandException;
 import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Player;
+import org.bukkit.event.server.TabCompleteEvent;
 
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 import java.util.logging.Level;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.Player;
-import org.bukkit.event.server.TabCompleteEvent;
 
 public class BukkitCommandNode extends LiteralCommandNode<CommandSourceStack> {
 
@@ -33,16 +30,16 @@ public class BukkitCommandNode extends LiteralCommandNode<CommandSourceStack> {
 
     private BukkitCommandNode(String literal, Command command, BukkitBrigCommand bukkitBrigCommand) {
         super(
-            literal, bukkitBrigCommand, source -> {
-                // If the source is null, assume it's true.
-                // As bukkit doesn't really map the command sender well in all cases
-                if (source instanceof net.minecraft.commands.CommandSourceStack commandSourceStack && commandSourceStack.source == CommandSource.NULL) {
-                    return true;
-                } else {
-                    return command.testPermissionSilent(source.getSender());
-                }
-            },
-            null, null, false
+                literal, bukkitBrigCommand, source -> {
+                    // If the source is null, assume it's true.
+                    // As bukkit doesn't really map the command sender well in all cases
+                    if (source instanceof net.minecraft.commands.CommandSourceStack commandSourceStack && commandSourceStack.source == CommandSource.NULL) {
+                        return true;
+                    } else {
+                        return command.testPermissionSilent(source.getSender());
+                    }
+                },
+                null, null, false
         );
         this.command = command;
     }
@@ -51,9 +48,9 @@ public class BukkitCommandNode extends LiteralCommandNode<CommandSourceStack> {
         BukkitBrigCommand bukkitBrigCommand = new BukkitBrigCommand(command, name);
         BukkitCommandNode commandNode = new BukkitCommandNode(name, command, bukkitBrigCommand);
         commandNode.addChild(
-            RequiredArgumentBuilder.<CommandSourceStack, String>argument("args", StringArgumentType.greedyString())
-                .suggests(new BukkitBrigSuggestionProvider(command, name))
-                .executes(bukkitBrigCommand).build()
+                RequiredArgumentBuilder.<CommandSourceStack, String>argument("args", StringArgumentType.greedyString())
+                        .suggests(new BukkitBrigSuggestionProvider(command, name))
+                        .executes(bukkitBrigCommand).build()
         );
 
         return commandNode;
@@ -82,8 +79,8 @@ public class BukkitCommandNode extends LiteralCommandNode<CommandSourceStack> {
             String content = context.getRange().get(context.getInput());
             String[] args = org.apache.commons.lang3.StringUtils.split(content, ' '); // fix adjacent spaces (from console/plugins) causing empty array elements
 
-                // Note: we don't return the result of target.execute as thats success / failure, we return handled (true) or not handled (false)
-                this.command.execute(sender, this.literal, Arrays.copyOfRange(args, 1, args.length));
+            // Note: we don't return the result of target.execute as thats success / failure, we return handled (true) or not handled (false)
+            this.command.execute(sender, this.literal, Arrays.copyOfRange(args, 1, args.length));
 
             // return true as command was handled
             return 1;
@@ -116,7 +113,7 @@ public class BukkitCommandNode extends LiteralCommandNode<CommandSourceStack> {
             }
 
             if (sender instanceof final Player player) {
-                TabCompleteEvent tabEvent = new org.bukkit.event.server.TabCompleteEvent(player, builder.getInput(), results != null ? results : new ArrayList<>(), true, pos); // Paper - AsyncTabCompleteEvent
+                TabCompleteEvent tabEvent = new org.bukkit.event.server.TabCompleteEvent(player, builder.getInput(), results != null ? results : new net.vansen.norspaper.collections.DynamicObjectArrayList<>(), true, pos); // Paper - AsyncTabCompleteEvent
                 if (!tabEvent.callEvent()) {
                     results = null;
                 } else {
diff --git a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
index 2dca7afbd93cfbb8686f336fcd3b45dd01fba0fc..27bfac59d9612a5eefe8bdec8521a49a8f1d3473 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/ChunkDebugCommand.java
@@ -51,7 +51,7 @@ public final class ChunkDebugCommand implements PaperSubcommand {
                 }
             }
             case "holderinfo" -> {
-                List<String> worldNames = new ArrayList<>();
+                List<String> worldNames = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 worldNames.add("*");
                 for (org.bukkit.World world : Bukkit.getWorlds()) {
                     worldNames.add(world.getName());
@@ -61,7 +61,7 @@ public final class ChunkDebugCommand implements PaperSubcommand {
                 }
             }
             case "chunkinfo" -> {
-                List<String> worldNames = new ArrayList<>();
+                List<String> worldNames = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 worldNames.add("*");
                 for (org.bukkit.World world : Bukkit.getWorlds()) {
                     worldNames.add(world.getName());
diff --git a/src/main/java/io/papermc/paper/command/subcommands/DumpItemCommand.java b/src/main/java/io/papermc/paper/command/subcommands/DumpItemCommand.java
index e993177b052c76cb3f9c44edb598ebb4be858393..1a4fe2f9e82883a79f0b7da9b0a87e8253e1c8b7 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/DumpItemCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/DumpItemCommand.java
@@ -3,14 +3,6 @@ package io.papermc.paper.command.subcommands;
 import io.papermc.paper.adventure.PaperAdventure;
 import io.papermc.paper.command.CommandUtil;
 import io.papermc.paper.command.PaperSubcommand;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.IdentityHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.function.Consumer;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.ComponentLike;
 import net.kyori.adventure.text.JoinConfiguration;
@@ -36,15 +28,12 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
-import static net.kyori.adventure.text.Component.join;
-import static net.kyori.adventure.text.Component.text;
-import static net.kyori.adventure.text.Component.textOfChildren;
+import java.util.*;
+import java.util.function.Consumer;
+
+import static net.kyori.adventure.text.Component.*;
 import static net.kyori.adventure.text.event.ClickEvent.copyToClipboard;
-import static net.kyori.adventure.text.format.NamedTextColor.AQUA;
-import static net.kyori.adventure.text.format.NamedTextColor.GRAY;
-import static net.kyori.adventure.text.format.NamedTextColor.RED;
-import static net.kyori.adventure.text.format.NamedTextColor.WHITE;
-import static net.kyori.adventure.text.format.NamedTextColor.YELLOW;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
 import static net.kyori.adventure.text.format.TextColor.color;
 import static net.kyori.adventure.text.format.TextDecoration.ITALIC;
 
@@ -79,8 +68,8 @@ public final class DumpItemCommand implements PaperSubcommand {
         final RegistryAccess.Frozen access = ((CraftServer) sender.getServer()).getServer().registryAccess();
         final RegistryOps<Tag> ops = access.createSerializationContext(NbtOps.INSTANCE);
         final Registry<DataComponentType<?>> registry = access.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
-        final List<ComponentLike> componentComponents = new ArrayList<>();
-        final List<String> commandComponents = new ArrayList<>();
+        final List<ComponentLike> componentComponents = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        final List<String> commandComponents = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final DataComponentType<?> type : referencedComponentTypes) {
             final String path = registry.getResourceKey(type).orElseThrow().location().getPath();
             final @Nullable Optional<?> patchedValue = patch.get(type);
@@ -100,14 +89,14 @@ public final class DumpItemCommand implements PaperSubcommand {
         }
         if (!componentComponents.isEmpty()) {
             visualOutput.append(
-                text("[", color(0x8910CE)),
-                join(JoinConfiguration.separator(text(",", GRAY)), componentComponents),
-                text("]", color(0x8910CE))
+                    text("[", color(0x8910CE)),
+                    join(JoinConfiguration.separator(text(",", GRAY)), componentComponents),
+                    text("]", color(0x8910CE))
             );
             itemCommandBuilder
-                .append("[")
-                .append(String.join(",", commandComponents))
-                .append("]");
+                    .append("[")
+                    .append(String.join(",", commandComponents))
+                    .append("]");
         }
         player.sendMessage(visualOutput.build().compact());
         final Component copyMsg = text("Click to copy item definition to clipboard for use with /give", GRAY, ITALIC);
@@ -116,11 +105,11 @@ public final class DumpItemCommand implements PaperSubcommand {
 
     private static void writeComponentValue(final Consumer<Component> visualOutput, final Consumer<String> commandOutput, final String path, final Tag serialized) {
         visualOutput.accept(textOfChildren(
-            text(path, color(0xFF7FD7)),
-            text("=", WHITE),
-            PaperAdventure.asAdventure(NbtUtils.toPrettyComponent(serialized))
+                text(path, color(0xFF7FD7)),
+                text("=", WHITE),
+                PaperAdventure.asAdventure(NbtUtils.toPrettyComponent(serialized))
         ));
-        commandOutput.accept(path + "=" + new SnbtPrinterTagVisitor("", 0, new ArrayList<>()).visit(serialized));
+        commandOutput.accept(path + "=" + new SnbtPrinterTagVisitor("", 0, new net.vansen.norspaper.collections.DynamicObjectArrayList<>()).visit(serialized));
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/command/subcommands/DumpListenersCommand.java b/src/main/java/io/papermc/paper/command/subcommands/DumpListenersCommand.java
index aa44d4685de3caee4131449bead7a084868ff976..904aebd22cfc65cf0082b261e97c0ac97d16aa3c 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/DumpListenersCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/DumpListenersCommand.java
@@ -2,6 +2,16 @@ package io.papermc.paper.command.subcommands;
 
 import com.destroystokyo.paper.util.SneakyThrow;
 import io.papermc.paper.command.PaperSubcommand;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.event.HandlerList;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.RegisteredListener;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -10,28 +20,13 @@ import java.lang.invoke.MethodHandles;
 import java.lang.reflect.Field;
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
-import net.kyori.adventure.text.Component;
-import net.minecraft.server.MinecraftServer;
-import org.bukkit.Bukkit;
-import org.bukkit.command.CommandSender;
-import org.bukkit.event.HandlerList;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.RegisteredListener;
-import org.checkerframework.checker.nullness.qual.NonNull;
-import org.checkerframework.framework.qual.DefaultQualifier;
 
-import static net.kyori.adventure.text.Component.newline;
-import static net.kyori.adventure.text.Component.space;
-import static net.kyori.adventure.text.Component.text;
-import static net.kyori.adventure.text.format.NamedTextColor.GRAY;
-import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
-import static net.kyori.adventure.text.format.NamedTextColor.RED;
-import static net.kyori.adventure.text.format.NamedTextColor.WHITE;
+import static net.kyori.adventure.text.Component.*;
+import static net.kyori.adventure.text.format.NamedTextColor.*;
 
 @DefaultQualifier(NonNull.class)
 public final class DumpListenersCommand implements PaperSubcommand {
@@ -59,7 +54,7 @@ public final class DumpListenersCommand implements PaperSubcommand {
 
     private void dumpToFile(final CommandSender sender) {
         final File file = new File("debug/listeners-"
-            + DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(LocalDateTime.now()) + ".txt");
+                + DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(LocalDateTime.now()) + ".txt");
         file.getParentFile().mkdirs();
         try (final PrintWriter writer = new PrintWriter(file)) {
             for (final String eventClass : eventClassNames()) {
@@ -100,16 +95,16 @@ public final class DumpListenersCommand implements PaperSubcommand {
 
             for (final RegisteredListener listener : handlers.getRegisteredListeners()) {
                 final Component hoverText = text("Priority: " + listener.getPriority().name() + " (" + listener.getPriority().getSlot() + ")", WHITE)
-                    .append(newline())
-                    .append(text("Listener: " + listener.getListener()))
-                    .append(newline())
-                    .append(text("Executor: " + listener.getExecutor()))
-                    .append(newline())
-                    .append(text("Ignoring cancelled: " + listener.isIgnoringCancelled()));
+                        .append(newline())
+                        .append(text("Listener: " + listener.getListener()))
+                        .append(newline())
+                        .append(text("Executor: " + listener.getExecutor()))
+                        .append(newline())
+                        .append(text("Ignoring cancelled: " + listener.isIgnoringCancelled()));
 
                 sender.sendMessage(text(listener.getPlugin().getName(), GREEN)
-                    .append(space())
-                    .append(text("(" + listener.getListener().getClass().getName() + ")", GRAY).hoverEvent(hoverText)));
+                        .append(space())
+                        .append(text("(" + listener.getListener().getClass().getName() + ")", GRAY).hoverEvent(hoverText)));
             }
 
             sender.sendMessage(text("Total listeners: " + handlers.getRegisteredListeners().length));
@@ -129,14 +124,14 @@ public final class DumpListenersCommand implements PaperSubcommand {
         return switch (args.length) {
             case 0 -> suggestions();
             case 1 -> suggestions().stream()
-                .filter(clazz -> clazz.toLowerCase(Locale.ROOT).contains(args[0].toLowerCase(Locale.ROOT)))
-                .toList();
+                    .filter(clazz -> clazz.toLowerCase(Locale.ROOT).contains(args[0].toLowerCase(Locale.ROOT)))
+                    .toList();
             default -> Collections.emptyList();
         };
     }
 
     private static List<String> suggestions() {
-        final List<String> ret = new ArrayList<>();
+        final List<String> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         ret.add("tofile");
         ret.addAll(eventClassNames());
         return ret;
diff --git a/src/main/java/io/papermc/paper/command/subcommands/DumpPluginsCommand.java b/src/main/java/io/papermc/paper/command/subcommands/DumpPluginsCommand.java
index d4a092243e587e3a555fbc0f00c8f78c00b3d1c6..eb17515c033d47ced36d97b35859849fab6e8cb8 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/DumpPluginsCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/DumpPluginsCommand.java
@@ -107,7 +107,7 @@ public final class DumpPluginsCommand implements PaperSubcommand {
             JsonArray providers = new JsonArray();
             entrypoint.add("providers", providers);
 
-            List<PluginProvider<Object>> pluginProviders = new ArrayList<>();
+            List<PluginProvider<Object>> pluginProviders = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (PluginProvider<?> provider : entry.getValue().getRegisteredProviders()) {
                 JsonObject providerObj = new JsonObject();
                 providerObj.addProperty("name", provider.getMeta().getName());
diff --git a/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java b/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java
index d3b39d88a72ca25057fd8574d32f28db0d420818..63d2113f9d8961caf2e9f4c56ec904e3c8ca4f64 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/MobcapsCommand.java
@@ -3,11 +3,6 @@ package io.papermc.paper.command.subcommands;
 import com.google.common.collect.ImmutableMap;
 import io.papermc.paper.command.CommandUtil;
 import io.papermc.paper.command.PaperSubcommand;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.function.ToIntFunction;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.ComponentLike;
 import net.kyori.adventure.text.JoinConfiguration;
@@ -29,18 +24,24 @@ import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.function.ToIntFunction;
+
 @DefaultQualifier(NonNull.class)
 public final class MobcapsCommand implements PaperSubcommand {
     static final Map<MobCategory, TextColor> MOB_CATEGORY_COLORS = ImmutableMap.<MobCategory, TextColor>builder()
-        .put(MobCategory.MONSTER, NamedTextColor.RED)
-        .put(MobCategory.CREATURE, NamedTextColor.GREEN)
-        .put(MobCategory.AMBIENT, NamedTextColor.GRAY)
-        .put(MobCategory.AXOLOTLS, TextColor.color(0x7324FF))
-        .put(MobCategory.UNDERGROUND_WATER_CREATURE, TextColor.color(0x3541E6))
-        .put(MobCategory.WATER_CREATURE, TextColor.color(0x006EFF))
-        .put(MobCategory.WATER_AMBIENT, TextColor.color(0x00B3FF))
-        .put(MobCategory.MISC, TextColor.color(0x636363))
-        .build();
+            .put(MobCategory.MONSTER, NamedTextColor.RED)
+            .put(MobCategory.CREATURE, NamedTextColor.GREEN)
+            .put(MobCategory.AMBIENT, NamedTextColor.GRAY)
+            .put(MobCategory.AXOLOTLS, TextColor.color(0x7324FF))
+            .put(MobCategory.UNDERGROUND_WATER_CREATURE, TextColor.color(0x3541E6))
+            .put(MobCategory.WATER_CREATURE, TextColor.color(0x006EFF))
+            .put(MobCategory.WATER_AMBIENT, TextColor.color(0x00B3FF))
+            .put(MobCategory.MISC, TextColor.color(0x636363))
+            .build();
 
     @Override
     public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
@@ -55,7 +56,8 @@ public final class MobcapsCommand implements PaperSubcommand {
     public List<String> tabComplete(final CommandSender sender, final String subCommand, final String[] args) {
         return switch (subCommand) {
             case "mobcaps" -> CommandUtil.getListMatchingLast(sender, args, this.suggestMobcaps(args));
-            case "playermobcaps" -> CommandUtil.getListMatchingLast(sender, args, this.suggestPlayerMobcaps(sender, args));
+            case "playermobcaps" ->
+                    CommandUtil.getListMatchingLast(sender, args, this.suggestPlayerMobcaps(sender, args));
             default -> throw new IllegalArgumentException();
         };
     }
@@ -72,7 +74,7 @@ public final class MobcapsCommand implements PaperSubcommand {
 
     private List<String> suggestPlayerMobcaps(final CommandSender sender, final String[] args) {
         if (args.length == 1) {
-            final List<String> list = new ArrayList<>();
+            final List<String> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (final Player player : Bukkit.getOnlinePlayers()) {
                 if (!(sender instanceof Player senderPlayer) || senderPlayer.canSee(player)) {
                     list.add(player.getName());
@@ -122,20 +124,20 @@ public final class MobcapsCommand implements PaperSubcommand {
                 chunks = state.getSpawnableChunkCount();
             }
             sender.sendMessage(Component.join(JoinConfiguration.noSeparators(),
-                Component.text("Mobcaps for world: "),
-                Component.text(world.getName(), NamedTextColor.AQUA),
-                Component.text(" (" + chunks + " spawnable chunks)")
+                    Component.text("Mobcaps for world: "),
+                    Component.text(world.getName(), NamedTextColor.AQUA),
+                    Component.text(" (" + chunks + " spawnable chunks)")
             ));
 
             sender.sendMessage(createMobcapsComponent(
-                category -> {
-                    if (state == null) {
-                        return 0;
-                    } else {
-                        return state.getMobCategoryCounts().getOrDefault(category, 0);
-                    }
-                },
-                category -> NaturalSpawner.globalLimitForCategory(level, category, chunks)
+                    category -> {
+                        if (state == null) {
+                            return 0;
+                        } else {
+                            return state.getMobCategoryCounts().getOrDefault(category, 0);
+                        }
+                    },
+                    category -> NaturalSpawner.globalLimitForCategory(level, category, chunks)
             ));
         }
     }
@@ -171,59 +173,59 @@ public final class MobcapsCommand implements PaperSubcommand {
 
         sender.sendMessage(Component.join(JoinConfiguration.noSeparators(), Component.text("Mobcaps for player: "), Component.text(player.getName(), NamedTextColor.GREEN)));
         sender.sendMessage(createMobcapsComponent(
-            category -> level.chunkSource.chunkMap.getMobCountNear(serverPlayer, category),
-            category -> level.getWorld().getSpawnLimitUnsafe(org.bukkit.craftbukkit.util.CraftSpawnCategory.toBukkit(category))
+                category -> level.chunkSource.chunkMap.getMobCountNear(serverPlayer, category),
+                category -> level.getWorld().getSpawnLimitUnsafe(org.bukkit.craftbukkit.util.CraftSpawnCategory.toBukkit(category))
         ));
     }
 
     private static Component createMobcapsComponent(final ToIntFunction<MobCategory> countGetter, final ToIntFunction<MobCategory> limitGetter) {
         return MOB_CATEGORY_COLORS.entrySet().stream()
-            .map(entry -> {
-                final MobCategory category = entry.getKey();
-                final TextColor color = entry.getValue();
-
-                final Component categoryHover = Component.join(JoinConfiguration.noSeparators(),
-                    Component.text("Entity types in category ", TextColor.color(0xE0E0E0)),
-                    Component.text(category.getName(), color),
-                    Component.text(':', NamedTextColor.GRAY),
-                    Component.newline(),
-                    Component.newline(),
-                    BuiltInRegistries.ENTITY_TYPE.entrySet().stream()
-                        .filter(it -> it.getValue().getCategory() == category)
-                        .map(it -> Component.translatable(it.getValue().getDescriptionId()))
-                        .collect(Component.toComponent(Component.text(", ", NamedTextColor.GRAY)))
-                );
-
-                final Component categoryComponent = Component.text()
-                    .content("  " + category.getName())
-                    .color(color)
-                    .hoverEvent(categoryHover)
-                    .build();
-
-                final TextComponent.Builder builder = Component.text()
-                    .append(
-                        categoryComponent,
-                        Component.text(": ", NamedTextColor.GRAY)
+                .map(entry -> {
+                    final MobCategory category = entry.getKey();
+                    final TextColor color = entry.getValue();
+
+                    final Component categoryHover = Component.join(JoinConfiguration.noSeparators(),
+                            Component.text("Entity types in category ", TextColor.color(0xE0E0E0)),
+                            Component.text(category.getName(), color),
+                            Component.text(':', NamedTextColor.GRAY),
+                            Component.newline(),
+                            Component.newline(),
+                            BuiltInRegistries.ENTITY_TYPE.entrySet().stream()
+                                    .filter(it -> it.getValue().getCategory() == category)
+                                    .map(it -> Component.translatable(it.getValue().getDescriptionId()))
+                                    .collect(Component.toComponent(Component.text(", ", NamedTextColor.GRAY)))
                     );
-                final int limit = limitGetter.applyAsInt(category);
-                if (limit != -1) {
-                    builder.append(
-                        Component.text(countGetter.applyAsInt(category)),
-                        Component.text("/", NamedTextColor.GRAY),
-                        Component.text(limit)
-                    );
-                } else {
-                    builder.append(Component.text()
-                        .append(
-                            Component.text('n'),
-                            Component.text("/", NamedTextColor.GRAY),
-                            Component.text('a')
-                        )
-                        .hoverEvent(Component.text("This category does not naturally spawn.")));
-                }
-                return builder;
-            })
-            .map(ComponentLike::asComponent)
-            .collect(Component.toComponent(Component.newline()));
+
+                    final Component categoryComponent = Component.text()
+                            .content("  " + category.getName())
+                            .color(color)
+                            .hoverEvent(categoryHover)
+                            .build();
+
+                    final TextComponent.Builder builder = Component.text()
+                            .append(
+                                    categoryComponent,
+                                    Component.text(": ", NamedTextColor.GRAY)
+                            );
+                    final int limit = limitGetter.applyAsInt(category);
+                    if (limit != -1) {
+                        builder.append(
+                                Component.text(countGetter.applyAsInt(category)),
+                                Component.text("/", NamedTextColor.GRAY),
+                                Component.text(limit)
+                        );
+                    } else {
+                        builder.append(Component.text()
+                                .append(
+                                        Component.text('n'),
+                                        Component.text("/", NamedTextColor.GRAY),
+                                        Component.text('a')
+                                )
+                                .hoverEvent(Component.text("This category does not naturally spawn.")));
+                    }
+                    return builder;
+                })
+                .map(ComponentLike::asComponent)
+                .collect(Component.toComponent(Component.newline()));
     }
 }
diff --git a/src/main/java/io/papermc/paper/configuration/serializer/NbtPathSerializer.java b/src/main/java/io/papermc/paper/configuration/serializer/NbtPathSerializer.java
index b44b2dc28f619594e302417848e95c0087acbcea..d3d5e70ae42dcdb84e111ee4c0d1421b8fe5b300 100644
--- a/src/main/java/io/papermc/paper/configuration/serializer/NbtPathSerializer.java
+++ b/src/main/java/io/papermc/paper/configuration/serializer/NbtPathSerializer.java
@@ -3,14 +3,14 @@ package io.papermc.paper.configuration.serializer;
 import com.destroystokyo.paper.util.SneakyThrow;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Predicate;
 import net.minecraft.commands.arguments.NbtPathArgument;
 import org.spongepowered.configurate.serialize.ScalarSerializer;
 import org.spongepowered.configurate.serialize.SerializationException;
 
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.function.Predicate;
+
 public class NbtPathSerializer extends ScalarSerializer<NbtPathArgument.NbtPath> {
 
     public static final NbtPathSerializer SERIALIZER = new NbtPathSerializer();
@@ -31,7 +31,7 @@ public class NbtPathSerializer extends ScalarSerializer<NbtPathArgument.NbtPath>
     }
 
     public static List<NbtPathArgument.NbtPath> fromString(final List<String> tags) {
-        List<NbtPathArgument.NbtPath> paths = new ArrayList<>();
+        List<NbtPathArgument.NbtPath> paths = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         try {
             for (final String tag : tags) {
                 paths.add(fromString(tag));
diff --git a/src/main/java/io/papermc/paper/console/BrigadierConsoleParser.java b/src/main/java/io/papermc/paper/console/BrigadierConsoleParser.java
index 8239a8ba57f856cbbee237a601b3cabfce20ba26..f1949b2bf392b7166305d4f0429f99bf0854480c 100644
--- a/src/main/java/io/papermc/paper/console/BrigadierConsoleParser.java
+++ b/src/main/java/io/papermc/paper/console/BrigadierConsoleParser.java
@@ -26,7 +26,7 @@ public class BrigadierConsoleParser implements Parser {
     public ParsedLine parse(final String line, final int cursor, final ParseContext context) throws SyntaxError {
         final ParseResults<CommandSourceStack> results = this.server.getCommands().getDispatcher().parse(new StringReader(line), this.server.createCommandSourceStack());
         final ImmutableStringReader reader = results.getReader();
-        final List<String> words = new ArrayList<>();
+        final List<String> words = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         CommandContextBuilder<CommandSourceStack> currentContext = results.getContext();
         int currentWordIdx = -1;
         int wordIdx = -1;
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperPluginClassLoader.java
index 18401ede9cd1fc7094c6b74859929938e01795ca..3f3693247e0bacc059962ee74b9a8b193e594bff 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperPluginClassLoader.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperPluginClassLoader.java
@@ -88,7 +88,7 @@ public class PaperPluginClassLoader extends PaperSimplePluginClassLoader impleme
 
     @Override
     public Enumeration<URL> getResources(String name) throws IOException {
-        List<URL> resources = new ArrayList<>();
+        List<URL> resources = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.addEnumeration(resources, this.findResources(name));
         if (this.libraryLoader != null) {
             addEnumeration(resources, this.libraryLoader.getResources(name));
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/DependencyBasedPluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/DependencyBasedPluginClassLoaderGroup.java
index eaf5c794cbe8d6138c9d60eaae20f5fc7711f541..8edf699c3978dd0543cd7285696b50e599a66b66 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/DependencyBasedPluginClassLoaderGroup.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/DependencyBasedPluginClassLoaderGroup.java
@@ -4,8 +4,6 @@ import io.papermc.paper.plugin.provider.classloader.ClassLoaderAccess;
 import io.papermc.paper.plugin.provider.classloader.ConfiguredPluginClassLoader;
 import org.jetbrains.annotations.ApiStatus;
 
-import java.util.ArrayList;
-
 @ApiStatus.Internal
 public class DependencyBasedPluginClassLoaderGroup extends SimpleListPluginClassLoaderGroup {
 
@@ -13,7 +11,7 @@ public class DependencyBasedPluginClassLoaderGroup extends SimpleListPluginClass
     private final ClassLoaderAccess access;
 
     public DependencyBasedPluginClassLoaderGroup(GlobalPluginClassLoaderGroup globalPluginClassLoaderGroup, ClassLoaderAccess access) {
-        super(new ArrayList<>());
+        super(new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
         this.access = access;
         this.globalPluginClassLoaderGroup = globalPluginClassLoaderGroup;
     }
@@ -39,9 +37,9 @@ public class DependencyBasedPluginClassLoaderGroup extends SimpleListPluginClass
     @Override
     public String toString() {
         return "DependencyBasedPluginClassLoaderGroup{" +
-            "globalPluginClassLoaderGroup=" + this.globalPluginClassLoaderGroup +
-            ", access=" + this.access +
-            ", classloaders=" + this.classloaders +
-            '}';
+                "globalPluginClassLoaderGroup=" + this.globalPluginClassLoaderGroup +
+                ", access=" + this.access +
+                ", classloaders=" + this.classloaders +
+                '}';
     }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/PaperPluginClassLoaderStorage.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/PaperPluginClassLoaderStorage.java
index e6fcdeb96356ff4713627b1458ac8bbfad1866b1..1767fc9e439f7e805f551666b84e1f7e1f27fb3a 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/PaperPluginClassLoaderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/group/PaperPluginClassLoaderStorage.java
@@ -37,7 +37,7 @@ public final class PaperPluginClassLoaderStorage implements PaperClassLoaderStor
 
     @Override
     public PluginClassLoaderGroup registerAccessBackedGroup(ConfiguredPluginClassLoader classLoader, ClassLoaderAccess access) {
-        List<ConfiguredPluginClassLoader> allowedLoaders = new ArrayList<>();
+        List<ConfiguredPluginClassLoader> allowedLoaders = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (ConfiguredPluginClassLoader configuredPluginClassLoader : this.globalGroup.getClassLoaders()) {
             if (access.canAccess(configuredPluginClassLoader)) {
                 allowedLoaders.add(configuredPluginClassLoader);
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/JohnsonSimpleCycles.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/JohnsonSimpleCycles.java
index a9bca905eba67972e4d1b07b1d243272b62fec66..f6aaa7e2e29b0995c46ed4c1ebb416481407a950 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/JohnsonSimpleCycles.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/JohnsonSimpleCycles.java
@@ -92,7 +92,7 @@ public class JohnsonSimpleCycles<V>
      */
     public List<List<V>> findAndRemoveSimpleCycles()
     {
-        List<List<V>> result = new ArrayList<>();
+        List<List<V>> result = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findSimpleCycles(result::add, (v, s) -> ((MutableGraph<V>) graph).removeEdge(v, s)); // Paper
         return result;
     }
@@ -318,7 +318,7 @@ public class JohnsonSimpleCycles<V>
     private void initMinSCGState()
     {
         index = 0;
-        foundSCCs = new ArrayList<>();
+        foundSCCs = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         vIndex = new HashMap<>();
         vLowlink = new HashMap<>();
         path = new ArrayDeque<>();
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/LegacyPluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/LegacyPluginLoadingStrategy.java
index f59f48654eaa299bcac862991b1e2e622264639b..4a623846839715a3041f67dfe30547b34569c258 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/LegacyPluginLoadingStrategy.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/LegacyPluginLoadingStrategy.java
@@ -33,7 +33,7 @@ public class LegacyPluginLoadingStrategy<T> implements ProviderLoadingStrategy<T
 
     @Override
     public List<ProviderPair<T>> loadProviders(List<PluginProvider<T>> providers, MetaDependencyTree dependencyTree) {
-        List<ProviderPair<T>> javapluginsLoaded = new ArrayList<>();
+        List<ProviderPair<T>> javapluginsLoaded = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         MutableGraph<String> dependencyGraph = dependencyTree.getGraph();
 
         Map<String, PluginProvider<T>> providersToLoad = new HashMap<>();
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/TopographicGraphSorter.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/TopographicGraphSorter.java
index 52a110044611c8a0ace6d49549e8acc16cbbe83d..48ff80a0ef92d7daa4cf6f493c0198af3e0261d4 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/TopographicGraphSorter.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/TopographicGraphSorter.java
@@ -12,7 +12,7 @@ public final class TopographicGraphSorter {
 
     // Topographically sort dependencies
     public static <N> List<N> sortGraph(Graph<N> graph) throws PluginGraphCycleException {
-        List<N> sorted = new ArrayList<>();
+        List<N> sorted = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Deque<N> roots = new ArrayDeque<>();
         Object2IntMap<N> nonRoots = new Object2IntOpenHashMap<>();
 
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/LoadOrderTree.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/LoadOrderTree.java
index e3f01ec40a704acb46f7ac31d500e9d0185e3db9..48e5ebe2be7df7fc4ecde6756009c22a0ba655f4 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/LoadOrderTree.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/LoadOrderTree.java
@@ -110,7 +110,7 @@ class LoadOrderTree {
                 LOGGER.error("   {} loadafter: {}", meta.getName(), paperPluginMeta.getLoadAfterPlugins());
             }
         } else {
-            List<String> dependencies = new ArrayList<>();
+            List<String> dependencies = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             dependencies.addAll(meta.getPluginDependencies());
             dependencies.addAll(meta.getPluginSoftDependencies());
             if (!dependencies.isEmpty()) {
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
index 9af388a8e56806ab44f8c3ef4f97086ce38ef3b4..b5df4289aa892ccdcf3e1a631b2f9e8945409aa5 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/strategy/modern/ModernPluginLoadingStrategy.java
@@ -32,7 +32,7 @@ public class ModernPluginLoadingStrategy<T> implements ProviderLoadingStrategy<T
     public List<ProviderPair<T>> loadProviders(List<PluginProvider<T>> pluginProviders, MetaDependencyTree dependencyTree) {
         Map<String, PluginProviderEntry<T>> providerMap = new HashMap<>();
         Map<String, PluginProvider<?>> providerMapMirror = Maps.transformValues(providerMap, (entry) -> entry.provider);
-        List<PluginProvider<T>> validatedProviders = new ArrayList<>();
+        List<PluginProvider<T>> validatedProviders = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         // Populate provider map
         for (PluginProvider<T> provider : pluginProviders) {
@@ -96,7 +96,7 @@ public class ModernPluginLoadingStrategy<T> implements ProviderLoadingStrategy<T
 
         // Reverse the topographic search to let us see which providers we can load first.
         List<String> reversedTopographicSort = loadOrderTree.getLoadOrder();
-        List<ProviderPair<T>> loadedPlugins = new ArrayList<>();
+        List<ProviderPair<T>> loadedPlugins = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (String providerIdentifier : reversedTopographicSort) {
             // It's possible that this will be null because the above dependencies for soft/load before aren't validated if they exist.
             // The graph could be MutableGraph<PluginProvider<T>>, but we would have to check if each dependency exists there... just
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
index ce808520d639581696689a2ab85de00d85aa0ee3..f509678aa92f2c3441020808ea4a62cd290c606d 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
@@ -20,7 +20,7 @@ public class LifecycleEventRunner {
 
     public static final LifecycleEventRunner INSTANCE = new LifecycleEventRunner();
 
-    private final List<LifecycleEventType<?, ?, ?>> lifecycleEventTypes = new ArrayList<>();
+    private final List<LifecycleEventType<?, ?, ?>> lifecycleEventTypes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private boolean blockPluginReloading = false;
 
     public <O extends LifecycleEventOwner> void checkRegisteredHandler(final O owner, final AbstractLifecycleEventType<O, ?, ?> eventType) {
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
index abb969cf6ed967fe7720c56d3b3157bd1b74700d..b66e7cd6c5000ab7fd057cb9e99f082b960de151 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/MonitorableLifecycleEventType.java
@@ -6,17 +6,17 @@ import io.papermc.paper.plugin.lifecycle.event.handler.LifecycleEventHandler;
 import io.papermc.paper.plugin.lifecycle.event.handler.configuration.AbstractLifecycleEventHandlerConfiguration;
 import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfiguration;
 import io.papermc.paper.plugin.lifecycle.event.handler.configuration.MonitorLifecycleEventHandlerConfigurationImpl;
-import java.util.ArrayList;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
 import java.util.List;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
-import org.checkerframework.checker.nullness.qual.NonNull;
-import org.checkerframework.framework.qual.DefaultQualifier;
 
 @DefaultQualifier(NonNull.class)
 public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E, MonitorLifecycleEventHandlerConfiguration<O>> implements LifecycleEventType.Monitorable<O, E> {
 
-    final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
+    final List<RegisteredHandler<O, E>> handlers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     int nonMonitorIdx = 0;
 
     public MonitorableLifecycleEventType(final String name, final Class<? extends O> ownerType) {
@@ -35,7 +35,7 @@ public class MonitorableLifecycleEventType<O extends LifecycleEventOwner, E exte
 
     @Override
     protected void register(final O owner, final AbstractLifecycleEventHandlerConfiguration<O, E> config) {
-        if (!(config instanceof final MonitorLifecycleEventHandlerConfigurationImpl<?,?> monitor)) {
+        if (!(config instanceof final MonitorLifecycleEventHandlerConfigurationImpl<?, ?> monitor)) {
             throw new IllegalArgumentException("Configuration must be a MonitorLifecycleEventHandlerConfiguration");
         }
         final RegisteredHandler<O, E> registeredHandler = new RegisteredHandler<>(owner, config);
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
index 2ed622a61ddc37b11888867770b513909b9a2ecc..37eb833d38d0659e2b6ca53bb0daad83e6814b0b 100644
--- a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizableLifecycleEventType.java
@@ -34,7 +34,7 @@ public abstract class PrioritizableLifecycleEventType<
         }
     });
 
-    private final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
+    private final List<RegisteredHandler<O, E>> handlers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     public PrioritizableLifecycleEventType(final String name, final Class<? extends O> ownerType) {
         super(name, ownerType);
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PaperClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/loader/PaperClasspathBuilder.java
index 21a0a4e29c0eb1b4f7dc89ad3df481ca89dbf1a4..6a02489564a1124ede8cf4af7cdc9f078dfe1eb7 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/PaperClasspathBuilder.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/PaperClasspathBuilder.java
@@ -8,20 +8,20 @@ import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
 import io.papermc.paper.plugin.loader.library.PaperLibraryStore;
 import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
 import io.papermc.paper.util.MappingEnvironment;
+import org.jetbrains.annotations.NotNull;
+
 import java.io.IOException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLClassLoader;
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.jar.JarFile;
 import java.util.logging.Logger;
-import org.jetbrains.annotations.NotNull;
 
 public class PaperClasspathBuilder implements PluginClasspathBuilder {
 
-    private final List<ClassPathLibrary> libraries = new ArrayList<>();
+    private final List<ClassPathLibrary> libraries = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     private final PluginProviderContext context;
 
@@ -54,8 +54,8 @@ public class PaperClasspathBuilder implements PluginClasspathBuilder {
 
         try {
             final URLClassLoader libraryLoader = MappingEnvironment.DISABLE_PLUGIN_REMAPPING
-                ? new URLClassLoader(urls, this.getClass().getClassLoader())
-                : new BytecodeModifyingURLClassLoader(urls, this.getClass().getClassLoader());
+                    ? new URLClassLoader(urls, this.getClass().getClassLoader())
+                    : new BytecodeModifyingURLClassLoader(urls, this.getClass().getClassLoader());
             return new PaperPluginClassLoader(logger, source, jarFile, configuration, this.getClass().getClassLoader(), libraryLoader);
         } catch (IOException exception) {
             throw new RuntimeException(exception);
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/PaperLibraryStore.java b/src/main/java/io/papermc/paper/plugin/loader/library/PaperLibraryStore.java
index 5fcce65009f715d46dd3013f1f92ec8393d66e15..3e46d630d664591f99a269b74f375b6da7aa7b6e 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/library/PaperLibraryStore.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/PaperLibraryStore.java
@@ -8,7 +8,7 @@ import java.util.List;
 
 public class PaperLibraryStore implements LibraryStore {
 
-    private final List<Path> paths = new ArrayList<>();
+    private final List<Path> paths = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     @Override
     public void addLibrary(@NotNull Path library) {
diff --git a/src/main/java/io/papermc/paper/plugin/manager/MultiRuntimePluginProviderStorage.java b/src/main/java/io/papermc/paper/plugin/manager/MultiRuntimePluginProviderStorage.java
index d681222f355af5c4c26f35aaba484a393aee41c6..a87d68b5678c34737b0dfa6f977f320c98195137 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/MultiRuntimePluginProviderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/MultiRuntimePluginProviderStorage.java
@@ -3,7 +3,6 @@ package io.papermc.paper.plugin.manager;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.plugin.entrypoint.Entrypoint;
 import io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler;
-import io.papermc.paper.plugin.entrypoint.dependency.GraphDependencyContext;
 import io.papermc.paper.plugin.entrypoint.dependency.MetaDependencyTree;
 import io.papermc.paper.plugin.provider.PluginProvider;
 import io.papermc.paper.plugin.provider.type.paper.PaperPluginParent;
@@ -11,13 +10,12 @@ import io.papermc.paper.plugin.storage.ServerPluginProviderStorage;
 import org.bukkit.plugin.java.JavaPlugin;
 import org.slf4j.Logger;
 
-import java.util.ArrayList;
 import java.util.List;
 
 public class MultiRuntimePluginProviderStorage extends ServerPluginProviderStorage {
 
     private static final Logger LOGGER = LogUtils.getClassLogger();
-    private final List<JavaPlugin> provided = new ArrayList<>();
+    private final List<JavaPlugin> provided = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     private final MetaDependencyTree dependencyTree;
 
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
index 3e82ea07ca4194844c5528446e2c4a46ff4acee5..b0fddb9b21d39718e90101cd0961b74f7ff50b93 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
@@ -48,7 +48,7 @@ class PaperPluginInstanceManager {
 
     private static final FileProviderSource FILE_PROVIDER_SOURCE = new FileProviderSource("File '%s'"::formatted);
 
-    private final List<Plugin> plugins = new ArrayList<>();
+    private final List<Plugin> plugins = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final Map<String, Plugin> lookupNames = new HashMap<>();
 
     private final PluginManager pluginManager;
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java
index f951f4024745503e9cdfa7ff17b9313ac6d7b4c4..82b22613455423773ff826ab023fb723c140d960 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java
@@ -8,7 +8,6 @@ import org.spongepowered.configurate.serialize.SerializationException;
 import org.spongepowered.configurate.serialize.TypeSerializer;
 
 import java.lang.reflect.Type;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
@@ -33,7 +32,7 @@ public class PermissionConfigurationSerializer {
                 permissionDefault = PermissionDefault.getByName(permNode.getString());
             }
 
-            List<Permission> result = new ArrayList<>();
+            List<Permission> result = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             if (map != null) {
                 for (Map.Entry<?, ?> entry : map.entrySet()) {
                     try {
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/DirectoryProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/DirectoryProviderSource.java
index 0846d3a904e470ae1920c5c8be3df9c5dfc3de27..04ba3dd9078a1f4eb10afe4f868636b7d7278025 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/source/DirectoryProviderSource.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/DirectoryProviderSource.java
@@ -2,14 +2,14 @@ package io.papermc.paper.plugin.provider.source;
 
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import org.slf4j.Logger;
+
 import java.io.IOException;
 import java.nio.file.FileVisitOption;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
-import org.slf4j.Logger;
 
 /**
  * Loads all plugin providers in the given directory.
@@ -27,7 +27,7 @@ public class DirectoryProviderSource implements ProviderSource<Path, List<Path>>
             Files.createDirectories(context);
         }
 
-        final List<Path> files = new ArrayList<>();
+        final List<Path> files = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.walkFiles(context, path -> {
             try {
                 files.add(FILE_PROVIDER_SOURCE.prepareContext(path));
@@ -60,8 +60,8 @@ public class DirectoryProviderSource implements ProviderSource<Path, List<Path>>
 
     private void walkFiles(Path context, Consumer<Path> consumer) throws IOException {
         Files.walk(context, 1, FileVisitOption.FOLLOW_LINKS)
-            .filter(this::isValidFile)
-            .forEach(consumer);
+                .filter(this::isValidFile)
+                .forEach(consumer);
     }
 
     public boolean isValidFile(Path path) {
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/FileArrayProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/FileArrayProviderSource.java
index b2ec31fdb2ba8f18c29f2014c03c96a15ec995ad..8bf6dcd41980d882499d6cf15d76649a66722e8a 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/source/FileArrayProviderSource.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/FileArrayProviderSource.java
@@ -2,11 +2,11 @@ package io.papermc.paper.plugin.provider.source;
 
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
+import org.slf4j.Logger;
+
 import java.io.File;
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.List;
-import org.slf4j.Logger;
 
 public class FileArrayProviderSource implements ProviderSource<File[], List<Path>> {
 
@@ -16,7 +16,7 @@ public class FileArrayProviderSource implements ProviderSource<File[], List<Path
 
     @Override
     public List<Path> prepareContext(File[] context) {
-        final List<Path> files = new ArrayList<>();
+        final List<Path> files = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (File file : context) {
             try {
                 files.add(FILE_PROVIDER_SOURCE.prepareContext(file.toPath()));
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/PluginFlagProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/PluginFlagProviderSource.java
index c2b60c74513544e5d96110c7c3ff80e8f1b686d1..fea881851a826eb8c29fea8f00d89044ba9ffa78 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/source/PluginFlagProviderSource.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/PluginFlagProviderSource.java
@@ -19,7 +19,7 @@ public class PluginFlagProviderSource implements ProviderSource<List<Path>, List
 
     @Override
     public List<Path> prepareContext(List<Path> context) {
-        final List<Path> files = new ArrayList<>();
+        final List<Path> files = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (Path path : context) {
             try {
                 files.add(FILE_PROVIDER_SOURCE.prepareContext(path));
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
index 8d0da6e46d4eb5eb05c3144510c4ef083559d0ec..e01ed9dd781a273c1a3be2a8d1a7648e93df272d 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
@@ -10,7 +10,6 @@ import org.bukkit.plugin.PluginDescriptionFile;
 import org.jetbrains.annotations.Nullable;
 
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
@@ -23,8 +22,8 @@ import java.util.jar.JarFile;
 public abstract class PluginFileType<T, C extends PluginMeta> {
 
     public static final String PAPER_PLUGIN_YML = "paper-plugin.yml";
-    private static final List<String> CONFIG_TYPES = new ArrayList<>();
-    
+    private static final List<String> CONFIG_TYPES = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+
     public static final PluginFileType<PaperPluginParent, PaperPluginMeta> PAPER = new PluginFileType<>(PAPER_PLUGIN_YML, PaperPluginParent.FACTORY) {
         @Override
         protected void register(EntrypointHandler entrypointHandler, PaperPluginParent parent) {
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperBootstrapOrderConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperBootstrapOrderConfiguration.java
index 7750741b6a4a774986d833919510770b593ec7b9..a22261f668b8aa0c6d00c8ecb99409855bd4d968 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperBootstrapOrderConfiguration.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperBootstrapOrderConfiguration.java
@@ -13,8 +13,8 @@ import java.util.Map;
 public class PaperBootstrapOrderConfiguration implements LoadOrderConfiguration {
 
     private final PaperPluginMeta paperPluginMeta;
-    private final List<String> loadBefore = new ArrayList<>();
-    private final List<String> loadAfter = new ArrayList<>();
+    private final List<String> loadBefore = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private final List<String> loadAfter = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     public PaperBootstrapOrderConfiguration(PaperPluginMeta paperPluginMeta) {
         this.paperPluginMeta = paperPluginMeta;
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParent.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParent.java
index 55a6898e95704cddafda1ca5dc0951c7102fe10b..2f5ccea4e31aa4f6e9bc4157b703a905c9ca7b23 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParent.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParent.java
@@ -1,17 +1,17 @@
 package io.papermc.paper.plugin.provider.type.paper;
 
 import com.destroystokyo.paper.util.SneakyThrow;
-import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
-import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
-import io.papermc.paper.plugin.provider.configuration.type.DependencyConfiguration;
-import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
-import io.papermc.paper.plugin.entrypoint.dependency.DependencyContextHolder;
 import io.papermc.paper.plugin.bootstrap.PluginBootstrap;
+import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
 import io.papermc.paper.plugin.entrypoint.classloader.PaperPluginClassLoader;
+import io.papermc.paper.plugin.entrypoint.dependency.DependencyContextHolder;
 import io.papermc.paper.plugin.provider.PluginProvider;
 import io.papermc.paper.plugin.provider.ProviderStatus;
 import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.configuration.LoadOrderConfiguration;
 import io.papermc.paper.plugin.provider.configuration.PaperPluginMeta;
+import io.papermc.paper.plugin.provider.configuration.type.DependencyConfiguration;
+import io.papermc.paper.plugin.provider.entrypoint.DependencyContext;
 import io.papermc.paper.plugin.provider.type.PluginTypeFactory;
 import io.papermc.paper.plugin.provider.util.ProviderUtil;
 import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
@@ -19,7 +19,6 @@ import org.bukkit.plugin.java.JavaPlugin;
 import org.jetbrains.annotations.NotNull;
 
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.jar.JarFile;
@@ -73,7 +72,7 @@ public class PaperPluginParent {
         @Override
         public PluginBootstrap createInstance() {
             PluginBootstrap bootstrap = ProviderUtil.loadClass(PaperPluginParent.this.description.getBootstrapper(),
-                PluginBootstrap.class, PaperPluginParent.this.classLoader, () -> this.status = ProviderStatus.ERRORED);
+                    PluginBootstrap.class, PaperPluginParent.this.classLoader, () -> this.status = ProviderStatus.ERRORED);
             this.status = ProviderStatus.INITIALIZED;
             this.lastProvided = bootstrap;
             return bootstrap;
@@ -96,7 +95,7 @@ public class PaperPluginParent {
 
         @Override
         public List<String> validateDependencies(@NotNull DependencyContext context) {
-            List<String> missingDependencies = new ArrayList<>();
+            List<String> missingDependencies = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (Map.Entry<String, DependencyConfiguration> configuration : this.getMeta().getBootstrapDependencies().entrySet()) {
                 String dependency = configuration.getKey();
                 if (configuration.getValue().required() && !context.hasDependency(dependency)) {
@@ -129,10 +128,10 @@ public class PaperPluginParent {
         @Override
         public String toString() {
             return "PaperBootstrapProvider{" +
-                "parent=" + PaperPluginParent.this +
-                "status=" + status +
-                ", lastProvided=" + lastProvided +
-                '}';
+                    "parent=" + PaperPluginParent.this +
+                    "status=" + status +
+                    ", lastProvided=" + lastProvided +
+                    '}';
         }
     }
 
@@ -202,7 +201,7 @@ public class PaperPluginParent {
 
         @Override
         public List<String> validateDependencies(@NotNull DependencyContext context) {
-            List<String> missingDependencies = new ArrayList<>();
+            List<String> missingDependencies = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (Map.Entry<String, DependencyConfiguration> dependency : this.getMeta().getServerDependencies().entrySet()) {
                 String name = dependency.getKey();
                 if (dependency.getValue().required() && !context.hasDependency(name)) {
@@ -244,10 +243,10 @@ public class PaperPluginParent {
         @Override
         public String toString() {
             return "PaperServerPluginProvider{" +
-                "parent=" + PaperPluginParent.this +
-                "bootstrapProvider=" + bootstrapProvider +
-                ", status=" + status +
-                '}';
+                    "parent=" + PaperPluginParent.this +
+                    "bootstrapProvider=" + bootstrapProvider +
+                    ", status=" + status +
+                    '}';
         }
     }
 
@@ -255,10 +254,10 @@ public class PaperPluginParent {
     @Override
     public String toString() {
         return "PaperPluginParent{" +
-            "path=" + path +
-            ", jarFile=" + jarFile +
-            ", description=" + description +
-            ", classLoader=" + classLoader +
-            '}';
+                "path=" + path +
+                ", jarFile=" + jarFile +
+                ", description=" + description +
+                ", classLoader=" + classLoader +
+                '}';
     }
 }
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotLoadOrderConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotLoadOrderConfiguration.java
index b2a6544e321fa61c58bdf5684231de1020884fcc..984cb2d60df9a2c14583508affa5be16da3ae88f 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotLoadOrderConfiguration.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotLoadOrderConfiguration.java
@@ -24,7 +24,7 @@ public class SpigotLoadOrderConfiguration implements LoadOrderConfiguration {
         this.meta = spigotPluginProvider.getMeta();
 
         this.loadBefore = meta.getLoadBeforePlugins();
-        this.loadAfter = new ArrayList<>();
+        this.loadAfter = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.loadAfter.addAll(meta.getDepend());
         this.loadAfter.addAll(meta.getSoftDepend());
 
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
index 0fd1040ed376f19c6d5326767baaf3048ce1bfb4..c7c53fbf0983eac9450ee34036c47a9adaa64b6b 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
@@ -161,7 +161,7 @@ public class SpigotPluginProvider implements PluginProvider<JavaPlugin>, Provide
 
     @Override
     public List<String> validateDependencies(@NotNull DependencyContext context) {
-        List<String> missingDependencies = new ArrayList<>();
+        List<String> missingDependencies = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (String hardDependency : this.getMeta().getPluginDependencies()) {
             if (!context.hasDependency(hardDependency)) {
                 missingDependencies.add(hardDependency);
diff --git a/src/main/java/io/papermc/paper/plugin/storage/SimpleProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/SimpleProviderStorage.java
index 26422904751647a061397ce978bba752149003cd..32a08e1ddff6ad28452627924d72fc8baf025313 100644
--- a/src/main/java/io/papermc/paper/plugin/storage/SimpleProviderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/storage/SimpleProviderStorage.java
@@ -17,7 +17,7 @@ public abstract class SimpleProviderStorage<T> implements ProviderStorage<T> {
 
     private static final Logger LOGGER = LogUtils.getClassLogger();
 
-    protected final List<PluginProvider<T>> providers = new ArrayList<>();
+    protected final List<PluginProvider<T>> providers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     protected ProviderLoadingStrategy<T> strategy;
 
     protected SimpleProviderStorage(ProviderLoadingStrategy<T> strategy) {
@@ -61,7 +61,7 @@ public abstract class SimpleProviderStorage<T> implements ProviderStorage<T> {
     }
 
     protected void handleCycle(PluginGraphCycleException exception) {
-        List<String> logMessages = new ArrayList<>();
+        List<String> logMessages = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (List<String> list : exception.getCycles()) {
             logMessages.add(String.join(" -> ", list) + " -> " + list.get(0));
         }
diff --git a/src/main/java/io/papermc/paper/pluginremap/PluginRemapper.java b/src/main/java/io/papermc/paper/pluginremap/PluginRemapper.java
index 28857d0c9b53f2068d51b8f09ef40df7a2b97502..b76264301f71f1470ddee18884a38c053b2f6805 100644
--- a/src/main/java/io/papermc/paper/pluginremap/PluginRemapper.java
+++ b/src/main/java/io/papermc/paper/pluginremap/PluginRemapper.java
@@ -6,6 +6,17 @@ import io.papermc.paper.plugin.provider.type.PluginFileType;
 import io.papermc.paper.util.AtomicFiles;
 import io.papermc.paper.util.MappingEnvironment;
 import io.papermc.paper.util.concurrent.ScalingThreadPool;
+import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
+import net.minecraft.util.ExceptionCollector;
+import net.neoforged.art.api.Renamer;
+import net.neoforged.art.api.SignatureStripperConfig;
+import net.neoforged.art.api.Transformer;
+import net.neoforged.srgutils.IMappingFile;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.slf4j.Logger;
+
 import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -13,29 +24,13 @@ import java.nio.file.FileSystem;
 import java.nio.file.FileSystems;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.*;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.jar.Manifest;
 import java.util.stream.Stream;
-import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
-import net.minecraft.util.ExceptionCollector;
-import net.neoforged.art.api.Renamer;
-import net.neoforged.art.api.SignatureStripperConfig;
-import net.neoforged.art.api.Transformer;
-import net.neoforged.srgutils.IMappingFile;
-import org.checkerframework.checker.nullness.qual.NonNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
-import org.checkerframework.framework.qual.DefaultQualifier;
-import org.slf4j.Logger;
 
 import static io.papermc.paper.pluginremap.InsertManifestAttribute.addNamespaceManifestAttribute;
 
@@ -103,9 +98,9 @@ public final class PluginRemapper {
     public void loadingPlugins() {
         if (this.reversedMappings == null) {
             this.reversedMappings = this.reversedMappingsFuture(
-                () -> CompletableFuture.supplyAsync(PluginRemapper::loadReobfMappings, this.threadPool),
-                this.remappedPlugins.dir(),
-                this.threadPool
+                    () -> CompletableFuture.supplyAsync(PluginRemapper::loadReobfMappings, this.threadPool),
+                    this.remappedPlugins.dir(),
+                    this.threadPool
             );
         }
     }
@@ -117,7 +112,7 @@ public final class PluginRemapper {
     }
 
     public List<Path> remapLibraries(final List<Path> libraries) {
-        final List<CompletableFuture<Path>> tasks = new ArrayList<>();
+        final List<CompletableFuture<Path>> tasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final Path lib : libraries) {
             if (!lib.getFileName().toString().endsWith(".jar")) {
                 if (DEBUG_LOGGING) {
@@ -142,7 +137,7 @@ public final class PluginRemapper {
     public Path rewritePlugin(final Path plugin) {
         // Already remapped
         if (plugin.getParent().equals(this.remappedPlugins.dir())
-            || plugin.getParent().equals(this.extraPlugins.dir())) {
+                || plugin.getParent().equals(this.extraPlugins.dir())) {
             return plugin;
         }
 
@@ -166,7 +161,7 @@ public final class PluginRemapper {
             return allCached;
         }
 
-        final List<CompletableFuture<Path>> tasks = new ArrayList<>();
+        final List<CompletableFuture<Path>> tasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final Path file : plugins) {
             final @Nullable Path cached = this.extraPlugins.getIfPresent(file);
             if (cached != null) {
@@ -190,7 +185,7 @@ public final class PluginRemapper {
             return remappedJars;
         }
 
-        final List<CompletableFuture<Path>> tasks = new ArrayList<>();
+        final List<CompletableFuture<Path>> tasks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final Path file : jars) {
             final @Nullable Path existingFile = this.remappedPlugins.getIfPresent(file);
             if (existingFile != null) {
@@ -219,9 +214,9 @@ public final class PluginRemapper {
     }
 
     private CompletableFuture<IMappingFile> reversedMappingsFuture(
-        final Supplier<CompletableFuture<IMappingFile>> mappingsFuture,
-        final Path remappedPlugins,
-        final Executor executor
+            final Supplier<CompletableFuture<IMappingFile>> mappingsFuture,
+            final Path remappedPlugins,
+            final Executor executor
     ) {
         return CompletableFuture.supplyAsync(() -> {
             try {
@@ -232,7 +227,7 @@ public final class PluginRemapper {
                 if (Files.isDirectory(reversedMappings1)) {
                     if (Files.isRegularFile(file)) {
                         return CompletableFuture.completedFuture(
-                            loadMappings("Reversed", Files.newInputStream(file))
+                                loadMappings("Reversed", Files.newInputStream(file))
                         );
                     } else {
                         for (final Path oldFile : list(reversedMappings1, Files::isRegularFile)) {
@@ -260,15 +255,15 @@ public final class PluginRemapper {
     }
 
     private CompletableFuture<Path> remapPlugin(
-        final RemappedPluginIndex index,
-        final Path inputFile
+            final RemappedPluginIndex index,
+            final Path inputFile
     ) {
         return this.remap(index, inputFile, false);
     }
 
     private CompletableFuture<Path> remapLibrary(
-        final RemappedPluginIndex index,
-        final Path inputFile
+            final RemappedPluginIndex index,
+            final Path inputFile
     ) {
         return this.remap(index, inputFile, true);
     }
@@ -281,9 +276,9 @@ public final class PluginRemapper {
      * @return remapped file, or inputFile if no remapping was necessary
      */
     private CompletableFuture<Path> remap(
-        final RemappedPluginIndex index,
-        final Path inputFile,
-        final boolean library
+            final RemappedPluginIndex index,
+            final Path inputFile,
+            final boolean library
     ) {
         final Path destination = index.input(inputFile);
 
@@ -344,14 +339,14 @@ public final class PluginRemapper {
             final long start = System.currentTimeMillis();
             try (final DebugLogger logger = DebugLogger.forOutputFile(destination)) {
                 try (final Renamer renamer = Renamer.builder()
-                    .add(Transformer.renamerFactory(this.mappings(), false))
-                    .add(addNamespaceManifestAttribute(InsertManifestAttribute.MOJANG_PLUS_YARN_NAMESPACE))
-                    .add(Transformer.signatureStripperFactory(SignatureStripperConfig.ALL))
-                    .lib(reobfServer.toFile())
-                    .threads(1)
-                    .logger(logger)
-                    .debug(logger.debug())
-                    .build()) {
+                        .add(Transformer.renamerFactory(this.mappings(), false))
+                        .add(addNamespaceManifestAttribute(InsertManifestAttribute.MOJANG_PLUS_YARN_NAMESPACE))
+                        .add(Transformer.signatureStripperFactory(SignatureStripperConfig.ALL))
+                        .lib(reobfServer.toFile())
+                        .threads(1)
+                        .logger(logger)
+                        .debug(logger.debug())
+                        .build()) {
                     renamer.run(inputFile.toFile(), destination.toFile());
                 }
             } catch (final Exception ex) {
@@ -366,9 +361,9 @@ public final class PluginRemapper {
         final @Nullable CompletableFuture<IMappingFile> mappings = this.reversedMappings;
         if (mappings == null) {
             return this.reversedMappingsFuture(
-                () -> CompletableFuture.supplyAsync(PluginRemapper::loadReobfMappings, Runnable::run),
-                this.remappedPlugins.dir(),
-                Runnable::run
+                    () -> CompletableFuture.supplyAsync(PluginRemapper::loadReobfMappings, Runnable::run),
+                    this.remappedPlugins.dir(),
+                    Runnable::run
             ).join();
         }
         return mappings.join();
@@ -404,7 +399,7 @@ public final class PluginRemapper {
 
     private static List<Path> waitForAll(final List<CompletableFuture<Path>> tasks) {
         final ExceptionCollector<Exception> collector = new ExceptionCollector<>();
-        final List<Path> ret = new ArrayList<>();
+        final List<Path> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final CompletableFuture<Path> task : tasks) {
             try {
                 ret.add(task.join());
@@ -423,16 +418,16 @@ public final class PluginRemapper {
 
     private static ThreadPoolExecutor createThreadPool() {
         return new ThreadPoolExecutor(
-            0,
-            4,
-            5L,
-            TimeUnit.SECONDS,
-            ScalingThreadPool.createUnboundedQueue(),
-            new ThreadFactoryBuilder()
-                .setNameFormat("Paper Plugin Remapper Thread - %1$d")
-                .setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandlerWithName(LOGGER))
-                .build(),
-            ScalingThreadPool.defaultReEnqueuePolicy()
+                0,
+                4,
+                5L,
+                TimeUnit.SECONDS,
+                ScalingThreadPool.createUnboundedQueue(),
+                new ThreadFactoryBuilder()
+                        .setNameFormat("Paper Plugin Remapper Thread - %1$d")
+                        .setUncaughtExceptionHandler(new DefaultUncaughtExceptionHandlerWithName(LOGGER))
+                        .build(),
+                ScalingThreadPool.defaultReEnqueuePolicy()
         );
     }
 }
diff --git a/src/main/java/io/papermc/paper/pluginremap/RemappedPluginIndex.java b/src/main/java/io/papermc/paper/pluginremap/RemappedPluginIndex.java
index 86fc60452404d1f4609c25a90c4803ffb80dc8ab..bbdf238179104af55247fd285f184f288e7a8f80 100644
--- a/src/main/java/io/papermc/paper/pluginremap/RemappedPluginIndex.java
+++ b/src/main/java/io/papermc/paper/pluginremap/RemappedPluginIndex.java
@@ -121,7 +121,7 @@ class RemappedPluginIndex {
         // Also clear hashes of skipped files
         this.state.skippedHashes.removeIf(hash -> paths.stream().noneMatch(path -> inputFileHash.apply(path).equals(hash)));
 
-        final List<Path> ret = new ArrayList<>();
+        final List<Path> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final Path path : paths) {
             final String inputHash = inputFileHash.apply(path);
             if (this.state.skippedHashes.contains(inputHash)) {
diff --git a/src/main/java/io/papermc/paper/registry/set/PaperRegistrySets.java b/src/main/java/io/papermc/paper/registry/set/PaperRegistrySets.java
index f09ce9c8547ef05153847245746473dd9a8acbe6..77501dead146d1d822e764d1bcde83217301e73f 100644
--- a/src/main/java/io/papermc/paper/registry/set/PaperRegistrySets.java
+++ b/src/main/java/io/papermc/paper/registry/set/PaperRegistrySets.java
@@ -3,8 +3,6 @@ package io.papermc.paper.registry.set;
 import io.papermc.paper.registry.PaperRegistries;
 import io.papermc.paper.registry.RegistryKey;
 import io.papermc.paper.registry.TypedKey;
-import java.util.ArrayList;
-import java.util.List;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderSet;
 import net.minecraft.core.Registry;
@@ -14,6 +12,8 @@ import org.bukkit.Keyed;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 
+import java.util.List;
+
 @DefaultQualifier(NonNull.class)
 public final class PaperRegistrySets {
 
@@ -32,7 +32,7 @@ public final class PaperRegistrySets {
         if (holders instanceof final HolderSet.Named<M> named) {
             return new NamedRegistryKeySetImpl<>(PaperRegistries.fromNms(named.key()), named);
         } else {
-            final List<TypedKey<A>> keys = new ArrayList<>();
+            final List<TypedKey<A>> keys = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (final Holder<M> holder : holders) {
                 if (!(holder instanceof final Holder.Reference<M> reference)) {
                     throw new UnsupportedOperationException("Cannot convert a holder set containing direct holders");
diff --git a/src/main/java/io/papermc/paper/tag/PaperPostFlattenTagRegistrar.java b/src/main/java/io/papermc/paper/tag/PaperPostFlattenTagRegistrar.java
index cc37618cbbad7f21d65c7753f4dd4416042d2146..c211c24f6f7bda7899c28728e243ea2e79901cd9 100644
--- a/src/main/java/io/papermc/paper/tag/PaperPostFlattenTagRegistrar.java
+++ b/src/main/java/io/papermc/paper/tag/PaperPostFlattenTagRegistrar.java
@@ -88,7 +88,7 @@ public class PaperPostFlattenTagRegistrar<M, T> implements PaperRegistrar<Bootst
         Collection<M> tag = this.tags.get(vanillaKey);
         if (tag == null) {
             if (create) {
-                tag = this.tags.computeIfAbsent(vanillaKey, k -> new ArrayList<>());
+                tag = this.tags.computeIfAbsent(vanillaKey, k -> new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
             } else {
                 throw new NoSuchElementException("Tag " + tagKey + " is not present");
             }
diff --git a/src/main/java/io/papermc/paper/tag/PaperPreFlattenTagRegistrar.java b/src/main/java/io/papermc/paper/tag/PaperPreFlattenTagRegistrar.java
index 44111b55eaa6d1cc93e2c556b23bb5c97953caac..e856b9f48707c69b349f91a032621ad5f2da1e64 100644
--- a/src/main/java/io/papermc/paper/tag/PaperPreFlattenTagRegistrar.java
+++ b/src/main/java/io/papermc/paper/tag/PaperPreFlattenTagRegistrar.java
@@ -98,7 +98,7 @@ public class PaperPreFlattenTagRegistrar<T> implements PaperRegistrar<BootstrapC
         List<TagLoader.EntryWithSource> tag = this.tags.get(vanillaKey);
         if (tag == null) {
             if (create) {
-                tag = this.tags.computeIfAbsent(vanillaKey, k -> new ArrayList<>());
+                tag = this.tags.computeIfAbsent(vanillaKey, k -> new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
             } else {
                 throw new NoSuchElementException("Tag " + tagKey + " is not present");
             }
diff --git a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
index 15b21fa3907db1b77ed5b5d1050a37f42d27d5ab..5f14676098000b535e0e695d4773ccbdf8e174b8 100644
--- a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
@@ -7,7 +7,6 @@ import net.minecraft.world.entity.Entity;
 import org.bukkit.craftbukkit.entity.CraftEntity;
 
 import java.util.ArrayDeque;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
 
@@ -38,7 +37,8 @@ public final class EntityScheduler {
     public final CraftEntity entity;
     public final net.minecraft.server.MinecraftServer server; // SparklyPaper - skip EntityScheduler's executeTick checks if there isn't any tasks to be run
 
-    private static final record ScheduledTask(Consumer<? extends Entity> run, Consumer<? extends Entity> retired) {}
+    private static final record ScheduledTask(Consumer<? extends Entity> run, Consumer<? extends Entity> retired) {
+    }
 
     private long tickCount = 0L;
     private static final long RETIRED_TICK_COUNT = -1L;
@@ -77,7 +77,7 @@ public final class EntityScheduler {
         // correctly handle and order retiring while running executeTick
         for (int i = 0, len = this.currentlyExecuting.size(); i < len; ++i) {
             final ScheduledTask task = this.currentlyExecuting.pollFirst();
-            final Consumer<Entity> retireTask = (Consumer<Entity>)task.retired;
+            final Consumer<Entity> retireTask = (Consumer<Entity>) task.retired;
             if (retireTask == null) {
                 continue;
             }
@@ -88,7 +88,7 @@ public final class EntityScheduler {
         for (final List<ScheduledTask> tasks : this.oneTimeDelayed.values()) {
             for (int i = 0, len = tasks.size(); i < len; ++i) {
                 final ScheduledTask task = tasks.get(i);
-                final Consumer<Entity> retireTask = (Consumer<Entity>)task.retired;
+                final Consumer<Entity> retireTask = (Consumer<Entity>) task.retired;
                 if (retireTask == null) {
                     continue;
                 }
@@ -113,12 +113,13 @@ public final class EntityScheduler {
      * is tied to. Since the scheduler is transferred when an entity changes dimensions, it is possible the entity parameter
      * is not the same when the task was first scheduled. Thus, <b>only</b> the parameter provided should be used.
      * </p>
-     * @param run The callback to run after the specified delay, may not be null.
+     *
+     * @param run     The callback to run after the specified delay, may not be null.
      * @param retired Retire callback to run if the entity is retired before the run callback can be invoked, may be null.
-     * @param delay The delay in ticks before the run callback is invoked. Any value less-than 1 is treated as 1.
+     * @param delay   The delay in ticks before the run callback is invoked. Any value less-than 1 is treated as 1.
      * @return {@code true} if the task was scheduled, which means that either the run function or the retired function
-     *         will be invoked (but never both), or {@code false} indicating neither the run nor retired function will be invoked
-     *         since the scheduler has been retired.
+     * will be invoked (but never both), or {@code false} indicating neither the run nor retired function will be invoked
+     * since the scheduler has been retired.
      */
     public boolean schedule(final Consumer<? extends Entity> run, final Consumer<? extends Entity> retired, final long delay) {
         Validate.notNull(run, "Run task may not be null");
@@ -130,7 +131,7 @@ public final class EntityScheduler {
             }
             this.server.entitiesWithScheduledTasks.add(this.entity.getHandleRaw()); // SparklyPaper - skip EntityScheduler's executeTick checks if there isn't any tasks to be run
             this.oneTimeDelayed.computeIfAbsent(this.tickCount + Math.max(1L, delay), (final long keyInMap) -> {
-                return new ArrayList<>();
+                return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             }).add(task);
         }
 
@@ -182,7 +183,7 @@ public final class EntityScheduler {
             final ScheduledTask task = this.currentlyExecuting.pollFirst();
 
             if (this.tickCount != RETIRED_TICK_COUNT) {
-                ((Consumer<Entity>)task.run).accept(thisEntity);
+                ((Consumer<Entity>) task.run).accept(thisEntity);
             } else {
                 // retired synchronously
                 // note: here task is null
diff --git a/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaGlobalRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaGlobalRegionScheduler.java
index d306f911757a4d556c82c0070d4837db87afc497..625ed2e8957845014044d57abf2302eda9f831ea 100644
--- a/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaGlobalRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/scheduler/FoliaGlobalRegionScheduler.java
@@ -7,7 +7,6 @@ import org.bukkit.plugin.IllegalPluginAccessException;
 import org.bukkit.plugin.Plugin;
 
 import java.lang.invoke.VarHandle;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
 import java.util.logging.Level;
@@ -108,7 +107,7 @@ public class FoliaGlobalRegionScheduler implements GlobalRegionScheduler {
     public void cancelTasks(final Plugin plugin) {
         Validate.notNull(plugin, "Plugin may not be null");
 
-        final List<GlobalScheduledTask> toCancel = new ArrayList<>();
+        final List<GlobalScheduledTask> toCancel = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         synchronized (this.stateLock) {
             for (final List<GlobalScheduledTask> tasks : this.tasksByDeadline.values()) {
                 for (int i = 0, len = tasks.size(); i < len; ++i) {
@@ -129,18 +128,18 @@ public class FoliaGlobalRegionScheduler implements GlobalRegionScheduler {
         // note: delay > 0
         synchronized (this.stateLock) {
             this.tasksByDeadline.computeIfAbsent(this.tickCount + delay, (final long keyInMap) -> {
-                return new ArrayList<>();
+                return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             }).add(task);
         }
     }
 
     private final class GlobalScheduledTask implements ScheduledTask, Runnable {
 
-        private static final int STATE_IDLE                = 0;
-        private static final int STATE_EXECUTING           = 1;
+        private static final int STATE_IDLE = 0;
+        private static final int STATE_EXECUTING = 1;
         private static final int STATE_EXECUTING_CANCELLED = 2;
-        private static final int STATE_FINISHED            = 3;
-        private static final int STATE_CANCELLED           = 4;
+        private static final int STATE_FINISHED = 3;
+        private static final int STATE_CANCELLED = 4;
 
         private final Plugin plugin;
         private final long repeatDelay; // in ticks
@@ -155,15 +154,15 @@ public class FoliaGlobalRegionScheduler implements GlobalRegionScheduler {
             this.run = run;
         }
 
-        private final int getStateVolatile() {
-            return (int)STATE_HANDLE.get(this);
+        private int getStateVolatile() {
+            return (int) STATE_HANDLE.get(this);
         }
 
-        private final int compareAndExchangeStateVolatile(final int expect, final int update) {
-            return (int)STATE_HANDLE.compareAndExchange(this, expect, update);
+        private int compareAndExchangeStateVolatile(final int expect, final int update) {
+            return (int) STATE_HANDLE.compareAndExchange(this, expect, update);
         }
 
-        private final void setStateVolatile(final int value) {
+        private void setStateVolatile(final int value) {
             STATE_HANDLE.setVolatile(this, value);
         }
 
@@ -207,7 +206,7 @@ public class FoliaGlobalRegionScheduler implements GlobalRegionScheduler {
 
         @Override
         public CancelledState cancel() {
-            for (int curr = this.getStateVolatile();;) {
+            for (int curr = this.getStateVolatile(); ; ) {
                 switch (curr) {
                     case STATE_IDLE: {
                         if (STATE_IDLE == (curr = this.compareAndExchangeStateVolatile(STATE_IDLE, STATE_CANCELLED))) {
diff --git a/src/main/java/io/papermc/paper/util/MCUtil.java b/src/main/java/io/papermc/paper/util/MCUtil.java
index 0449d4619e3a0752dea0981fb149542e23076c52..6bf03a44dd7328d760c56180360f1c0db33b71cd 100644
--- a/src/main/java/io/papermc/paper/util/MCUtil.java
+++ b/src/main/java/io/papermc/paper/util/MCUtil.java
@@ -4,15 +4,6 @@ import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import io.papermc.paper.math.BlockPosition;
 import io.papermc.paper.math.FinePosition;
 import io.papermc.paper.math.Position;
-import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-import java.util.function.Supplier;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Vec3i;
 import net.minecraft.server.MinecraftServer;
@@ -22,6 +13,12 @@ import net.minecraft.world.phys.Vec3;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.util.Waitable;
 
+import java.util.List;
+import java.util.concurrent.*;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
 public final class MCUtil {
     public static final java.util.concurrent.Executor MAIN_EXECUTOR = (run) -> {
         if (!isMainThread()) {
@@ -31,19 +28,19 @@ public final class MCUtil {
         }
     };
     public static final ThreadPoolExecutor asyncExecutor = new ThreadPoolExecutor(
-        2, 2, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<>(),
-        new ThreadFactoryBuilder()
-            .setNameFormat("Paper Async Task Handler Thread - %1$d")
-            .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(MinecraftServer.LOGGER))
-            .build()
+            2, 2, 60L, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new ThreadFactoryBuilder()
+                    .setNameFormat("Paper Async Task Handler Thread - %1$d")
+                    .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(MinecraftServer.LOGGER))
+                    .build()
     );
 
     private MCUtil() {
     }
 
     public static List<ChunkPos> getSpiralOutChunks(BlockPos blockposition, int radius) {
-        List<ChunkPos> list = com.google.common.collect.Lists.newArrayList();
+        List<ChunkPos> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         list.add(new ChunkPos(blockposition.getX() >> 4, blockposition.getZ() >> 4));
         for (int r = 1; r <= radius; r++) {
diff --git a/src/main/java/io/papermc/paper/util/PoiAccess.java b/src/main/java/io/papermc/paper/util/PoiAccess.java
index f39294b1f83c4022be5ced4da781103a1eee2daf..37f293e8cb460e2e3f190622602932da2538f45a 100644
--- a/src/main/java/io/papermc/paper/util/PoiAccess.java
+++ b/src/main/java/io/papermc/paper/util/PoiAccess.java
@@ -7,7 +7,6 @@ import it.unimi.dsi.fastutil.doubles.Double2ObjectMap;
 import it.unimi.dsi.fastutil.doubles.Double2ObjectRBTreeMap;
 import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import java.util.function.BiPredicate;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.util.Mth;
@@ -15,13 +14,9 @@ import net.minecraft.world.entity.ai.village.poi.PoiManager;
 import net.minecraft.world.entity.ai.village.poi.PoiRecord;
 import net.minecraft.world.entity.ai.village.poi.PoiSection;
 import net.minecraft.world.entity.ai.village.poi.PoiType;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
+
+import java.util.*;
+import java.util.function.BiPredicate;
 import java.util.function.Predicate;
 
 /**
@@ -72,10 +67,10 @@ public final class PoiAccess {
     protected static long getKey(final int minSection, final int maxSection, final int section, final int radius) {
         return (
                 (maxSection & 0xFFFFL) << (64 - 16)
-                | (minSection & 0xFFFFL) << (64 - 32)
-                | (section & 0xFFFFL) << (64 - 48)
-                | (radius & 0xFFFFL) << (64 - 64)
-                );
+                        | (minSection & 0xFFFFL) << (64 - 32)
+                        | (section & 0xFFFFL) << (64 - 48)
+                        | (radius & 0xFFFFL) << (64 - 64)
+        );
     }
 
     // only includes x/z axis
@@ -99,16 +94,16 @@ public final class PoiAccess {
     // only includes x/z axis
     // finds the closest poi data by distance.
     public static Pair<Holder<PoiType>, BlockPos> findClosestPoiDataTypeAndPosition(final PoiManager poiStorage,
-                                                                             final Predicate<Holder<PoiType>> villagePlaceType,
-                                                                             // position predicate must not modify chunk POI
-                                                                             final Predicate<BlockPos> positionPredicate,
-                                                                             final BlockPos sourcePosition,
-                                                                             final int range, // distance on x y z axis
-                                                                             final double maxDistanceSquared,
-                                                                             final PoiManager.Occupancy occupancy,
-                                                                             final boolean load) {
+                                                                                    final Predicate<Holder<PoiType>> villagePlaceType,
+                                                                                    // position predicate must not modify chunk POI
+                                                                                    final Predicate<BlockPos> positionPredicate,
+                                                                                    final BlockPos sourcePosition,
+                                                                                    final int range, // distance on x y z axis
+                                                                                    final double maxDistanceSquared,
+                                                                                    final PoiManager.Occupancy occupancy,
+                                                                                    final boolean load) {
         final PoiRecord ret = findClosestPoiDataRecord(
-            poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistanceSquared, occupancy, load
+                poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistanceSquared, occupancy, load
         );
 
         return ret == null ? null : Pair.of(ret.getPoiType(), ret.getPos());
@@ -135,7 +130,7 @@ public final class PoiAccess {
             return positions.add(pos.immutable());
         };
 
-        final List<PoiRecord> toConvert = new ArrayList<>();
+        final List<PoiRecord> toConvert = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findClosestPoiDataRecords(
                 poiStorage, villagePlaceType, newPredicate, sourcePosition, range, maxDistanceSquared, occupancy, load, toConvert
         );
@@ -156,9 +151,9 @@ public final class PoiAccess {
                                                      final double maxDistanceSquared,
                                                      final PoiManager.Occupancy occupancy,
                                                      final boolean load) {
-        final List<PoiRecord> ret = new ArrayList<>();
+        final List<PoiRecord> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findClosestPoiDataRecords(
-            poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistanceSquared, occupancy, load, ret
+                poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistanceSquared, occupancy, load, ret
         );
         return ret.isEmpty() ? null : ret.get(0);
     }
@@ -174,7 +169,7 @@ public final class PoiAccess {
                                                      final double maxDistanceSquared,
                                                      final PoiManager.Occupancy occupancy,
                                                      final boolean load) {
-        final List<PoiRecord> ret = new ArrayList<>();
+        final List<PoiRecord> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findClosestPoiDataRecords(
                 poiStorage, villagePlaceType, predicate, sourcePosition, range, maxDistanceSquared, occupancy, load, ret
         );
@@ -209,7 +204,7 @@ public final class PoiAccess {
                                                  final List<PoiRecord> ret) {
         final Predicate<? super PoiRecord> occupancyFilter = occupancy.getTest();
 
-        final List<PoiRecord> closestRecords = new ArrayList<>();
+        final List<PoiRecord> closestRecords = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         double closestDistanceSquared = maxDistanceSquared;
 
         final int lowerX = Mth.floor(sourcePosition.getX() - range) >> 4;
@@ -247,7 +242,7 @@ public final class PoiAccess {
                     (sectionX << 4) + 15.5,
                     (sectionY << 4) + 15.5,
                     (sectionZ << 4) + 15.5,
-                    (double)sourcePosition.getX(), (double)sourcePosition.getY(), (double)sourcePosition.getZ()
+                    (double) sourcePosition.getX(), (double) sourcePosition.getY(), (double) sourcePosition.getZ()
             );
             if (sectionDistanceSquared > closestDistanceSquared) {
                 continue;
@@ -409,7 +404,7 @@ public final class PoiAccess {
             return positions.add(pos.immutable());
         };
 
-        final List<PoiRecord> toConvert = new ArrayList<>();
+        final List<PoiRecord> toConvert = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findNearestPoiRecords(
                 poiStorage, villagePlaceType, newPredicate, sourcePosition, range, maxDistanceSquared, occupancy, load, max, toConvert
         );
@@ -429,7 +424,7 @@ public final class PoiAccess {
                                                  final double maxDistanceSquared,
                                                  final PoiManager.Occupancy occupancy,
                                                  final boolean load) {
-        final List<PoiRecord> ret = new ArrayList<>();
+        final List<PoiRecord> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findNearestPoiRecords(
                 poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, maxDistanceSquared, occupancy, load,
                 1, ret
@@ -578,7 +573,7 @@ public final class PoiAccess {
                     }
 
                     closestRecords.computeIfAbsent(dataRange, (final double unused) -> {
-                        return new ArrayList<>();
+                        return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                     }).add(poiData);
 
                     if (++totalRecords >= max) {
@@ -607,7 +602,7 @@ public final class PoiAccess {
             }
         }
 
-        final List<PoiRecord> closestRecordsUnsorted = new ArrayList<>();
+        final List<PoiRecord> closestRecordsUnsorted = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         // we're done here, so now just flatten the map and sort it.
 
@@ -692,7 +687,7 @@ public final class PoiAccess {
             return positions.add(pos.immutable());
         };
 
-        final List<PoiRecord> toConvert = new ArrayList<>();
+        final List<PoiRecord> toConvert = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findAnyPoiRecords(
                 poiStorage, villagePlaceType, newPredicate, sourcePosition, range, occupancy, load, max, toConvert
         );
@@ -709,7 +704,7 @@ public final class PoiAccess {
                                              final int range, // distance on x y z axis
                                              final PoiManager.Occupancy occupancy,
                                              final boolean load) {
-        final List<PoiRecord> ret = new ArrayList<>();
+        final List<PoiRecord> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         findAnyPoiRecords(poiStorage, villagePlaceType, positionPredicate, sourcePosition, range, occupancy, load, 1, ret);
         return ret.isEmpty() ? null : ret.get(0);
     }
diff --git a/src/main/java/net/caffeinemc/mods/lithium/common/util/change_tracking/ChangeSubscriber.java b/src/main/java/net/caffeinemc/mods/lithium/common/util/change_tracking/ChangeSubscriber.java
index ef206b9ebbd555a786dad37e1ab1bc48e11961cb..191e9cce053158023d2784010c4c72dbdcca00c0 100644
--- a/src/main/java/net/caffeinemc/mods/lithium/common/util/change_tracking/ChangeSubscriber.java
+++ b/src/main/java/net/caffeinemc/mods/lithium/common/util/change_tracking/ChangeSubscriber.java
@@ -1,11 +1,11 @@
 package net.caffeinemc.mods.lithium.common.util.change_tracking;
 
 import it.unimi.dsi.fastutil.ints.IntArrayList;
+import net.minecraft.world.item.ItemStack;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import java.util.ArrayList;
-import net.minecraft.world.item.ItemStack;
 
 public interface ChangeSubscriber<T> {
 
@@ -19,7 +19,7 @@ public interface ChangeSubscriber<T> {
             subscriberDatas.add(newSData);
             return new Multi<>(subscribers, subscriberDatas);
         } else {
-            ArrayList<ChangeSubscriber<T>> subscribers = new ArrayList<>();
+            ArrayList<ChangeSubscriber<T>> subscribers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             IntArrayList subscriberDatas = new IntArrayList();
             subscribers.add(prevSubscriber);
             subscriberDatas.add(prevSData);
@@ -28,6 +28,7 @@ public interface ChangeSubscriber<T> {
             return new Multi<>(subscribers, subscriberDatas);
         }
     }
+
     static <T> ChangeSubscriber<T> without(ChangeSubscriber<T> prevSubscriber, ChangeSubscriber<T> removedSubscriber) {
         return without(prevSubscriber, removedSubscriber, 0, false);
     }
@@ -90,7 +91,8 @@ public interface ChangeSubscriber<T> {
 
     /**
      * Notify the subscriber that the publisher will be changed immediately after this call.
-     * @param publisher The publisher that is about to change
+     *
+     * @param publisher      The publisher that is about to change
      * @param subscriberData The data associated with the subscriber, given when the subscriber was added
      */
     void notify(@Nullable T publisher, int subscriberData);
@@ -99,7 +101,7 @@ public interface ChangeSubscriber<T> {
      * Notify the subscriber about being unsubscribed from the publisher. Used when the publisher becomes invalid.
      * The subscriber should not attempt to unsubscribe itself from the publisher in this method.
      *
-     * @param publisher The publisher unsubscribed from
+     * @param publisher      The publisher unsubscribed from
      * @param subscriberData The data associated with the subscriber, given when the subscriber was added
      */
     void forceUnsubscribe(T publisher, int subscriberData);
@@ -108,9 +110,10 @@ public interface ChangeSubscriber<T> {
 
         /**
          * Notify the subscriber that the publisher's count data will be changed immediately after this call.
-         * @param publisher The publisher that is about to change
+         *
+         * @param publisher      The publisher that is about to change
          * @param subscriberData The data associated with the subscriber, given when the subscriber was added
-         * @param newCount The new count of the publisher
+         * @param newCount       The new count of the publisher
          */
         void notifyCount(T publisher, int subscriberData, int newCount);
     }
@@ -119,7 +122,8 @@ public interface ChangeSubscriber<T> {
 
         /**
          * Notify the subscriber that the publisher's enchantment data has been changed immediately before this call.
-         * @param publisher The publisher that has changed
+         *
+         * @param publisher      The publisher that has changed
          * @param subscriberData The data associated with the subscriber, given when the subscriber was added
          */
         void notifyAfterEnchantmentChange(T publisher, int subscriberData);
diff --git a/src/main/java/net/minecraft/ChatFormatting.java b/src/main/java/net/minecraft/ChatFormatting.java
index d5f63d06d921d731b4e64b38228377712fe9c75b..47e876b6f78e1115cb6f2d475690d53597aba067 100644
--- a/src/main/java/net/minecraft/ChatFormatting.java
+++ b/src/main/java/net/minecraft/ChatFormatting.java
@@ -1,18 +1,14 @@
 package net.minecraft;
 
-import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import net.minecraft.util.StringRepresentable;
 import org.jetbrains.annotations.Contract;
 
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
 public enum ChatFormatting implements StringRepresentable {
     BLACK("BLACK", '0', 0, 0),
     DARK_BLUE("DARK_BLUE", '1', 1, 170),
@@ -40,7 +36,7 @@ public enum ChatFormatting implements StringRepresentable {
     public static final Codec<ChatFormatting> CODEC = StringRepresentable.fromEnum(ChatFormatting::values);
     public static final char PREFIX_CODE = '§';
     private static final Map<String, ChatFormatting> FORMATTING_BY_NAME = Arrays.stream(values())
-        .collect(Collectors.toMap(f -> cleanName(f.name), f -> (ChatFormatting)f));
+            .collect(Collectors.toMap(f -> cleanName(f.name), f -> (ChatFormatting) f));
     private static final Pattern STRIP_FORMATTING_PATTERN = Pattern.compile("(?i)§[0-9A-FK-OR]");
     private final String name;
     public final char code;
@@ -113,7 +109,8 @@ public enum ChatFormatting implements StringRepresentable {
     }
 
     // Paper start - add method to get by hex value
-    @Nullable public static ChatFormatting getByHexValue(int i) {
+    @Nullable
+    public static ChatFormatting getByHexValue(int i) {
         for (ChatFormatting value : values()) {
             if (value.getColor() != null && value.getColor() == i) {
                 return value;
@@ -153,7 +150,7 @@ public enum ChatFormatting implements StringRepresentable {
     }
 
     public static Collection<String> getNames(boolean colors, boolean modifiers) {
-        List<String> list = Lists.newArrayList();
+        List<String> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (ChatFormatting chatFormatting : values()) {
             if ((!chatFormatting.isColor() || colors) && (!chatFormatting.isFormat() || modifiers)) {
diff --git a/src/main/java/net/minecraft/CrashReport.java b/src/main/java/net/minecraft/CrashReport.java
index fe346986074aca752c074ad86241e13b586ca773..b48eba6c84c7c6477eef3981d6cd936e5bc83576 100644
--- a/src/main/java/net/minecraft/CrashReport.java
+++ b/src/main/java/net/minecraft/CrashReport.java
@@ -1,6 +1,5 @@
 package net.minecraft;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
@@ -26,7 +25,7 @@ public class CrashReport {
     private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss", Locale.ROOT);
     private final String title;
     private final Throwable exception;
-    private final List<CrashReportCategory> details = Lists.newArrayList();
+    private final List<CrashReportCategory> details = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     @Nullable
     private Path saveFile;
     private boolean trackingStackTrace = true;
diff --git a/src/main/java/net/minecraft/CrashReportCategory.java b/src/main/java/net/minecraft/CrashReportCategory.java
index 2176171954609fd88f97f93408e14e018c1d6eaa..f60b8641fd56bf3f9c09a3877d9e3527ff865b37 100644
--- a/src/main/java/net/minecraft/CrashReportCategory.java
+++ b/src/main/java/net/minecraft/CrashReportCategory.java
@@ -1,17 +1,17 @@
 package net.minecraft;
 
-import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.Locale;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.world.level.LevelHeightAccessor;
 import net.minecraft.world.level.block.state.BlockState;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Locale;
+
 public class CrashReportCategory {
     private final String title;
-    private final List<CrashReportCategory.Entry> entries = Lists.newArrayList();
+    private final List<CrashReportCategory.Entry> entries = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private StackTraceElement[] stackTrace = new StackTraceElement[0];
 
     public CrashReportCategory(String title) {
@@ -51,7 +51,7 @@ public class CrashReportCategory {
             int s = world.getMaxBuildHeight() - 1;
             int t = SectionPos.sectionToBlockCoord(k + 1) - 1;
             stringBuilder.append(
-                String.format(Locale.ROOT, "Section: (at %d,%d,%d in %d,%d,%d; chunk contains blocks %d,%d,%d to %d,%d,%d)", l, m, n, i, j, k, o, p, q, r, s, t)
+                    String.format(Locale.ROOT, "Section: (at %d,%d,%d in %d,%d,%d; chunk contains blocks %d,%d,%d to %d,%d,%d)", l, m, n, i, j, k, o, p, q, r, s, t)
             );
         } catch (Throwable var18) {
             stringBuilder.append("(Error finding chunk loc)");
@@ -73,9 +73,9 @@ public class CrashReportCategory {
             int ah = world.getMaxBuildHeight() - 1;
             int ai = (v + 1 << 9) - 1;
             stringBuilder.append(
-                String.format(
-                    Locale.ROOT, "Region: (%d,%d; contains chunks %d,%d to %d,%d, blocks %d,%d,%d to %d,%d,%d)", u, v, w, aa, ab, ac, ad, ae, af, ag, ah, ai
-                )
+                    String.format(
+                            Locale.ROOT, "Region: (%d,%d; contains chunks %d,%d to %d,%d, blocks %d,%d,%d to %d,%d,%d)", u, v, w, aa, ab, ac, ad, ae, af, ag, ah, ai
+                    )
             );
         } catch (Throwable var17) {
             stringBuilder.append("(Error finding world loc)");
@@ -119,9 +119,9 @@ public class CrashReportCategory {
         if (this.stackTrace.length != 0 && prev != null) {
             StackTraceElement stackTraceElement = this.stackTrace[0];
             if (stackTraceElement.isNativeMethod() == prev.isNativeMethod()
-                && stackTraceElement.getClassName().equals(prev.getClassName())
-                && stackTraceElement.getFileName().equals(prev.getFileName())
-                && stackTraceElement.getMethodName().equals(prev.getMethodName())) {
+                    && stackTraceElement.getClassName().equals(prev.getClassName())
+                    && stackTraceElement.getFileName().equals(prev.getFileName())
+                    && stackTraceElement.getMethodName().equals(prev.getMethodName())) {
                 if (next != null != this.stackTrace.length > 1) {
                     return false;
                 } else if (next != null && !this.stackTrace[1].equals(next)) {
diff --git a/src/main/java/net/minecraft/advancements/AdvancementTree.java b/src/main/java/net/minecraft/advancements/AdvancementTree.java
index e00d4e0896c0163c43d79af63338de67c7cb0dc4..153100b41b07af2376aff52641ccf2eb0e22bc00 100644
--- a/src/main/java/net/minecraft/advancements/AdvancementTree.java
+++ b/src/main/java/net/minecraft/advancements/AdvancementTree.java
@@ -3,18 +3,12 @@ package net.minecraft.advancements;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import javax.annotation.Nullable;
 import net.minecraft.resources.ResourceLocation;
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+import java.util.*;
+
 public class AdvancementTree {
 
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -24,7 +18,8 @@ public class AdvancementTree {
     @Nullable
     private AdvancementTree.Listener listener;
 
-    public AdvancementTree() {}
+    public AdvancementTree() {
+    }
 
     private void remove(AdvancementNode advancement) {
         Iterator iterator = advancement.children().iterator();
@@ -85,7 +80,7 @@ public class AdvancementTree {
         Map map = this.nodes;
 
         Objects.requireNonNull(this.nodes);
-        AdvancementNode advancementnode = (AdvancementNode) optional.map(map::get).orElse((Object) null);
+        AdvancementNode advancementnode = (AdvancementNode) optional.map(map::get).orElse(null);
 
         if (advancementnode == null && optional.isPresent()) {
             return false;
diff --git a/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java b/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
index 35772110e9318df46a2729dbc0b5879b290011b7..ea73587289f3a9bb1c7dbc4bec745e11ab2ca28e 100644
--- a/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
+++ b/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
@@ -1,19 +1,17 @@
 package net.minecraft.advancements.critereon;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.function.Predicate;
 import net.minecraft.advancements.CriterionTrigger;
 import net.minecraft.advancements.CriterionTriggerInstance;
 import net.minecraft.server.PlayerAdvancements;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.storage.loot.LootContext;
 
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+
 public abstract class SimpleCriterionTrigger<T extends SimpleCriterionTrigger.SimpleInstance> implements CriterionTrigger<T> {
     // private final Map<PlayerAdvancements, Set<CriterionTrigger.Listener<T>>> players = Maps.newIdentityHashMap(); // Paper - fix AdvancementDataPlayer leak; moved into AdvancementDataPlayer to fix memory leak
 
@@ -51,7 +49,7 @@ public abstract class SimpleCriterionTrigger<T extends SimpleCriterionTrigger.Si
                     Optional<ContextAwarePredicate> optional = simpleInstance.player();
                     if (optional.isEmpty() || optional.get().matches(lootContext = (lootContext == null ? EntityPredicate.createContext(player, player) : lootContext))) { // Paper - Perf: lazily create LootContext for criterions
                         if (list == null) {
-                            list = Lists.newArrayList();
+                            list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                         }
 
                         list.add(listener);
diff --git a/src/main/java/net/minecraft/commands/arguments/MessageArgument.java b/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
index 237e4f7b24908e9ade9a483eb7ae05fa3b7931d8..f3db59dfd2879cb98eba541c1cee6a0ae5df93ba 100644
--- a/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
+++ b/src/main/java/net/minecraft/commands/arguments/MessageArgument.java
@@ -1,16 +1,9 @@
 package net.minecraft.commands.arguments;
 
-import com.google.common.collect.Lists;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.context.CommandContext;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.CompletableFuture;
-import java.util.function.Consumer;
-import javax.annotation.Nullable;
 import net.minecraft.commands.CommandSigningContext;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.arguments.selector.EntitySelector;
@@ -23,10 +16,17 @@ import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.FilteredText;
 
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Consumer;
+
 public class MessageArgument implements SignedArgument<MessageArgument.Message> {
     private static final Collection<String> EXAMPLES = Arrays.asList("Hello world!", "foo", "@e", "Hello @p :)");
     static final Dynamic2CommandExceptionType TOO_LONG = new Dynamic2CommandExceptionType(
-        (length, maxLength) -> Component.translatableEscape("argument.message.too_long", length, maxLength)
+            (length, maxLength) -> Component.translatableEscape("argument.message.too_long", length, maxLength)
     );
 
     public static MessageArgument message() {
@@ -40,11 +40,12 @@ public class MessageArgument implements SignedArgument<MessageArgument.Message>
 
     public static void resolveChatMessage(CommandContext<CommandSourceStack> context, String name, Consumer<PlayerChatMessage> callback) throws CommandSyntaxException {
         MessageArgument.Message message = context.getArgument(name, MessageArgument.Message.class);
-    // Paper start
+        // Paper start
         resolveChatMessage(message, context, name, callback);
     }
+
     public static void resolveChatMessage(MessageArgument.Message message, CommandContext<CommandSourceStack> context, String name, Consumer<PlayerChatMessage> callback) throws CommandSyntaxException {
-    // Paper end
+        // Paper end
         CommandSourceStack commandSourceStack = context.getSource();
         Component component = message.resolveComponent(commandSourceStack);
         CommandSigningContext commandSigningContext = commandSourceStack.getSigningContext();
@@ -79,18 +80,21 @@ public class MessageArgument implements SignedArgument<MessageArgument.Message>
     private static CompletableFuture<FilteredText> filterPlainText(CommandSourceStack source, PlayerChatMessage message) {
         ServerPlayer serverPlayer = source.getPlayer();
         return serverPlayer != null && message.hasSignatureFrom(serverPlayer.getUUID())
-            ? serverPlayer.getTextFilter().processStreamMessage(message.signedContent())
-            : CompletableFuture.completedFuture(FilteredText.passThrough(message.signedContent()));
+                ? serverPlayer.getTextFilter().processStreamMessage(message.signedContent())
+                : CompletableFuture.completedFuture(FilteredText.passThrough(message.signedContent()));
     }
 
+    @Override
     public MessageArgument.Message parse(StringReader stringReader) throws CommandSyntaxException {
         return MessageArgument.Message.parseText(stringReader, true);
     }
 
+    @Override
     public <S> MessageArgument.Message parse(StringReader stringReader, @Nullable S object) throws CommandSyntaxException {
         return MessageArgument.Message.parseText(stringReader, EntitySelectorParser.allowSelectors(object));
     }
 
+    @Override
     public Collection<String> getExamples() {
         return EXAMPLES;
     }
@@ -134,7 +138,7 @@ public class MessageArgument implements SignedArgument<MessageArgument.Message>
                     reader.setCursor(reader.getTotalLength());
                     return new MessageArgument.Message(string, new MessageArgument.Part[0]);
                 } else {
-                    List<MessageArgument.Part> list = Lists.newArrayList();
+                    List<MessageArgument.Part> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                     int i = reader.getCursor();
 
                     while (true) {
@@ -154,7 +158,7 @@ public class MessageArgument implements SignedArgument<MessageArgument.Message>
                                     break;
                                 } catch (CommandSyntaxException var8) {
                                     if (var8.getType() != EntitySelectorParser.ERROR_MISSING_SELECTOR_TYPE
-                                        && var8.getType() != EntitySelectorParser.ERROR_UNKNOWN_SELECTOR_TYPE) {
+                                            && var8.getType() != EntitySelectorParser.ERROR_UNKNOWN_SELECTOR_TYPE) {
                                         throw var8;
                                     }
 
diff --git a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelectorParser.java b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelectorParser.java
index ce200e673b54c66cfdf34657db28d3eee28dc4e0..a41458bccc7c6a71f9605057b007ac22beebd8e4 100644
--- a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelectorParser.java
+++ b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelectorParser.java
@@ -129,7 +129,7 @@ public class EntitySelectorParser {
         this.level = MinMaxBounds.Ints.ANY;
         this.rotX = WrappedMinMaxBounds.ANY;
         this.rotY = WrappedMinMaxBounds.ANY;
-        this.predicates = new ArrayList();
+        this.predicates = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.order = EntitySelector.ORDER_ARBITRARY;
         this.suggestions = EntitySelectorParser.SUGGEST_NOTHING;
         this.reader = reader;
diff --git a/src/main/java/net/minecraft/core/MappedRegistry.java b/src/main/java/net/minecraft/core/MappedRegistry.java
index 92c2c37363fe31147f94f645c49e54ac626951cd..07fa6106eb2d7a62e1bcaac0017fb81931bbbad1 100644
--- a/src/main/java/net/minecraft/core/MappedRegistry.java
+++ b/src/main/java/net/minecraft/core/MappedRegistry.java
@@ -383,7 +383,7 @@ public class MappedRegistry<T> implements WritableRegistry<T> {
     @Override
     public void bindTags(Map<TagKey<T>, List<Holder<T>>> tagEntries) {
         Map<Holder.Reference<T>, List<TagKey<T>>> map = new IdentityHashMap<>();
-        this.byKey.values().forEach(entry -> map.put((Holder.Reference<T>)entry, new ArrayList<>()));
+        this.byKey.values().forEach(entry -> map.put((Holder.Reference<T>)entry, new net.vansen.norspaper.collections.DynamicObjectArrayList<>()));
         tagEntries.forEach((tag, entries) -> {
             for (Holder<T> holder : entries) {
                 if (!holder.canSerializeIn(this.asLookup())) {
diff --git a/src/main/java/net/minecraft/nbt/ListTag.java b/src/main/java/net/minecraft/nbt/ListTag.java
index ef2671f8be6787796c3ed5415a9722713be9a65b..21896084b5706396dfdf09b2677fc5197787546b 100644
--- a/src/main/java/net/minecraft/nbt/ListTag.java
+++ b/src/main/java/net/minecraft/nbt/ListTag.java
@@ -2,6 +2,7 @@ package net.minecraft.nbt;
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
@@ -33,7 +34,7 @@ public class ListTag extends CollectionTag<Tag> {
             if (b == 0 && i > 0) {
                 throw new NbtFormatException("Missing type on ListTag");
             } else {
-                tracker.accountBytes(4L, (long)i);
+                tracker.accountBytes(4L, (long) i);
                 TagType<?> tagType = TagTypes.getType(b);
                 List<Tag> list = Lists.newArrayListWithCapacity(i);
 
@@ -70,11 +71,12 @@ public class ListTag extends CollectionTag<Tag> {
                     tagType.skip(input, i, tracker);
                     return visitor.visitContainerEnd();
                 default:
-                    tracker.accountBytes(4L, (long)i);
+                    tracker.accountBytes(4L, (long) i);
                     int j = 0;
 
                     while (true) {
-                        label41: {
+                        label41:
+                        {
                             if (j < i) {
                                 switch (visitor.visitElement(tagType, j)) {
                                     case HALT:
@@ -142,7 +144,7 @@ public class ListTag extends CollectionTag<Tag> {
     }
 
     public ListTag() {
-        this(Lists.newArrayList(), (byte)0);
+        this(new net.vansen.norspaper.collections.DynamicObjectArrayList<>(), (byte) 0);
     }
 
     @Override
@@ -210,7 +212,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 10) {
-                return (CompoundTag)tag;
+                return (CompoundTag) tag;
             }
         }
 
@@ -221,7 +223,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 9) {
-                return (ListTag)tag;
+                return (ListTag) tag;
             }
         }
 
@@ -232,7 +234,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 2) {
-                return ((ShortTag)tag).getAsShort();
+                return ((ShortTag) tag).getAsShort();
             }
         }
 
@@ -243,7 +245,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 3) {
-                return ((IntTag)tag).getAsInt();
+                return ((IntTag) tag).getAsInt();
             }
         }
 
@@ -254,7 +256,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 11) {
-                return ((IntArrayTag)tag).getAsIntArray();
+                return ((IntArrayTag) tag).getAsIntArray();
             }
         }
 
@@ -265,7 +267,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 12) {
-                return ((LongArrayTag)tag).getAsLongArray();
+                return ((LongArrayTag) tag).getAsLongArray();
             }
         }
 
@@ -276,7 +278,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 6) {
-                return ((DoubleTag)tag).getAsDouble();
+                return ((DoubleTag) tag).getAsDouble();
             }
         }
 
@@ -287,7 +289,7 @@ public class ListTag extends CollectionTag<Tag> {
         if (index >= 0 && index < this.list.size()) {
             Tag tag = this.list.get(index);
             if (tag.getId() == 5) {
-                return ((FloatTag)tag).getAsFloat();
+                return ((FloatTag) tag).getAsFloat();
             }
         }
 
@@ -363,14 +365,14 @@ public class ListTag extends CollectionTag<Tag> {
 
     @Override
     public ListTag copy() {
-        Iterable<Tag> iterable = (Iterable<Tag>)(TagTypes.getType(this.type).isValue() ? this.list : Iterables.transform(this.list, Tag::copy));
+        Iterable<Tag> iterable = (Iterable<Tag>) (TagTypes.getType(this.type).isValue() ? this.list : Iterables.transform(this.list, Tag::copy));
         List<Tag> list = Lists.newArrayList(iterable);
         return new ListTag(list, this.type);
     }
 
     @Override
     public boolean equals(Object object) {
-        return this == object || object instanceof ListTag && Objects.equals(this.list, ((ListTag)object).list);
+        return this == object || object instanceof ListTag && Objects.equals(this.list, ((ListTag) object).list);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/nbt/TagParser.java b/src/main/java/net/minecraft/nbt/TagParser.java
index 3cd112584accb8e8f050ac99738eed11c902e60e..83f39b2194a2277092c0d1d88a4b6977ba83e969 100644
--- a/src/main/java/net/minecraft/nbt/TagParser.java
+++ b/src/main/java/net/minecraft/nbt/TagParser.java
@@ -1,7 +1,6 @@
 package net.minecraft.nbt;
 
 import com.google.common.annotations.VisibleForTesting;
-import com.google.common.collect.Lists;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.brigadier.exceptions.Dynamic2CommandExceptionType;
@@ -10,22 +9,23 @@ import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Lifecycle;
+import net.minecraft.network.chat.Component;
+
 import java.util.List;
 import java.util.regex.Pattern;
-import net.minecraft.network.chat.Component;
 
 public class TagParser {
     public static final SimpleCommandExceptionType ERROR_TRAILING_DATA = new SimpleCommandExceptionType(Component.translatable("argument.nbt.trailing"));
     public static final SimpleCommandExceptionType ERROR_EXPECTED_KEY = new SimpleCommandExceptionType(Component.translatable("argument.nbt.expected.key"));
     public static final SimpleCommandExceptionType ERROR_EXPECTED_VALUE = new SimpleCommandExceptionType(Component.translatable("argument.nbt.expected.value"));
     public static final Dynamic2CommandExceptionType ERROR_INSERT_MIXED_LIST = new Dynamic2CommandExceptionType(
-        (receivedType, expectedType) -> Component.translatableEscape("argument.nbt.list.mixed", receivedType, expectedType)
+            (receivedType, expectedType) -> Component.translatableEscape("argument.nbt.list.mixed", receivedType, expectedType)
     );
     public static final Dynamic2CommandExceptionType ERROR_INSERT_MIXED_ARRAY = new Dynamic2CommandExceptionType(
-        (receivedType, expectedType) -> Component.translatableEscape("argument.nbt.array.mixed", receivedType, expectedType)
+            (receivedType, expectedType) -> Component.translatableEscape("argument.nbt.array.mixed", receivedType, expectedType)
     );
     public static final DynamicCommandExceptionType ERROR_INVALID_ARRAY = new DynamicCommandExceptionType(
-        type -> Component.translatableEscape("argument.nbt.array.invalid", type)
+            type -> Component.translatableEscape("argument.nbt.array.invalid", type)
     );
     public static final char ELEMENT_SEPARATOR = ',';
     public static final char NAME_VALUE_SEPARATOR = ':';
@@ -154,8 +154,8 @@ public class TagParser {
 
     protected Tag readList() throws CommandSyntaxException {
         return this.reader.canRead(3) && !StringReader.isQuotedStringStart(this.reader.peek(1)) && this.reader.peek(2) == ';'
-            ? this.readArrayTag()
-            : this.readListTag();
+                ? this.readArrayTag()
+                : this.readListTag();
     }
 
     public CompoundTag readStruct() throws CommandSyntaxException {
@@ -246,7 +246,7 @@ public class TagParser {
     }
 
     private <T extends Number> List<T> readArray(TagType<?> arrayTypeReader, TagType<?> typeReader) throws CommandSyntaxException {
-        List<T> list = Lists.newArrayList();
+        List<T> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         while (this.reader.peek() != ']') {
             int i = this.reader.getCursor();
@@ -258,11 +258,11 @@ public class TagParser {
             }
 
             if (typeReader == ByteTag.TYPE) {
-                list.add((T)(Byte)((NumericTag)tag).getAsByte()); // Paper - decompile fix
+                list.add((T) (Byte) ((NumericTag) tag).getAsByte()); // Paper - decompile fix
             } else if (typeReader == LongTag.TYPE) {
-                list.add((T)(Long)((NumericTag)tag).getAsLong()); // Paper - decompile fix
+                list.add((T) (Long) ((NumericTag) tag).getAsLong()); // Paper - decompile fix
             } else {
-                list.add((T)(Integer)((NumericTag)tag).getAsInt()); // Paper - decompile fix
+                list.add((T) (Integer) ((NumericTag) tag).getAsInt()); // Paper - decompile fix
             }
 
             if (!this.hasElementSeparator()) {
diff --git a/src/main/java/net/minecraft/network/chat/Component.java b/src/main/java/net/minecraft/network/chat/Component.java
index 2de8da4dbe2f7b9da740a90829f18bff0b3d5b8c..6c7e452329c9b8b3cca0b5fe929e6a749d8fd1bd 100644
--- a/src/main/java/net/minecraft/network/chat/Component.java
+++ b/src/main/java/net/minecraft/network/chat/Component.java
@@ -1,41 +1,20 @@
 package net.minecraft.network.chat;
 
-import com.google.common.collect.Lists;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonDeserializationContext;
-import com.google.gson.JsonDeserializer;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonParser;
-import com.google.gson.JsonSerializationContext;
-import com.google.gson.JsonSerializer;
+import com.google.gson.*;
 import com.google.gson.stream.JsonReader;
 import com.mojang.brigadier.Message;
 import com.mojang.serialization.JsonOps;
-import java.io.StringReader;
-import java.lang.reflect.Type;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Optional;
-import java.util.UUID;
-import javax.annotation.Nullable;
 import net.minecraft.core.HolderLookup;
-import net.minecraft.network.chat.contents.DataSource;
-import net.minecraft.network.chat.contents.KeybindContents;
-import net.minecraft.network.chat.contents.NbtContents;
-import net.minecraft.network.chat.contents.PlainTextContents;
-import net.minecraft.network.chat.contents.ScoreContents;
-import net.minecraft.network.chat.contents.SelectorContents;
-import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.network.chat.contents.*;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.util.FormattedCharSequence;
 import net.minecraft.world.level.ChunkPos;
-// CraftBukkit start
+
+import javax.annotation.Nullable;
+import java.io.StringReader;
+import java.lang.reflect.Type;
+import java.net.URI;
+import java.util.*;
 import java.util.stream.Stream;
 // CraftBukkit end
 
@@ -158,7 +137,7 @@ public interface Component extends Message, FormattedText, Iterable<Component> {
     }
 
     default List<Component> toFlatList(Style style) {
-        List<Component> list = Lists.newArrayList();
+        List<Component> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         this.visit((chatmodifier1, s) -> {
             if (!s.isEmpty()) {
@@ -277,10 +256,12 @@ public interface Component extends Message, FormattedText, Iterable<Component> {
             this.registries = registries;
         }
 
+        @Override
         public MutableComponent deserialize(JsonElement jsonelement, Type type, JsonDeserializationContext jsondeserializationcontext) throws JsonParseException {
             return Component.Serializer.deserialize(jsonelement, this.registries);
         }
 
+        @Override
         public JsonElement serialize(Component ichatbasecomponent, Type type, JsonSerializationContext jsonserializationcontext) {
             return Component.Serializer.serialize(ichatbasecomponent, this.registries);
         }
@@ -290,7 +271,8 @@ public interface Component extends Message, FormattedText, Iterable<Component> {
 
         private static final Gson GSON = (new GsonBuilder()).disableHtmlEscaping().create();
 
-        private Serializer() {}
+        private Serializer() {
+        }
 
         static MutableComponent deserialize(JsonElement json, HolderLookup.Provider registries) {
             return (MutableComponent) ComponentSerialization.CODEC.parse(registries.createSerializationContext(JsonOps.INSTANCE), json).getOrThrow(JsonParseException::new);
diff --git a/src/main/java/net/minecraft/network/chat/MutableComponent.java b/src/main/java/net/minecraft/network/chat/MutableComponent.java
index e34a8a66411b7571813117ce47d9dec08e567978..4a5464a5031b22d2cc44722755969cf05a4bca3b 100644
--- a/src/main/java/net/minecraft/network/chat/MutableComponent.java
+++ b/src/main/java/net/minecraft/network/chat/MutableComponent.java
@@ -1,14 +1,14 @@
 package net.minecraft.network.chat;
 
-import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.Objects;
-import java.util.function.UnaryOperator;
-import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.locale.Language;
 import net.minecraft.util.FormattedCharSequence;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Objects;
+import java.util.function.UnaryOperator;
+
 public class MutableComponent implements Component {
     private final ComponentContents contents;
     private final List<Component> siblings;
@@ -24,7 +24,7 @@ public class MutableComponent implements Component {
     }
 
     public static MutableComponent create(ComponentContents content) {
-        return new MutableComponent(content, Lists.newArrayList(), Style.EMPTY);
+        return new MutableComponent(content, new net.vansen.norspaper.collections.DynamicObjectArrayList<>(), Style.EMPTY);
     }
 
     @Override
@@ -100,7 +100,7 @@ public class MutableComponent implements Component {
         }
         // Paper end - make AdventureComponent equivalent
         return this == object
-            || object instanceof MutableComponent mutableComponent
+                || object instanceof MutableComponent mutableComponent
                 && this.contents.equals(mutableComponent.contents)
                 && this.style.equals(mutableComponent.style)
                 && this.siblings.equals(mutableComponent.siblings);
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index 0a8d07bf68b0ceabd13c70196d357fce79dcc2c3..e08994de8a24fe8319e675da1e7430f67cbf5c39 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -1,12 +1,7 @@
 package net.minecraft.network.protocol.game;
 
-import com.google.common.collect.Lists;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import java.util.List;
-import java.util.Map.Entry;
-import java.util.function.Consumer;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.registries.Registries;
@@ -22,6 +17,11 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.levelgen.Heightmap;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.function.Consumer;
+
 public class ClientboundLevelChunkPacketData {
     private static final int TWO_MEGABYTES = 2097152;
     private final CompoundTag heightmaps;
@@ -37,7 +37,12 @@ public class ClientboundLevelChunkPacketData {
     // Paper end - Handle oversized block entities in chunks
 
     // Paper start - Anti-Xray - Add chunk packet info
-    @Deprecated @io.papermc.paper.annotation.DoNotUse public ClientboundLevelChunkPacketData(LevelChunk chunk) { this(chunk, null); }
+    @Deprecated
+    @io.papermc.paper.annotation.DoNotUse
+    public ClientboundLevelChunkPacketData(LevelChunk chunk) {
+        this(chunk, null);
+    }
+
     public ClientboundLevelChunkPacketData(LevelChunk chunk, com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo) {
         // Paper end
         this.heightmaps = new CompoundTag();
@@ -57,7 +62,7 @@ public class ClientboundLevelChunkPacketData {
 
         extractChunkData(new FriendlyByteBuf(this.getWriteBuffer()), chunk, chunkPacketInfo);
         // Paper end
-        this.blockEntitiesData = Lists.newArrayList();
+        this.blockEntitiesData = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         int totalTileEntities = 0; // Paper - Handle oversized block entities in chunks
 
         for (Entry<BlockPos, BlockEntity> entry2 : chunk.getBlockEntities().entrySet()) {
@@ -114,7 +119,12 @@ public class ClientboundLevelChunkPacketData {
     }
 
     // Paper start - Anti-Xray - Add chunk packet info
-    @Deprecated @io.papermc.paper.annotation.DoNotUse public static void extractChunkData(FriendlyByteBuf buf, LevelChunk chunk) { ClientboundLevelChunkPacketData.extractChunkData(buf, chunk, null); }
+    @Deprecated
+    @io.papermc.paper.annotation.DoNotUse
+    public static void extractChunkData(FriendlyByteBuf buf, LevelChunk chunk) {
+        ClientboundLevelChunkPacketData.extractChunkData(buf, chunk, null);
+    }
+
     public static void extractChunkData(FriendlyByteBuf buf, LevelChunk chunk, com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo) {
         int chunkSectionIndex = 0;
 
@@ -152,10 +162,10 @@ public class ClientboundLevelChunkPacketData {
 
     static class BlockEntityInfo {
         public static final StreamCodec<RegistryFriendlyByteBuf, ClientboundLevelChunkPacketData.BlockEntityInfo> STREAM_CODEC = StreamCodec.ofMember(
-            ClientboundLevelChunkPacketData.BlockEntityInfo::write, ClientboundLevelChunkPacketData.BlockEntityInfo::new
+                ClientboundLevelChunkPacketData.BlockEntityInfo::write, ClientboundLevelChunkPacketData.BlockEntityInfo::new
         );
         public static final StreamCodec<RegistryFriendlyByteBuf, List<ClientboundLevelChunkPacketData.BlockEntityInfo>> LIST_STREAM_CODEC = STREAM_CODEC.apply(
-            ByteBufCodecs.list()
+                ByteBufCodecs.list()
         );
         final int packedXZ;
         final int y;
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
index 56bde49e6b7790155b032d0be40961d566ab89e9..bf80f1254952b36f7cce89a3b0f176be2aa1e4d5 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
@@ -1,16 +1,17 @@
 package net.minecraft.network.protocol.game;
 
-import java.util.ArrayList;
-import java.util.List;
 import net.minecraft.network.RegistryFriendlyByteBuf;
 import net.minecraft.network.codec.StreamCodec;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketType;
 import net.minecraft.network.syncher.SynchedEntityData;
 
-public record ClientboundSetEntityDataPacket(int id, List<SynchedEntityData.DataValue<?>> packedItems) implements Packet<ClientGamePacketListener> {
+import java.util.List;
+
+public record ClientboundSetEntityDataPacket(int id,
+                                             List<SynchedEntityData.DataValue<?>> packedItems) implements Packet<ClientGamePacketListener> {
     public static final StreamCodec<RegistryFriendlyByteBuf, ClientboundSetEntityDataPacket> STREAM_CODEC = Packet.codec(
-        ClientboundSetEntityDataPacket::write, ClientboundSetEntityDataPacket::new
+            ClientboundSetEntityDataPacket::write, ClientboundSetEntityDataPacket::new
     );
     public static final int EOF_MARKER = 255;
 
@@ -20,16 +21,16 @@ public record ClientboundSetEntityDataPacket(int id, List<SynchedEntityData.Data
 
     private static void pack(List<SynchedEntityData.DataValue<?>> trackedValues, RegistryFriendlyByteBuf buf) {
         try (var ignored = io.papermc.paper.util.DataSanitizationUtil.start(true)) { // Paper - data sanitization
-        for (SynchedEntityData.DataValue<?> dataValue : trackedValues) {
-            dataValue.write(buf);
-        }
+            for (SynchedEntityData.DataValue<?> dataValue : trackedValues) {
+                dataValue.write(buf);
+            }
         } // Paper - data sanitization
 
         buf.writeByte(255);
     }
 
     private static List<SynchedEntityData.DataValue<?>> unpack(RegistryFriendlyByteBuf buf) {
-        List<SynchedEntityData.DataValue<?>> list = new ArrayList<>();
+        List<SynchedEntityData.DataValue<?>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         int i;
         while ((i = buf.readUnsignedByte()) != 255) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
index bf0db5e46a530a8d4c5ebaa58d0e14c4b457036b..cc9769a614f8ada25c5348e8c0dfe6d22e620863 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
@@ -1,8 +1,6 @@
 package net.minecraft.network.protocol.game;
 
-import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
-import java.util.List;
 import net.minecraft.network.RegistryFriendlyByteBuf;
 import net.minecraft.network.codec.StreamCodec;
 import net.minecraft.network.protocol.Packet;
@@ -10,9 +8,11 @@ import net.minecraft.network.protocol.PacketType;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.item.ItemStack;
 
+import java.util.List;
+
 public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketListener> {
     public static final StreamCodec<RegistryFriendlyByteBuf, ClientboundSetEquipmentPacket> STREAM_CODEC = Packet.codec(
-        ClientboundSetEquipmentPacket::write, ClientboundSetEquipmentPacket::new
+            ClientboundSetEquipmentPacket::write, ClientboundSetEquipmentPacket::new
     );
     private static final byte CONTINUE_MASK = -128;
     private final int entity;
@@ -22,7 +22,9 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
         // Paper start - data sanitization
         this(entityId, equipmentList, false);
     }
+
     private boolean sanitize;
+
     public ClientboundSetEquipmentPacket(int entityId, List<Pair<EquipmentSlot, ItemStack>> equipmentList, boolean sanitize) {
         this.sanitize = sanitize;
         // Paper end - data sanitization
@@ -33,7 +35,7 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
     private ClientboundSetEquipmentPacket(RegistryFriendlyByteBuf buf) {
         this.entity = buf.readVarInt();
         EquipmentSlot[] equipmentSlots = EquipmentSlot.VALUES; // Gale - JettPack - reduce array allocations
-        this.slots = Lists.newArrayList();
+        this.slots = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         int i;
         do {
@@ -49,14 +51,14 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
         int i = this.slots.size();
 
         try (var ignored = io.papermc.paper.util.DataSanitizationUtil.start(this.sanitize)) {  // Paper - data sanitization
-        for (int j = 0; j < i; j++) {
-            Pair<EquipmentSlot, ItemStack> pair = this.slots.get(j);
-            EquipmentSlot equipmentSlot = pair.getFirst();
-            boolean bl = j != i - 1;
-            int k = equipmentSlot.ordinal();
-            buf.writeByte(bl ? k | -128 : k);
-            ItemStack.OPTIONAL_STREAM_CODEC.encode(buf, pair.getSecond());
-        }
+            for (int j = 0; j < i; j++) {
+                Pair<EquipmentSlot, ItemStack> pair = this.slots.get(j);
+                EquipmentSlot equipmentSlot = pair.getFirst();
+                boolean bl = j != i - 1;
+                int k = equipmentSlot.ordinal();
+                buf.writeByte(bl ? k | -128 : k);
+                ItemStack.OPTIONAL_STREAM_CODEC.encode(buf, pair.getSecond());
+            }
         } // Paper - data sanitization
     }
 
diff --git a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
index 0f99733660f91280e4c6262cf75b3c9cae86f65a..2c5be07ff788dd1f6db4b8b08f3529032aa67830 100644
--- a/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
+++ b/src/main/java/net/minecraft/network/syncher/SynchedEntityData.java
@@ -3,17 +3,17 @@ package net.minecraft.network.syncher;
 import com.mojang.logging.LogUtils;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.EncoderException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import javax.annotation.Nullable;
 import net.minecraft.network.RegistryFriendlyByteBuf;
 import net.minecraft.util.ClassTreeIdRegistry;
 import org.apache.commons.lang3.ObjectUtils;
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Objects;
+
 public class SynchedEntityData {
 
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -37,7 +37,6 @@ public class SynchedEntityData {
                     SynchedEntityData.LOGGER.debug("defineId called for: {} from {}", new Object[]{entityClass, oclass1, new RuntimeException()});
                 }
             } catch (ClassNotFoundException classnotfoundexception) {
-                ;
             }
         }
 
@@ -91,7 +90,7 @@ public class SynchedEntityData {
             return null;
         } else {
             this.isDirty = false;
-            List<SynchedEntityData.DataValue<?>> list = new ArrayList();
+            List<SynchedEntityData.DataValue<?>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             SynchedEntityData.DataItem[] adatawatcher_item = this.itemsById;
             int i = adatawatcher_item.length;
 
@@ -119,7 +118,7 @@ public class SynchedEntityData {
 
             if (!datawatcher_item.isSetToDefault()) {
                 if (list == null) {
-                    list = new ArrayList();
+                    list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 }
 
                 list.add(datawatcher_item.value());
@@ -156,7 +155,7 @@ public class SynchedEntityData {
     // Because these values can possibly be desynced on the client.
     @Nullable
     public List<SynchedEntityData.DataValue<?>> packAll() {
-        final List<SynchedEntityData.DataValue<?>> list = new ArrayList<>();
+        final List<SynchedEntityData.DataValue<?>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final DataItem<?> dataItem : this.itemsById) {
             list.add(dataItem.value());
         }
diff --git a/src/main/java/net/minecraft/recipebook/ServerPlaceRecipe.java b/src/main/java/net/minecraft/recipebook/ServerPlaceRecipe.java
index 6d1f9c15dc99917a2ac966ea38ef1970f4f0289c..82aa71805a6414e9c10e8f913d3619777464a9be 100644
--- a/src/main/java/net/minecraft/recipebook/ServerPlaceRecipe.java
+++ b/src/main/java/net/minecraft/recipebook/ServerPlaceRecipe.java
@@ -1,10 +1,7 @@
 package net.minecraft.recipebook;
 
-import com.google.common.collect.Lists;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntList;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.network.protocol.game.ClientboundPlaceGhostRecipePacket;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.player.Inventory;
@@ -16,6 +13,9 @@ import net.minecraft.world.item.crafting.Recipe;
 import net.minecraft.world.item.crafting.RecipeHolder;
 import net.minecraft.world.item.crafting.RecipeInput;
 
+import javax.annotation.Nullable;
+import java.util.List;
+
 public class ServerPlaceRecipe<I extends RecipeInput, R extends Recipe<I>> implements PlaceRecipe<Integer> {
     private static final int ITEM_NOT_FOUND = -1;
     protected final StackedContents stackedContents = new StackedContents();
@@ -144,12 +144,14 @@ public class ServerPlaceRecipe<I extends RecipeInput, R extends Recipe<I>> imple
         return i;
     }
 
-    @Deprecated @io.papermc.paper.annotation.DoNotUse // Paper - Improve exact choice recipe ingredients
+    @Deprecated
+    @io.papermc.paper.annotation.DoNotUse // Paper - Improve exact choice recipe ingredients
 
     protected int moveItemToGrid(Slot slot, ItemStack stack, int i) {
         // Paper start - Improve exact choice recipe ingredients
         return this.moveItemToGrid(slot, stack, i, false);
     }
+
     protected int moveItemToGrid(Slot slot, ItemStack stack, int i, final boolean isExact) {
         int j = isExact ? this.inventory.findSlotMatchingItem(stack) : this.inventory.findSlotMatchingUnusedItem(stack);
         // Paper end - Improve exact choice recipe ingredients
@@ -177,7 +179,7 @@ public class ServerPlaceRecipe<I extends RecipeInput, R extends Recipe<I>> imple
     }
 
     private boolean testClearGrid() {
-        List<ItemStack> list = Lists.newArrayList();
+        List<ItemStack> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         int i = this.getAmountOfFreeSlotsInInventory();
 
         for (int j = 0; j < this.menu.getGridWidth() * this.menu.getGridHeight() + 1; j++) {
@@ -188,8 +190,8 @@ public class ServerPlaceRecipe<I extends RecipeInput, R extends Recipe<I>> imple
                     if (k == -1 && list.size() <= i) {
                         for (ItemStack itemStack2 : list) {
                             if (ItemStack.isSameItem(itemStack2, itemStack)
-                                && itemStack2.getCount() != itemStack2.getMaxStackSize()
-                                && itemStack2.getCount() + itemStack.getCount() <= itemStack2.getMaxStackSize()) {
+                                    && itemStack2.getCount() != itemStack2.getMaxStackSize()
+                                    && itemStack2.getCount() + itemStack.getCount() <= itemStack2.getMaxStackSize()) {
                                 itemStack2.grow(itemStack.getCount());
                                 itemStack.setCount(0);
                                 break;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 6b9b3d366343a0bef76036b2b150691787f93db6..147bde704975b1953ccd0491f637232722cc7787 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -3,8 +3,6 @@ package net.minecraft.server;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
-import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
-import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -13,65 +11,22 @@ import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import com.mojang.serialization.Dynamic;
+import com.mojang.serialization.Lifecycle;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
-import java.awt.image.BufferedImage;
-import java.io.BufferedWriter;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.lang.management.ManagementFactory;
-import java.lang.management.ThreadInfo;
-import java.lang.management.ThreadMXBean;
-import java.net.Proxy;
-import java.nio.file.FileStore;
-import java.nio.file.Files;
-import java.nio.file.LinkOption;
-import java.nio.file.Path;
-import java.security.KeyPair;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.BooleanSupplier;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
-import javax.imageio.ImageIO;
-import net.minecraft.CrashReport;
-import net.minecraft.CrashReportCategory;
-import net.minecraft.FileUtil;
-import net.minecraft.ReportType;
-import net.minecraft.ReportedException;
-import net.minecraft.SharedConstants;
-import net.minecraft.SystemReport;
-import net.minecraft.Util;
+import joptsimple.OptionSet;
+import net.minecraft.*;
 import net.minecraft.commands.CommandSource;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.HolderGetter;
-import net.minecraft.core.LayeredRegistryAccess;
-import net.minecraft.core.Registry;
-import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.*;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.data.worldgen.features.MiscOverworldFeatures;
 import net.minecraft.gametest.framework.GameTestTicker;
+import net.minecraft.nbt.NbtException;
+import net.minecraft.nbt.ReportedNbtException;
 import net.minecraft.network.chat.ChatDecorator;
 import net.minecraft.network.chat.ChatType;
 import net.minecraft.network.chat.Component;
@@ -81,6 +36,14 @@ import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.obfuscate.DontObfuscate;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.bossevents.CustomBossEvents;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.dedicated.DedicatedServerProperties;
+import net.minecraft.server.level.*;
+import net.minecraft.server.level.progress.ChunkProgressListener;
+import net.minecraft.server.level.progress.ChunkProgressListenerFactory;
+import net.minecraft.server.network.ServerConnectionListener;
+import net.minecraft.server.network.TextFilter;
 import net.minecraft.server.packs.PackType;
 import net.minecraft.server.packs.repository.Pack;
 import net.minecraft.server.packs.repository.PackRepository;
@@ -92,15 +55,7 @@ import net.minecraft.server.players.GameProfileCache;
 import net.minecraft.server.players.PlayerList;
 import net.minecraft.server.players.ServerOpListEntry;
 import net.minecraft.server.players.UserWhiteList;
-import net.minecraft.util.Crypt;
-import net.minecraft.util.CryptException;
-import net.minecraft.util.ModCheck;
-import net.minecraft.util.Mth;
-import net.minecraft.util.NativeModuleLister;
-import net.minecraft.util.ProgressListener;
-import net.minecraft.util.RandomSource;
-import net.minecraft.util.SignatureValidator;
-import net.minecraft.util.TimeUtil;
+import net.minecraft.util.*;
 import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.util.debugchart.RemoteDebugSampleType;
 import net.minecraft.util.debugchart.SampleLogger;
@@ -120,70 +75,51 @@ import net.minecraft.world.flag.FeatureFlagSet;
 import net.minecraft.world.flag.FeatureFlags;
 import net.minecraft.world.item.alchemy.PotionBrewing;
 import net.minecraft.world.item.crafting.RecipeManager;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.CustomSpawner;
-import net.minecraft.world.level.DataPackConfig;
-import net.minecraft.world.level.ForcedChunksSavedData;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.GameType;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.LevelSettings;
-import net.minecraft.world.level.WorldDataConfiguration;
+import net.minecraft.world.level.*;
 import net.minecraft.world.level.biome.BiomeManager;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.chunk.storage.ChunkIOErrorReporter;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
 import net.minecraft.world.level.dimension.LevelStem;
-import net.minecraft.world.level.levelgen.WorldOptions;
+import net.minecraft.world.level.levelgen.*;
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
-import net.minecraft.world.level.storage.WorldData;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import com.mojang.serialization.Dynamic;
-import com.mojang.serialization.Lifecycle;
-import java.io.File;
-import java.util.Random;
-// import jline.console.ConsoleReader; // Paper
-import joptsimple.OptionSet;
-import net.minecraft.nbt.NbtException;
-import net.minecraft.nbt.ReportedNbtException;
-import net.minecraft.server.bossevents.CustomBossEvents;
-import net.minecraft.server.dedicated.DedicatedServer;
-import net.minecraft.server.dedicated.DedicatedServerProperties;
-import net.minecraft.server.level.DemoMode;
-import net.minecraft.server.level.PlayerRespawnLogic;
-import net.minecraft.server.level.ServerChunkCache;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.level.ServerPlayerGameMode;
-import net.minecraft.server.level.progress.ChunkProgressListener;
-import net.minecraft.server.level.progress.ChunkProgressListenerFactory;
-import net.minecraft.server.network.ServerConnectionListener;
-import net.minecraft.server.network.TextFilter;
-import net.minecraft.world.level.levelgen.Heightmap;
-import net.minecraft.world.level.levelgen.PatrolSpawner;
-import net.minecraft.world.level.levelgen.PhantomSpawner;
-import net.minecraft.world.level.levelgen.WorldDimensions;
 import net.minecraft.world.level.levelgen.presets.WorldPresets;
-import net.minecraft.world.level.storage.CommandStorage;
-import net.minecraft.world.level.storage.DimensionDataStorage;
-import net.minecraft.world.level.storage.LevelData;
-import net.minecraft.world.level.storage.LevelDataAndDimensions;
-import net.minecraft.world.level.storage.LevelResource;
-import net.minecraft.world.level.storage.LevelStorageSource;
-import net.minecraft.world.level.storage.LevelSummary;
-import net.minecraft.world.level.storage.PlayerDataStorage;
-import net.minecraft.world.level.storage.PrimaryLevelData;
-import net.minecraft.world.level.storage.ServerLevelData;
+import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
+import net.minecraft.world.level.storage.*;
 import net.minecraft.world.level.validation.ContentValidationException;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftRegistry;
 import org.bukkit.event.server.ServerLoadEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.BufferedWriter;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadInfo;
+import java.lang.management.ThreadMXBean;
+import java.net.Proxy;
+import java.nio.file.FileStore;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+import java.security.KeyPair;
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.BooleanSupplier;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
@@ -212,7 +148,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static final GameProfile ANONYMOUS_PLAYER_PROFILE = new GameProfile(Util.NIL_UUID, "Anonymous Player");
     public LevelStorageSource.LevelStorageAccess storageSource;
     public final PlayerDataStorage playerDataStorage;
-    private final List<Runnable> tickables = Lists.newArrayList();
+    private final List<Runnable> tickables = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private ServerConnectionListener connection;
     public final ChunkProgressListenerFactory progressListenerFactory;
     @Nullable
@@ -297,7 +233,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
     private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
     @Deprecated(forRemoval = true) // Paper
-    public final double[] recentTps = new double[ 4 ]; // Purpur
+    public final double[] recentTps = new double[4]; // Purpur
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
     public final org.galemc.gale.configuration.GaleConfigurations galeConfigurations; // Gale - Gale configuration
@@ -322,7 +258,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         thread.setUncaughtExceptionHandler((thread1, throwable) -> {
             MinecraftServer.LOGGER.error("Uncaught exception in server thread", throwable);
         });
-        thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - Perf: Boost priority
+        thread.setPriority(Thread.NORM_PRIORITY + 2); // Paper - Perf: Boost priority
         if (Runtime.getRuntime().availableProcessors() > 4) {
             thread.setPriority(8);
         }
@@ -360,12 +296,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         boolean executed = false;
         for (final ServerLevel world : this.getAllLevels()) {
             long currTime = System.nanoTime();
-            if (currTime - ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getLastMidTickFailure() <= TASK_EXECUTION_FAILURE_BACKOFF) {
+            if (currTime - ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) world).moonrise$getLastMidTickFailure() <= TASK_EXECUTION_FAILURE_BACKOFF) {
                 continue;
             }
             if (!world.getChunkSource().pollTask()) {
                 // we need to back off if this fails
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$setLastMidTickFailure(currTime);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) world).moonrise$setLastMidTickFailure(currTime);
             } else {
                 executed = true;
             }
@@ -383,7 +319,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return;
         }
 
-        for (;;) {
+        for (; ; ) {
             final boolean moreTasks = this.tickMidTickTasks();
             final long currTime = System.nanoTime();
             final long diff = currTime - startTime;
@@ -400,8 +336,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     overuse = 10L * 1000L * 1000L; // 10ms
                 }
 
-                final double overuseCount = (double)overuse/(double)MAX_CHUNK_EXEC_TIME;
-                final long extraSleep = (long)Math.round(overuseCount*CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME);
+                final double overuseCount = (double) overuse / (double) MAX_CHUNK_EXEC_TIME;
+                final long extraSleep = (long) Math.round(overuseCount * CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME);
 
                 this.lastMidTickExecute = currTime + extraSleep;
                 return;
@@ -495,7 +431,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     protected void loadLevel(String s) { // CraftBukkit
         if (!JvmProfiler.INSTANCE.isRunning()) {
-            ;
         }
 
         boolean flag = false;
@@ -517,7 +452,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     }
 
-    protected void forceDifficulty() {}
+    protected void forceDifficulty() {
+    }
 
     // CraftBukkit start
     private void loadWorld0(String s) {
@@ -742,7 +678,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         this.server.spark.enableAfterPlugins(this.server); // Paper - spark
-        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null) io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.pluginsEnabled(); // Paper - Remap plugins
+        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null)
+            io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.pluginsEnabled(); // Paper - Remap plugins
         io.papermc.paper.command.brigadier.PaperCommands.INSTANCE.setValid(); // Paper - reset invalid state for event fire below
         io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents.COMMANDS, io.papermc.paper.command.brigadier.PaperCommands.INSTANCE, org.bukkit.plugin.Plugin.class, io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.INITIAL); // Paper - call commands event for regular plugins
         ((org.bukkit.craftbukkit.help.SimpleHelpMap) this.server.getHelpMap()).initializeCommands();
@@ -773,7 +710,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 try {
                     worldserver.fillReportDetails(crashreport);
                 } catch (Throwable throwable1) {
-                    ;
                 }
 
                 throw new ReportedException(crashreport);
@@ -939,6 +875,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - add close param
         return this.saveAllChunks(suppressLogs, flush, force, false);
     }
+
     public boolean saveAllChunks(boolean suppressLogs, boolean flush, boolean force, boolean close) {
         // Paper end - add close param
         boolean flag3 = false;
@@ -1002,6 +939,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private boolean hasLoggedStop = false; // Paper - Debugging
     public volatile boolean hasFullyShutdown = false; // Paper
     private final Object stopLock = new Object();
+
     public final boolean hasStopped() {
         synchronized (this.stopLock) {
             return this.hasStopped;
@@ -1011,11 +949,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public void stopServer() {
         // CraftBukkit start - prevent double stopping on multiple threads
-        synchronized(this.stopLock) {
+        synchronized (this.stopLock) {
             if (this.hasStopped) return;
             this.hasStopped = true;
         }
-        if (!hasLoggedStop && isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
+        if (!hasLoggedStop && isDebugging())
+            io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
         // Paper start - kill main thread, and kill it hard
         shutdownThread = Thread.currentThread();
         org.spigotmc.WatchdogThread.doStop(); // Paper
@@ -1040,14 +979,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.server.waitForAsyncTasksShutdown(); // Paper - Wait for Async Tasks during shutdown
         }
         // CraftBukkit end
-        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null) io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.shutdown(); // Paper - Plugin remapping
+        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null)
+            io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.shutdown(); // Paper - Plugin remapping
         this.getConnection().stop();
         this.isSaving = true;
         if (this.playerList != null) {
             MinecraftServer.LOGGER.info("Saving players");
             this.playerList.saveAll();
             this.playerList.removeAll(this.isRestarting); // Paper
-            try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ex) {
+            } // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
         }
 
         MinecraftServer.LOGGER.info("Saving worlds");
@@ -1091,8 +1034,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Spigot start
         io.papermc.paper.util.MCUtil.asyncExecutor.shutdown(); // Paper
-        try { io.papermc.paper.util.MCUtil.asyncExecutor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
-        } catch (java.lang.InterruptedException ignored) {} // Paper
+        try {
+            io.papermc.paper.util.MCUtil.asyncExecutor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
+        } catch (java.lang.InterruptedException ignored) {
+        } // Paper
         if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
             MinecraftServer.LOGGER.info("Saving usercache.json");
             this.getProfileCache().save(false); // Paper - Perf: Async GameProfileCache saving
@@ -1128,6 +1073,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - allow passing of the intent to restart
         this.safeShutdown(waitForShutdown, false);
     }
+
     public void safeShutdown(boolean waitForShutdown, boolean isRestarting) {
         org.purpurmc.purpur.task.BossBarTask.stopAll(); // Purpur
         org.purpurmc.purpur.task.BeehiveTask.instance().unregister(); // Purpur
@@ -1147,9 +1093,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // Spigot Start
-    private static double calcTps(double avg, double exp, double tps)
-    {
-        return ( avg * exp ) + ( tps * ( 1 - exp ) );
+    private static double calcTps(double avg, double exp, double tps) {
+        return (avg * exp) + (tps * (1 - exp));
     }
 
     // Paper start - Further improve server tick loop
@@ -1185,6 +1130,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         private static java.math.BigDecimal dec(long t) {
             return new java.math.BigDecimal(t);
         }
+
         public void add(java.math.BigDecimal x, long t) {
             time -= times[index];
             total = total.subtract(samples[index].multiply(dec(times[index])));
@@ -1201,6 +1147,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             return total.divide(dec(time), 30, java.math.RoundingMode.HALF_UP).doubleValue();
         }
     }
+
     private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
     // Paper end
     // Spigot End
@@ -1238,7 +1185,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
             org.dreeam.leaf.config.LeafConfig.regSparkExtraConfig(); // Leaf - Leaf Config
 
-            Arrays.fill( this.recentTps, 20 );
+            Arrays.fill(this.recentTps, 20);
             // Paper start - further improve server tick loop
             long tickSection = Util.getNanos();
             long currentTime;
@@ -1287,7 +1234,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                         long k = j / i;
 
                         if (this.server.getWarnOnOverload()) // CraftBukkit
-                        MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", j / TimeUtil.NANOSECONDS_PER_MILLISECOND, k);
+                            MinecraftServer.LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", j / TimeUtil.NANOSECONDS_PER_MILLISECOND, k);
                         this.nextTickTimeNanos += k * i;
                         this.lastOverloadWarningNanos = this.nextTickTimeNanos;
                     }
@@ -1457,6 +1404,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     // Paper start
     boolean isOversleep = false;
+
     private boolean canOversleep() {
         return this.mayHaveDelayedTasks && Util.getNanos() < this.delayedTasksMaxNextTickTimeNanos;
     }
@@ -1528,12 +1476,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - anything that does try to post to main during watchdog crash, run on watchdog
         if (this.hasStopped && Thread.currentThread().equals(shutdownThread)) {
             runnable.run();
-            runnable = () -> {};
+            runnable = () -> {
+            };
         }
         // Paper end
         return new TickTask(this.tickCount, runnable);
     }
 
+    @Override
     protected boolean shouldRun(TickTask ticktask) {
         return ticktask.getTick() + 3 < this.tickCount || this.haveTime();
     }
@@ -1568,6 +1518,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
     }
 
+    @Override
     public void doRunTask(TickTask ticktask) { // CraftBukkit - decompile error
         super.doRunTask(ticktask);
     }
@@ -1606,9 +1557,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return Path.of("");
     }
 
-    public void onServerCrash(CrashReport report) {}
+    public void onServerCrash(CrashReport report) {
+    }
 
-    public void onServerExit() {}
+    public void onServerExit() {
+    }
 
     public boolean isPaused() {
         return false;
@@ -1625,7 +1578,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         isOversleep = false;
         // Paper end
         this.server.spark.tickStart(); // Paper - spark
-        new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper - Server Tick Events
+        new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount + 1).callEvent(); // Paper - Server Tick Events
 
         // Leaf start - Lag compensation tick hook
         if (org.dreeam.leaf.config.modules.misc.LagCompensation.enabled) {
@@ -1662,12 +1615,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.isSaving = false;
         }
         // Paper end - Incremental chunk and player saving
-            this.runAllTasks();
+        this.runAllTasks();
         // Paper start - Server Tick Events
         long endTime = System.nanoTime();
         long remaining = (TICK_TIME - (endTime - lastTick)) - catchupTime;
-        new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.tickCount, ((double)(endTime - lastTick) / 1000000D), remaining).callEvent();
-        this.server.spark.tickEnd(((double)(endTime - lastTick) / 1000000D)); // Paper - spark
+        new com.destroystokyo.paper.event.server.ServerTickEndEvent(this.tickCount, ((double) (endTime - lastTick) / 1000000D), remaining).callEvent();
+        this.server.spark.tickEnd(((double) (endTime - lastTick) / 1000000D)); // Paper - spark
         // Paper end - Server Tick Events
         long j = Util.getNanos() - i;
         int k = this.tickCount % 100;
@@ -1806,7 +1759,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 ServerPlayer entityplayer = (ServerPlayer) entityhuman;
                 long playerTime = entityplayer.getPlayerTime();
                 ClientboundSetTimePacket packet = (playerTime == dayTime) ? worldPacket :
-                    new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
+                        new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
                 entityplayer.connection.send(packet); // Add support for per player time
             }
         }
@@ -2306,10 +2259,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     // Paper start - Add ServerResourcesReloadedEvent
-    @Deprecated @io.papermc.paper.annotation.DoNotUse
+    @Deprecated
+    @io.papermc.paper.annotation.DoNotUse
     public CompletableFuture<Void> reloadResources(Collection<String> dataPacks) {
         return this.reloadResources(dataPacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause.PLUGIN);
     }
+
     public CompletableFuture<Void> reloadResources(Collection<String> dataPacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause cause) {
         // Paper end - Add ServerResourcesReloadedEvent
         CompletableFuture<Void> completablefuture = CompletableFuture.supplyAsync(() -> {
@@ -2486,7 +2441,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (this.isEnforceWhitelist()) {
             PlayerList playerlist = source.getServer().getPlayerList();
             UserWhiteList whitelist = playerlist.getWhiteList();
-            if (!((DedicatedServer) getServer()).getProperties().whiteList.get()) return; // Paper - whitelist not enabled
+            if (!((DedicatedServer) getServer()).getProperties().whiteList.get())
+                return; // Paper - whitelist not enabled
             List<ServerPlayer> list = Lists.newArrayList(playerlist.getPlayers());
             Iterator iterator = list.iterator();
 
@@ -2592,7 +2548,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public abstract boolean isSingleplayerOwner(GameProfile profile);
 
-    public void dumpServerProperties(Path file) throws IOException {}
+    public void dumpServerProperties(Path file) throws IOException {
+    }
 
     private void saveDebugReport(Path path) {
         Path path1 = path.resolve("levels");
@@ -2651,7 +2608,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         BufferedWriter bufferedwriter = Files.newBufferedWriter(path);
 
         try {
-            final List<String> list = Lists.newArrayList();
+            final List<String> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             final GameRules gamerules = this.getGameRules();
 
             GameRules.visitGameRuleTypes(new GameRules.GameRuleTypeVisitor() { // CraftBukkit - decompile error
@@ -2902,6 +2859,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setThreadFactory(org.dreeam.leaf.config.modules.opt.VT4ChatExecutor.enabled ? Thread.ofVirtual().factory() : java.util.concurrent.Executors.defaultThreadFactory()).setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper // Leaf - Virtual thread for chatExecutor
 
     public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
+
     public ChatDecorator getChatDecorator() {
         return this.improvedChatDecorator; // Paper - support async chat decoration events
     }
@@ -2910,7 +2868,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return true;
     }
 
-    public void subscribeToDebugSample(ServerPlayer player, RemoteDebugSampleType type) {}
+    public void subscribeToDebugSample(ServerPlayer player, RemoteDebugSampleType type) {
+    }
 
     public boolean acceptsTransfers() {
         return false;
@@ -2972,14 +2931,17 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return ServerLinks.EMPTY;
     }
 
-    public static record ReloadableResources(CloseableResourceManager resourceManager, ReloadableServerResources managers) implements AutoCloseable {
+    public static record ReloadableResources(CloseableResourceManager resourceManager,
+                                             ReloadableServerResources managers) implements AutoCloseable {
 
+        @Override
         public void close() {
             this.resourceManager.close();
         }
     }
 
-    public static record ServerResourcePackInfo(UUID id, String url, String hash, boolean isRequired, @Nullable Component prompt) {
+    public static record ServerResourcePackInfo(UUID id, String url, String hash, boolean isRequired,
+                                                @Nullable Component prompt) {
 
     }
 
diff --git a/src/main/java/net/minecraft/server/ServerScoreboard.java b/src/main/java/net/minecraft/server/ServerScoreboard.java
index f180001493146ef0d54079a8b2b47ad7decc24ca..b67138f792c3be77934a196faf4f54b7ae934335 100644
--- a/src/main/java/net/minecraft/server/ServerScoreboard.java
+++ b/src/main/java/net/minecraft/server/ServerScoreboard.java
@@ -1,38 +1,23 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import javax.annotation.Nullable;
 import net.minecraft.core.HolderLookup;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientboundResetScorePacket;
-import net.minecraft.network.protocol.game.ClientboundSetDisplayObjectivePacket;
-import net.minecraft.network.protocol.game.ClientboundSetObjectivePacket;
-import net.minecraft.network.protocol.game.ClientboundSetPlayerTeamPacket;
-import net.minecraft.network.protocol.game.ClientboundSetScorePacket;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.saveddata.SavedData;
-import net.minecraft.world.scores.DisplaySlot;
-import net.minecraft.world.scores.Objective;
-import net.minecraft.world.scores.PlayerScoreEntry;
-import net.minecraft.world.scores.PlayerTeam;
-import net.minecraft.world.scores.Score;
-import net.minecraft.world.scores.ScoreHolder;
-import net.minecraft.world.scores.Scoreboard;
-import net.minecraft.world.scores.ScoreboardSaveData;
+import net.minecraft.world.scores.*;
+
+import javax.annotation.Nullable;
+import java.util.*;
 
 public class ServerScoreboard extends Scoreboard {
 
     private final MinecraftServer server;
     private final Set<Objective> trackedObjectives = Sets.newHashSet();
-    private final List<Runnable> dirtyListeners = Lists.newArrayList();
+    private final List<Runnable> dirtyListeners = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     public ServerScoreboard(MinecraftServer server) {
         this.server = server;
@@ -206,7 +191,7 @@ public class ServerScoreboard extends Scoreboard {
     }
 
     public List<Packet<?>> getStartTrackingPackets(Objective objective) {
-        List<Packet<?>> list = Lists.newArrayList();
+        List<Packet<?>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         list.add(new ClientboundSetObjectivePacket(objective, 0));
         DisplaySlot[] adisplayslot = DisplaySlot.values();
@@ -237,7 +222,8 @@ public class ServerScoreboard extends Scoreboard {
 
         while (iterator.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator.next();
-            if (entityplayer.getBukkitEntity().getScoreboard().getHandle() != this) continue; // CraftBukkit - Only players on this board
+            if (entityplayer.getBukkitEntity().getScoreboard().getHandle() != this)
+                continue; // CraftBukkit - Only players on this board
             Iterator iterator1 = list.iterator();
 
             while (iterator1.hasNext()) {
@@ -251,7 +237,7 @@ public class ServerScoreboard extends Scoreboard {
     }
 
     public List<Packet<?>> getStopTrackingPackets(Objective objective) {
-        List<Packet<?>> list = Lists.newArrayList();
+        List<Packet<?>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         list.add(new ClientboundSetObjectivePacket(objective, 1));
         DisplaySlot[] adisplayslot = DisplaySlot.values();
@@ -274,7 +260,8 @@ public class ServerScoreboard extends Scoreboard {
 
         while (iterator.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator.next();
-            if (entityplayer.getBukkitEntity().getScoreboard().getHandle() != this) continue; // CraftBukkit - Only players on this board
+            if (entityplayer.getBukkitEntity().getScoreboard().getHandle() != this)
+                continue; // CraftBukkit - Only players on this board
             Iterator iterator1 = list.iterator();
 
             while (iterator1.hasNext()) {
@@ -333,6 +320,7 @@ public class ServerScoreboard extends Scoreboard {
 
         CHANGE, REMOVE;
 
-        private Method() {}
+        private Method() {
+        }
     }
 }
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 86462d3eff74f373820ccdbb162978d1d4a6d9d6..f51661a790f1f47c9c1a1bbeb3e9630aa521c20c 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -966,6 +966,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
     }
 
     // CraftBukkit start
+    @Override
     public boolean isDebugging() {
         return this.getProperties().debug;
     }
diff --git a/src/main/java/net/minecraft/server/gui/MinecraftServerGui.java b/src/main/java/net/minecraft/server/gui/MinecraftServerGui.java
index 8f951e3b6241d040b28d3c8b8e7d7f96ab4d2b8d..e5edd507bdd64f977829ebc714206f294197ffe7 100644
--- a/src/main/java/net/minecraft/server/gui/MinecraftServerGui.java
+++ b/src/main/java/net/minecraft/server/gui/MinecraftServerGui.java
@@ -1,12 +1,16 @@
 package net.minecraft.server.gui;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogQueues;
 import com.mojang.logging.LogUtils;
-import java.awt.BorderLayout;
-import java.awt.Component;
-import java.awt.Dimension;
-import java.awt.Font;
+import net.minecraft.DefaultUncaughtExceptionHandler;
+import net.minecraft.server.dedicated.DedicatedServer;
+import org.slf4j.Logger;
+
+import javax.swing.*;
+import javax.swing.border.EtchedBorder;
+import javax.swing.border.TitledBorder;
+import javax.swing.text.Document;
+import java.awt.*;
 import java.awt.event.FocusAdapter;
 import java.awt.event.FocusEvent;
 import java.awt.event.WindowAdapter;
@@ -14,24 +18,6 @@ import java.awt.event.WindowEvent;
 import java.util.Collection;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
-import javax.swing.JComponent;
-import javax.swing.JFrame;
-import javax.swing.JList;
-import javax.swing.JPanel;
-import javax.swing.JScrollBar;
-import javax.swing.JScrollPane;
-import javax.swing.JTextArea;
-import javax.swing.JTextField;
-import javax.swing.SwingUtilities;
-import javax.swing.UIManager;
-import javax.swing.border.EtchedBorder;
-import javax.swing.border.TitledBorder;
-import javax.swing.text.AttributeSet;
-import javax.swing.text.BadLocationException;
-import javax.swing.text.Document;
-import net.minecraft.DefaultUncaughtExceptionHandler;
-import net.minecraft.server.dedicated.DedicatedServer;
-import org.slf4j.Logger;
 
 public class MinecraftServerGui extends JComponent {
 
@@ -41,7 +27,7 @@ public class MinecraftServerGui extends JComponent {
     private static final String SHUTDOWN_TITLE = "Minecraft server - shutting down!";
     private final DedicatedServer server;
     private Thread logAppenderThread;
-    private final Collection<Runnable> finalizers = Lists.newArrayList();
+    private final Collection<Runnable> finalizers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     final AtomicBoolean isClosing = new AtomicBoolean();
     // Purpur start
     private final CommandHistory history = new CommandHistory();
@@ -53,7 +39,6 @@ public class MinecraftServerGui extends JComponent {
         try {
             UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
         } catch (Exception exception) {
-            ;
         }
 
         final JFrame jframe = new JFrame(org.dreeam.leaf.config.modules.misc.ServerBrand.serverGUIName); // Purpur // Leaf - Configurable server GUI name
@@ -74,6 +59,7 @@ public class MinecraftServerGui extends JComponent {
         // Paper end - Improve ServerGUI
 
         jframe.addWindowListener(new WindowAdapter() {
+            @Override
             public void windowClosing(WindowEvent windowevent) {
                 if (!servergui.isClosing.getAndSet(true)) {
                     jframe.setTitle(org.dreeam.leaf.config.modules.misc.ServerBrand.serverGUIName + " - shutting down!"); // Purpur // Leaf - Configurable server GUI name
@@ -214,7 +200,9 @@ public class MinecraftServerGui extends JComponent {
         });
         // Purpur end
         jtextarea.addFocusListener(new FocusAdapter() { // CraftBukkit - decompile error
-            public void focusGained(FocusEvent focusevent) {}
+            @Override
+            public void focusGained(FocusEvent focusevent) {
+            }
         });
         jpanel.add(jscrollpane, "Center");
         jpanel.add(jtextfield, "South");
@@ -248,6 +236,7 @@ public class MinecraftServerGui extends JComponent {
     }
 
     private static final java.util.regex.Pattern ANSI = java.util.regex.Pattern.compile("\\e\\[[\\d;]*[^\\d;]"); // CraftBukkit // Paper
+
     public void print(org.purpurmc.purpur.gui.JColorTextPane textArea, JScrollPane scrollPane, String message) { // Purpur
         if (!SwingUtilities.isEventDispatchThread()) {
             SwingUtilities.invokeLater(() -> {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 58e79417e3722ce73cbbc1f9c74cbc73178f762d..fa160a45e1be83a4c3cc12915a1852dc58508717 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -3,49 +3,12 @@ package net.minecraft.server.level;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
-import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2LongMap;
-import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import java.io.IOException;
-import java.io.Writer;
-import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
-import java.util.function.Consumer;
-import java.util.function.IntFunction;
-import java.util.function.IntSupplier;
-import java.util.function.Supplier;
-import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -58,7 +21,6 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtException;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundChunksBiomesPacket;
-import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
 import net.minecraft.util.CsvOutput;
@@ -73,19 +35,11 @@ import net.minecraft.world.entity.ai.village.poi.PoiManager;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.chunk.ChunkGeneratorStructureState;
-import net.minecraft.world.level.chunk.ImposterProtoChunk;
-import net.minecraft.world.level.chunk.LevelChunk;
-import net.minecraft.world.level.chunk.LightChunkGetter;
-import net.minecraft.world.level.chunk.ProtoChunk;
-import net.minecraft.world.level.chunk.UpgradeData;
+import net.minecraft.world.level.chunk.*;
 import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.chunk.status.ChunkStep;
 import net.minecraft.world.level.chunk.status.ChunkType;
 import net.minecraft.world.level.chunk.status.WorldGenContext;
-import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.ChunkStorage;
 import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
 import net.minecraft.world.level.entity.ChunkStatusUpdateListener;
@@ -94,16 +48,23 @@ import net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator;
 import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
 import net.minecraft.world.level.levelgen.RandomState;
 import net.minecraft.world.level.levelgen.blending.BlendingData;
-import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import net.minecraft.world.phys.Vec3;
-import org.apache.commons.lang3.mutable.MutableBoolean;
+import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
 import org.slf4j.Logger;
 
-// CraftBukkit start
-import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.*;
 // CraftBukkit end
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider, GeneratingChunkMap {
@@ -146,6 +107,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
     public final CallbackExecutor callbackExecutor = new CallbackExecutor();
+
     public static final class CallbackExecutor implements java.util.concurrent.Executor, Runnable {
 
         private final java.util.Queue<Runnable> queue = new java.util.ArrayDeque<>();
@@ -162,7 +124,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 task.run();
             }
         }
-    };
+    }
     // CraftBukkit end
 
     // Paper start
@@ -229,7 +191,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         final int index = entity.getType().getCategory().ordinal();
 
         final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> inRange =
-            this.level.moonrise$getNearbyPlayers().getPlayers(entity.chunkPosition(), ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
+                this.level.moonrise$getNearbyPlayers().getPlayers(entity.chunkPosition(), ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
         if (inRange == null) {
             return;
         }
@@ -243,10 +205,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
         else
             // Leaf end - Multithreaded tracker
-        for (int i = 0, len = inRange.size(); i < len; i++) {
-            ++(backingSet[i].mobCounts[index]);
-        }
+            for (int i = 0, len = inRange.size(); i < len; i++) {
+                ++(backingSet[i].mobCounts[index]);
+            }
     }
+
     // Paper start - per player mob count backoff
     public void updateFailurePlayerMobTypeMap(int chunkX, int chunkZ, net.minecraft.world.entity.MobCategory mobCategory) {
         if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) {
@@ -254,7 +217,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
         int idx = mobCategory.ordinal();
         final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> inRange =
-            this.level.moonrise$getNearbyPlayers().getPlayersByChunk(chunkX, chunkZ, ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
+                this.level.moonrise$getNearbyPlayers().getPlayersByChunk(chunkX, chunkZ, ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.TICK_VIEW_DISTANCE);
         if (inRange == null) {
             return;
         }
@@ -263,6 +226,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             ++(backingSet[i].mobBackoffCounts[idx]);
         }
     }
+
     // Paper end - per player mob count backoff
     public int getMobCountNear(final ServerPlayer player, final net.minecraft.world.entity.MobCategory mobCategory) {
         return player.mobCounts[mobCategory.ordinal()] + player.mobBackoffCounts[mobCategory.ordinal()]; // Paper - per player mob count backoff
@@ -292,11 +256,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     boolean isChunkTracked(ServerPlayer player, int chunkX, int chunkZ) {
-        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().isChunkSent(player, chunkX, chunkZ); // Paper - rewrite chunk system
+        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getPlayerChunkLoader().isChunkSent(player, chunkX, chunkZ); // Paper - rewrite chunk system
     }
 
     private boolean isChunkOnTrackedBorder(ServerPlayer player, int chunkX, int chunkZ) {
-        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().isChunkSent(player, chunkX, chunkZ, true); // Paper - rewrite chunk system
+        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getPlayerChunkLoader().isChunkSent(player, chunkX, chunkZ, true); // Paper - rewrite chunk system
     }
 
     protected ThreadedLevelLightEngine getLightEngine() {
@@ -306,7 +270,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     @Nullable
     protected ChunkHolder getUpdatingChunkIfPresent(long pos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(pos);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(pos);
         return holder == null ? null : holder.vanillaChunkHolder;
         // Paper end - rewrite chunk system
     }
@@ -314,7 +278,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     @Nullable
     public ChunkHolder getVisibleChunkIfPresent(long pos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(pos);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(pos);
         return holder == null ? null : holder.vanillaChunkHolder;
         // Paper end - rewrite chunk system
     }
@@ -393,8 +357,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     protected void saveAllChunks(boolean flush) {
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.saveAllChunks(
-            flush, false, false
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.saveAllChunks(
+                flush, false, false
         );
     }
 
@@ -410,8 +374,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     private void processUnloads(BooleanSupplier shouldKeepTicking) {
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processUnloads(); // Paper - rewrite chunk system
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.autoSave(); // Paper - rewrite chunk system
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processUnloads(); // Paper - rewrite chunk system
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.autoSave(); // Paper - rewrite chunk system
 
     }
 
@@ -454,7 +418,6 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         if (!flag) {
             if (!flag1) {
-                ;
             }
 
             this.level.getServer().reportChunkLoadFailure(throwable3, this.storageInfo(), chunkPos);
@@ -548,7 +511,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         this.serverViewDistance = clamped;
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().setLoadDistance(this.serverViewDistance + 1);
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getPlayerChunkLoader().setLoadDistance(this.serverViewDistance + 1);
         // Paper end - rewrite chunk system
     }
 
@@ -576,9 +539,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             try {
                 return CompletableFuture.completedFuture(
                         Optional.ofNullable(
-                            ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.loadData(
+                                ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.loadData(
                                         this.level, pos.x, pos.z, ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA,
-                                         ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
+                                        ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.getIOBlockingPriorityForCurrentThread()
                                 )
                         )
                 );
@@ -593,8 +556,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public CompletableFuture<Void> write(final ChunkPos pos, final CompoundTag tag) {
         if (!ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.isRegionFileThread()) {
             ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.scheduleSave(
-                this.level, pos.x, pos.z, tag,
-                ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
+                    this.level, pos.x, pos.z, tag,
+                    ca.spottedleaf.moonrise.patches.chunk_system.io.RegionFileIOThread.RegionFileType.CHUNK_DATA);
             return null;
         }
         super.write(pos, tag);
@@ -762,7 +725,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             );
 
             if (players == null) {
-                return new ArrayList<>();
+                return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             }
 
             List<ServerPlayer> ret = null;
@@ -783,7 +746,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 }
             }
 
-            return ret == null ? new ArrayList<>() : ret;
+            return ret == null ? new net.vansen.norspaper.collections.DynamicObjectArrayList<>() : ret;
         }
         // Moonrise end - Optimize nearby players for spawning iteration
         long i = pos.toLong();
@@ -829,7 +792,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.updatePlayerPos(player);
             if (!flag1) {
                 this.distanceManager.addPlayer(SectionPos.of((EntityAccess) player), player);
-                ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$addPlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
+                ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager) this.distanceManager).moonrise$addPlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
             }
 
             player.setChunkTrackingView(ChunkTrackingView.EMPTY);
@@ -840,7 +803,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.playerMap.removePlayer(player);
             if (!flag2) {
                 this.distanceManager.removePlayer(sectionposition, player);
-                ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$removePlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
+                ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager) this.distanceManager).moonrise$removePlayer(player, SectionPos.of(player)); // Paper - chunk tick iteration optimisation
             }
 
             ca.spottedleaf.moonrise.common.util.ChunkSystem.removePlayerFromDistanceMaps(this.level, player); // Paper - rewrite chunk system
@@ -865,7 +828,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         if (flag2 || flag != flag1) {
             this.updatePlayerPos(player);
-            ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager)this.distanceManager).moonrise$updatePlayer(player, sectionposition, sectionposition1, flag, flag1); // Paper - chunk tick iteration optimisation
+            ((ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickDistanceManager) this.distanceManager).moonrise$updatePlayer(player, sectionposition, sectionposition1, flag, flag1); // Paper - chunk tick iteration optimisation
             if (!flag) {
                 this.distanceManager.removePlayer(sectionposition, player);
             }
@@ -901,9 +864,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper start - rewrite chunk system
         final ChunkHolder holder = this.getVisibleChunkIfPresent(chunkPos.toLong());
         if (holder == null) {
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         } else {
-            return ((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemChunkHolder)holder).moonrise$getPlayers(onlyOnWatchDistanceEdge);
+            return ((ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemChunkHolder) holder).moonrise$getPlayers(onlyOnWatchDistanceEdge);
         }
         // Paper end - rewrite chunk system
     }
@@ -913,11 +876,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
         if (!entity.valid || entity.level() != this.level || this.entityMap.containsKey(entity.getId())) {
             LOGGER.error("Illegal ChunkMap::addEntity for world " + this.level.getWorld().getName()
-                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable());
+                    + ": " + entity + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable());
             return;
         }
         // Paper end - ignore and warn about illegal addEntity calls instead of crashing server
-        if (entity instanceof ServerPlayer && ((ServerPlayer) entity).supressTrackerForLogin) return; // Paper - Fire PlayerJoinEvent when Player is actually ready; Delay adding to tracker until after list packets
+        if (entity instanceof ServerPlayer && ((ServerPlayer) entity).supressTrackerForLogin)
+            return; // Paper - Fire PlayerJoinEvent when Player is actually ready; Delay adding to tracker until after list packets
         if (!(entity instanceof EnderDragonPart)) {
             EntityType<?> entitytypes = entity.getType();
             int i = entitytypes.clientTrackingRange() * 16;
@@ -933,10 +897,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
                     this.entityMap.put(entity.getId(), playerchunkmap_entitytracker);
                     // Paper start - optimise entity tracker
-                    if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity() != null) {
+                    if (((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity) entity).moonrise$getTrackedEntity() != null) {
                         throw new IllegalStateException("Entity is already tracked");
                     }
-                    ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$setTrackedEntity(playerchunkmap_entitytracker);
+                    ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity) entity).moonrise$setTrackedEntity(playerchunkmap_entitytracker);
                     // Paper end - optimise entity tracker
                     playerchunkmap_entitytracker.updatePlayers(this.level.players());
                     if (entity instanceof ServerPlayer) {
@@ -978,7 +942,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             playerchunkmap_entitytracker1.broadcastRemoved();
         }
 
-        ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$setTrackedEntity(null); // Paper - optimise entity tracker
+        ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity) entity).moonrise$setTrackedEntity(null); // Paper - optimise entity tracker
     }
 
     // Leaf start - petal - Multithreaded tracker
@@ -998,18 +962,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     // Paper start - optimise entity tracker
     private void newTrackerTick() {
-        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getNearbyPlayers();
-        final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup)((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getEntityLookup();;
+        final ca.spottedleaf.moonrise.common.misc.NearbyPlayers nearbyPlayers = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getNearbyPlayers();
+        final ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup entityLookup = (ca.spottedleaf.moonrise.patches.chunk_system.level.entity.server.ServerEntityLookup) ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getEntityLookup();
 
         final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.entity.Entity> trackerEntities = entityLookup.trackerEntities;
         final Entity[] trackerEntitiesRaw = trackerEntities.getRawDataUnchecked();
         for (int i = 0, len = trackerEntities.size(); i < len; ++i) {
             final Entity entity = trackerEntitiesRaw[i];
-            final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
+            final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity) entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
             }
-            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$tick(nearbyPlayers.getChunk(entity.chunkPosition()));
+            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity) tracker).moonrise$tick(nearbyPlayers.getChunk(entity.chunkPosition()));
             tracker.serverEntity.sendChanges();
         }
 
@@ -1019,11 +983,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         unloadedEntities.clear();
 
         for (final Entity entity : unloadedEntitiesRaw) {
-            final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity)entity).moonrise$getTrackedEntity();
+            final ChunkMap.TrackedEntity tracker = ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity) entity).moonrise$getTrackedEntity();
             if (tracker == null) {
                 continue;
             }
-            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity)tracker).moonrise$clearPlayers();
+            ((ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerTrackedEntity) tracker).moonrise$clearPlayers();
         }
     }
     // Paper end - optimise entity tracker
@@ -1044,7 +1008,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - optimise entity tracker
         // Paper - rewrite chunk system
 
-        List<ServerPlayer> list = Lists.newArrayList();
+        List<ServerPlayer> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         List<ServerPlayer> list1 = this.level.players();
         ObjectIterator objectiterator = this.entityMap.values().iterator();
 
@@ -1122,7 +1086,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 ServerPlayer entityplayer = (ServerPlayer) iterator1.next();
 
                 ((List) map.computeIfAbsent(entityplayer, (entityplayer1) -> {
-                    return new ArrayList();
+                    return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 })).add(chunk);
             }
         }
@@ -1247,21 +1211,21 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     updatePlayerTasks.run();
                 }
             } else {
-            for (int i = 0, len = players.size(); i < len; ++i) {
-                final ServerPlayer player = playersRaw[i];
-                this.updatePlayer(player);
-            }
+                for (int i = 0, len = players.size(); i < len; ++i) {
+                    final ServerPlayer player = playersRaw[i];
+                    this.updatePlayer(player);
+                }
 
-            if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
-                // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
-                    final ServerPlayer player = conn.getPlayer();
-                    if (!players.contains(player)) {
-                        this.removePlayer(player);
+                if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
+                    // need to purge any players possible not in the chunk list
+                    for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                        final ServerPlayer player = conn.getPlayer();
+                        if (!players.contains(player)) {
+                            this.removePlayer(player);
+                        }
                     }
                 }
             }
-            }
             // Leaf end - Multithreaded tracker
         }
 
@@ -1308,10 +1272,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.lastSectionPos = SectionPos.of((EntityAccess) entity);
         }
 
+        @Override
         public boolean equals(Object object) {
             return object instanceof ChunkMap.TrackedEntity ? ((ChunkMap.TrackedEntity) object).entity.getId() == this.entity.getId() : false;
         }
 
+        @Override
         public int hashCode() {
             return this.entity.getId();
         }
@@ -1351,7 +1317,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         public void updatePlayer(ServerPlayer player) {
             //org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot // Leaf - petal - Multithreaded tracker - We can update async
             if (player != this.entity) {
-                if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled && player == null) return; // Leaf - Multithreaded tracker
+                if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled && player == null)
+                    return; // Leaf - Multithreaded tracker
                 // Paper start - remove allocation of Vec3D here
                 // Vec3 vec3d = player.position().subtract(this.entity.position());
                 double vec3d_dx = player.getX() - this.entity.getX();
@@ -1382,7 +1349,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     if (this.seenBy.add(player.connection)) {
                         // Paper start - entity tracking events
                         if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 || new io.papermc.paper.event.player.PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity()).callEvent()) {
-                        this.serverEntity.addPairing(player);
+                            this.serverEntity.addPairing(player);
                         }
                         // Paper end - entity tracking events
                         this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 189bfe0e97943f3f560fa3c2674013e2e833bd5e..e04db007d82761d4bf2ca8b79077d7bb3e8ab575 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -1,35 +1,12 @@
 package net.minecraft.server.level;
 
-import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-import java.util.function.Consumer;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
-import net.minecraft.core.component.DataComponents;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientGamePacketListener;
-import net.minecraft.network.protocol.game.ClientboundBundlePacket;
-import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundProjectilePowerPacket;
-import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
-import net.minecraft.network.protocol.game.ClientboundRotateHeadPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
-import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundUpdateAttributesPacket;
-import net.minecraft.network.protocol.game.VecDeltaCodec;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.network.ServerPlayerConnection;
+import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.entity.Leashable;
@@ -43,13 +20,14 @@ import net.minecraft.world.item.MapItem;
 import net.minecraft.world.level.saveddata.maps.MapId;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
 import net.minecraft.world.phys.Vec3;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import net.minecraft.server.network.ServerPlayerConnection;
-import net.minecraft.util.Mth;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerVelocityEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public class ServerEntity {
@@ -98,6 +76,7 @@ public class ServerEntity {
 
     // Paper start - fix desync when a player is added to the tracker
     private boolean forceStateResync;
+
     public void onPlayerAdd() {
         this.forceStateResync = true;
     }
@@ -105,7 +84,7 @@ public class ServerEntity {
 
     public void sendChanges() {
         // Paper start - optimise collisions
-        if (((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this.entity).moonrise$isHardColliding()) {
+        if (((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity) this.entity).moonrise$isHardColliding()) {
             this.teleportDelay = 9999;
         }
         // Paper end - optimise collisions
@@ -150,19 +129,19 @@ public class ServerEntity {
                                 }
                             }
                         } else {
-                        // Paper end
-                        Iterator<ServerPlayerConnection> iterator = this.trackedPlayers.iterator(); // CraftBukkit
+                            // Paper end
+                            Iterator<ServerPlayerConnection> iterator = this.trackedPlayers.iterator(); // CraftBukkit
 
-                        while (iterator.hasNext()) {
-                            ServerPlayer entityplayer = iterator.next().getPlayer(); // CraftBukkit
+                            while (iterator.hasNext()) {
+                                ServerPlayer entityplayer = iterator.next().getPlayer(); // CraftBukkit
 
-                            //worldmap.tickCarriedBy(entityplayer, itemstack); // Paper
-                            Packet<?> packet = worldmap.framedUpdatePacket(mapid, entityplayer); // Paper
+                                //worldmap.tickCarriedBy(entityplayer, itemstack); // Paper
+                                Packet<?> packet = worldmap.framedUpdatePacket(mapid, entityplayer); // Paper
 
-                            if (packet != null) {
-                                entityplayer.connection.send(packet);
+                                if (packet != null) {
+                                    entityplayer.connection.send(packet);
+                                }
                             }
-                        }
                         } // Paper
                     }
                 }
@@ -213,19 +192,19 @@ public class ServerEntity {
 
                 if (!this.forceStateResync && !flag6 && this.teleportDelay <= 400 && !this.wasRiding && this.wasOnGround == this.entity.onGround()) { // Paper - fix desync when a player is added to the tracker
                     if (flag2 || flag3 || this.entity instanceof AbstractArrow) { // Gale - Airplane - better checking for useless move packets
-                    if ((!flag2 || !flag3) && !(this.entity instanceof AbstractArrow)) {
-                        if (flag2) {
-                            packet1 = new ClientboundMoveEntityPacket.Pos(this.entity.getId(), (short) ((int) k), (short) ((int) l), (short) ((int) i1), this.entity.onGround());
+                        if ((!flag2 || !flag3) && !(this.entity instanceof AbstractArrow)) {
+                            if (flag2) {
+                                packet1 = new ClientboundMoveEntityPacket.Pos(this.entity.getId(), (short) ((int) k), (short) ((int) l), (short) ((int) i1), this.entity.onGround());
+                                flag4 = true;
+                            } else if (flag3) {
+                                packet1 = new ClientboundMoveEntityPacket.Rot(this.entity.getId(), (byte) i, (byte) j, this.entity.onGround());
+                                flag5 = true;
+                            }
+                        } else {
+                            packet1 = new ClientboundMoveEntityPacket.PosRot(this.entity.getId(), (short) ((int) k), (short) ((int) l), (short) ((int) i1), (byte) i, (byte) j, this.entity.onGround());
                             flag4 = true;
-                        } else if (flag3) {
-                            packet1 = new ClientboundMoveEntityPacket.Rot(this.entity.getId(), (byte) i, (byte) j, this.entity.onGround());
                             flag5 = true;
                         }
-                    } else {
-                        packet1 = new ClientboundMoveEntityPacket.PosRot(this.entity.getId(), (short) ((int) k), (short) ((int) l), (short) ((int) i1), (byte) i, (byte) j, this.entity.onGround());
-                        flag4 = true;
-                        flag5 = true;
-                    }
                     } // Gale - Airplane - better checking for useless move packets
                 } else {
                     this.wasOnGround = this.entity.onGround();
@@ -235,25 +214,26 @@ public class ServerEntity {
                     flag5 = true;
                 }
 
-                if (org.dreeam.leaf.config.modules.opt.ReduceUselessPackets.reduceUselessEntityMovePackets && isUselessMoveEntityPacket(packet1)) packet1 = null; // Purpur
+                if (org.dreeam.leaf.config.modules.opt.ReduceUselessPackets.reduceUselessEntityMovePackets && isUselessMoveEntityPacket(packet1))
+                    packet1 = null; // Purpur
 
                 if ((this.trackDelta || this.entity.hasImpulse || this.entity instanceof LivingEntity && ((LivingEntity) this.entity).isFallFlying()) && this.tickCount > 0) {
                     Vec3 vec3d1 = this.entity.getDeltaMovement();
                     if (vec3d1 != this.lastSentMovement) { // SparklyPaper start - skip distanceToSqr call in ServerEntity#sendChanges if the delta movement hasn't changed
-                    double d0 = vec3d1.distanceToSqr(this.lastSentMovement);
+                        double d0 = vec3d1.distanceToSqr(this.lastSentMovement);
 
-                    if (d0 > 1.0E-7D || d0 > 0.0D && vec3d1.lengthSqr() == 0.0D) {
-                        this.lastSentMovement = vec3d1;
-                        Entity entity1 = this.entity;
+                        if (d0 > 1.0E-7D || d0 > 0.0D && vec3d1.lengthSqr() == 0.0D) {
+                            this.lastSentMovement = vec3d1;
+                            Entity entity1 = this.entity;
 
-                        if (entity1 instanceof AbstractHurtingProjectile) {
-                            AbstractHurtingProjectile entityfireball = (AbstractHurtingProjectile) entity1;
+                            if (entity1 instanceof AbstractHurtingProjectile) {
+                                AbstractHurtingProjectile entityfireball = (AbstractHurtingProjectile) entity1;
 
-                            this.broadcast.accept(new ClientboundBundlePacket(List.of(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement), new ClientboundProjectilePowerPacket(entityfireball.getId(), entityfireball.accelerationPower))));
-                        } else {
-                            this.broadcast.accept(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement));
+                                this.broadcast.accept(new ClientboundBundlePacket(List.of(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement), new ClientboundProjectilePowerPacket(entityfireball.getId(), entityfireball.accelerationPower))));
+                            } else {
+                                this.broadcast.accept(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement));
+                            }
                         }
-                    }
                     } // SparklyPaper end
                 }
 
@@ -344,13 +324,13 @@ public class ServerEntity {
         this.entity.stopSeenByPlayer(player);
         // Leaf start - petal - Multithreaded tracker - send in main thread
         ((ServerLevel) this.entity.level()).chunkSource.chunkMap.runOnTrackerMainThread(() ->
-            player.connection.send(new ClientboundRemoveEntitiesPacket(this.entity.getId()))
+                player.connection.send(new ClientboundRemoveEntitiesPacket(this.entity.getId()))
         );
         // Leaf end - petal - Multithreaded tracker - send in main thread
     }
 
     public void addPairing(ServerPlayer player) {
-        List<Packet<? super ClientGamePacketListener>> list = new ArrayList();
+        List<Packet<? super ClientGamePacketListener>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         Objects.requireNonNull(list);
         this.sendPairingData(player, list::add);
@@ -402,7 +382,7 @@ public class ServerEntity {
         }
 
         if (this.entity instanceof LivingEntity) {
-            List<Pair<EquipmentSlot, ItemStack>> list = Lists.newArrayList();
+            List<Pair<EquipmentSlot, ItemStack>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             EquipmentSlot[] aenumitemslot = EquipmentSlot.VALUES; // Gale - JettPack - reduce array allocations
             int i = aenumitemslot.length;
 
@@ -492,12 +472,12 @@ public class ServerEntity {
                 // Leaf end - petal - Multithreaded tracker - send in main thread
                 final Set<AttributeInstance> copy = new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(set);
                 ((ServerLevel) this.entity.level()).chunkSource.chunkMap.runOnTrackerMainThread(() -> {
-                // CraftBukkit start - Send scaled max health
-                if (this.entity instanceof ServerPlayer) {
-                    ((ServerPlayer) this.entity).getBukkitEntity().injectScaledMaxHealth(copy, false);
-                }
-                // CraftBukkit end
-                this.broadcastAndSend(new ClientboundUpdateAttributesPacket(this.entity.getId(), copy));
+                    // CraftBukkit start - Send scaled max health
+                    if (this.entity instanceof ServerPlayer) {
+                        ((ServerPlayer) this.entity).getBukkitEntity().injectScaledMaxHealth(copy, false);
+                    }
+                    // CraftBukkit end
+                    this.broadcastAndSend(new ClientboundUpdateAttributesPacket(this.entity.getId(), copy));
                 });
                 // Leaf end - petal - Multithreaded tracker - send in main thread
             }
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 5bba2d22b92274a7222f7123e3380b9cda4cd784..ac2c07e29102c34a8b1b16cb557c9aaba710e89e 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -475,7 +475,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         this.tickTime = flag1;
         this.server = minecraftserver;
         // Purpur start - enable/disable MobSpawners per world
-        this.customSpawners = Lists.newArrayList();
+        this.customSpawners = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         if (purpurConfig.phantomSpawning) {
             customSpawners.add(new net.minecraft.world.level.levelgen.PhantomSpawner());
         }
@@ -563,7 +563,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         this.chunkTaskScheduler = new ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler((ServerLevel) (Object) this, ca.spottedleaf.moonrise.common.util.MoonriseCommon.WORKER_POOL);
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
-        this.realPlayers = Lists.newArrayList(); // Leaves - skip
+        this.realPlayers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // Leaves - skip
         this.preciseTime = this.serverLevelData.getDayTime(); // Purpur
     }
 
@@ -1368,7 +1368,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     }
 
     public <T extends Entity> List<? extends T> getEntities(EntityTypeTest<Entity, T> filter, Predicate<? super T> predicate) {
-        List<T> list = Lists.newArrayList();
+        List<T> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         this.getEntities(filter, predicate, (List) list);
         return list;
@@ -1400,7 +1400,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     }
 
     public List<ServerPlayer> getPlayers(Predicate<? super ServerPlayer> predicate, int limit) {
-        List<ServerPlayer> list = Lists.newArrayList();
+        List<ServerPlayer> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index edef689792b163e6a33921fe2e4b1af69715a2ee..659245df238b5ed938beb8e7e5314d591df89d05 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -2189,6 +2189,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
         return this.teleportTo(world, destX, destY, destZ, flags, yaw, pitch, TeleportCause.UNKNOWN);
     }
 
+    @Override
     public boolean teleportTo(ServerLevel worldserver, double d0, double d1, double d2, Set<RelativeMovement> set, float f, float f1, TeleportCause cause) {
         // CraftBukkit end
         ChunkPos chunkcoordintpair = new ChunkPos(BlockPos.containing(d0, d1, d2));
@@ -2408,6 +2409,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
         return this.server.getProfilePermissions(this.getGameProfile());
     }
 
+    @Override
     public void resetLastActionTime() {
         this.lastActionTime = Util.getMillis();
         this.setAfk(false); // Purpur
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 28731f0c5b0ba63fa8d5ce3ee580bf314a844f92..cc0f10d7f4f2d43a768f567683c5e412c1114748 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -1,19 +1,13 @@
 package net.minecraft.server.level;
 
 import com.mojang.logging.LogUtils;
-import java.util.Objects;
-import javax.annotation.Nullable;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
 import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
-import net.minecraft.world.InteractionHand;
-import net.minecraft.world.InteractionResult;
-import net.minecraft.world.InteractionResultHolder;
-import net.minecraft.world.ItemInteractionResult;
-import net.minecraft.world.MenuProvider;
+import net.minecraft.world.*;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.item.DoubleHighBlockItem;
 import net.minecraft.world.item.ItemStack;
@@ -21,30 +15,23 @@ import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.GameMasterBlock;
-import net.minecraft.world.level.block.TrapDoorBlock;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
-import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import java.util.ArrayList;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.CakeBlock;
-import net.minecraft.world.level.block.DoorBlock;
 import org.bukkit.GameMode;
 import org.bukkit.craftbukkit.block.CraftBlock;
-import org.bukkit.event.block.BlockBreakEvent;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
+import org.bukkit.event.block.BlockBreakEvent;
 import org.bukkit.event.player.PlayerGameModeChangeEvent;
 import org.bukkit.event.player.PlayerInteractEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.Objects;
 // CraftBukkit end
 
 public class ServerPlayerGameMode {
@@ -80,6 +67,7 @@ public class ServerPlayerGameMode {
         PlayerGameModeChangeEvent event = this.changeGameModeForPlayer(gameMode, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause.UNKNOWN, null);
         return event != null && event.isCancelled();
     }
+
     @Nullable
     public PlayerGameModeChangeEvent changeGameModeForPlayer(GameType gameMode, org.bukkit.event.player.PlayerGameModeChangeEvent.Cause cause, @Nullable net.kyori.adventure.text.Component cancelMessage) {
         // Paper end - Expand PlayerGameModeChangeEvent
@@ -129,7 +117,7 @@ public class ServerPlayerGameMode {
     }
 
     public void tick() {
-        this.gameTicks = (int)this.level.getLagCompensationTick(); // CraftBukkit; // Paper - lag compensation
+        this.gameTicks = (int) this.level.getLagCompensationTick(); // CraftBukkit; // Paper - lag compensation
         BlockState iblockdata;
 
         if (this.hasDelayedDestroy) {
@@ -176,7 +164,8 @@ public class ServerPlayerGameMode {
         return f;
     }
 
-    private void debugLogging(BlockPos pos, boolean success, int sequence, String reason) {}
+    private void debugLogging(BlockPos pos, boolean success, int sequence, String reason) {
+    }
 
     public void handleBlockBreakAction(BlockPos pos, ServerboundPlayerActionPacket.Action action, Direction direction, int worldHeight, int sequence) {
         if (!this.player.canInteractWithBlock(pos, 1.0D)) {
@@ -398,14 +387,17 @@ public class ServerPlayerGameMode {
 
                 // Update any tile entity data for this block
                 if (!captureSentBlockEntities) { // Paper - Send block entities after destroy prediction
-                BlockEntity tileentity = this.level.getBlockEntity(pos);
-                if (tileentity != null) {
-                    this.player.connection.send(tileentity.getUpdatePacket());
-                }
-                } else {capturedBlockEntity = true;} // Paper - Send block entities after destroy prediction
+                    BlockEntity tileentity = this.level.getBlockEntity(pos);
+                    if (tileentity != null) {
+                        this.player.connection.send(tileentity.getUpdatePacket());
+                    }
+                } else {
+                    capturedBlockEntity = true;
+                } // Paper - Send block entities after destroy prediction
                 return false;
             }
-            if (this.player.level().purpurConfig.slabHalfBreak && this.player.isShiftKeyDown() && iblockdata.getBlock() instanceof net.minecraft.world.level.block.SlabBlock && ((net.minecraft.world.level.block.SlabBlock) iblockdata.getBlock()).halfBreak(iblockdata, pos, this.player)) return true; // Purpur
+            if (this.player.level().purpurConfig.slabHalfBreak && this.player.isShiftKeyDown() && iblockdata.getBlock() instanceof net.minecraft.world.level.block.SlabBlock && ((net.minecraft.world.level.block.SlabBlock) iblockdata.getBlock()).halfBreak(iblockdata, pos, this.player))
+                return true; // Purpur
         }
         // CraftBukkit end
 
@@ -425,7 +417,7 @@ public class ServerPlayerGameMode {
             } else {
                 // CraftBukkit start
                 org.bukkit.block.BlockState state = bblock.getState();
-                this.level.captureDrops = new ArrayList<>();
+                this.level.captureDrops = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 // CraftBukkit end
                 BlockState iblockdata1 = block.playerWillDestroy(this.level, pos, iblockdata, this.player);
                 boolean flag = this.level.removeBlock(pos, false);
@@ -517,6 +509,7 @@ public class ServerPlayerGameMode {
     public BlockPos interactPosition;
     public InteractionHand interactHand;
     public ItemStack interactItemStack;
+
     public InteractionResult useItemOn(ServerPlayer player, Level world, ItemStack stack, InteractionHand hand, BlockHitResult hitResult) {
         if (shiftClickMended(stack)) return InteractionResult.SUCCESS; // Purpur
         BlockPos blockposition = hitResult.getBlockPos();
@@ -557,7 +550,7 @@ public class ServerPlayerGameMode {
 
                 // send a correcting update to the client for the block above as well, this because of replaceable blocks (such as grass, sea grass etc)
                 //player.connection.send(new ClientboundBlockUpdatePacket(world, blockposition.above())); // Paper - Don't resync blocks
-            // Paper start - extend Player Interact cancellation // TODO: consider merging this into the extracted method
+                // Paper start - extend Player Interact cancellation // TODO: consider merging this into the extracted method
             } else if (iblockdata.is(Blocks.JIGSAW) || iblockdata.is(Blocks.STRUCTURE_BLOCK) || iblockdata.getBlock() instanceof net.minecraft.world.level.block.CommandBlock) {
                 player.connection.send(new net.minecraft.network.protocol.game.ClientboundContainerClosePacket(this.player.containerMenu.containerId));
             }
diff --git a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
index 3a9e25b436f366fffe08c3b0c1fce11ed42ee646..a4b6e6dfe303b3d0a8535996f47cd3967b18ae12 100644
--- a/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
+++ b/src/main/java/net/minecraft/server/network/ServerConnectionListener.java
@@ -1,40 +1,21 @@
 package net.minecraft.server.network;
 
 import com.google.common.base.Suppliers;
-import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.logging.LogUtils;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.EventLoopGroup;
+import io.netty.channel.*;
 import io.netty.channel.epoll.Epoll;
 import io.netty.channel.epoll.EpollEventLoopGroup;
 import io.netty.channel.epoll.EpollServerSocketChannel;
 import io.netty.channel.local.LocalAddress;
 import io.netty.channel.local.LocalServerChannel;
 import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.ServerSocketChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
 import io.netty.handler.timeout.ReadTimeoutHandler;
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timeout;
 import io.netty.util.Timer;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.SocketAddress;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.network.BandwidthDebugMonitor;
@@ -48,6 +29,16 @@ import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
 import net.minecraft.server.MinecraftServer;
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.SocketAddress;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+
 public class ServerConnectionListener {
 
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -59,12 +50,13 @@ public class ServerConnectionListener {
     });
     final MinecraftServer server;
     public volatile boolean running;
-    private final List<ChannelFuture> channels = Collections.synchronizedList(Lists.newArrayList());
-    final List<Connection> connections = Collections.synchronizedList(Lists.newArrayList());
+    private final List<ChannelFuture> channels = Collections.synchronizedList(new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
+    final List<Connection> connections = Collections.synchronizedList(new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
     // Paper start - prevent blocking on adding a new connection while the server is ticking
     private final java.util.Queue<Connection> pending = new java.util.concurrent.ConcurrentLinkedQueue<>();
     private static final boolean disableFlushConsolidation = Boolean.getBoolean("Paper.disableFlushConsolidate"); // Paper - Optimize network
-    private final void addPending() {
+
+    private void addPending() {
         Connection connection;
         while ((connection = pending.poll()) != null) {
             connections.add(connection);
@@ -82,8 +74,9 @@ public class ServerConnectionListener {
     public void startTcpServerListener(@Nullable InetAddress address, int port) throws IOException {
         bind(new java.net.InetSocketAddress(address, port));
     }
+
     public void bind(java.net.SocketAddress address) throws IOException {
-    // Paper end - Unix domain socket support
+        // Paper end - Unix domain socket support
         List list = this.channels;
 
         synchronized (this.channels) {
@@ -95,7 +88,7 @@ public class ServerConnectionListener {
                 if (address instanceof io.netty.channel.unix.DomainSocketAddress) {
                     oclass = io.netty.channel.epoll.EpollServerDomainSocketChannel.class;
                 } else {
-                oclass = EpollServerSocketChannel.class;
+                    oclass = EpollServerSocketChannel.class;
                 }
                 // Paper end - Unix domain socket support
                 eventloopgroup = (EventLoopGroup) ServerConnectionListener.SERVER_EPOLL_EVENT_GROUP.get();
@@ -118,14 +111,15 @@ public class ServerConnectionListener {
             // Paper end - Use Velocity cipher
 
             this.channels.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(oclass)).childHandler(new ChannelInitializer<Channel>() {
+                @Override
                 protected void initChannel(Channel channel) {
                     try {
                         channel.config().setOption(ChannelOption.TCP_NODELAY, true);
                     } catch (ChannelException channelexception) {
-                        ;
                     }
 
-                    if (!disableFlushConsolidation) channel.pipeline().addFirst(new io.netty.handler.flush.FlushConsolidationHandler()); // Paper - Optimize network
+                    if (!disableFlushConsolidation)
+                        channel.pipeline().addFirst(new io.netty.handler.flush.FlushConsolidationHandler()); // Paper - Optimize network
                     ChannelPipeline channelpipeline = channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30));
 
                     if (ServerConnectionListener.this.server.repliesToStatus()) {
@@ -192,6 +186,7 @@ public class ServerConnectionListener {
 
         synchronized (this.channels) {
             channelfuture = ((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(LocalServerChannel.class)).childHandler(new ChannelInitializer<Channel>() {
+                @Override
                 protected void initChannel(Channel channel) {
                     Connection networkmanager = new Connection(PacketFlow.SERVERBOUND);
 
@@ -232,9 +227,8 @@ public class ServerConnectionListener {
             // Spigot Start
             this.addPending(); // Paper - prevent blocking on adding a new connection while the server is ticking
             // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
-            if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
-            {
-                Collections.shuffle( this.connections );
+            if (org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0) {
+                Collections.shuffle(this.connections);
             }
             // Spigot End
             Iterator<Connection> iterator = this.connections.iterator();
@@ -286,13 +280,14 @@ public class ServerConnectionListener {
         private static final Timer TIMER = new HashedWheelTimer();
         private final int delay;
         private final int jitter;
-        private final List<ServerConnectionListener.LatencySimulator.DelayedMessage> queuedMessages = Lists.newArrayList();
+        private final List<ServerConnectionListener.LatencySimulator.DelayedMessage> queuedMessages = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         public LatencySimulator(int baseDelay, int extraDelay) {
             this.delay = baseDelay;
             this.jitter = extraDelay;
         }
 
+        @Override
         public void channelRead(ChannelHandlerContext channelhandlercontext, Object object) {
             this.delayDownstream(channelhandlercontext, object);
         }
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index e0962547709d6951cc98da94f028bd4d5b7b25dd..43cdbc152f1435bea7d9caeabc0c26237a17a63b 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1,34 +1,18 @@
 package net.minecraft.server.network;
 
-import com.google.common.collect.Lists;
 import com.google.common.primitives.Floats;
 import com.mojang.authlib.GameProfile;
 import com.mojang.brigadier.ParseResults;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.adventure.ChatProcessor;
+import io.papermc.paper.adventure.PaperAdventure;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import java.net.SocketAddress;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CompletableFuture;
-import java.util.function.BiFunction;
-import java.util.function.Consumer;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.Util;
 import net.minecraft.advancements.AdvancementHolder;
@@ -45,88 +29,12 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.Connection;
 import net.minecraft.network.DisconnectionDetails;
 import net.minecraft.network.TickablePacketListener;
-import net.minecraft.network.chat.ChatDecorator;
-import net.minecraft.network.chat.ChatType;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.LastSeenMessages;
-import net.minecraft.network.chat.LastSeenMessagesValidator;
-import net.minecraft.network.chat.MessageSignature;
-import net.minecraft.network.chat.MessageSignatureCache;
-import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.network.chat.PlayerChatMessage;
-import net.minecraft.network.chat.RemoteChatSession;
-import net.minecraft.network.chat.SignableCommand;
-import net.minecraft.network.chat.SignedMessageBody;
-import net.minecraft.network.chat.SignedMessageChain;
+import net.minecraft.network.chat.*;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketUtils;
 import net.minecraft.network.protocol.common.ServerboundClientInformationPacket;
-import net.minecraft.network.protocol.common.ServerboundCustomPayloadPacket;
 import net.minecraft.network.protocol.configuration.ConfigurationProtocols;
-import net.minecraft.network.protocol.game.ClientboundBlockChangedAckPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundCommandSuggestionsPacket;
-import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
-import net.minecraft.network.protocol.game.ClientboundDisguisedChatPacket;
-import net.minecraft.network.protocol.game.ClientboundMoveVehiclePacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerChatPacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerPositionPacket;
-import net.minecraft.network.protocol.game.ClientboundSetCarriedItemPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
-import net.minecraft.network.protocol.game.ClientboundStartConfigurationPacket;
-import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
-import net.minecraft.network.protocol.game.ClientboundTagQueryPacket;
-import net.minecraft.network.protocol.game.ServerGamePacketListener;
-import net.minecraft.network.protocol.game.ServerboundAcceptTeleportationPacket;
-import net.minecraft.network.protocol.game.ServerboundBlockEntityTagQueryPacket;
-import net.minecraft.network.protocol.game.ServerboundChangeDifficultyPacket;
-import net.minecraft.network.protocol.game.ServerboundChatAckPacket;
-import net.minecraft.network.protocol.game.ServerboundChatCommandPacket;
-import net.minecraft.network.protocol.game.ServerboundChatCommandSignedPacket;
-import net.minecraft.network.protocol.game.ServerboundChatPacket;
-import net.minecraft.network.protocol.game.ServerboundChatSessionUpdatePacket;
-import net.minecraft.network.protocol.game.ServerboundChunkBatchReceivedPacket;
-import net.minecraft.network.protocol.game.ServerboundClientCommandPacket;
-import net.minecraft.network.protocol.game.ServerboundCommandSuggestionPacket;
-import net.minecraft.network.protocol.game.ServerboundConfigurationAcknowledgedPacket;
-import net.minecraft.network.protocol.game.ServerboundContainerButtonClickPacket;
-import net.minecraft.network.protocol.game.ServerboundContainerClickPacket;
-import net.minecraft.network.protocol.game.ServerboundContainerClosePacket;
-import net.minecraft.network.protocol.game.ServerboundContainerSlotStateChangedPacket;
-import net.minecraft.network.protocol.game.ServerboundDebugSampleSubscriptionPacket;
-import net.minecraft.network.protocol.game.ServerboundEditBookPacket;
-import net.minecraft.network.protocol.game.ServerboundEntityTagQueryPacket;
-import net.minecraft.network.protocol.game.ServerboundInteractPacket;
-import net.minecraft.network.protocol.game.ServerboundJigsawGeneratePacket;
-import net.minecraft.network.protocol.game.ServerboundLockDifficultyPacket;
-import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket;
-import net.minecraft.network.protocol.game.ServerboundMoveVehiclePacket;
-import net.minecraft.network.protocol.game.ServerboundPaddleBoatPacket;
-import net.minecraft.network.protocol.game.ServerboundPickItemPacket;
-import net.minecraft.network.protocol.game.ServerboundPlaceRecipePacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerAbilitiesPacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerActionPacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerCommandPacket;
-import net.minecraft.network.protocol.game.ServerboundPlayerInputPacket;
-import net.minecraft.network.protocol.game.ServerboundRecipeBookChangeSettingsPacket;
-import net.minecraft.network.protocol.game.ServerboundRecipeBookSeenRecipePacket;
-import net.minecraft.network.protocol.game.ServerboundRenameItemPacket;
-import net.minecraft.network.protocol.game.ServerboundSeenAdvancementsPacket;
-import net.minecraft.network.protocol.game.ServerboundSelectTradePacket;
-import net.minecraft.network.protocol.game.ServerboundSetBeaconPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCommandBlockPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCommandMinecartPacket;
-import net.minecraft.network.protocol.game.ServerboundSetCreativeModeSlotPacket;
-import net.minecraft.network.protocol.game.ServerboundSetJigsawBlockPacket;
-import net.minecraft.network.protocol.game.ServerboundSetStructureBlockPacket;
-import net.minecraft.network.protocol.game.ServerboundSignUpdatePacket;
-import net.minecraft.network.protocol.game.ServerboundSwingPacket;
-import net.minecraft.network.protocol.game.ServerboundTeleportToEntityPacket;
-import net.minecraft.network.protocol.game.ServerboundUseItemOnPacket;
-import net.minecraft.network.protocol.game.ServerboundUseItemPacket;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.network.protocol.ping.ClientboundPongResponsePacket;
 import net.minecraft.network.protocol.ping.ServerboundPingRequestPacket;
 import net.minecraft.resources.ResourceKey;
@@ -143,48 +51,25 @@ import net.minecraft.world.Container;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.effect.MobEffects;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.ExperienceOrb;
-import net.minecraft.world.entity.HasCustomInventoryScreen;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MoverType;
-import net.minecraft.world.entity.PlayerRideableJumping;
-import net.minecraft.world.entity.RelativeMovement;
+import net.minecraft.world.entity.*;
+import net.minecraft.world.entity.animal.Bucketable;
+import net.minecraft.world.entity.animal.allay.Allay;
+import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.ChatVisiblity;
 import net.minecraft.world.entity.player.Inventory;
 import net.minecraft.world.entity.player.ProfilePublicKey;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.entity.vehicle.Boat;
-import net.minecraft.world.inventory.AbstractContainerMenu;
-import net.minecraft.world.inventory.AnvilMenu;
-import net.minecraft.world.inventory.BeaconMenu;
-import net.minecraft.world.inventory.CrafterMenu;
-import net.minecraft.world.inventory.MerchantMenu;
-import net.minecraft.world.inventory.RecipeBookMenu;
-import net.minecraft.world.item.BlockItem;
-import net.minecraft.world.item.BucketItem;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
+import net.minecraft.world.inventory.*;
+import net.minecraft.world.item.*;
 import net.minecraft.world.item.component.CustomData;
 import net.minecraft.world.item.component.WritableBookContent;
 import net.minecraft.world.item.component.WrittenBookContent;
-import net.minecraft.world.level.BaseCommandBlock;
-import net.minecraft.world.level.ClipContext;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.GameType;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.LevelReader;
+import net.minecraft.world.item.crafting.RecipeHolder;
+import net.minecraft.world.level.*;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.CommandBlock;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.entity.CommandBlockEntity;
-import net.minecraft.world.level.block.entity.CrafterBlockEntity;
-import net.minecraft.world.level.block.entity.JigsawBlockEntity;
-import net.minecraft.world.level.block.entity.SignBlockEntity;
-import net.minecraft.world.level.block.entity.StructureBlockEntity;
-import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.entity.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
@@ -193,29 +78,12 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import io.papermc.paper.adventure.ChatProcessor; // Paper
-import io.papermc.paper.adventure.PaperAdventure; // Paper
-import com.mojang.datafixers.util.Pair;
-import java.util.Arrays;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Function;
-import net.minecraft.network.chat.OutgoingChatMessage;
-import net.minecraft.world.entity.animal.Bucketable;
-import net.minecraft.world.entity.animal.allay.Allay;
-import net.minecraft.world.entity.item.ItemEntity;
-import net.minecraft.world.inventory.Slot;
-import net.minecraft.world.item.crafting.RecipeHolder;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.inventory.CraftItemType;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.craftbukkit.util.LazyPlayerSet;
 import org.bukkit.craftbukkit.util.Waitable;
@@ -223,31 +91,28 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
 import org.bukkit.event.inventory.ClickType;
-import org.bukkit.event.inventory.CraftItemEvent;
-import org.bukkit.event.inventory.InventoryAction;
-import org.bukkit.event.inventory.InventoryClickEvent;
-import org.bukkit.event.inventory.InventoryCreativeEvent;
+import org.bukkit.event.inventory.*;
 import org.bukkit.event.inventory.InventoryType.SlotType;
-import org.bukkit.event.inventory.SmithItemEvent;
-import org.bukkit.event.player.AsyncPlayerChatEvent;
-import org.bukkit.event.player.PlayerAnimationEvent;
-import org.bukkit.event.player.PlayerAnimationType;
-import org.bukkit.event.player.PlayerChatEvent;
-import org.bukkit.event.player.PlayerCommandPreprocessEvent;
-import org.bukkit.event.player.PlayerInteractAtEntityEvent;
-import org.bukkit.event.player.PlayerInteractEntityEvent;
-import org.bukkit.event.player.PlayerItemHeldEvent;
-import org.bukkit.event.player.PlayerMoveEvent;
+import org.bukkit.event.player.*;
 import org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;
-import org.bukkit.event.player.PlayerSwapHandItemsEvent;
-import org.bukkit.event.player.PlayerTeleportEvent;
-import org.bukkit.event.player.PlayerToggleFlightEvent;
-import org.bukkit.event.player.PlayerToggleSneakEvent;
-import org.bukkit.event.player.PlayerToggleSprintEvent;
 import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.net.SocketAddress;
+import java.util.*;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl implements ServerGamePacketListener, ServerPlayerConnection, TickablePacketListener {
@@ -266,7 +131,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // CraftBukkit start - multithreaded fields
     private final AtomicInteger chatSpamTickCount = new AtomicInteger();
     private final java.util.concurrent.atomic.AtomicInteger tabSpamLimiter = new java.util.concurrent.atomic.AtomicInteger(); // Paper - configurable tab spam limits
-    private final java.util.concurrent.atomic.AtomicInteger recipeSpamPackets =  new java.util.concurrent.atomic.AtomicInteger(); // Paper - auto recipe limit
+    private final java.util.concurrent.atomic.AtomicInteger recipeSpamPackets = new java.util.concurrent.atomic.AtomicInteger(); // Paper - auto recipe limit
     // CraftBukkit end
     private int dropSpamTickCount;
     private double firstGoodX;
@@ -321,7 +186,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     private int lastTick = MinecraftServer.currentTick;
     private int allowedPlayerTicks = 1;
     private int lastDropTick = MinecraftServer.currentTick;
-    private int lastBookTick  = MinecraftServer.currentTick;
+    private int lastBookTick = MinecraftServer.currentTick;
     private int dropCount = 0;
 
     private boolean hasMoved = false;
@@ -333,11 +198,11 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     private boolean justTeleported = false;
     // CraftBukkit end
 
-        // Purpur start
+    // Purpur start
     // Leaf start - Use caffeine cache kickPermission instead of using google.common.cache
     private final com.github.benmanes.caffeine.cache.LoadingCache<CraftPlayer, Boolean> kickPermissionCache = com.github.benmanes.caffeine.cache.Caffeine.newBuilder()
-        .maximumSize(1000)
-        .expireAfterWrite(1, java.util.concurrent.TimeUnit.MINUTES)
+            .maximumSize(1000)
+            .expireAfterWrite(1, java.util.concurrent.TimeUnit.MINUTES)
             .build(player -> player.hasPermission("purpur.bypassIdleKick"));
     // Leaf - Use caffeine cache kickPermission instead of using google.common.cache
     // Purpur end
@@ -396,7 +261,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
         this.keepConnectionAlive();
         // CraftBukkit start
-        for (int spam; (spam = this.chatSpamTickCount.get()) > 0 && !this.chatSpamTickCount.compareAndSet(spam, spam - 1); ) ;
+        for (int spam; (spam = this.chatSpamTickCount.get()) > 0 && !this.chatSpamTickCount.compareAndSet(spam, spam - 1); )
+            ;
         if (tabSpamLimiter.get() > 0) tabSpamLimiter.getAndDecrement(); // Paper - configurable tab spam limits
         if (recipeSpamPackets.get() > 0) recipeSpamPackets.getAndDecrement(); // Paper - auto recipe limit
         /* Use thread-safe field access instead
@@ -525,12 +391,18 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 float prevYaw = this.player.getYRot();
                 float prevPitch = this.player.getXRot();
                 // CraftBukkit end
-                double d0 = entity.getX();final double fromX = d0; // Paper - OBFHELPER
-                double d1 = entity.getY();final double fromY = d1; // Paper - OBFHELPER
-                double d2 = entity.getZ();final double fromZ = d2; // Paper - OBFHELPER
-                double d3 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX()); final double toX = d3; // Paper - OBFHELPER
-                double d4 = ServerGamePacketListenerImpl.clampVertical(packet.getY()); final double toY = d4; // Paper - OBFHELPER
-                double d5 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ()); final double toZ = d5; // Paper - OBFHELPER
+                double d0 = entity.getX();
+                final double fromX = d0; // Paper - OBFHELPER
+                double d1 = entity.getY();
+                final double fromY = d1; // Paper - OBFHELPER
+                double d2 = entity.getZ();
+                final double fromZ = d2; // Paper - OBFHELPER
+                double d3 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX());
+                final double toX = d3; // Paper - OBFHELPER
+                double d4 = ServerGamePacketListenerImpl.clampVertical(packet.getY());
+                final double toY = d4; // Paper - OBFHELPER
+                double d5 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ());
+                final double toZ = d5; // Paper - OBFHELPER
                 float f = Mth.wrapDegrees(packet.getYRot());
                 float f1 = Mth.wrapDegrees(packet.getXRot());
                 double d6 = d3 - this.vehicleFirstGoodX;
@@ -575,16 +447,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
                 // Paper start - Prevent moving into unloaded chunks
                 if (this.player.level().paperConfig().chunks.preventMovingIntoUnloadedChunks && (
-                    !worldserver.areChunksLoadedForMove(this.player.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(this.player.position()))) ||
-                        !worldserver.areChunksLoadedForMove(entity.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(entity.position())))
-                    )) {
+                        !worldserver.areChunksLoadedForMove(this.player.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(this.player.position()))) ||
+                                !worldserver.areChunksLoadedForMove(entity.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(entity.position())))
+                )) {
                     this.connection.send(new ClientboundMoveVehiclePacket(entity));
                     return;
                 }
                 // Paper end - Prevent moving into unloaded chunks
 
                 if (!org.dreeam.leaf.config.modules.gameplay.DisableMovedWronglyThreshold.enabled && d10 - d9 > Math.max(100.0D, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner()) { // Leaves - disable can
-                // CraftBukkit end
+                    // CraftBukkit end
                     ServerGamePacketListenerImpl.LOGGER.warn("{} (vehicle of {}) moved too quickly! {},{},{}", new Object[]{entity.getName().getString(), this.player.getName().getString(), d6, d7, d8});
                     this.send(new ClientboundMoveVehiclePacket(entity));
                     return;
@@ -676,7 +548,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                     this.lastYaw = to.getYaw();
                     this.lastPitch = to.getPitch();
 
-                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur
+                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch())
+                        this.player.resetLastActionTime(); // Purpur
 
                     Location oldTo = to.clone();
                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
@@ -805,7 +678,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     // Paper start - AsyncTabCompleteEvent
     private static final java.util.concurrent.ExecutorService TAB_COMPLETE_EXECUTOR = java.util.concurrent.Executors.newFixedThreadPool(4,
-        new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Tab Complete Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build());
+            new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Tab Complete Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build());
+
     // Paper end - AsyncTabCompleteEvent
     @Override
     public void handleCustomCommandSuggestions(ServerboundCommandSuggestionPacket packet) {
@@ -871,6 +745,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             // Paper end - Brigadier API
         }
     }
+
     // Paper start - brig API
     private static Suggestions limitTo(final Suggestions suggestions, final int size) {
         return suggestions.getList().size() <= size ? suggestions : new Suggestions(suggestions.getRange(), suggestions.getList().subList(0, size));
@@ -882,7 +757,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         ParseResults<CommandSourceStack> parseresults = this.server.getCommands().getDispatcher().parse(stringreader, this.player.createCommandSourceStack());
         // Paper start - Handle non-recoverable exceptions
         if (!parseresults.getExceptions().isEmpty()
-            && parseresults.getExceptions().values().stream().anyMatch(e -> e instanceof io.papermc.paper.brigadier.TagParseCommandSyntaxException)) {
+                && parseresults.getExceptions().values().stream().anyMatch(e -> e instanceof io.papermc.paper.brigadier.TagParseCommandSyntaxException)) {
             this.disconnect(Component.translatable("disconnect.spam"), org.bukkit.event.player.PlayerKickEvent.Cause.SPAM);
             return;
         }
@@ -1220,8 +1095,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
             if (byteTotal > byteAllowed) {
                 ServerGamePacketListenerImpl.LOGGER.warn("{} tried to send a book too large. Book size: {} - Allowed: {} - Pages: {}", this.player.getScoreboardName(), byteTotal, byteAllowed, pageList.size());
-                org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent event = new org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent(player.getBukkitEntity(), itemstack.asBukkitCopy()); if (event.shouldKickPlayer()) // Purpur
-                this.disconnectAsync(Component.literal("Book too large!"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause // Paper - add proper async disconnect
+                org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent event = new org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent(player.getBukkitEntity(), itemstack.asBukkitCopy());
+                if (event.shouldKickPlayer()) // Purpur
+                    this.disconnectAsync(Component.literal("Book too large!"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause // Paper - add proper async disconnect
                 return;
             }
         }
@@ -1236,7 +1112,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         int i = packet.slot();
 
         if (Inventory.isHotbarSlot(i) || i == 40) {
-            List<String> list = Lists.newArrayList();
+            List<String> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             Optional<String> optional = packet.title();
 
             Objects.requireNonNull(list);
@@ -1260,11 +1136,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     private void updateBookContents(List<FilteredText> pages, int slotId) {
-    // Purpur start
+        // Purpur start
         updateBookContents(pages, slotId, false);
     }
+
     private void updateBookContents(List<FilteredText> pages, int slotId, boolean hasPerm) {
-    // Purpur end
+        // Purpur end
         // CraftBukkit start
         ItemStack handItem = this.player.getInventory().getItem(slotId);
         ItemStack itemstack = handItem.copy();
@@ -1279,11 +1156,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     private void signBook(FilteredText title, List<FilteredText> pages, int slotId) {
-    // Purpur start
+        // Purpur start
         signBook(title, pages, slotId, false);
     }
+
     private void signBook(FilteredText title, List<FilteredText> pages, int slotId, boolean hasPerm) {
-    // Purpur end
+        // Purpur end
         ItemStack itemstack = this.player.getInventory().getItem(slotId);
 
         if (itemstack.is(Items.WRITABLE_BOOK)) {
@@ -1371,7 +1249,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         boolean invalidPitch = !Floats.isFinite(packet.getXRot(0.0F));
         if (invalidX || invalidY || invalidZ || invalidYaw || invalidPitch) {
             ServerGamePacketListenerImpl.LOGGER.warn(String.format("Disconnected on move player packet. Invalid data: x=%b, y=%b, z=%b, yaw=%b, pitch=%b", invalidX, invalidY, invalidZ, invalidYaw, invalidPitch)); // Purpur
-        // Purpur end
+            // Purpur end
             this.disconnect((Component) Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
         } else {
             ServerLevel worldserver = this.player.serverLevel();
@@ -1382,11 +1260,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 }
 
                 if (!this.updateAwaitingTeleport()) {
-                    double d0 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX(this.player.getX())); final double toX = d0; // Paper - OBFHELPER
-                    double d1 = ServerGamePacketListenerImpl.clampVertical(packet.getY(this.player.getY())); final double toY = d1; // Paper - OBFHELPER
-                    double d2 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ(this.player.getZ())); final double toZ = d2; // Paper - OBFHELPER
-                    float f = Mth.wrapDegrees(packet.getYRot(this.player.getYRot())); final float toYaw = f; // Paper - OBFHELPER
-                    float f1 = Mth.wrapDegrees(packet.getXRot(this.player.getXRot())); final float toPitch = f1; // Paper - OBFHELPER
+                    double d0 = ServerGamePacketListenerImpl.clampHorizontal(packet.getX(this.player.getX()));
+                    final double toX = d0; // Paper - OBFHELPER
+                    double d1 = ServerGamePacketListenerImpl.clampVertical(packet.getY(this.player.getY()));
+                    final double toY = d1; // Paper - OBFHELPER
+                    double d2 = ServerGamePacketListenerImpl.clampHorizontal(packet.getZ(this.player.getZ()));
+                    final double toZ = d2; // Paper - OBFHELPER
+                    float f = Mth.wrapDegrees(packet.getYRot(this.player.getYRot()));
+                    final float toYaw = f; // Paper - OBFHELPER
+                    float f1 = Mth.wrapDegrees(packet.getXRot(this.player.getXRot()));
+                    final float toPitch = f1; // Paper - OBFHELPER
 
                     if (this.player.isPassenger()) {
                         this.player.absMoveTo(this.player.getX(), this.player.getY(), this.player.getZ(), f, f1);
@@ -1455,7 +1338,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 if (this.player.level().paperConfig().chunks.preventMovingIntoUnloadedChunks && (this.player.getX() != toX || this.player.getZ() != toZ) && !worldserver.areChunksLoadedForMove(this.player.getBoundingBox().expandTowards(new Vec3(toX, toY, toZ).subtract(this.player.position())))) {
                                     // Paper start - Add fail move event
                                     io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.MOVED_INTO_UNLOADED_CHUNK,
-                                        toX, toY, toZ, toYaw, toPitch, false);
+                                            toX, toY, toZ, toYaw, toPitch, false);
                                     if (!event.isAllowed()) {
                                         this.internalTeleport(this.player.getX(), this.player.getY(), this.player.getZ(), this.player.getYRot(), this.player.getXRot(), Collections.emptySet());
                                         return;
@@ -1468,10 +1351,10 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                     float f2 = flag ? 300.0F : 100.0F;
 
                                     if (d10 - d9 > Math.max(f2, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && !this.isSingleplayerOwner()) {
-                                    // CraftBukkit end
+                                        // CraftBukkit end
                                         // Paper start - Add fail move event
                                         io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.MOVED_TOO_QUICKLY,
-                                            toX, toY, toZ, toYaw, toPitch, true);
+                                                toX, toY, toZ, toYaw, toPitch, true);
                                         if (!event.isAllowed()) {
                                             if (!org.dreeam.leaf.config.modules.gameplay.DisableMovedWronglyThreshold.enabled && event.getLogWarning()) // Leaves - disable can
                                                 ServerGamePacketListenerImpl.LOGGER.warn("{} moved too quickly! {},{},{}", new Object[]{this.player.getName().getString(), d6, d7, d8});
@@ -1546,12 +1429,12 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             if (!org.dreeam.leaf.config.modules.gameplay.DisableMovedWronglyThreshold.enabled && !this.player.isChangingDimension() && d10 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.gameMode.isCreative() && this.player.gameMode.getGameModeForPlayer() != GameType.SPECTATOR) { // Spigot // Leaves - disable can
                                 // Paper start - Add fail move event
                                 io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.MOVED_WRONGLY,
-                                    toX, toY, toZ, toYaw, toPitch, true);
+                                        toX, toY, toZ, toYaw, toPitch, true);
                                 if (!event.isAllowed()) {
                                     movedWrongly = true;
                                     if (event.getLogWarning())
-                                // Paper end
-                                ServerGamePacketListenerImpl.LOGGER.warn("{} moved wrongly!, ({})", this.player.getName().getString(), d11); // Purpur
+                                        // Paper end
+                                        ServerGamePacketListenerImpl.LOGGER.warn("{} moved wrongly!, ({})", this.player.getName().getString(), d11); // Purpur
                                 } // Paper
                             }
 
@@ -1569,13 +1452,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             // Paper end - optimise out extra getCubes
                             if (teleportBack) {
                                 io.papermc.paper.event.player.PlayerFailMoveEvent event = fireFailMove(io.papermc.paper.event.player.PlayerFailMoveEvent.FailReason.CLIPPED_INTO_BLOCK,
-                                    toX, toY, toZ, toYaw, toPitch, false);
+                                        toX, toY, toZ, toYaw, toPitch, false);
                                 if (event.isAllowed()) {
                                     teleportBack = false;
                                 }
                             }
                             if (teleportBack) {
-                            // Paper end - Add fail move event
+                                // Paper end - Add fail move event
                                 this.internalTeleport(d3, d4, d5, f, f1, Collections.emptySet()); // CraftBukkit - SPIGOT-1807: Don't call teleport event, when the client thinks the player is falling, because the chunks are not loaded on the client yet.
                                 this.player.doCheckFallDamage(this.player.getX() - d3, this.player.getY() - d4, this.player.getZ() - d5, packet.isOnGround());
                             } else {
@@ -1619,7 +1502,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                     this.lastYaw = to.getYaw();
                                     this.lastPitch = to.getPitch();
 
-                                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur
+                                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch())
+                                        this.player.resetLastActionTime(); // Purpur
 
                                     Location oldTo = to.clone();
                                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
@@ -1668,7 +1552,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                 // Purpur Start
                                 if (this.player.level().purpurConfig.dontRunWithScissors && this.player.isSprinting() && !(this.player.level().purpurConfig.ignoreScissorsInWater && this.player.isInWater()) && !(this.player.level().purpurConfig.ignoreScissorsInLava && this.player.isInLava()) && (isScissor(this.player.getItemInHand(InteractionHand.MAIN_HAND)) || isScissor(this.player.getItemInHand(InteractionHand.OFF_HAND))) && (int) (Math.random() * 10) == 0) {
                                     this.player.hurt(this.player.damageSources().scissors(), (float) this.player.level().purpurConfig.scissorsRunningDamage);
-                                    if (!org.purpurmc.purpur.PurpurConfig.dontRunWithScissors.isBlank()) this.player.sendActionBarMessage(org.purpurmc.purpur.PurpurConfig.dontRunWithScissors);
+                                    if (!org.purpurmc.purpur.PurpurConfig.dontRunWithScissors.isBlank())
+                                        this.player.sendActionBarMessage(org.purpurmc.purpur.PurpurConfig.dontRunWithScissors);
                                 }
                                 // Purpur End
 
@@ -1712,9 +1597,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         final List<AABB> collisionsBB = new java.util.ArrayList<>();
         final List<VoxelShape> collisionsVoxel = new java.util.ArrayList<>();
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisions(
-            world, entity, newBox, collisionsVoxel, collisionsBB,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_COLLIDE_WITH_UNLOADED_CHUNKS | ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
-            null, null
+                world, entity, newBox, collisionsVoxel, collisionsBB,
+                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_COLLIDE_WITH_UNLOADED_CHUNKS | ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
+                null, null
         );
 
         for (int i = 0, len = collisionsBB.size(); i < len; ++i) {
@@ -1733,6 +1618,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
         return false;
     }
+
     // Paper end - optimise out extra getCubes
     private boolean isPlayerCollidingWithAnythingNew(LevelReader world, AABB box, double newX, double newY, double newZ) {
         AABB axisalignedbb1 = this.player.getBoundingBox().move(newX - this.player.getX(), newY - this.player.getY(), newZ - this.player.getZ());
@@ -1815,7 +1701,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // Paper start - Prevent teleporting dead entities
         if (player.isRemoved()) {
             LOGGER.info("Attempt to teleport removed player {} restricted", player.getScoreboardName());
-            if (server.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Attempt to teleport removed player");
+            if (server.isDebugging())
+                io.papermc.paper.util.TraceUtil.dumpTraceForThread("Attempt to teleport removed player");
             return;
         }
         // Paper end - Prevent teleporting dead entities
@@ -1970,7 +1857,10 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     // Spigot start - limit place/interactions
     private int limitedPackets;
     private long lastLimitedPacket = -1;
-    private static int getSpamThreshold() { return io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.incomingPacketThreshold; } // Paper - Configurable threshold
+
+    private static int getSpamThreshold() {
+        return io.papermc.paper.configuration.GlobalConfiguration.get().spamLimiter.incomingPacketThreshold;
+    } // Paper - Configurable threshold
 
     private boolean checkLimit(long timestamp) {
         if (this.lastLimitedPacket != -1 && timestamp - this.lastLimitedPacket < getSpamThreshold() && this.limitedPackets++ >= 8) { // Paper - Configurable threshold; raise packet limit to 8
@@ -2036,7 +1926,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                             } else if (enuminteractionresult.shouldSwing() && !this.player.gameMode.interactResult) { // Paper - Call interact event
                                 this.player.swing(enumhand, true);
                             }
-                        } else { this.player.containerMenu.sendAllDataToRemote(); } // Paper - Fix inventory desync; MC-99075
+                        } else {
+                            this.player.containerMenu.sendAllDataToRemote();
+                        } // Paper - Fix inventory desync; MC-99075
                     } else {
                         MutableComponent ichatmutablecomponent1 = Component.translatable("build.tooHigh", i - 1).withStyle(ChatFormatting.RED);
 
@@ -2158,6 +2050,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // Paper start - Fix kick event leave message not being sent
         this.onDisconnect(info, null);
     }
+
     @Override
     public void onDisconnect(DisconnectionDetails info, @Nullable net.kyori.adventure.text.Component quitMessage) {
         // Paper end - Fix kick event leave message not being sent
@@ -2212,7 +2105,9 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
         if (this.player.isImmobile()) return; // CraftBukkit
         if (packet.getSlot() >= 0 && packet.getSlot() < Inventory.getSelectionSize()) {
-            if (packet.getSlot() == this.player.getInventory().selected) { return; } // Paper - don't fire itemheldevent when there wasn't a slot change
+            if (packet.getSlot() == this.player.getInventory().selected) {
+                return;
+            } // Paper - don't fire itemheldevent when there wasn't a slot change
             PlayerItemHeldEvent event = new PlayerItemHeldEvent(this.getCraftPlayer(), this.player.getInventory().selected, packet.getSlot());
             this.cserver.getPluginManager().callEvent(event);
             if (event.isCancelled()) {
@@ -2285,7 +2180,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // CraftBukkit start
         String command1 = "/" + command;
         if (org.spigotmc.SpigotConfig.logCommands) { // Paper - Add missing SpigotConfig logCommands check
-        ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command1);
+            ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command1);
         }
 
         // Leaf start - Improve Purpur AFK system
@@ -2353,7 +2248,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // CraftBukkit start
         String command = "/" + packet.command(); // Leaf start - Improve Purpur AFK system - diff on change
         if (org.spigotmc.SpigotConfig.logCommands) { // Paper - Add missing SpigotConfig logCommands check
-        ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command);
+            ServerGamePacketListenerImpl.LOGGER.info(this.player.getScoreboardName() + " issued server command: " + command);
         } // Paper - Add missing SpigotConfig logCommands check
 
         // Leaf start - Improve Purpur AFK system
@@ -2544,7 +2439,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             this.handleCommand(s);
         } else if (this.player.getChatVisibility() == ChatVisiblity.SYSTEM) {
             // Do nothing, this is coming from a plugin
-        // Paper start
+            // Paper start
         } else if (true) {
             if (!async && !org.bukkit.Bukkit.isPrimaryThread()) {
                 org.spigotmc.AsyncCatcher.catchOp("Asynchronous player chat is not allowed here");
@@ -2589,7 +2484,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                         ServerGamePacketListenerImpl.this.server.console.sendMessage(message);
 
                         return null;
-                    }};
+                    }
+                };
                 if (async) {
                     this.server.processQueue.add(waitable);
                 } else {
@@ -2654,7 +2550,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // CraftBukkit start
         String s = message.signedContent();
         if (s.isEmpty()) {
-            if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.chat.emptyMessageWarning) ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send an empty message"); // Gale - do not log empty message warnings
+            if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.chat.emptyMessageWarning)
+                ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send an empty message"); // Gale - do not log empty message warnings
         } else if (this.getCraftPlayer().isConversing()) {
             final String conversationInput = s;
             this.server.processQueue.add(new Runnable() {
@@ -2677,10 +2574,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     private void detectRateSpam(String s) {
         // CraftBukkit start - replaced with thread safe throttle
         boolean counted = true;
-        for ( String exclude : org.spigotmc.SpigotConfig.spamExclusions )
-        {
-            if ( exclude != null && s.startsWith( exclude ) )
-            {
+        for (String exclude : org.spigotmc.SpigotConfig.spamExclusions) {
+            if (exclude != null && s.startsWith(exclude)) {
                 counted = false;
                 break;
             }
@@ -2864,8 +2759,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // CraftBukkit end
         // Paper start - Ensure that client receives chat packets in the same order that we add into the message signature cache
         synchronized (this.messageSignatureCache) {
-        this.send(new ClientboundPlayerChatPacket(message.link().sender(), message.link().index(), message.signature(), message.signedBody().pack(this.messageSignatureCache), message.unsignedContent(), message.filterMask(), params));
-        this.addPendingMessage(message);
+            this.send(new ClientboundPlayerChatPacket(message.link().sender(), message.link().index(), message.signature(), message.signedBody().pack(this.messageSignatureCache), message.unsignedContent(), message.filterMask(), params));
+            this.addPendingMessage(message);
         }
         // Paper end - Ensure that client receives chat packets in the same order that we add into the message signature cache
     }
@@ -2879,8 +2774,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     }
 
     // Spigot Start
-    public SocketAddress getRawAddress()
-    {
+    public SocketAddress getRawAddress() {
         // Paper start - Unix domain socket support; this can be nullable in the case of a Unix domain socket, so if it is, fake something
         if (connection.channel.remoteAddress() == null) {
             return new java.net.InetSocketAddress(java.net.InetAddress.getLoopbackAddress(), 0);
@@ -2909,9 +2803,8 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         final ServerLevel worldserver = this.player.serverLevel();
         final Entity entity = packet.getTarget(worldserver);
         // Spigot Start
-        if ( entity == this.player && !this.player.isSpectator() )
-        {
-            this.disconnect( Component.literal( "Cannot interact with self!" ), org.bukkit.event.player.PlayerKickEvent.Cause.SELF_INTERACTION ); // Paper - kick event cause
+        if (entity == this.player && !this.player.isSpectator()) {
+            this.disconnect(Component.literal("Cannot interact with self!"), org.bukkit.event.player.PlayerKickEvent.Cause.SELF_INTERACTION); // Paper - kick event cause
             return;
         }
         // Spigot End
@@ -3091,6 +2984,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // Paper start - Inventory close reason
         this.handleContainerClose(packet, org.bukkit.event.inventory.InventoryCloseEvent.Reason.PLAYER);
     }
+
     public void handleContainerClose(ServerboundContainerClosePacket packet, org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
         // Paper end - Inventory close reason
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
@@ -3148,7 +3042,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                                     if (!this.player.containerMenu.getCarried().isEmpty()) {
                                         action = packet.getButtonNum() == 0 ? InventoryAction.DROP_ALL_CURSOR : InventoryAction.DROP_ONE_CURSOR;
                                     }
-                                } else if (packet.getSlotNum() < 0)  {
+                                } else if (packet.getSlotNum() < 0) {
                                     action = InventoryAction.NOTHING;
                                 } else {
                                     Slot slot = this.player.containerMenu.getSlot(packet.getSlotNum());
@@ -3471,7 +3365,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 ResourceLocation recipeName = packet.getRecipe();
                 boolean makeAll = packet.isShiftDown();
                 com.destroystokyo.paper.event.player.PlayerRecipeBookClickEvent paperEvent = new com.destroystokyo.paper.event.player.PlayerRecipeBookClickEvent(
-                    this.player.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(recipeName), makeAll
+                        this.player.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(recipeName), makeAll
                 );
                 if (!paperEvent.callEvent()) {
                     return;
@@ -3479,16 +3373,16 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 recipeName = CraftNamespacedKey.toMinecraft(paperEvent.getRecipe());
                 makeAll = paperEvent.isMakeAll();
                 if (org.bukkit.event.player.PlayerRecipeBookClickEvent.getHandlerList().getRegisteredListeners().length > 0) {
-                // Paper end - Add PlayerRecipeBookClickEvent
-                // CraftBukkit start - implement PlayerRecipeBookClickEvent
-                org.bukkit.inventory.Recipe recipe = this.cserver.getRecipe(CraftNamespacedKey.fromMinecraft(recipeName)); // Paper
-                if (recipe == null) {
-                    return;
-                }
-                // Paper start - Add PlayerRecipeBookClickEvent
-                org.bukkit.event.player.PlayerRecipeBookClickEvent event = CraftEventFactory.callRecipeBookClickEvent(this.player, recipe, makeAll);
-                recipeName = CraftNamespacedKey.toMinecraft(((org.bukkit.Keyed) event.getRecipe()).getKey());
-                makeAll = event.isShiftClick();
+                    // Paper end - Add PlayerRecipeBookClickEvent
+                    // CraftBukkit start - implement PlayerRecipeBookClickEvent
+                    org.bukkit.inventory.Recipe recipe = this.cserver.getRecipe(CraftNamespacedKey.fromMinecraft(recipeName)); // Paper
+                    if (recipe == null) {
+                        return;
+                    }
+                    // Paper start - Add PlayerRecipeBookClickEvent
+                    org.bukkit.event.player.PlayerRecipeBookClickEvent event = CraftEventFactory.callRecipeBookClickEvent(this.player, recipe, makeAll);
+                    recipeName = CraftNamespacedKey.toMinecraft(((org.bukkit.Keyed) event.getRecipe()).getKey());
+                    makeAll = event.isShiftClick();
                 }
                 if (!(this.player.containerMenu instanceof RecipeBookMenu<?, ?> recipeBookMenu)) {
                     return;
@@ -3579,19 +3473,19 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
                 itemstack = CraftItemStack.asNMSCopy(event.getCursor());
 
                 switch (event.getResult()) {
-                case ALLOW:
-                    // Plugin cleared the id / stacksize checks
-                    flag2 = true;
-                    break;
-                case DEFAULT:
-                    break;
-                case DENY:
-                    // Reset the slot
-                    if (packet.slotNum() >= 0) {
-                        this.player.connection.send(new ClientboundContainerSetSlotPacket(this.player.inventoryMenu.containerId, this.player.inventoryMenu.incrementStateId(), packet.slotNum(), this.player.inventoryMenu.getSlot(packet.slotNum()).getItem()));
-                        this.player.connection.send(new ClientboundContainerSetSlotPacket(-1, this.player.inventoryMenu.incrementStateId(), -1, ItemStack.EMPTY));
-                    }
-                    return;
+                    case ALLOW:
+                        // Plugin cleared the id / stacksize checks
+                        flag2 = true;
+                        break;
+                    case DEFAULT:
+                        break;
+                    case DENY:
+                        // Reset the slot
+                        if (packet.slotNum() >= 0) {
+                            this.player.connection.send(new ClientboundContainerSetSlotPacket(this.player.inventoryMenu.containerId, this.player.inventoryMenu.incrementStateId(), packet.slotNum(), this.player.inventoryMenu.getSlot(packet.slotNum()).getItem()));
+                            this.player.connection.send(new ClientboundContainerSetSlotPacket(-1, this.player.inventoryMenu.incrementStateId(), -1, ItemStack.EMPTY));
+                        }
+                        return;
                 }
             }
             // CraftBukkit end
@@ -3777,7 +3671,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         Location from = new Location(player.getWorld(), this.lastPosX, this.lastPosY, this.lastPosZ, this.lastYaw, this.lastPitch);
         Location to = new Location(player.getWorld(), toX, toY, toZ, toYaw, toPitch);
         io.papermc.paper.event.player.PlayerFailMoveEvent event = new io.papermc.paper.event.player.PlayerFailMoveEvent(player, failReason,
-            false, logWarning, from, to);
+                false, logWarning, from, to);
         event.callEvent();
         return event;
     }
diff --git a/src/main/java/net/minecraft/server/packs/resources/ReloadableResourceManager.java b/src/main/java/net/minecraft/server/packs/resources/ReloadableResourceManager.java
index 7b327b59374474f68b189cefbf97d4a4b4478472..50fd2421c4b6d0921cfaf0ea18c350f9d42e24ac 100644
--- a/src/main/java/net/minecraft/server/packs/resources/ReloadableResourceManager.java
+++ b/src/main/java/net/minecraft/server/packs/resources/ReloadableResourceManager.java
@@ -1,7 +1,12 @@
 package net.minecraft.server.packs.resources;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.packs.PackResources;
+import net.minecraft.server.packs.PackType;
+import net.minecraft.util.Unit;
+import org.slf4j.Logger;
+
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -11,16 +16,11 @@ import java.util.concurrent.Executor;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.packs.PackResources;
-import net.minecraft.server.packs.PackType;
-import net.minecraft.util.Unit;
-import org.slf4j.Logger;
 
 public class ReloadableResourceManager implements ResourceManager, AutoCloseable {
     private static final Logger LOGGER = LogUtils.getLogger();
     private CloseableResourceManager resources;
-    private final List<PreparableReloadListener> listeners = Lists.newArrayList();
+    private final List<PreparableReloadListener> listeners = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final PackType type;
 
     public ReloadableResourceManager(PackType type) {
diff --git a/src/main/java/net/minecraft/server/players/GameProfileCache.java b/src/main/java/net/minecraft/server/players/GameProfileCache.java
index 34b4166adfae8ff7d1eb73d56a72931b005330a7..3dd5dfed80cc7bdfff8bc70183fa75785e2c05e2 100644
--- a/src/main/java/net/minecraft/server/players/GameProfileCache.java
+++ b/src/main/java/net/minecraft/server/players/GameProfileCache.java
@@ -1,48 +1,30 @@
 package net.minecraft.server.players;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.io.Files;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
+import com.google.gson.*;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.ProfileLookupCallback;
 import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
+import net.minecraft.Util;
+import net.minecraft.core.UUIDUtil;
+import net.minecraft.util.StringUtil;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.io.*;
 import java.nio.charset.StandardCharsets;
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.UUID;
+import java.util.*;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.stream.Stream;
-import javax.annotation.Nullable;
-import net.minecraft.Util;
-import net.minecraft.core.UUIDUtil;
-import net.minecraft.util.StringUtil;
-import org.slf4j.Logger;
 
 public class GameProfileCache {
 
@@ -72,13 +54,16 @@ public class GameProfileCache {
     }
 
     private void safeAdd(GameProfileCache.GameProfileInfo entry) {
-        try { this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
-        GameProfile gameprofile = entry.getProfile();
+        try {
+            this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
+            GameProfile gameprofile = entry.getProfile();
 
-        entry.setLastAccess(this.getNextOperation());
-        this.profilesByName.put(gameprofile.getName().toLowerCase(Locale.ROOT), entry);
-        this.profilesByUUID.put(gameprofile.getId(), entry);
-        } finally { this.stateLock.unlock(); } // Paper - Fix GameProfileCache concurrency
+            entry.setLastAccess(this.getNextOperation());
+            this.profilesByName.put(gameprofile.getName().toLowerCase(Locale.ROOT), entry);
+            this.profilesByUUID.put(gameprofile.getId(), entry);
+        } finally {
+            this.stateLock.unlock();
+        } // Paper - Fix GameProfileCache concurrency
     }
 
     private static Optional<GameProfile> lookupGameProfile(GameProfileRepository repository, String name) {
@@ -87,18 +72,20 @@ public class GameProfileCache {
         } else {
             final AtomicReference<GameProfile> atomicreference = new AtomicReference();
             ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback() {
+                @Override
                 public void onProfileLookupSucceeded(GameProfile gameprofile) {
                     atomicreference.set(gameprofile);
                 }
 
+                @Override
                 public void onProfileLookupFailed(String s1, Exception exception) {
                     atomicreference.set(null); // CraftBukkit - decompile error
                 }
             };
 
-        if (!org.apache.commons.lang3.StringUtils.isBlank(name) // Paper - Don't lookup a profile with a blank name
-                && io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode()) // Paper - Add setting for proxy online mode status
-            repository.findProfilesByNames(new String[]{name}, profilelookupcallback);
+            if (!org.apache.commons.lang3.StringUtils.isBlank(name) // Paper - Don't lookup a profile with a blank name
+                    && io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode()) // Paper - Add setting for proxy online mode status
+                repository.findProfilesByNames(new String[]{name}, profilelookupcallback);
             GameProfile gameprofile = (GameProfile) atomicreference.get();
 
             return gameprofile != null ? Optional.of(gameprofile) : GameProfileCache.createUnknownProfile(name);
@@ -126,7 +113,8 @@ public class GameProfileCache {
         GameProfileCache.GameProfileInfo usercache_usercacheentry = new GameProfileCache.GameProfileInfo(profile, date);
 
         this.safeAdd(usercache_usercacheentry);
-        if( !org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly ) this.save(true); // Spigot - skip saving if disabled // Paper - Perf: Async GameProfileCache saving
+        if (!org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly)
+            this.save(true); // Spigot - skip saving if disabled // Paper - Perf: Async GameProfileCache saving
     }
 
     private long getNextOperation() {
@@ -135,53 +123,67 @@ public class GameProfileCache {
 
     // Paper start
     public @Nullable GameProfile getProfileIfCached(String name) {
-        try { this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
-        GameProfileCache.GameProfileInfo entry = this.profilesByName.get(name.toLowerCase(Locale.ROOT));
-        if (entry == null) {
-            return null;
-        }
-        entry.setLastAccess(this.getNextOperation());
-        return entry.getProfile();
-        } finally { this.stateLock.unlock(); } // Paper - Fix GameProfileCache concurrency
+        try {
+            this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
+            GameProfileCache.GameProfileInfo entry = this.profilesByName.get(name.toLowerCase(Locale.ROOT));
+            if (entry == null) {
+                return null;
+            }
+            entry.setLastAccess(this.getNextOperation());
+            return entry.getProfile();
+        } finally {
+            this.stateLock.unlock();
+        } // Paper - Fix GameProfileCache concurrency
     }
     // Paper end
 
     public Optional<GameProfile> get(String name) {
         String s1 = name.toLowerCase(Locale.ROOT);
-        boolean stateLocked = true; try { this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
-        GameProfileCache.GameProfileInfo usercache_usercacheentry = (GameProfileCache.GameProfileInfo) this.profilesByName.get(s1);
-        boolean flag = false;
-
-        if (usercache_usercacheentry != null && (new Date()).getTime() >= usercache_usercacheentry.expirationDate.getTime()) {
-            this.profilesByUUID.remove(usercache_usercacheentry.getProfile().getId());
-            this.profilesByName.remove(usercache_usercacheentry.getProfile().getName().toLowerCase(Locale.ROOT));
-            flag = true;
-            usercache_usercacheentry = null;
-        }
+        boolean stateLocked = true;
+        try {
+            this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
+            GameProfileCache.GameProfileInfo usercache_usercacheentry = (GameProfileCache.GameProfileInfo) this.profilesByName.get(s1);
+            boolean flag = false;
+
+            if (usercache_usercacheentry != null && (new Date()).getTime() >= usercache_usercacheentry.expirationDate.getTime()) {
+                this.profilesByUUID.remove(usercache_usercacheentry.getProfile().getId());
+                this.profilesByName.remove(usercache_usercacheentry.getProfile().getName().toLowerCase(Locale.ROOT));
+                flag = true;
+                usercache_usercacheentry = null;
+            }
 
-        Optional optional;
+            Optional optional;
 
-        if (usercache_usercacheentry != null) {
-            usercache_usercacheentry.setLastAccess(this.getNextOperation());
-            optional = Optional.of(usercache_usercacheentry.getProfile());
-            stateLocked = false; this.stateLock.unlock(); // Paper - Fix GameProfileCache concurrency
-        } else {
-            stateLocked = false; this.stateLock.unlock(); // Paper - Fix GameProfileCache concurrency
-            try { this.lookupLock.lock(); // Paper - Fix GameProfileCache concurrency
-            optional = GameProfileCache.lookupGameProfile(this.profileRepository, name); // CraftBukkit - use correct case for offline players
-            } finally { this.lookupLock.unlock(); } // Paper - Fix GameProfileCache concurrency
-            if (optional.isPresent()) {
-                this.add((GameProfile) optional.get());
-                flag = false;
+            if (usercache_usercacheentry != null) {
+                usercache_usercacheentry.setLastAccess(this.getNextOperation());
+                optional = Optional.of(usercache_usercacheentry.getProfile());
+                stateLocked = false;
+                this.stateLock.unlock(); // Paper - Fix GameProfileCache concurrency
+            } else {
+                stateLocked = false;
+                this.stateLock.unlock(); // Paper - Fix GameProfileCache concurrency
+                try {
+                    this.lookupLock.lock(); // Paper - Fix GameProfileCache concurrency
+                    optional = GameProfileCache.lookupGameProfile(this.profileRepository, name); // CraftBukkit - use correct case for offline players
+                } finally {
+                    this.lookupLock.unlock();
+                } // Paper - Fix GameProfileCache concurrency
+                if (optional.isPresent()) {
+                    this.add((GameProfile) optional.get());
+                    flag = false;
+                }
             }
-        }
 
-        if (flag && !org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) { // Spigot - skip saving if disabled
-            this.save(true); // Paper - Perf: Async GameProfileCache saving
-        }
+            if (flag && !org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) { // Spigot - skip saving if disabled
+                this.save(true); // Paper - Perf: Async GameProfileCache saving
+            }
 
-        return optional;
-        } finally { if (stateLocked) {  this.stateLock.unlock(); } } // Paper - Fix GameProfileCache concurrency
+            return optional;
+        } finally {
+            if (stateLocked) {
+                this.stateLock.unlock();
+            }
+        } // Paper - Fix GameProfileCache concurrency
     }
 
     public CompletableFuture<Optional<GameProfile>> getAsync(String username) {
@@ -206,16 +208,19 @@ public class GameProfileCache {
     }
 
     public Optional<GameProfile> get(UUID uuid) {
-        try { this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
-        GameProfileCache.GameProfileInfo usercache_usercacheentry = (GameProfileCache.GameProfileInfo) this.profilesByUUID.get(uuid);
+        try {
+            this.stateLock.lock(); // Paper - Fix GameProfileCache concurrency
+            GameProfileCache.GameProfileInfo usercache_usercacheentry = (GameProfileCache.GameProfileInfo) this.profilesByUUID.get(uuid);
 
-        if (usercache_usercacheentry == null) {
-            return Optional.empty();
-        } else {
-            usercache_usercacheentry.setLastAccess(this.getNextOperation());
-            return Optional.of(usercache_usercacheentry.getProfile());
-        }
-        } finally { this.stateLock.unlock(); } // Paper - Fix GameProfileCache concurrency
+            if (usercache_usercacheentry == null) {
+                return Optional.empty();
+            } else {
+                usercache_usercacheentry.setLastAccess(this.getNextOperation());
+                return Optional.of(usercache_usercacheentry.getProfile());
+            }
+        } finally {
+            this.stateLock.unlock();
+        } // Paper - Fix GameProfileCache concurrency
     }
 
     public void setExecutor(Executor executor) {
@@ -231,7 +236,7 @@ public class GameProfileCache {
     }
 
     public List<GameProfileCache.GameProfileInfo> load() {
-        List<GameProfileCache.GameProfileInfo> list = Lists.newArrayList();
+        List<GameProfileCache.GameProfileInfo> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         try {
             BufferedReader bufferedreader = Files.newReader(this.file, StandardCharsets.UTF_8);
@@ -279,12 +284,11 @@ public class GameProfileCache {
                 bufferedreader.close();
             }
         } catch (FileNotFoundException filenotfoundexception) {
-            ;
-        // Spigot Start
+            // Spigot Start
         } catch (com.google.gson.JsonSyntaxException | NullPointerException ex) {
-            GameProfileCache.LOGGER.warn( "Usercache.json is corrupted or has bad formatting. Deleting it to prevent further issues." );
+            GameProfileCache.LOGGER.warn("Usercache.json is corrupted or has bad formatting. Deleting it to prevent further issues.");
             this.file.delete();
-        // Spigot End
+            // Spigot End
         } catch (JsonParseException | IOException ioexception) {
             GameProfileCache.LOGGER.warn("Failed to load profile cache {}", this.file, ioexception);
         }
@@ -302,30 +306,29 @@ public class GameProfileCache {
         String s = this.gson.toJson(jsonarray);
         Runnable save = () -> { // Paper - Perf: Async GameProfileCache saving
 
-        try {
-            BufferedWriter bufferedwriter = Files.newWriter(this.file, StandardCharsets.UTF_8);
-
             try {
-                bufferedwriter.write(s);
-            } catch (Throwable throwable) {
-                if (bufferedwriter != null) {
-                    try {
-                        bufferedwriter.close();
-                    } catch (Throwable throwable1) {
-                        throwable.addSuppressed(throwable1);
+                BufferedWriter bufferedwriter = Files.newWriter(this.file, StandardCharsets.UTF_8);
+
+                try {
+                    bufferedwriter.write(s);
+                } catch (Throwable throwable) {
+                    if (bufferedwriter != null) {
+                        try {
+                            bufferedwriter.close();
+                        } catch (Throwable throwable1) {
+                            throwable.addSuppressed(throwable1);
+                        }
                     }
-                }
 
-                throw throwable;
-            }
+                    throw throwable;
+                }
 
-            if (bufferedwriter != null) {
-                bufferedwriter.close();
+                if (bufferedwriter != null) {
+                    bufferedwriter.close();
+                }
+            } catch (IOException ioexception) {
             }
-        } catch (IOException ioexception) {
-            ;
-        }
-        // Paper start - Perf: Async GameProfileCache saving
+            // Paper start - Perf: Async GameProfileCache saving
         };
         if (asyncSave) {
             io.papermc.paper.util.MCUtil.scheduleAsyncTask(save);
@@ -376,7 +379,6 @@ public class GameProfileCache {
                     try {
                         date = dateFormat.parse(jsonelement3.getAsString());
                     } catch (ParseException parseexception) {
-                        ;
                     }
                 }
 
diff --git a/src/main/java/net/minecraft/server/players/OldUsersConverter.java b/src/main/java/net/minecraft/server/players/OldUsersConverter.java
index 6416bc12f3d7733a4bd89d208a320f1b68983788..a9a8716d62e4d4f4ba4eaa463acc41852cd5f859 100644
--- a/src/main/java/net/minecraft/server/players/OldUsersConverter.java
+++ b/src/main/java/net/minecraft/server/players/OldUsersConverter.java
@@ -7,19 +7,6 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.ProfileLookupCallback;
 import com.mojang.authlib.yggdrasil.ProfileNotFoundException;
 import com.mojang.logging.LogUtils;
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.text.ParseException;
-import java.util.Collection;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Optional;
-import java.util.UUID;
-import javax.annotation.Nullable;
 import net.minecraft.core.UUIDUtil;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtAccounter;
@@ -30,6 +17,12 @@ import net.minecraft.util.StringUtil;
 import net.minecraft.world.level.storage.LevelResource;
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.*;
+
 public class OldUsersConverter {
 
     static final Logger LOGGER = LogUtils.getLogger();
@@ -38,7 +31,8 @@ public class OldUsersConverter {
     public static final File OLD_OPLIST = new File("ops.txt");
     public static final File OLD_WHITELIST = new File("white-list.txt");
 
-    public OldUsersConverter() {}
+    public OldUsersConverter() {
+    }
 
     static List<String> readOldListFormat(File file, Map<String, String[]> valueMap) throws IOException {
         List<String> list = Files.readLines(file, StandardCharsets.UTF_8);
@@ -66,7 +60,7 @@ public class OldUsersConverter {
         });
 
         if (server.usesAuthentication() ||
-            (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode())) { // Spigot: bungee = online mode, for now.  // Paper - Add setting for proxy online mode status
+                (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode())) { // Spigot: bungee = online mode, for now.  // Paper - Add setting for proxy online mode status
             server.getProfileRepository().findProfilesByNames(astring, callback);
         } else {
             String[] astring1 = astring;
@@ -98,6 +92,7 @@ public class OldUsersConverter {
 
                 OldUsersConverter.readOldListFormat(OldUsersConverter.OLD_USERBANLIST, map);
                 ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback() {
+                    @Override
                     public void onProfileLookupSucceeded(GameProfile gameprofile) {
                         server.getProfileCache().add(gameprofile);
                         String[] astring = (String[]) map.get(gameprofile.getName().toLowerCase(Locale.ROOT));
@@ -115,6 +110,7 @@ public class OldUsersConverter {
                         }
                     }
 
+                    @Override
                     public void onProfileLookupFailed(String s, Exception exception) {
                         OldUsersConverter.LOGGER.warn("Could not lookup user banlist entry for {}", s, exception);
                         if (!(exception instanceof ProfileNotFoundException)) {
@@ -195,11 +191,13 @@ public class OldUsersConverter {
             try {
                 List<String> list = Files.readLines(OldUsersConverter.OLD_OPLIST, StandardCharsets.UTF_8);
                 ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback() {
+                    @Override
                     public void onProfileLookupSucceeded(GameProfile gameprofile) {
                         server.getProfileCache().add(gameprofile);
                         oplist.add(new ServerOpListEntry(gameprofile, server.getOperatorUserPermissionLevel(), false));
                     }
 
+                    @Override
                     public void onProfileLookupFailed(String s, Exception exception) {
                         OldUsersConverter.LOGGER.warn("Could not lookup oplist entry for {}", s, exception);
                         if (!(exception instanceof ProfileNotFoundException)) {
@@ -239,11 +237,13 @@ public class OldUsersConverter {
             try {
                 List<String> list = Files.readLines(OldUsersConverter.OLD_WHITELIST, StandardCharsets.UTF_8);
                 ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback() {
+                    @Override
                     public void onProfileLookupSucceeded(GameProfile gameprofile) {
                         server.getProfileCache().add(gameprofile);
                         whitelist.add(new UserWhiteListEntry(gameprofile));
                     }
 
+                    @Override
                     public void onProfileLookupFailed(String s, Exception exception) {
                         OldUsersConverter.LOGGER.warn("Could not lookup user whitelist entry for {}", s, exception);
                         if (!(exception instanceof ProfileNotFoundException)) {
@@ -276,13 +276,15 @@ public class OldUsersConverter {
             if (optional.isPresent()) {
                 return (UUID) optional.get();
             } else if (!server.isSingleplayer() && server.usesAuthentication()) {
-                final List<GameProfile> list = Lists.newArrayList();
+                final List<GameProfile> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback() {
+                    @Override
                     public void onProfileLookupSucceeded(GameProfile gameprofile) {
                         server.getProfileCache().add(gameprofile);
                         list.add(gameprofile);
                     }
 
+                    @Override
                     public void onProfileLookupFailed(String s1, Exception exception) {
                         OldUsersConverter.LOGGER.warn("Could not lookup user whitelist entry for {}", s1, exception);
                     }
@@ -309,7 +311,7 @@ public class OldUsersConverter {
 
         if (file.exists() && file.isDirectory()) {
             File[] afile = file.listFiles();
-            List<String> list = Lists.newArrayList();
+            List<String> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             File[] afile1 = afile;
             int i = afile.length;
 
@@ -329,6 +331,7 @@ public class OldUsersConverter {
             try {
                 final String[] astring = (String[]) list.toArray(new String[list.size()]);
                 ProfileLookupCallback profilelookupcallback = new ProfileLookupCallback() {
+                    @Override
                     public void onProfileLookupSucceeded(GameProfile gameprofile) {
                         minecraftServer.getProfileCache().add(gameprofile);
                         UUID uuid = gameprofile.getId();
@@ -336,6 +339,7 @@ public class OldUsersConverter {
                         this.movePlayerFile(file1, this.getFileNameForProfile(gameprofile.getName()), uuid.toString());
                     }
 
+                    @Override
                     public void onProfileLookupFailed(String s2, Exception exception) {
                         OldUsersConverter.LOGGER.warn("Could not lookup user uuid for {}", s2, exception);
                         if (exception instanceof ProfileNotFoundException) {
@@ -380,7 +384,7 @@ public class OldUsersConverter {
                                 com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception);
                                 // Paper end
                             }
-                       }
+                        }
                         // CraftBukkit end
 
                         OldUsersConverter.ensureDirectoryExists(playerDataFolder);
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index de33245cda9beda04e1d75a0ab180cc788ddd789..7462147c4562eb482f7f4f6dc546a1e21e4ac260 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -846,7 +846,7 @@ public abstract class PlayerList {
 
         // Moved from processLogin
         UUID uuid = gameprofile.getId();
-        List<ServerPlayer> list = Lists.newArrayList();
+        List<ServerPlayer> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         ServerPlayer entityplayer;
 
@@ -1527,7 +1527,7 @@ public abstract class PlayerList {
     }
 
     public List<ServerPlayer> getPlayersWithAddress(String ip) {
-        List<ServerPlayer> list = Lists.newArrayList();
+        List<ServerPlayer> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/rcon/thread/RconThread.java b/src/main/java/net/minecraft/server/rcon/thread/RconThread.java
index c12d7db2b048a327c0e8f398848cd3a9bce0ebce..cbacec446f8e2a6e03cb7868f469f32fd55ea431 100644
--- a/src/main/java/net/minecraft/server/rcon/thread/RconThread.java
+++ b/src/main/java/net/minecraft/server/rcon/thread/RconThread.java
@@ -1,23 +1,23 @@
 package net.minecraft.server.rcon.thread;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
+import net.minecraft.server.ServerInterface;
+import net.minecraft.server.dedicated.DedicatedServerProperties;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
 import java.util.List;
-import javax.annotation.Nullable;
-import net.minecraft.server.ServerInterface;
-import net.minecraft.server.dedicated.DedicatedServerProperties;
-import org.slf4j.Logger;
 
 public class RconThread extends GenericThread {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final ServerSocket socket;
     private final String rconPassword;
-    private final List<RconClient> clients = Lists.newArrayList();
+    private final List<RconClient> clients = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final ServerInterface serverInterface;
 
     private RconThread(ServerInterface server, ServerSocket listener, String password) {
@@ -45,7 +45,7 @@ public class RconThread extends GenericThread {
                     this.clearClients();
                 } catch (IOException var8) {
                     if (this.running) {
-                        LOGGER.info("IO exception: ", (Throwable)var8);
+                        LOGGER.info("IO exception: ", (Throwable) var8);
                     }
                 }
             }
@@ -104,6 +104,7 @@ public class RconThread extends GenericThread {
 
         this.clients.clear();
     }
+
     // Paper start - don't wait for remote connections
     public void stopNonBlocking() {
         this.running = false;
@@ -119,7 +120,7 @@ public class RconThread extends GenericThread {
         try {
             socket.close();
         } catch (IOException var3) {
-            LOGGER.warn("Failed to close socket", (Throwable)var3);
+            LOGGER.warn("Failed to close socket", (Throwable) var3);
         }
     }
 }
diff --git a/src/main/java/net/minecraft/stats/ServerRecipeBook.java b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
index 2aaf3ba2c2d2d7cdf1848d6dc4d334dd77617907..e6e0ecb3b92423ca5641a13d9b8ae9ece7adab93 100644
--- a/src/main/java/net/minecraft/stats/ServerRecipeBook.java
+++ b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
@@ -1,13 +1,6 @@
 package net.minecraft.stats;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Optional;
-import java.util.function.Consumer;
 import net.minecraft.ResourceLocationException;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.nbt.CompoundTag;
@@ -18,19 +11,22 @@ import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.item.crafting.RecipeHolder;
 import net.minecraft.world.item.crafting.RecipeManager;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.slf4j.Logger;
 
-import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+import java.util.*;
+import java.util.function.Consumer;
 
 public class ServerRecipeBook extends RecipeBook {
 
     public static final String RECIPE_BOOK_TAG = "recipeBook";
     private static final Logger LOGGER = LogUtils.getLogger();
 
-    public ServerRecipeBook() {}
+    public ServerRecipeBook() {
+    }
 
     public int addRecipes(Collection<RecipeHolder<?>> recipes, ServerPlayer player) {
-        List<ResourceLocation> list = Lists.newArrayList();
+        List<ResourceLocation> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         int i = 0;
         Iterator iterator = recipes.iterator();
 
@@ -55,7 +51,7 @@ public class ServerRecipeBook extends RecipeBook {
     }
 
     public int removeRecipes(Collection<RecipeHolder<?>> recipes, ServerPlayer player) {
-        List<ResourceLocation> list = Lists.newArrayList();
+        List<ResourceLocation> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         int i = 0;
         Iterator iterator = recipes.iterator();
 
@@ -125,7 +121,8 @@ public class ServerRecipeBook extends RecipeBook {
                 Optional<RecipeHolder<?>> optional = recipeManager.byKey(minecraftkey);
 
                 if (optional.isEmpty()) {
-                    if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.unrecognizedRecipes) ServerRecipeBook.LOGGER.error("Tried to load unrecognized recipe: {} removed now.", minecraftkey); // Gale - Purpur - do not log unrecognized recipes
+                    if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.unrecognizedRecipes)
+                        ServerRecipeBook.LOGGER.error("Tried to load unrecognized recipe: {} removed now.", minecraftkey); // Gale - Purpur - do not log unrecognized recipes
                 } else {
                     handler.accept((RecipeHolder) optional.get());
                 }
diff --git a/src/main/java/net/minecraft/tags/TagLoader.java b/src/main/java/net/minecraft/tags/TagLoader.java
index 0bde4f7ae7d1897c630513261d1d5fb75a762634..5c8d84f35046fac04e1dec2ed9c4ffb1cf7e230f 100644
--- a/src/main/java/net/minecraft/tags/TagLoader.java
+++ b/src/main/java/net/minecraft/tags/TagLoader.java
@@ -1,26 +1,14 @@
 package net.minecraft.tags;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.common.collect.ImmutableSet.Builder;
+import com.google.common.collect.Maps;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
 import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.JsonOps;
-import java.io.Reader;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Map.Entry;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import net.minecraft.resources.FileToIdConverter;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.Resource;
@@ -28,6 +16,14 @@ import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.util.DependencySorter;
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+import java.io.Reader;
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
 public class TagLoader<T> {
     private static final Logger LOGGER = LogUtils.getLogger();
     final Function<ResourceLocation, Optional<? extends T>> idToValue;
@@ -49,7 +45,7 @@ public class TagLoader<T> {
             for (Resource resource : entry.getValue()) {
                 try (Reader reader = resource.openAsReader()) {
                     JsonElement jsonElement = JsonParser.parseReader(reader);
-                    List<TagLoader.EntryWithSource> list = map.computeIfAbsent(resourceLocation2, id -> new ArrayList<>());
+                    List<TagLoader.EntryWithSource> list = map.computeIfAbsent(resourceLocation2, id -> new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
                     TagFile tagFile = TagFile.CODEC.parse(new Dynamic<>(JsonOps.INSTANCE, jsonElement)).getOrThrow();
                     if (tagFile.replace()) {
                         list.clear();
@@ -68,7 +64,7 @@ public class TagLoader<T> {
 
     private Either<Collection<TagLoader.EntryWithSource>, Collection<T>> build(TagEntry.Lookup<T> valueGetter, List<TagLoader.EntryWithSource> entries) {
         Builder<T> builder = ImmutableSet.builder();
-        List<TagLoader.EntryWithSource> list = new ArrayList<>();
+        List<TagLoader.EntryWithSource> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (TagLoader.EntryWithSource entryWithSource : entries) {
             if (!entryWithSource.entry().build(valueGetter, builder::add)) {
@@ -88,7 +84,7 @@ public class TagLoader<T> {
             @Nullable
             @Override
             public T element(ResourceLocation id) {
-                return (T)TagLoader.this.idToValue.apply(id).orElse(null);
+                return (T) TagLoader.this.idToValue.apply(id).orElse(null);
             }
 
             @Nullable
@@ -98,17 +94,17 @@ public class TagLoader<T> {
             }
         };
         DependencySorter<ResourceLocation, TagLoader.SortingEntry> dependencySorter = new DependencySorter<>();
-        tags.forEach((id, entries) -> dependencySorter.addEntry(id, new TagLoader.SortingEntry((List<TagLoader.EntryWithSource>)entries)));
+        tags.forEach((id, entries) -> dependencySorter.addEntry(id, new TagLoader.SortingEntry((List<TagLoader.EntryWithSource>) entries)));
         dependencySorter.orderByDependencies(
-            (id, dependencies) -> this.build(lookup, dependencies.entries)
-                    .ifLeft(
-                        missingReferences -> LOGGER.error(
-                                "Couldn't load tag {} as it is missing following references: {}",
-                                id,
-                                missingReferences.stream().map(Objects::toString).collect(Collectors.joining(", "))
-                            )
-                    )
-                    .ifRight(resolvedEntries -> map.put(id, (Collection<T>)resolvedEntries))
+                (id, dependencies) -> this.build(lookup, dependencies.entries)
+                        .ifLeft(
+                                missingReferences -> LOGGER.error(
+                                        "Couldn't load tag {} as it is missing following references: {}",
+                                        id,
+                                        missingReferences.stream().map(Objects::toString).collect(Collectors.joining(", "))
+                                )
+                        )
+                        .ifRight(resolvedEntries -> map.put(id, (Collection<T>) resolvedEntries))
         );
         return io.papermc.paper.tag.PaperTagListenerManager.INSTANCE.firePostFlattenEvent(map, eventConfig); // Paper - fire tag registrar events
     }
@@ -126,7 +122,8 @@ public class TagLoader<T> {
         }
     }
 
-    static record SortingEntry(List<TagLoader.EntryWithSource> entries) implements DependencySorter.Entry<ResourceLocation> {
+    static record SortingEntry(
+            List<TagLoader.EntryWithSource> entries) implements DependencySorter.Entry<ResourceLocation> {
         @Override
         public void visitRequiredDependencies(Consumer<ResourceLocation> callback) {
             this.entries.forEach(entry -> entry.entry.visitRequiredDependencies(callback));
diff --git a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
index dc41c7c4616fa925427cd5a862f3923c5fa65902..613c5af14fd8d83ce90d59f5c192b3aa49951133 100644
--- a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
+++ b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
@@ -1,28 +1,11 @@
 package net.minecraft.util.worldupdate;
 
-import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Reference2FloatMap;
 import it.unimi.dsi.fastutil.objects.Reference2FloatMaps;
 import it.unimi.dsi.fastutil.objects.Reference2FloatOpenHashMap;
-import java.io.File;
-import java.io.IOException;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.ThreadFactory;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
@@ -38,17 +21,25 @@ import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.chunk.storage.ChunkStorage;
-import net.minecraft.world.level.chunk.storage.RecreatingChunkStorage;
-import net.minecraft.world.level.chunk.storage.RecreatingSimpleRegionStorage;
-import net.minecraft.world.level.chunk.storage.RegionFile;
-import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
-import net.minecraft.world.level.chunk.storage.SimpleRegionStorage;
+import net.minecraft.world.level.chunk.storage.*;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ThreadFactory;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
 public class WorldUpgrader {
 
     static final Logger LOGGER = LogUtils.getLogger();
@@ -102,7 +93,6 @@ public class WorldUpgrader {
         try {
             this.thread.join();
         } catch (InterruptedException interruptedexception) {
-            ;
         }
 
     }
@@ -194,6 +184,7 @@ public class WorldUpgrader {
             super(DataFixTypes.CHUNK, "chunk", "region", WorldUpgrader.STATUS_UPGRADING_CHUNKS, WorldUpgrader.STATUS_FINISHED_CHUNKS);
         }
 
+        @Override
         protected boolean tryProcessOnePosition(ChunkStorage storage, ChunkPos chunkPos, ResourceKey<Level> worldKey) {
             CompoundTag nbttagcompound = (CompoundTag) ((Optional) storage.read(chunkPos).join()).orElse((Object) null);
 
@@ -258,6 +249,7 @@ public class WorldUpgrader {
             return (SimpleRegionStorage) (WorldUpgrader.this.recreateRegionFiles ? new RecreatingSimpleRegionStorage(key.withTypeSuffix("source"), worldDirectory, key.withTypeSuffix("target"), WorldUpgrader.resolveRecreateDirectory(worldDirectory), WorldUpgrader.this.dataFixer, true, this.dataFixType) : new SimpleRegionStorage(key, worldDirectory, WorldUpgrader.this.dataFixer, true, this.dataFixType));
         }
 
+        @Override
         protected boolean tryProcessOnePosition(SimpleRegionStorage storage, ChunkPos chunkPos, ResourceKey<Level> worldKey) {
             CompoundTag nbttagcompound = (CompoundTag) ((Optional) storage.read(chunkPos).join()).orElse((Object) null);
 
@@ -370,7 +362,7 @@ public class WorldUpgrader {
         }
 
         private List<WorldUpgrader.DimensionToUpgrade<T>> getDimensionsToUpgrade() {
-            List<WorldUpgrader.DimensionToUpgrade<T>> list = Lists.newArrayList();
+            List<WorldUpgrader.DimensionToUpgrade<T>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             Iterator iterator = WorldUpgrader.this.levels.iterator();
 
             while (iterator.hasNext()) {
@@ -406,7 +398,7 @@ public class WorldUpgrader {
             if (afile == null) {
                 return List.of();
             } else {
-                List<WorldUpgrader.FileToUpgrade> list = Lists.newArrayList();
+                List<WorldUpgrader.FileToUpgrade> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 File[] afile1 = afile;
                 int i = afile.length;
 
@@ -417,7 +409,7 @@ public class WorldUpgrader {
                     if (matcher.matches()) {
                         int k = Integer.parseInt(matcher.group(1)) << 5;
                         int l = Integer.parseInt(matcher.group(2)) << 5;
-                        List<ChunkPos> list1 = Lists.newArrayList();
+                        List<ChunkPos> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
                         try {
                             org.stupidcraft.linearpaper.region.IRegionFile regionfile = org.stupidcraft.linearpaper.region.IRegionFileFactory.getAbstractRegionFile(key, file.toPath(), regionDirectory, true); // LinearPaper
@@ -508,11 +500,13 @@ public class WorldUpgrader {
         }
     }
 
-    static record FileToUpgrade(org.stupidcraft.linearpaper.region.IRegionFile file, List<ChunkPos> chunksToUpgrade) { // LinearPaper
+    static record FileToUpgrade(org.stupidcraft.linearpaper.region.IRegionFile file,
+                                List<ChunkPos> chunksToUpgrade) { // LinearPaper
 
     }
 
-    static record DimensionToUpgrade<T>(ResourceKey<Level> dimensionKey, T storage, ListIterator<WorldUpgrader.FileToUpgrade> files) {
+    static record DimensionToUpgrade<T>(ResourceKey<Level> dimensionKey, T storage,
+                                        ListIterator<WorldUpgrader.FileToUpgrade> files) {
 
     }
 }
diff --git a/src/main/java/net/minecraft/world/SimpleContainer.java b/src/main/java/net/minecraft/world/SimpleContainer.java
index d04bf7d06855022c973073fb84c5d3d65f2553e1..94140b5d38a7fff00044d4fb20554ea188112006 100644
--- a/src/main/java/net/minecraft/world/SimpleContainer.java
+++ b/src/main/java/net/minecraft/world/SimpleContainer.java
@@ -1,10 +1,5 @@
 package net.minecraft.world;
 
-import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import net.minecraft.core.HolderLookup;
 import net.minecraft.core.NonNullList;
 import net.minecraft.nbt.ListTag;
@@ -13,11 +8,14 @@ import net.minecraft.world.entity.player.StackedContents;
 import net.minecraft.world.inventory.StackedContentsCompatible;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
-
-// CraftBukkit start
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
+
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.stream.Collectors;
 // CraftBukkit end
 
 public class SimpleContainer implements Container, StackedContentsCompatible {
@@ -32,18 +30,22 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
     private int maxStack = MAX_STACK;
     protected @Nullable org.bukkit.inventory.InventoryHolder bukkitOwner; // Paper - annotation
 
+    @Override
     public List<ItemStack> getContents() {
         return this.items;
     }
 
+    @Override
     public void onOpen(CraftHumanEntity who) {
         this.transaction.add(who);
     }
 
+    @Override
     public void onClose(CraftHumanEntity who) {
         this.transaction.remove(who);
     }
 
+    @Override
     public List<HumanEntity> getViewers() {
         return this.transaction;
     }
@@ -53,10 +55,12 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
         return this.maxStack;
     }
 
+    @Override
     public void setMaxStackSize(int i) {
         this.maxStack = i;
     }
 
+    @Override
     public org.bukkit.inventory.InventoryHolder getOwner() {
         // Paper start - Add missing InventoryHolders
         if (this.bukkitOwner == null && this.bukkitOwnerCreator != null) {
@@ -91,8 +95,10 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
     public SimpleContainer(int size) {
         this(size, null);
     }
+
     // Paper start - Add missing InventoryHolders
     private @Nullable java.util.function.Supplier<? extends org.bukkit.inventory.InventoryHolder> bukkitOwnerCreator;
+
     public SimpleContainer(java.util.function.Supplier<? extends org.bukkit.inventory.InventoryHolder> bukkitOwnerCreator, int size) {
         this(size);
         this.bukkitOwnerCreator = bukkitOwnerCreator;
@@ -113,7 +119,7 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
 
     public void addListener(ContainerListener listener) {
         if (this.listeners == null) {
-            this.listeners = Lists.newArrayList();
+            this.listeners = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
 
         this.listeners.add(listener);
@@ -285,6 +291,7 @@ public class SimpleContainer implements Container, StackedContentsCompatible {
 
     }
 
+    @Override
     public String toString() {
         return ((List) this.items.stream().filter((itemstack) -> {
             return !itemstack.isEmpty();
diff --git a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
index 4fb025a63628eb60509d90b680922a0220104bcb..f78a4e39cc05da229343bcba3c2e82e55b95a873 100644
--- a/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
+++ b/src/main/java/net/minecraft/world/damagesource/CombatTracker.java
@@ -1,27 +1,23 @@
 package net.minecraft.world.damagesource;
 
-import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.Objects;
-import javax.annotation.Nullable;
 import net.minecraft.core.component.DataComponents;
-import net.minecraft.network.chat.ClickEvent;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.chat.HoverEvent;
-import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.*;
 import net.minecraft.tags.DamageTypeTags;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.item.ItemStack;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Objects;
+
 public class CombatTracker {
     public static final int RESET_DAMAGE_STATUS_TIME = 100;
     public static final int RESET_COMBAT_STATUS_TIME = 300;
     private static final Style INTENTIONAL_GAME_DESIGN_STYLE = Style.EMPTY
-        .withClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, "https://bugs.mojang.com/browse/MCPE-28723"))
-        .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.literal("MCPE-28723")));
-    private final List<CombatEntry> entries = Lists.newArrayList();
+            .withClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, "https://bugs.mojang.com/browse/MCPE-28723"))
+            .withHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, Component.literal("MCPE-28723")));
+    private final List<CombatEntry> entries = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final LivingEntity mob;
     private int lastDamageTime;
     private int combatStartTime;
@@ -55,8 +51,8 @@ public class CombatTracker {
     private Component getMessageForAssistedFall(Entity attacker, Component attackerDisplayName, String itemDeathTranslationKey, String deathTranslationKey) {
         ItemStack itemStack = attacker instanceof LivingEntity livingEntity ? livingEntity.getMainHandItem() : ItemStack.EMPTY;
         return !itemStack.isEmpty() && (org.purpurmc.purpur.PurpurConfig.playerDeathsAlwaysShowItem || itemStack.has(DataComponents.CUSTOM_NAME)) // Purpur
-            ? Component.translatable(itemDeathTranslationKey, this.mob.getDisplayName(), attackerDisplayName, itemStack.getDisplayName())
-            : Component.translatable(deathTranslationKey, this.mob.getDisplayName(), attackerDisplayName);
+                ? Component.translatable(itemDeathTranslationKey, this.mob.getDisplayName(), attackerDisplayName, itemStack.getDisplayName())
+                : Component.translatable(deathTranslationKey, this.mob.getDisplayName(), attackerDisplayName);
     }
 
     private Component getFallMessage(CombatEntry damageRecord, @Nullable Entity attacker) {
@@ -68,9 +64,9 @@ public class CombatTracker {
             if (component2 != null && !component2.equals(component)) {
                 return this.getMessageForAssistedFall(entity, component2, "death.fell.assist.item", "death.fell.assist");
             } else {
-                return (Component)(component != null
-                    ? this.getMessageForAssistedFall(attacker, component, "death.fell.finish.item", "death.fell.finish")
-                    : Component.translatable("death.fell.killer", this.mob.getDisplayName()));
+                return (Component) (component != null
+                        ? this.getMessageForAssistedFall(attacker, component, "death.fell.finish.item", "death.fell.finish")
+                        : Component.translatable("death.fell.killer", this.mob.getDisplayName()));
             }
         } else {
             FallLocation fallLocation = Objects.requireNonNullElse(damageRecord.fallLocation(), FallLocation.GENERIC);
diff --git a/src/main/java/net/minecraft/world/effect/OozingMobEffect.java b/src/main/java/net/minecraft/world/effect/OozingMobEffect.java
index 6d75c501551120a0d21a197fae213307ea6f4ca8..9b78cd57bb9d5ce3b42b9495dbaec594bc6b9c60 100644
--- a/src/main/java/net/minecraft/world/effect/OozingMobEffect.java
+++ b/src/main/java/net/minecraft/world/effect/OozingMobEffect.java
@@ -62,7 +62,7 @@ class OozingMobEffect extends MobEffect {
 
         static OozingMobEffect.NearbySlimes closeTo(LivingEntity entity) {
             return (i) -> {
-                List<Slime> list = new ArrayList();
+                List<Slime> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
                 entity.level().getEntities(EntityType.SLIME, entity.getBoundingBox().inflate(2.0D), (entityslime) -> {
                     return entityslime != entity;
diff --git a/src/main/java/net/minecraft/world/entity/AreaEffectCloud.java b/src/main/java/net/minecraft/world/entity/AreaEffectCloud.java
index 1859477e96709368683fe5707327e92f56fbfc8e..40ca561af943f5972d3c21ff8e1120ccfb87a778 100644
--- a/src/main/java/net/minecraft/world/entity/AreaEffectCloud.java
+++ b/src/main/java/net/minecraft/world/entity/AreaEffectCloud.java
@@ -1,15 +1,7 @@
 package net.minecraft.world.entity;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.logging.LogUtils;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.UUID;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.core.Holder;
 import net.minecraft.core.particles.ColorParticleOption;
 import net.minecraft.core.particles.ParticleOptions;
@@ -30,12 +22,14 @@ import net.minecraft.world.item.alchemy.Potion;
 import net.minecraft.world.item.alchemy.PotionContents;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.material.PushReaction;
-import org.slf4j.Logger;
-
-// CraftBukkit start
 import org.bukkit.craftbukkit.entity.CraftLivingEntity;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.event.entity.EntityRemoveEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public class AreaEffectCloud extends Entity implements TraceableEntity {
@@ -237,7 +231,7 @@ public class AreaEffectCloud extends Entity implements TraceableEntity {
                 if (!this.potionContents.hasEffects()) {
                     this.victims.clear();
                 } else {
-                    List<MobEffectInstance> list = Lists.newArrayList();
+                    List<MobEffectInstance> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
                     if (this.potionContents.potion().isPresent()) {
                         Iterator iterator = ((Potion) ((Holder) this.potionContents.potion().get()).value()).getEffects().iterator();
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index d0bbbd2044809bdb1273248297f5d9fb87011189..cda41d76da9b9cb2fa6327dec8ece3c40f15adfe 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -12,52 +12,21 @@ import it.unimi.dsi.fastutil.floats.FloatArraySet;
 import it.unimi.dsi.fastutil.floats.FloatArrays;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BiConsumer;
-import java.util.function.Predicate;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
-import net.minecraft.BlockUtil;
-import net.minecraft.CrashReport;
-import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
-import net.minecraft.Util;
+import net.minecraft.*;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.commands.CommandSource;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.arguments.EntityAnchorArgument;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.Holder;
-import net.minecraft.core.RegistryAccess;
-import net.minecraft.core.SectionPos;
+import net.minecraft.core.*;
 import net.minecraft.core.particles.BlockParticleOption;
 import net.minecraft.core.particles.ParticleTypes;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.nbt.DoubleTag;
-import net.minecraft.nbt.FloatTag;
-import net.minecraft.nbt.ListTag;
-import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.*;
 import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientGamePacketListener;
-import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.VecDeltaCodec;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SyncedDataHolder;
@@ -71,11 +40,7 @@ import net.minecraft.server.level.TicketType;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.tags.BlockTags;
-import net.minecraft.tags.DamageTypeTags;
-import net.minecraft.tags.EntityTypeTags;
-import net.minecraft.tags.FluidTags;
-import net.minecraft.tags.TagKey;
+import net.minecraft.tags.*;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.InteractionHand;
@@ -91,22 +56,8 @@ import net.minecraft.world.entity.vehicle.Boat;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
-import net.minecraft.world.level.BlockGetter;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.ClipContext;
-import net.minecraft.world.level.Explosion;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.FenceGateBlock;
-import net.minecraft.world.level.block.HoneyBlock;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.Portal;
-import net.minecraft.world.level.block.RenderShape;
-import net.minecraft.world.level.block.Rotation;
-import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.*;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
 import net.minecraft.world.level.entity.EntityAccess;
@@ -119,11 +70,7 @@ import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.PushReaction;
 import net.minecraft.world.level.portal.DimensionTransition;
 import net.minecraft.world.level.portal.PortalShape;
-import net.minecraft.world.phys.AABB;
-import net.minecraft.world.phys.BlockHitResult;
-import net.minecraft.world.phys.HitResult;
-import net.minecraft.world.phys.Vec2;
-import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.*;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
@@ -131,40 +78,36 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Team;
-import org.slf4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
-import org.bukkit.Server;
 import org.bukkit.block.BlockFace;
 import org.bukkit.command.CommandSender;
-import org.bukkit.entity.Hanging;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.event.entity.EntityCombustByEntityEvent;
-import org.bukkit.event.hanging.HangingBreakByEntityEvent;
-import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
-import org.bukkit.event.vehicle.VehicleEnterEvent;
-import org.bukkit.event.vehicle.VehicleExitEvent;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.event.CraftPortalEvent;
 import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Pose;
-import org.bukkit.event.entity.EntityAirChangeEvent;
-import org.bukkit.event.entity.EntityCombustEvent;
-import org.bukkit.event.entity.EntityDismountEvent;
-import org.bukkit.event.entity.EntityDropItemEvent;
-import org.bukkit.event.entity.EntityMountEvent;
-import org.bukkit.event.entity.EntityPortalEvent;
-import org.bukkit.event.entity.EntityPoseChangeEvent;
-import org.bukkit.event.entity.EntityRemoveEvent;
-import org.bukkit.event.entity.EntityTeleportEvent;
-import org.bukkit.event.entity.EntityUnleashEvent;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.entity.*;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
 import org.bukkit.plugin.PluginManager;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.BiConsumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess, CommandSource, ScoreHolder, ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity, ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity { // Paper - rewrite chunk system // Paper - optimise entity tracker
@@ -172,12 +115,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
     public boolean preserveMotion = true; // Paper - Fix Entity Teleportation and cancel velocity if teleported; keep initial motion on first setPositionRotation
+
     static boolean isLevelAtLeast(CompoundTag tag, int level) {
         return tag.contains("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
     }
 
     // Paper start - Share random for entities to make them more random
     public static RandomSource SHARED_RANDOM = new RandomRandomSource();
+
     private static final class RandomRandomSource extends java.util.Random implements net.minecraft.world.level.levelgen.BitRandomSource {
         private boolean locked = false;
 
@@ -247,6 +192,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             return super.nextGaussian();
         }
     }
+
     // Paper end - Share random for entities to make them more random
     public org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason; // Paper - Entity#getEntitySpawnReason
 
@@ -417,7 +363,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public final org.spigotmc.ActivationRange.ActivationType activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
     public final boolean defaultActivationState;
     public long activatedTick = Integer.MIN_VALUE;
-    public void inactiveTick() { }
+
+    public void inactiveTick() {
+    }
+
     // Spigot end
     protected int numCollisions = 0; // Paper - Cap entity collisions
     public boolean fromNetherPortal; // Paper - Add option to nerf pigmen from nether portals
@@ -458,11 +407,13 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public boolean isChunkLoaded() {
         return this.level.hasChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4);
     }
+
     // CraftBukkit end
     // Paper start
     public final AABB getBoundingBoxAt(double x, double y, double z) {
         return this.dimensions.makeBoundingBox(x, y, z);
     }
+
     // Paper end
     // Paper start - rewrite chunk system
     private final boolean isHardColliding = this.moonrise$isHardCollidingUncached();
@@ -534,6 +485,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         }
         return this.getIndirectPassengersStream().anyMatch((entity) -> entity instanceof Player);
     }
+
     // Paper end - rewrite chunk system
     // Paper start - optimise entity tracker
     private net.minecraft.server.level.ChunkMap.TrackedEntity trackedEntity;
@@ -551,9 +503,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     private static void collectIndirectPassengers(final List<Entity> into, final List<Entity> from) {
         for (final Entity passenger : from) {
             into.add(passenger);
-            collectIndirectPassengers(into, ((Entity)(Object)passenger).passengers);
+            collectIndirectPassengers(into, ((Entity) (Object) passenger).passengers);
         }
     }
+
     // Paper end - optimise entity tracker
     // Purpur start
     public boolean canSaveToDisk() {
@@ -733,13 +686,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             to.connection.send(new ClientboundSetEntityDataPacket(this.getId(), list));
         }
     }
+
     // CraftBukkit end
     // Paper start
     // This method should only be used if the data of an entity could have become desynced
     // due to interactions on the client.
     public void resendPossiblyDesyncedEntityData(net.minecraft.server.level.ServerPlayer player) {
         if (player.getBukkitEntity().canSee(this.getBukkitEntity())) {
-            ServerLevel world = (net.minecraft.server.level.ServerLevel)this.level();
+            ServerLevel world = (net.minecraft.server.level.ServerLevel) this.level();
             net.minecraft.server.level.ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId());
             if (tracker == null) {
                 return;
@@ -767,10 +721,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
     // Paper end
 
+    @Override
     public boolean equals(Object object) {
         return object instanceof Entity ? ((Entity) object).id == this.id : false;
     }
 
+    @Override
     public int hashCode() {
         return this.id;
     }
@@ -785,7 +741,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         // CraftBukkit end
     }
 
-    public void onClientRemoval() {}
+    public void onClientRemoval() {
+    }
 
     public void setPose(net.minecraft.world.entity.Pose pose) {
         if (this.fixedPose) return; // Paper - Expand Pose API
@@ -907,7 +864,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // CraftBukkit end
 
     public void baseTick() {
-        if (firstTick && this instanceof net.minecraft.world.entity.NeutralMob neutralMob) neutralMob.tickInitialPersistentAnger(level); // Paper - Prevent entity loading causing async lookups
+        if (firstTick && this instanceof net.minecraft.world.entity.NeutralMob neutralMob)
+            neutralMob.tickInitialPersistentAnger(level); // Paper - Prevent entity loading causing async lookups
         this.inBlockState = null;
         if (this.isPassenger() && this.getVehicle().isRemoved()) {
             this.stopRiding();
@@ -967,8 +925,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             if (this instanceof net.minecraft.world.entity.LivingEntity livingEntity) {
                 this.setSharedFlagOnFire(this.remainingFireTicks > 0 && (!this.level.galeConfig().gameplayMechanics.hideFlamesOnEntitiesWithFireResistance || !livingEntity.hasEffect(net.minecraft.world.effect.MobEffects.FIRE_RESISTANCE)));
             } else {
-            // Gale end - Slice - hide flames on entities with fire resistance
-            this.setSharedFlagOnFire(this.remainingFireTicks > 0);
+                // Gale end - Slice - hide flames on entities with fire resistance
+                this.setSharedFlagOnFire(this.remainingFireTicks > 0);
             } // Gale - Slice - hide flames on entities with fire resistance
         }
 
@@ -983,15 +941,18 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public void checkBelowWorld() {
-        if (!this.level.getWorld().isVoidDamageEnabled()) return; // Paper - check if void damage is enabled on the world
+        if (!this.level.getWorld().isVoidDamageEnabled())
+            return; // Paper - check if void damage is enabled on the world
 
         // Paper start - Configurable nether ceiling damage
-        if (this.getY() < (double) (this.level.getMinBuildHeight() + this.level.getWorld().getVoidDamageMinBuildHeightOffset())  || (this.level.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER // Paper - use configured min build height offset
-            && this.level.paperConfig().environment.netherCeilingVoidDamageHeight.test(v -> this.getY() >= v)
-            && (!(this instanceof Player player) || !player.getAbilities().invulnerable))) {
+        if (this.getY() < (double) (this.level.getMinBuildHeight() + this.level.getWorld().getVoidDamageMinBuildHeightOffset()) || (this.level.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER // Paper - use configured min build height offset
+                && this.level.paperConfig().environment.netherCeilingVoidDamageHeight.test(v -> this.getY() >= v)
+                && (!(this instanceof Player player) || !player.getAbilities().invulnerable))) {
             // Paper end - Configurable nether ceiling damage
-            if (this.level().purpurConfig.teleportOnNetherCeilingDamage && this.level.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this instanceof ServerPlayer player) player.teleport(io.papermc.paper.util.MCUtil.toLocation(this.level, this.level.getSharedSpawnPos())); else // Purpur
-            this.onBelowWorld();
+            if (this.level().purpurConfig.teleportOnNetherCeilingDamage && this.level.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this instanceof ServerPlayer player)
+                player.teleport(io.papermc.paper.util.MCUtil.toLocation(this.level, this.level.getSharedSpawnPos()));
+            else // Purpur
+                this.onBelowWorld();
         }
 
     }
@@ -1182,177 +1143,177 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             this.moveVector = movement;
         }
         try {
-        // Paper end - detailed watchdog information
-        if (this.noPhysics) {
-            this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
-        } else {
-            this.wasOnFire = this.isOnFire();
-            if (movementType == MoverType.PISTON) {
-                this.activatedTick = Math.max(this.activatedTick, MinecraftServer.currentTick + 20); // Paper
-                this.activatedImmunityTick = Math.max(this.activatedImmunityTick, MinecraftServer.currentTick + 20);   // Paper
-                movement = this.limitPistonMovement(movement);
-                if (movement.equals(Vec3.ZERO)) {
-                    return;
+            // Paper end - detailed watchdog information
+            if (this.noPhysics) {
+                this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
+            } else {
+                this.wasOnFire = this.isOnFire();
+                if (movementType == MoverType.PISTON) {
+                    this.activatedTick = Math.max(this.activatedTick, MinecraftServer.currentTick + 20); // Paper
+                    this.activatedImmunityTick = Math.max(this.activatedImmunityTick, MinecraftServer.currentTick + 20);   // Paper
+                    movement = this.limitPistonMovement(movement);
+                    if (movement.equals(Vec3.ZERO)) {
+                        return;
+                    }
                 }
-            }
 
-            if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7D) {
-                movement = movement.multiply(this.stuckSpeedMultiplier);
-                this.stuckSpeedMultiplier = Vec3.ZERO;
-                this.setDeltaMovement(Vec3.ZERO);
-            }
-            // Paper start - ignore movement changes while inactive.
-            if (isTemporarilyActive && !(this instanceof ItemEntity) && movement == getDeltaMovement() && movementType == MoverType.SELF) {
-                setDeltaMovement(Vec3.ZERO);
-                return;
-            }
-            // Paper end
+                if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7D) {
+                    movement = movement.multiply(this.stuckSpeedMultiplier);
+                    this.stuckSpeedMultiplier = Vec3.ZERO;
+                    this.setDeltaMovement(Vec3.ZERO);
+                }
+                // Paper start - ignore movement changes while inactive.
+                if (isTemporarilyActive && !(this instanceof ItemEntity) && movement == getDeltaMovement() && movementType == MoverType.SELF) {
+                    setDeltaMovement(Vec3.ZERO);
+                    return;
+                }
+                // Paper end
 
-            movement = this.maybeBackOffFromEdge(movement, movementType);
-            Vec3 vec3d1 = this.collide(movement);
-            double d0 = vec3d1.lengthSqr();
+                movement = this.maybeBackOffFromEdge(movement, movementType);
+                Vec3 vec3d1 = this.collide(movement);
+                double d0 = vec3d1.lengthSqr();
 
-            if (d0 > 1.0E-7D) {
-                if (this.fallDistance != 0.0F && d0 >= 1.0D) {
-                    BlockHitResult movingobjectpositionblock = this.level().clip(new ClipContext(this.position(), this.position().add(vec3d1), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this));
+                if (d0 > 1.0E-7D) {
+                    if (this.fallDistance != 0.0F && d0 >= 1.0D) {
+                        BlockHitResult movingobjectpositionblock = this.level().clip(new ClipContext(this.position(), this.position().add(vec3d1), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this));
 
-                    if (movingobjectpositionblock.getType() != HitResult.Type.MISS) {
-                        this.resetFallDistance();
+                        if (movingobjectpositionblock.getType() != HitResult.Type.MISS) {
+                            this.resetFallDistance();
+                        }
                     }
-                }
 
-                this.setPos(this.getX() + vec3d1.x, this.getY() + vec3d1.y, this.getZ() + vec3d1.z);
-            }
-
-            boolean flag = !Mth.equal(movement.x, vec3d1.x);
-            boolean flag1 = !Mth.equal(movement.z, vec3d1.z);
-
-            this.horizontalCollision = flag || flag1;
-            this.verticalCollision = movement.y != vec3d1.y;
-            this.verticalCollisionBelow = this.verticalCollision && movement.y < 0.0D;
-            if (this.horizontalCollision) {
-                this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3d1);
-            } else {
-                this.minorHorizontalCollision = false;
-            }
+                    this.setPos(this.getX() + vec3d1.x, this.getY() + vec3d1.y, this.getZ() + vec3d1.z);
+                }
 
-            this.setOnGroundWithMovement(this.verticalCollisionBelow, vec3d1);
-            BlockPos blockposition = this.getOnPosLegacy();
-            BlockState iblockdata = this.level().getBlockState(blockposition);
+                boolean flag = !Mth.equal(movement.x, vec3d1.x);
+                boolean flag1 = !Mth.equal(movement.z, vec3d1.z);
 
-            this.checkFallDamage(vec3d1.y, this.onGround(), iblockdata, blockposition);
-            if (!this.isRemoved()) {
+                this.horizontalCollision = flag || flag1;
+                this.verticalCollision = movement.y != vec3d1.y;
+                this.verticalCollisionBelow = this.verticalCollision && movement.y < 0.0D;
                 if (this.horizontalCollision) {
-                    Vec3 vec3d2 = this.getDeltaMovement();
-
-                    this.setDeltaMovement(flag ? 0.0D : vec3d2.x, vec3d2.y, flag1 ? 0.0D : vec3d2.z);
+                    this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3d1);
+                } else {
+                    this.minorHorizontalCollision = false;
                 }
 
-                Block block = iblockdata.getBlock();
+                this.setOnGroundWithMovement(this.verticalCollisionBelow, vec3d1);
+                BlockPos blockposition = this.getOnPosLegacy();
+                BlockState iblockdata = this.level().getBlockState(blockposition);
 
-                if (movement.y != vec3d1.y) {
-                    block.updateEntityAfterFallOn(this.level(), this);
-                }
+                this.checkFallDamage(vec3d1.y, this.onGround(), iblockdata, blockposition);
+                if (!this.isRemoved()) {
+                    if (this.horizontalCollision) {
+                        Vec3 vec3d2 = this.getDeltaMovement();
 
-                // CraftBukkit start
-                if (this.horizontalCollision && this.getBukkitEntity() instanceof Vehicle) {
-                    Vehicle vehicle = (Vehicle) this.getBukkitEntity();
-                    org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
-
-                    if (movement.x > vec3d1.x) {
-                        bl = bl.getRelative(BlockFace.EAST);
-                    } else if (movement.x < vec3d1.x) {
-                        bl = bl.getRelative(BlockFace.WEST);
-                    } else if (movement.z > vec3d1.z) {
-                        bl = bl.getRelative(BlockFace.SOUTH);
-                    } else if (movement.z < vec3d1.z) {
-                        bl = bl.getRelative(BlockFace.NORTH);
+                        this.setDeltaMovement(flag ? 0.0D : vec3d2.x, vec3d2.y, flag1 ? 0.0D : vec3d2.z);
                     }
 
-                    if (!bl.getType().isAir()) {
-                        VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl, org.bukkit.craftbukkit.util.CraftVector.toBukkit(originalMovement)); // Paper - Expose pre-collision velocity
-                        this.level.getCraftServer().getPluginManager().callEvent(event);
+                    Block block = iblockdata.getBlock();
+
+                    if (movement.y != vec3d1.y) {
+                        block.updateEntityAfterFallOn(this.level(), this);
                     }
-                }
-                // CraftBukkit end
 
-                if (this.onGround()) {
-                    block.stepOn(this.level(), blockposition, iblockdata, this);
-                }
+                    // CraftBukkit start
+                    if (this.horizontalCollision && this.getBukkitEntity() instanceof Vehicle) {
+                        Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                        org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
+
+                        if (movement.x > vec3d1.x) {
+                            bl = bl.getRelative(BlockFace.EAST);
+                        } else if (movement.x < vec3d1.x) {
+                            bl = bl.getRelative(BlockFace.WEST);
+                        } else if (movement.z > vec3d1.z) {
+                            bl = bl.getRelative(BlockFace.SOUTH);
+                        } else if (movement.z < vec3d1.z) {
+                            bl = bl.getRelative(BlockFace.NORTH);
+                        }
 
-                Entity.MovementEmission entity_movementemission = this.getMovementEmission();
+                        if (!bl.getType().isAir()) {
+                            VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl, org.bukkit.craftbukkit.util.CraftVector.toBukkit(originalMovement)); // Paper - Expose pre-collision velocity
+                            this.level.getCraftServer().getPluginManager().callEvent(event);
+                        }
+                    }
+                    // CraftBukkit end
 
-                if (entity_movementemission.emitsAnything() && !this.isPassenger()) {
-                    double d1 = vec3d1.x;
-                    double d2 = vec3d1.y;
-                    double d3 = vec3d1.z;
+                    if (this.onGround()) {
+                        block.stepOn(this.level(), blockposition, iblockdata, this);
+                    }
 
-                    this.flyDist += (float) (vec3d1.length() * 0.6D);
-                    BlockPos blockposition1 = this.getOnPos();
-                    BlockState iblockdata1 = this.level().getBlockState(blockposition1);
-                    boolean flag2 = this.isStateClimbable(iblockdata1);
+                    Entity.MovementEmission entity_movementemission = this.getMovementEmission();
 
-                    if (!flag2) {
-                        d2 = 0.0D;
-                    }
+                    if (entity_movementemission.emitsAnything() && !this.isPassenger()) {
+                        double d1 = vec3d1.x;
+                        double d2 = vec3d1.y;
+                        double d3 = vec3d1.z;
 
-                    this.walkDist += (float) vec3d1.horizontalDistance() * 0.6F;
-                    this.moveDist += (float) Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3) * 0.6F;
-                    if (this.moveDist > this.nextStep && !iblockdata1.isAir()) {
-                        boolean flag3 = blockposition1.equals(blockposition);
-                        boolean flag4 = this.vibrationAndSoundEffectsFromBlock(blockposition, iblockdata, entity_movementemission.emitsSounds(), flag3, movement);
+                        this.flyDist += (float) (vec3d1.length() * 0.6D);
+                        BlockPos blockposition1 = this.getOnPos();
+                        BlockState iblockdata1 = this.level().getBlockState(blockposition1);
+                        boolean flag2 = this.isStateClimbable(iblockdata1);
 
-                        if (!flag3) {
-                            flag4 |= this.vibrationAndSoundEffectsFromBlock(blockposition1, iblockdata1, false, entity_movementemission.emitsEvents(), movement);
+                        if (!flag2) {
+                            d2 = 0.0D;
                         }
 
-                        if (flag4) {
-                            this.nextStep = this.nextStep();
-                        } else if (this.isInWater()) {
-                            this.nextStep = this.nextStep();
-                            if (entity_movementemission.emitsSounds()) {
-                                this.waterSwimSound();
+                        this.walkDist += (float) vec3d1.horizontalDistance() * 0.6F;
+                        this.moveDist += (float) Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3) * 0.6F;
+                        if (this.moveDist > this.nextStep && !iblockdata1.isAir()) {
+                            boolean flag3 = blockposition1.equals(blockposition);
+                            boolean flag4 = this.vibrationAndSoundEffectsFromBlock(blockposition, iblockdata, entity_movementemission.emitsSounds(), flag3, movement);
+
+                            if (!flag3) {
+                                flag4 |= this.vibrationAndSoundEffectsFromBlock(blockposition1, iblockdata1, false, entity_movementemission.emitsEvents(), movement);
                             }
 
-                            if (entity_movementemission.emitsEvents()) {
-                                this.gameEvent(GameEvent.SWIM);
+                            if (flag4) {
+                                this.nextStep = this.nextStep();
+                            } else if (this.isInWater()) {
+                                this.nextStep = this.nextStep();
+                                if (entity_movementemission.emitsSounds()) {
+                                    this.waterSwimSound();
+                                }
+
+                                if (entity_movementemission.emitsEvents()) {
+                                    this.gameEvent(GameEvent.SWIM);
+                                }
                             }
+                        } else if (iblockdata1.isAir()) {
+                            this.processFlappingMovement();
                         }
-                    } else if (iblockdata1.isAir()) {
-                        this.processFlappingMovement();
                     }
-                }
 
-                this.tryCheckInsideBlocks();
-
-                // Gale start - skip negligible planar movement multiplication
-                Vec3 oldDeltaMovement = this.getDeltaMovement();
-                if (oldDeltaMovement.x < -1e-6 || oldDeltaMovement.x > 1e-6 || oldDeltaMovement.z < -1e-6 || oldDeltaMovement.z > 1e-6) {
-                    // Gale end - skip negligible planar movement multiplication
-                float f = this.getBlockSpeedFactor();
+                    this.tryCheckInsideBlocks();
 
                     // Gale start - skip negligible planar movement multiplication
-                    if (f < 1 - 1e-6 || f > 1 + 1e-6) {
-                        this.setDeltaMovement(oldDeltaMovement.multiply((double) f, 1.0D, (double) f));
-                    }
-                }
-                // Gale end - skip negligible planar movement multiplication
-                if (noLavaAndFireNearEntityByRange(this.getBoundingBox().deflate(1.0E-6D))) { // Moonrise - Avoid streams for block retrieval in Entity#move
-                    if (this.remainingFireTicks <= 0) {
-                        this.setRemainingFireTicks(-this.getFireImmuneTicks());
+                    Vec3 oldDeltaMovement = this.getDeltaMovement();
+                    if (oldDeltaMovement.x < -1e-6 || oldDeltaMovement.x > 1e-6 || oldDeltaMovement.z < -1e-6 || oldDeltaMovement.z > 1e-6) {
+                        // Gale end - skip negligible planar movement multiplication
+                        float f = this.getBlockSpeedFactor();
+
+                        // Gale start - skip negligible planar movement multiplication
+                        if (f < 1 - 1e-6 || f > 1 + 1e-6) {
+                            this.setDeltaMovement(oldDeltaMovement.multiply((double) f, 1.0D, (double) f));
+                        }
                     }
+                    // Gale end - skip negligible planar movement multiplication
+                    if (noLavaAndFireNearEntityByRange(this.getBoundingBox().deflate(1.0E-6D))) { // Moonrise - Avoid streams for block retrieval in Entity#move
+                        if (this.remainingFireTicks <= 0) {
+                            this.setRemainingFireTicks(-this.getFireImmuneTicks());
+                        }
 
-                    if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
-                        this.playEntityOnFireExtinguishedSound();
+                        if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                            this.playEntityOnFireExtinguishedSound();
+                        }
                     }
-                }
 
-                if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
-                    this.setRemainingFireTicks(-this.getFireImmuneTicks());
+                    if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                        this.setRemainingFireTicks(-this.getFireImmuneTicks());
+                    }
                 }
             }
-        }
-        // Paper start - detailed watchdog information
+            // Paper start - detailed watchdog information
         } finally {
             synchronized (this.posLock) { // Paper
                 this.moveVector = null;
@@ -1497,7 +1458,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     public BlockPos getOnPosLegacy() {
         return this.getOnPos(0.2F);
@@ -1602,9 +1565,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             return movement;
         }
 
-        final List<AABB> potentialCollisionsBB = new ArrayList<>();
-        final List<VoxelShape> potentialCollisionsVoxel = new ArrayList<>();
-        final double stepHeight = (double)this.maxUpStep();
+        final List<AABB> potentialCollisionsBB = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        final List<VoxelShape> potentialCollisionsVoxel = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        final double stepHeight = (double) this.maxUpStep();
         final AABB collisionBox;
         final boolean onGround = this.onGround;
 
@@ -1629,9 +1592,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         }
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisions(
-            world, (Entity)(Object)this, collisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
-            null, null
+                world, (Entity) (Object) this, collisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
+                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
+                null, null
         );
 
         if (potentialCollisionsVoxel.isEmpty() && potentialCollisionsBB.isEmpty()) {
@@ -1641,8 +1604,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         final Vec3 limitedMoveVector = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
 
         if (stepHeight > 0.0
-            && (onGround || (limitedMoveVector.y != movement.y && movement.y < 0.0))
-            && (limitedMoveVector.x != movement.x || limitedMoveVector.z != movement.z)) {
+                && (onGround || (limitedMoveVector.y != movement.y && movement.y < 0.0))
+                && (limitedMoveVector.x != movement.x || limitedMoveVector.z != movement.z)) {
             Vec3 vec3d2 = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(movement.x, stepHeight, movement.z), currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
             final Vec3 vec3d3 = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(0.0, stepHeight, 0.0), currBoundingBox.expandTowards(movement.x, 0.0, movement.z), potentialCollisionsVoxel, potentialCollisionsBB);
 
@@ -1903,7 +1866,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     }
 
-    protected void onInsideBlock(BlockState state) {}
+    protected void onInsideBlock(BlockState state) {
+    }
 
     public BlockPos adjustSpawnLocation(ServerLevel world, BlockPos basePos) {
         BlockPos blockposition1 = world.getSharedSpawnPos();
@@ -1982,7 +1946,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.playSound(this.getSwimSound(), volume, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
     }
 
-    protected void onFlap() {}
+    protected void onFlap() {
+    }
 
     protected boolean isFlapping() {
         return false;
@@ -2216,7 +2181,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.gameEvent(GameEvent.SPLASH);
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     protected BlockState getBlockStateOnLegacy() {
         return this.level().getBlockState(this.getOnPosLegacy());
@@ -2281,13 +2248,16 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         }
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     public float getLightLevelDependentMagicValue() {
         return this.getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())); // Gale - JettPack - optimize sun burn tick - allow passing BlockPos to getLightLevelDependentMagicValue
     }
 
     // Gale start - JettPack - optimize sun burn tick - allow passing BlockPos to getLightLevelDependentMagicValue
+
     /**
      * @deprecated
      */
@@ -2318,7 +2288,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.yo = y;
         this.zo = d4;
         this.setPos(d3, y, d4);
-        if (this.valid) this.level.getChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4); // CraftBukkit
+        if (this.valid)
+            this.level.getChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4); // CraftBukkit
     }
 
     public void moveTo(Vec3 pos) {
@@ -2404,12 +2375,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
     // Leaf end - Optimize distanceToSqr - inlining
 
-    public void playerTouch(Player player) {}
+    public void playerTouch(Player player) {
+    }
 
     public void push(Entity entity) {
         if (!entity.noPhysics && !this.noPhysics) { // Gale - Akarin - collision physics check before vehicle check
-        if (!this.isPassengerOfSameVehicle(entity)) {
-                if (this.level.paperConfig().collisions.onlyPlayersCollide && !(entity instanceof ServerPlayer || this instanceof ServerPlayer)) return; // Paper - Collision option for requiring a player participant
+            if (!this.isPassengerOfSameVehicle(entity)) {
+                if (this.level.paperConfig().collisions.onlyPlayersCollide && !(entity instanceof ServerPlayer || this instanceof ServerPlayer))
+                    return; // Paper - Collision option for requiring a player participant
                 double d0 = entity.getX() - this.getX();
                 double d1 = entity.getZ() - this.getZ();
                 double d2 = Mth.absMax(d0, d1);
@@ -2625,6 +2598,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.passengers = ImmutableList.copyOf(pass);
         return result;
     }
+
     // Paper end - Entity serialization api
     public boolean save(CompoundTag nbt) {
         return this.isPassenger() ? false : this.saveAsPassenger(nbt);
@@ -3024,7 +2998,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         // Paper start - Restore vanilla drops behavior
         return this.spawnAtLocation(stack, yOffset, null);
     }
-    public record DefaultDrop(Item item, org.bukkit.inventory.ItemStack stack, @Nullable java.util.function.Consumer<ItemStack> dropConsumer) {
+
+    public record DefaultDrop(Item item, org.bukkit.inventory.ItemStack stack,
+                              @Nullable java.util.function.Consumer<ItemStack> dropConsumer) {
         public DefaultDrop(final ItemStack stack, final java.util.function.Consumer<ItemStack> dropConsumer) {
             this(stack.getItem(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(stack), dropConsumer);
         }
@@ -3037,6 +3013,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             }
         }
     }
+
     @Nullable
     public ItemEntity spawnAtLocation(ItemStack stack, float yOffset, @Nullable java.util.function.Consumer<? super ItemEntity> delayedAddConsumer) {
         // Paper end - Restore vanilla drops behavior
@@ -3066,6 +3043,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             return this.spawnAtLocation(entityitem);
         }
     }
+
     @Nullable
     public ItemEntity spawnAtLocation(ItemEntity entityitem) {
         {
@@ -3118,14 +3096,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 final int newChunkX = fx >> 4;
                 final int newChunkZ = fz >> 4;
                 final net.minecraft.world.level.chunk.LevelChunk chunk = lastChunkKey == (lastChunkKey = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(newChunkX, newChunkZ)) ?
-                    lastChunk : (lastChunk = (net.minecraft.world.level.chunk.LevelChunk)chunkProvider.getChunk(newChunkX, newChunkZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, true));
+                        lastChunk : (lastChunk = (net.minecraft.world.level.chunk.LevelChunk) chunkProvider.getChunk(newChunkX, newChunkZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, true));
                 tempPos.setX(fx);
                 for (int fy = minY; fy <= maxY; ++fy) {
                     tempPos.setY(fy);
 
                     final BlockState state = chunk.getBlockState(tempPos);
 
-                    if (((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)state).moonrise$emptyCollisionShape() || !state.isSuffocating(this.level, tempPos)) {
+                    if (((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState) state).moonrise$emptyCollisionShape() || !state.isSuffocating(this.level, tempPos)) {
                         continue;
                     }
 
@@ -3136,9 +3114,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                         continue;
                     }
 
-                    final AABB toCollide = box.move(-(double)fx, -(double)fy, -(double)fz);
+                    final AABB toCollide = box.move(-(double) fx, -(double) fy, -(double) fz);
 
-                    final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)collisionShape).moonrise$getSingleAABBRepresentation();
+                    final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape) collisionShape).moonrise$getSingleAABBRepresentation();
                     if (singleAABB != null) {
                         if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersect(singleAABB, toCollide)) {
                             return true;
@@ -3162,7 +3140,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         if (this.isAlive() && this instanceof Leashable leashable) {
             if (leashable.getLeashHolder() == player) {
                 if (!this.level().isClientSide()) {
-                    if (hand == InteractionHand.OFF_HAND && (level().purpurConfig.villagerCanBeLeashed || level().purpurConfig.wanderingTraderCanBeLeashed) && this instanceof net.minecraft.world.entity.npc.AbstractVillager) return InteractionResult.CONSUME; // Purpur
+                    if (hand == InteractionHand.OFF_HAND && (level().purpurConfig.villagerCanBeLeashed || level().purpurConfig.wanderingTraderCanBeLeashed) && this instanceof net.minecraft.world.entity.npc.AbstractVillager)
+                        return InteractionResult.CONSUME; // Purpur
                     // CraftBukkit start - fire PlayerUnleashEntityEvent
                     // Paper start - Expand EntityUnleashEvent
                     org.bukkit.event.player.PlayerUnleashEntityEvent event = CraftEventFactory.callPlayerUnleashEntityEvent(this, player, hand, !player.hasInfiniteMaterials());
@@ -3231,7 +3210,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         positionUpdater.accept(passenger, vec3d.x - vec3d1.x, vec3d.y - vec3d1.y, vec3d.z - vec3d1.z);
     }
 
-    public void onPassengerTurned(Entity passenger) {}
+    public void onPassengerTurned(Entity passenger) {
+    }
 
     public Vec3 getVehicleAttachmentPoint(Entity vehicle) {
         return this.getAttachments().get(EntityAttachment.VEHICLE, 0, this.yRot);
@@ -3327,13 +3307,15 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         // Paper start - Force entity dismount during teleportation
         this.removeVehicle(false);
     }
+
     public void removeVehicle(boolean suppressCancellation) {
         // Paper end - Force entity dismount during teleportation
         if (this.vehicle != null) {
             Entity entity = this.vehicle;
 
             this.vehicle = null;
-            if (!entity.removePassenger(this, suppressCancellation)) this.vehicle = entity; // CraftBukkit // Paper - Force entity dismount during teleportation
+            if (!entity.removePassenger(this, suppressCancellation))
+                this.vehicle = entity; // CraftBukkit // Paper - Force entity dismount during teleportation
         }
 
     }
@@ -3378,7 +3360,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     // Paper start - Force entity dismount during teleportation
-    protected boolean removePassenger(Entity entity) { return removePassenger(entity, false);}
+    protected boolean removePassenger(Entity entity) {
+        return removePassenger(entity, false);
+    }
+
     protected boolean removePassenger(Entity entity, boolean suppressCancellation) { // CraftBukkit
         // Paper end - Force entity dismount during teleportation
         if (entity.getVehicle() == this) {
@@ -3499,10 +3484,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public BlockPos portalPos = BlockPos.ZERO; // Purpur
+
     public void setAsInsidePortal(Portal portal, BlockPos pos) {
         if (this.isOnPortalCooldown()) {
             if (!(level().purpurConfig.playerFixStuckPortal && this instanceof Player && !pos.equals(this.portalPos))) // Purpur - Fix stuck in portals
-            this.setPortalCooldown();
+                this.setPortalCooldown();
         } else if (this.level.purpurConfig.entitiesCanUsePortals || this instanceof ServerPlayer) { // Purpur - Entities can use portals
             if (this.portalProcess != null && this.portalProcess.isSamePortal(portal)) {
                 this.portalProcess.updateEntryPosition(pos.immutable());
@@ -3551,7 +3537,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         this.setDeltaMovement(x, y, z);
     }
 
-    public void handleDamageEvent(DamageSource damageSource) {}
+    public void handleDamageEvent(DamageSource damageSource) {
+    }
 
     public void handleEntityEvent(byte status) {
         switch (status) {
@@ -3561,7 +3548,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         }
     }
 
-    public void animateHurt(float yaw) {}
+    public void animateHurt(float yaw) {
+    }
 
     public boolean isOnFire() {
         boolean flag = this.level() != null && this.level().isClientSide;
@@ -3675,11 +3663,14 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return false;
     }
 
-    public void updateDynamicGameEventListener(BiConsumer<DynamicGameEventListener<?>, ServerLevel> callback) {}
+    public void updateDynamicGameEventListener(BiConsumer<DynamicGameEventListener<?>, ServerLevel> callback) {
+    }
 
     @Nullable
     public PlayerTeam getTeam() {
-        if (!this.level().paperConfig().scoreboards.allowNonPlayerEntitiesOnScoreboards && !(this instanceof Player)) { return null; } // Paper - Perf: Disable Scoreboards for non players by default
+        if (!this.level().paperConfig().scoreboards.allowNonPlayerEntitiesOnScoreboards && !(this instanceof Player)) {
+            return null;
+        } // Paper - Perf: Disable Scoreboards for non players by default
         return this.level().getScoreboard().getPlayersTeam(this.getScoreboardName());
     }
 
@@ -3715,7 +3706,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public int getMaxAirSupply() {
-        return this.level == null? this.maxAirTicks : this.level().purpurConfig.drowningAirTicks; // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir() // Purpur
+        return this.level == null ? this.maxAirTicks : this.level().purpurConfig.drowningAirTicks; // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir() // Purpur
     }
 
     public int getAirSupply() {
@@ -3773,10 +3764,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             pluginManager.callEvent(entityCombustEvent);
             if (!entityCombustEvent.isCancelled()) {
                 this.igniteForSeconds(entityCombustEvent.getDuration(), false);
-            // Paper start - fix EntityCombustEvent cancellation
+                // Paper start - fix EntityCombustEvent cancellation
             } else {
                 this.setRemainingFireTicks(this.remainingFireTicks - 1);
-            // Paper end - fix EntityCombustEvent cancellation
+                // Paper end - fix EntityCombustEvent cancellation
             }
             // CraftBukkit end
         }
@@ -3918,9 +3909,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return 0.0F;
     }
 
-    public void setYHeadRot(float headYaw) {}
+    public void setYHeadRot(float headYaw) {
+    }
 
-    public void setYBodyRot(float bodyYaw) {}
+    public void setYBodyRot(float bodyYaw) {
+    }
 
     public boolean isAttackable() {
         return true;
@@ -3930,6 +3923,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return false;
     }
 
+    @Override
     public String toString() {
         String s = this.level() == null ? "~NULL~" : this.level().toString();
 
@@ -4000,9 +3994,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                     CraftEntity bukkitEntity = this.getBukkitEntity();
                     Vec3 velocity = teleportTarget.speed();
                     org.bukkit.event.entity.EntityPortalExitEvent event = new org.bukkit.event.entity.EntityPortalExitEvent(
-                        bukkitEntity,
-                        bukkitEntity.getLocation(), to.clone(),
-                        bukkitEntity.getVelocity(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(velocity)
+                            bukkitEntity,
+                            bukkitEntity.getLocation(), to.clone(),
+                            bukkitEntity.getVelocity(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(velocity)
                     );
                     event.callEvent();
 
@@ -4021,7 +4015,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 List<Entity> list = this.getPassengers();
 
                 this.unRide();
-                List<Entity> list1 = new ArrayList();
+                List<Entity> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 Iterator iterator = list.iterator();
 
                 Entity entity;
@@ -4255,7 +4249,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
             if (entity == null) {
                 return false;
-            // Gale start - MultiPaper - load portal destination chunk before entity teleport
+                // Gale start - MultiPaper - load portal destination chunk before entity teleport
             } else {
                 if (entity.level.galeConfig().gameplayMechanics.technical.loadPortalDestinationChunkBeforeEntityTeleport) {
                     BlockPos pos = BlockPos.containing(position);
@@ -4312,7 +4306,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     @Override
-    public void onSyncedDataUpdated(List<SynchedEntityData.DataValue<?>> entries) {}
+    public void onSyncedDataUpdated(List<SynchedEntityData.DataValue<?>> entries) {
+    }
 
     @Override
     public void onSyncedDataUpdated(EntityDataAccessor<?> data) {
@@ -4322,7 +4317,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     protected void fixupDimensions() {
         net.minecraft.world.entity.Pose entitypose = this.getPose();
@@ -4462,7 +4459,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // Purpur end
 
     @Override
-    public void sendSystemMessage(Component message) {}
+    public void sendSystemMessage(Component message) {
+    }
 
     public Level getCommandSenderWorld() {
         return this.level();
@@ -4481,7 +4479,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return false;
     }
 
-    public void startSeenByPlayer(ServerPlayer player) {}
+    public void startSeenByPlayer(ServerPlayer player) {
+    }
 
     // Paper start - entity tracking events
     public void stopSeenByPlayer(ServerPlayer player) {
@@ -4567,25 +4566,31 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     private Stream<Entity> getIndirectPassengersStream() {
-        if (this.passengers.isEmpty()) { return Stream.of(); } // Paper - Optimize indirect passenger iteration
+        if (this.passengers.isEmpty()) {
+            return Stream.of();
+        } // Paper - Optimize indirect passenger iteration
         return this.passengers.stream().flatMap(Entity::getSelfAndPassengers);
     }
 
     @Override
     public Stream<Entity> getSelfAndPassengers() {
-        if (this.passengers.isEmpty()) { return Stream.of(this); } // Paper - Optimize indirect passenger iteration
+        if (this.passengers.isEmpty()) {
+            return Stream.of(this);
+        } // Paper - Optimize indirect passenger iteration
         return Stream.concat(Stream.of(this), this.getIndirectPassengersStream());
     }
 
     @Override
     public Stream<Entity> getPassengersAndSelf() {
-        if (this.passengers.isEmpty()) { return Stream.of(this); } // Paper - Optimize indirect passenger iteration
+        if (this.passengers.isEmpty()) {
+            return Stream.of(this);
+        } // Paper - Optimize indirect passenger iteration
         return Stream.concat(this.passengers.stream().flatMap(Entity::getPassengersAndSelf), Stream.of(this));
     }
 
     public Iterable<Entity> getIndirectPassengers() {
         // Paper start - optimise entity tracker
-        final List<Entity> ret = new ArrayList<>();
+        final List<Entity> ret = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         if (this.passengers.isEmpty()) {
             return ret;
@@ -4596,6 +4601,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return ret;
         // Paper end - optimise entity tracker
     }
+
     private Iterable<Entity> getIndirectPassengers_old() {
         // Paper end - Optimize indirect passenger iteration
         return () -> {
@@ -4610,7 +4616,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public boolean hasExactlyOnePlayerPassenger() {
-        if (this.passengers.isEmpty()) { return false; } // Paper - Optimize indirect passenger iteration
+        if (this.passengers.isEmpty()) {
+            return false;
+        } // Paper - Optimize indirect passenger iteration
         return this.countPlayerPassengers() == 1;
     }
 
@@ -4618,7 +4626,6 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         Entity entity;
 
         for (entity = this; entity.isPassenger(); entity = entity.getVehicle()) {
-            ;
         }
 
         return entity;
@@ -4810,30 +4817,30 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                             for (int currX = minX; currX < maxX; ++currX) {
                                 FluidState fluid = blocks.get(currX & 15, currY & 15, currZ & 15).getFluidState();
 
-                        if (fluid.is(tag)) {
-                            blockposition_mutableblockposition.set((currChunkX << 4) + currX, currY, (currChunkZ << 4) + currZ);
-                            double d2 = (double) ((float) currY + fluid.getHeight(this.level(), blockposition_mutableblockposition));
-
-                            if (d2 >= axisalignedbb.minY) {
-                                flag1 = true;
-                                d1 = Math.max(d2 - axisalignedbb.minY, d1);
-                                if (flag) {
-                                    Vec3 vec3d1 = fluid.getFlow(this.level(), blockposition_mutableblockposition);
-
-                                    if (d1 < 0.4D) {
-                                        vec3d1 = vec3d1.scale(d1);
+                                if (fluid.is(tag)) {
+                                    blockposition_mutableblockposition.set((currChunkX << 4) + currX, currY, (currChunkZ << 4) + currZ);
+                                    double d2 = (double) ((float) currY + fluid.getHeight(this.level(), blockposition_mutableblockposition));
+
+                                    if (d2 >= axisalignedbb.minY) {
+                                        flag1 = true;
+                                        d1 = Math.max(d2 - axisalignedbb.minY, d1);
+                                        if (flag) {
+                                            Vec3 vec3d1 = fluid.getFlow(this.level(), blockposition_mutableblockposition);
+
+                                            if (d1 < 0.4D) {
+                                                vec3d1 = vec3d1.scale(d1);
+                                            }
+
+                                            vec3d = vec3d.add(vec3d1);
+                                            ++k1;
+                                        }
+                                        // CraftBukkit start - store last lava contact location
+                                        if (tag == FluidTags.LAVA) {
+                                            this.lastLavaContact = blockposition_mutableblockposition.immutable();
+                                        }
+                                        // CraftBukkit end
                                     }
-
-                                    vec3d = vec3d.add(vec3d1);
-                                    ++k1;
                                 }
-                                // CraftBukkit start - store last lava contact location
-                                if (tag == FluidTags.LAVA) {
-                                    this.lastLavaContact = blockposition_mutableblockposition.immutable();
-                                }
-                                // CraftBukkit end
-                            }
-                        }
                             }
                         }
                     }
@@ -4946,7 +4953,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     public void setDeltaMovement(Vec3 velocity) {
         synchronized (this.posLock) { // Paper
-        this.deltaMovement = velocity;
+            this.deltaMovement = velocity;
         } // Paper
     }
 
@@ -5025,15 +5032,17 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         LOGGER.error("New entity position is invalid! Tried to set invalid position ({},{},{}) for entity {} located at {}, entity info: {}", newX, newY, newZ, entity.getClass().getName(), entity.position, entityInfo, new Throwable());
         return false;
     }
+
     public final void setPosRaw(double x, double y, double z) {
         this.setPosRaw(x, y, z, false);
     }
+
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
         // Paper start - rewrite chunk system
         if (this.updatingSectionStatus) {
             LOGGER.error(
-                "Refusing to update position for entity " + this + " to position " + new Vec3(x, y, z)
-                    + " since it is processing a section status update", new Throwable()
+                    "Refusing to update position for entity " + this + " to position " + new Vec3(x, y, z)
+                            + " since it is processing a section status update", new Throwable()
             );
             return;
         }
@@ -5054,7 +5063,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         // Paper end - Fix MC-4
         if (this.position.x != x || this.position.y != y || this.position.z != z) {
             synchronized (this.posLock) { // Paper
-            this.position = new Vec3(x, y, z);
+                this.position = new Vec3(x, y, z);
             } // Paper
             int i = Mth.floor(x);
             int j = Mth.floor(y);
@@ -5079,7 +5088,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         // Paper end - Block invalid positions and bounding box
     }
 
-    public void checkDespawn() {}
+    public void checkDespawn() {
+    }
 
     public Vec3 getRopeHoldPosition(float delta) {
         return this.getPosition(delta).add(0.0D, (double) this.eyeHeight * 0.7D, 0.0D);
@@ -5152,7 +5162,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return maxUpStep;
     }
 
-    public void onExplosionHit(@Nullable Entity entity) {}
+    public void onExplosionHit(@Nullable Entity entity) {
+    }
 
     public final boolean isRemoved() {
         return this.removalReason != null;
@@ -5172,7 +5183,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     @Override
     public final void setRemoved(Entity.RemovalReason entity_removalreason, EntityRemoveEvent.Cause cause) {
         // Paper start - rewrite chunk system
-        if (!((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this.level).moonrise$getEntityLookup().canRemoveEntity((Entity)(Object)this)) {
+        if (!((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this.level).moonrise$getEntityLookup().canRemoveEntity((Entity) (Object) this)) {
             LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
             return;
         }
@@ -5188,7 +5199,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             this.stopRiding();
         }
 
-        if (this.removalReason != Entity.RemovalReason.UNLOADED_TO_CHUNK) { this.getPassengers().forEach(Entity::stopRiding); } // Paper - rewrite chunk system
+        if (this.removalReason != Entity.RemovalReason.UNLOADED_TO_CHUNK) {
+            this.getPassengers().forEach(Entity::stopRiding);
+        } // Paper - rewrite chunk system
         this.levelCallback.onRemove(entity_removalreason);
         // Paper start - Folia schedulers
         if (!(this instanceof ServerPlayer) && entity_removalreason != RemovalReason.CHANGED_DIMENSION && !alreadyRemoved) {
@@ -5203,6 +5216,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     // Paper start - Folia schedulers
+
     /**
      * Invoked only when the entity is truly removed from the server, never to be added to any world.
      */
@@ -5219,7 +5233,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
     @Override
     public boolean shouldBeSaved() {
-        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this).moonrise$hasAnyPlayerPassengers()); // Paper - rewrite chunk system
+        return this.removalReason != null && !this.removalReason.shouldSave() ? false : (this.isPassenger() ? false : !this.isVehicle() || !((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity) this).moonrise$hasAnyPlayerPassengers()); // Paper - rewrite chunk system
     }
 
     @Override
@@ -5340,6 +5354,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public boolean isTicking() {
         return ((net.minecraft.server.level.ServerChunkCache) level.getChunkSource()).isPositionTicking(this);
     }
+
     // Paper end - Expose entity id counter
     // Purpur start
     @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 47e031130ca30cbe3bb9917cb9a43612ec73b538..ed4dd6d028693980cf6053e5ccc2ff442d334bcf 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -1,12 +1,9 @@
 package net.minecraft.world.entity;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Function;
 import com.google.common.base.Objects;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
+import com.google.common.collect.*;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
@@ -14,17 +11,6 @@ import com.mojang.serialization.Dynamic;
 import it.unimi.dsi.fastutil.doubles.DoubleDoubleImmutablePair;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectArrayMap;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
-import java.util.Collection;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Optional;
-import java.util.Set;
-import java.util.function.Predicate;
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
 import net.minecraft.Util;
 import net.minecraft.advancements.CriteriaTriggers;
@@ -38,19 +24,8 @@ import net.minecraft.core.particles.BlockParticleOption;
 import net.minecraft.core.particles.ItemParticleOption;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.particles.ParticleTypes;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.nbt.FloatTag;
-import net.minecraft.nbt.IntTag;
-import net.minecraft.nbt.ListTag;
-import net.minecraft.nbt.NbtOps;
-import net.minecraft.nbt.Tag;
-import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundAnimatePacket;
-import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
-import net.minecraft.network.protocol.game.ClientboundRemoveMobEffectPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
-import net.minecraft.network.protocol.game.ClientboundTakeItemEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
+import net.minecraft.nbt.*;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
@@ -63,12 +38,7 @@ import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.stats.Stats;
-import net.minecraft.tags.BlockTags;
-import net.minecraft.tags.DamageTypeTags;
-import net.minecraft.tags.EntityTypeTags;
-import net.minecraft.tags.FluidTags;
-import net.minecraft.tags.ItemTags;
-import net.minecraft.tags.TagKey;
+import net.minecraft.tags.*;
 import net.minecraft.util.Mth;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.InteractionHand;
@@ -81,13 +51,7 @@ import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.effect.MobEffectUtil;
 import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.ai.Brain;
-import net.minecraft.world.entity.ai.attributes.Attribute;
-import net.minecraft.world.entity.ai.attributes.AttributeInstance;
-import net.minecraft.world.entity.ai.attributes.AttributeMap;
-import net.minecraft.world.entity.ai.attributes.AttributeModifier;
-import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
-import net.minecraft.world.entity.ai.attributes.Attributes;
-import net.minecraft.world.entity.ai.attributes.DefaultAttributes;
+import net.minecraft.world.entity.ai.attributes.*;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
 import net.minecraft.world.entity.animal.FlyingAnimal;
 import net.minecraft.world.entity.animal.Wolf;
@@ -96,27 +60,14 @@ import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.entity.projectile.Projectile;
 import net.minecraft.world.food.FoodProperties;
-import net.minecraft.world.item.ArmorItem;
-import net.minecraft.world.item.AxeItem;
-import net.minecraft.world.item.ElytraItem;
-import net.minecraft.world.item.Equipable;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
-import net.minecraft.world.item.UseAnim;
+import net.minecraft.world.item.*;
 import net.minecraft.world.item.enchantment.Enchantment;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.item.enchantment.effects.EnchantmentLocationBasedEffect;
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.BedBlock;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.HoneyBlock;
-import net.minecraft.world.level.block.LadderBlock;
-import net.minecraft.world.level.block.PowderSnowBlock;
-import net.minecraft.world.level.block.SoundType;
-import net.minecraft.world.level.block.TrapDoorBlock;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.level.gameevent.GameEvent;
@@ -132,29 +83,21 @@ import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Scoreboard;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Set;
-import com.google.common.base.Function;
-import java.util.UUID;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.entity.Player;
-import org.bukkit.event.entity.ArrowBodyCountChangeEvent;
-import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.event.entity.*;
 import org.bukkit.event.entity.EntityDamageEvent.DamageModifier;
-import org.bukkit.event.entity.EntityKnockbackEvent;
-import org.bukkit.event.entity.EntityPotionEffectEvent;
-import org.bukkit.event.entity.EntityRegainHealthEvent;
-import org.bukkit.event.entity.EntityRemoveEvent;
-import org.bukkit.event.entity.EntityResurrectEvent;
-import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.function.Predicate;
 // CraftBukkit end
 
 public abstract class LivingEntity extends Entity implements Attackable, net.caffeinemc.mods.lithium.common.util.change_tracking.ChangeSubscriber.CountChangeSubscriber<ItemStack>, net.caffeinemc.mods.lithium.common.entity.EquipmentEntity, net.caffeinemc.mods.lithium.common.entity.EquipmentEntity.TickableEnchantmentTrackingEntity, net.caffeinemc.mods.lithium.common.entity.EquipmentEntity.EquipmentTrackingEntity { // Leaf - Lithium equipment tracking
@@ -239,9 +182,36 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     protected int deathScore;
     public float lastHurt;
     public boolean jumping;
-    public float xxa; public float getStrafeMot() { return xxa; } public void setStrafeMot(float strafe) { xxa = strafe; } // Purpur - OBFHELPER
-    public float yya; public float getVerticalMot() { return yya; } public void setVerticalMot(float vertical) { yya = vertical; } // Purpur - OBFHELPER
-    public float zza; public float getForwardMot() { return zza; } public void setForwardMot(float forward) { zza = forward; } // Purpur - OBFHELPER
+    public float xxa;
+
+    public float getStrafeMot() {
+        return xxa;
+    }
+
+    public void setStrafeMot(float strafe) {
+        xxa = strafe;
+    } // Purpur - OBFHELPER
+
+    public float yya;
+
+    public float getVerticalMot() {
+        return yya;
+    }
+
+    public void setVerticalMot(float vertical) {
+        yya = vertical;
+    } // Purpur - OBFHELPER
+
+    public float zza;
+
+    public float getForwardMot() {
+        return zza;
+    }
+
+    public void setForwardMot(float forward) {
+        zza = forward;
+    } // Purpur - OBFHELPER
+
     protected int lerpSteps;
     protected double lerpX;
     protected double lerpY;
@@ -280,28 +250,42 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     protected float appliedScale;
     // CraftBukkit start
     public int expToDrop;
-    public ArrayList<DefaultDrop> drops = new ArrayList<>(); // Paper - Restore vanilla drops behavior
+    public ArrayList<DefaultDrop> drops = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // Paper - Restore vanilla drops behavior
     public final org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
     public boolean collides = true;
     public Set<UUID> collidableExemptions = new HashSet<>();
     public boolean bukkitPickUpLoot;
-    public org.bukkit.craftbukkit.entity.CraftLivingEntity getBukkitLivingEntity() { return (org.bukkit.craftbukkit.entity.CraftLivingEntity) super.getBukkitEntity(); } // Paper
+
+    public org.bukkit.craftbukkit.entity.CraftLivingEntity getBukkitLivingEntity() {
+        return (org.bukkit.craftbukkit.entity.CraftLivingEntity) super.getBukkitEntity();
+    } // Paper
+
     public boolean silentDeath = false; // Paper - mark entity as dying silently for cancellable death event
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
-    protected boolean shouldBurnInDay = false; public boolean shouldBurnInDay() { return this.shouldBurnInDay; } public void setShouldBurnInDay(boolean shouldBurnInDay) { this.shouldBurnInDay = shouldBurnInDay; } // Purpur - API for any mob to burn daylight
+    protected boolean shouldBurnInDay = false;
+
+    public boolean shouldBurnInDay() {
+        return this.shouldBurnInDay;
+    }
+
+    public void setShouldBurnInDay(boolean shouldBurnInDay) {
+        this.shouldBurnInDay = shouldBurnInDay;
+    } // Purpur - API for any mob to burn daylight
 
     // Leaf start - Lithium equipment tracking
     private boolean maybeHasTickableEnchantments = this instanceof net.minecraft.world.entity.player.Player;
     private boolean equipmentChanged = true;
+
     // Leaf end - Lithium equipment tracking
     @Override
     public float getBukkitYaw() {
         return this.getYHeadRot();
     }
+
     // CraftBukkit end
     // Spigot start
-    public void inactiveTick()
-    {
+    @Override
+    public void inactiveTick() {
         super.inactiveTick();
         ++this.noActionTime; // Above all the floats
     }
@@ -336,7 +320,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         this.brain = this.makeBrain(new Dynamic(dynamicopsnbt, (Tag) dynamicopsnbt.createMap((Map) ImmutableMap.of(dynamicopsnbt.createString("memories"), (Tag) dynamicopsnbt.emptyMap()))));
     }
 
-    protected void initAttributes() {}// Purpur
+    protected void initAttributes() {
+    }// Purpur
 
     public Brain<?> getBrain() {
         return this.brain;
@@ -373,7 +358,10 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     public static AttributeSupplier.Builder createLivingAttributes() {
         return AttributeSupplier.builder().add(Attributes.MAX_HEALTH).add(Attributes.KNOCKBACK_RESISTANCE).add(Attributes.MOVEMENT_SPEED).add(Attributes.ARMOR).add(Attributes.ARMOR_TOUGHNESS).add(Attributes.MAX_ABSORPTION).add(Attributes.STEP_HEIGHT).add(Attributes.SCALE).add(Attributes.GRAVITY).add(Attributes.SAFE_FALL_DISTANCE).add(Attributes.FALL_DAMAGE_MULTIPLIER).add(Attributes.JUMP_STRENGTH).add(Attributes.OXYGEN_BONUS).add(Attributes.BURNING_TIME).add(Attributes.EXPLOSION_KNOCKBACK_RESISTANCE).add(Attributes.WATER_MOVEMENT_EFFICIENCY).add(Attributes.MOVEMENT_EFFICIENCY).add(Attributes.ATTACK_KNOCKBACK);
     }
-    public boolean shouldSendAttribute(Attribute attribute) { return true; } // Purpur
+
+    public boolean shouldSendAttribute(Attribute attribute) {
+        return true;
+    } // Purpur
 
     @Override
     protected void checkFallDamage(double heightDifference, boolean onGround, BlockState state, BlockPos landedPosition) {
@@ -471,7 +459,10 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                         double d1 = this.level().getWorldBorder().getDamagePerBlock();
 
                         if (d1 > 0.0D) {
-                            if (level().purpurConfig.teleportIfOutsideBorder && this instanceof ServerPlayer serverPlayer) { serverPlayer.teleport(io.papermc.paper.util.MCUtil.toLocation(level(), ((ServerLevel) level()).getSharedSpawnPos())); return; } // Purpur
+                            if (level().purpurConfig.teleportIfOutsideBorder && this instanceof ServerPlayer serverPlayer) {
+                                serverPlayer.teleport(io.papermc.paper.util.MCUtil.toLocation(level(), ((ServerLevel) level()).getSharedSpawnPos()));
+                                return;
+                            } // Purpur
                             this.hurt(this.damageSources().outOfBorder(), (float) Math.max(1, Mth.floor(-d0 * d1)));
                         }
                     }
@@ -578,19 +569,19 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     }
 
     protected void tryAddFrost() {
-            int i = this.getTicksFrozen();
+        int i = this.getTicksFrozen();
 
-            if (i > 0) {
-                AttributeInstance attributemodifiable = this.getBlockStateOnLegacy().isAir() ? null : this.getAttribute(Attributes.MOVEMENT_SPEED); // Gale - Lithium - check frozen ticks before landing block
+        if (i > 0) {
+            AttributeInstance attributemodifiable = this.getBlockStateOnLegacy().isAir() ? null : this.getAttribute(Attributes.MOVEMENT_SPEED); // Gale - Lithium - check frozen ticks before landing block
 
-                if (attributemodifiable == null) {
-                    return;
-                }
+            if (attributemodifiable == null) {
+                return;
+            }
 
-                float f = -0.05F * this.getPercentFrozen();
+            float f = -0.05F * this.getPercentFrozen();
 
-                attributemodifiable.addTransientModifier(new AttributeModifier(LivingEntity.SPEED_MODIFIER_POWDER_SNOW_ID, (double) f, AttributeModifier.Operation.ADD_VALUE));
-            }
+            attributemodifiable.addTransientModifier(new AttributeModifier(LivingEntity.SPEED_MODIFIER_POWDER_SNOW_ID, (double) f, AttributeModifier.Operation.ADD_VALUE));
+        }
 
     }
 
@@ -885,7 +876,9 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             String s = nbt.getString("Team");
             Scoreboard scoreboard = this.level().getScoreboard();
             PlayerTeam scoreboardteam = scoreboard.getPlayerTeam(s);
-            if (!this.level().paperConfig().scoreboards.allowNonPlayerEntitiesOnScoreboards && !(this instanceof net.minecraft.world.entity.player.Player)) { scoreboardteam = null; } // Paper - Perf: Disable Scoreboards for non players by default
+            if (!this.level().paperConfig().scoreboards.allowNonPlayerEntitiesOnScoreboards && !(this instanceof net.minecraft.world.entity.player.Player)) {
+                scoreboardteam = null;
+            } // Paper - Perf: Disable Scoreboards for non players by default
             boolean flag = scoreboardteam != null && scoreboard.addPlayerToTeam(this.getStringUUID(), scoreboardteam);
 
             if (!flag) {
@@ -901,11 +894,11 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             BlockPos blockposition = new BlockPos(nbt.getInt("SleepingX"), nbt.getInt("SleepingY"), nbt.getInt("SleepingZ"));
 
             if (this.position().distanceToSqr(blockposition.getX(), blockposition.getY(), blockposition.getZ()) < 16 * 16) { // Paper - The sleeping pos will always also set the actual pos, so a desync suggests something is wrong
-            this.setSleepingPos(blockposition);
-            this.entityData.set(LivingEntity.DATA_POSE, Pose.SLEEPING);
-            if (!this.firstTick) {
-                this.setPosToBed(blockposition);
-            }
+                this.setSleepingPos(blockposition);
+                this.entityData.set(LivingEntity.DATA_POSE, Pose.SLEEPING);
+                if (!this.firstTick) {
+                    this.setPosToBed(blockposition);
+                }
             } // Paper - The sleeping pos will always also set the actual pos, so a desync suggests something is wrong
         }
 
@@ -922,7 +915,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
 
     // CraftBukkit start
     private boolean isTickingEffects = false;
-    private List<ProcessableEffect> effectsToProcess = Lists.newArrayList();
+    private List<ProcessableEffect> effectsToProcess = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     private static class ProcessableEffect {
 
@@ -969,7 +962,6 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                 }
             }
         } catch (ConcurrentModificationException concurrentmodificationexception) {
-            ;
         }
         // CraftBukkit start
         this.isTickingEffects = false;
@@ -1018,7 +1010,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
 
     private void updateSynchronizedMobEffectParticles() {
         // Leaf start - Remove stream in entity visible effects filter
-        List<ParticleOptions> list = new ArrayList<>();
+        List<ParticleOptions> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         final Collection<MobEffectInstance> effectsValues = this.activeEffects.values(); // Leaf - Replace Entity active effects map with optimized collection
 
         for (MobEffectInstance effect : effectsValues) { // Leaf - Replace Entity active effects map with optimized collection
@@ -1143,7 +1135,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             for (flag = false; iterator.hasNext(); flag = true) {
                 // CraftBukkit start
                 MobEffectInstance effect = (MobEffectInstance) iterator.next();
-                if (cause == EntityPotionEffectEvent.Cause.MILK && !this.level().purpurConfig.milkClearsBeneficialEffects && effect.getEffect().value().isBeneficial()) continue; // Purpur
+                if (cause == EntityPotionEffectEvent.Cause.MILK && !this.level().purpurConfig.milkClearsBeneficialEffects && effect.getEffect().value().isBeneficial())
+                    continue; // Purpur
                 EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, effect, null, cause, EntityPotionEffectEvent.Action.CLEARED);
                 if (event.isCancelled()) {
                     continue;
@@ -1191,6 +1184,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         // Paper start - Don't fire sync event during generation
         return this.addEffect(mobeffect, entity, cause, true);
     }
+
     public boolean addEffect(MobEffectInstance mobeffect, @Nullable Entity entity, EntityPotionEffectEvent.Cause cause, boolean fireEvent) {
         // Paper end - Don't fire sync event during generation
         // org.spigotmc.AsyncCatcher.catchOp("effect add"); // Spigot // Paper - move to API
@@ -1213,11 +1207,11 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             }
 
             if (fireEvent) { // Paper - Don't fire sync event during generation
-            EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, mobeffect1, mobeffect, cause, override);
-            override = event.isOverride(); // Paper - Don't fire sync event during generation
-            if (event.isCancelled()) {
-                return false;
-            }
+                EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, mobeffect1, mobeffect, cause, override);
+                override = event.isOverride(); // Paper - Don't fire sync event during generation
+                if (event.isCancelled()) {
+                    return false;
+                }
             } // Paper - Don't fire sync event during generation
             // CraftBukkit end
 
@@ -1431,9 +1425,12 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
 
     public void setHealth(float health) {
         // Paper start - Check for NaN
-        if (Float.isNaN(health)) { health = getMaxHealth(); if (this.valid) {
-            System.err.println("[NAN-HEALTH] " + getScoreboardName() + " had NaN health set");
-        } } // Paper end - Check for NaN
+        if (Float.isNaN(health)) {
+            health = getMaxHealth();
+            if (this.valid) {
+                System.err.println("[NAN-HEALTH] " + getScoreboardName() + " had NaN health set");
+            }
+        } // Paper end - Check for NaN
         // CraftBukkit start - Handle scaled health
         if (this instanceof ServerPlayer) {
             org.bukkit.craftbukkit.entity.CraftPlayer player = ((ServerPlayer) this).getBukkitEntity();
@@ -1501,7 +1498,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             // Purpur end
 
             this.noActionTime = 0;
-            float f1 = amount; final float originalAmount = f1; // Paper - revert to vanilla #hurt - OBFHELPER
+            float f1 = amount;
+            final float originalAmount = f1; // Paper - revert to vanilla #hurt - OBFHELPER
             boolean flag = amount > 0.0F && this.isDamageSourceBlocked(source); // Copied from below
             float f2 = 0.0F;
 
@@ -1555,7 +1553,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                 if (!this.actuallyHurt(source, (float) event.getFinalDamage() - this.lastHurt, event)) {
                     return false;
                 }
-                if (this instanceof ServerPlayer && event.getDamage() == 0 && originalAmount == 0) return false; // Paper - revert to vanilla damage - players are not affected by damage that is 0 - skip damage if the vanilla damage is 0 and was not modified by plugins in the event.
+                if (this instanceof ServerPlayer && event.getDamage() == 0 && originalAmount == 0)
+                    return false; // Paper - revert to vanilla damage - players are not affected by damage that is 0 - skip damage if the vanilla damage is 0 and was not modified by plugins in the event.
                 // CraftBukkit end
                 this.lastHurt = amount;
                 flag1 = false;
@@ -1568,7 +1567,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                 if (!this.actuallyHurt(source, (float) event.getFinalDamage(), event)) {
                     return false;
                 }
-                if (this instanceof ServerPlayer && event.getDamage() == 0 && originalAmount == 0) return false; // Paper - revert to vanilla damage - players are not affected by damage that is 0 - skip damage if the vanilla damage is 0 and was not modified by plugins in the event.
+                if (this instanceof ServerPlayer && event.getDamage() == 0 && originalAmount == 0)
+                    return false; // Paper - revert to vanilla damage - players are not affected by damage that is 0 - skip damage if the vanilla damage is 0 and was not modified by plugins in the event.
                 this.lastHurt = amount;
                 this.invulnerableTime = this.invulnerableDuration; // CraftBukkit - restore use of maxNoDamageTicks
                 // this.actuallyHurt(damagesource, f);
@@ -1885,7 +1885,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                     }
 
                     if (!this.level().isClientSide && this.hasCustomName()) {
-                        if (org.spigotmc.SpigotConfig.logNamedDeaths) LivingEntity.LOGGER.info("Named entity {} died: {}", this, this.getCombatTracker().getDeathMessage().getString()); // Spigot
+                        if (org.spigotmc.SpigotConfig.logNamedDeaths)
+                            LivingEntity.LOGGER.info("Named entity {} died: {}", this, this.getCombatTracker().getDeathMessage().getString()); // Spigot
                     }
 
                     this.getCombatTracker().recheckStatus();
@@ -1898,14 +1899,14 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                     this.setHealth((float) deathEvent.getReviveHealth());
                 }
                 // Paper end
-                    this.createWitherRose(entityliving);
-                }
+                this.createWitherRose(entityliving);
+            }
 
             // Paper start
             if (this.dead) { // Paper
                 this.level().broadcastEntityEvent(this, (byte) 3);
 
-            this.setPose(Pose.DYING);
+                this.setPose(Pose.DYING);
             }
             // Paper end
         }
@@ -1947,6 +1948,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     // Paper start
     protected boolean clearEquipmentSlots = true;
     protected Set<EquipmentSlot> clearedEquipmentSlots = new java.util.HashSet<>();
+
     protected org.bukkit.event.entity.EntityDeathEvent dropAllDeathLoot(ServerLevel world, DamageSource damageSource) {
         // Paper end
         boolean flag = this.lastHurtByPlayerTime > 0;
@@ -1954,14 +1956,14 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         this.dropEquipment(); // CraftBukkit - from below
         if (this.shouldDropLoot() && this.level().getGameRules().getBoolean(GameRules.RULE_DOMOBLOOT)) {
             if (!(damageSource.is(net.minecraft.world.damagesource.DamageTypes.CRAMMING) && level().purpurConfig.disableDropsOnCrammingDeath)) { // Purpur
-            this.dropFromLootTable(damageSource, flag);
-            // Paper start
-            final boolean prev = this.clearEquipmentSlots;
-            this.clearEquipmentSlots = false;
-            this.clearedEquipmentSlots.clear();
-            // Paper end
-            this.dropCustomDeathLoot(world, damageSource, flag);
-            this.clearEquipmentSlots = prev; // Paper
+                this.dropFromLootTable(damageSource, flag);
+                // Paper start
+                final boolean prev = this.clearEquipmentSlots;
+                this.clearEquipmentSlots = false;
+                this.clearedEquipmentSlots.clear();
+                // Paper end
+                this.dropCustomDeathLoot(world, damageSource, flag);
+                this.clearEquipmentSlots = prev; // Paper
             } // Purpur
         }
         // CraftBukkit start - Call death event // Paper start - call advancement triggers with correct entity equipment
@@ -1972,7 +1974,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             }
         }); // Paper end
         this.postDeathDropItems(deathEvent); // Paper
-        this.drops = new ArrayList<>();
+        this.drops = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         // CraftBukkit end
 
         // this.dropEquipment();// CraftBukkit - moved up
@@ -1980,8 +1982,11 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         return deathEvent; // Paper
     }
 
-    protected void dropEquipment() {}
-    protected void postDeathDropItems(org.bukkit.event.entity.EntityDeathEvent event) {} // Paper - method for post death logic that cannot be ran before the event is potentially cancelled
+    protected void dropEquipment() {
+    }
+
+    protected void postDeathDropItems(org.bukkit.event.entity.EntityDeathEvent event) {
+    } // Paper - method for post death logic that cannot be ran before the event is potentially cancelled
 
     public int getExpReward(@Nullable Entity entity) { // CraftBukkit
         Level world = this.level();
@@ -2004,7 +2009,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         // CraftBukkit end
     }
 
-    protected void dropCustomDeathLoot(ServerLevel world, DamageSource source, boolean causedByPlayer) {}
+    protected void dropCustomDeathLoot(ServerLevel world, DamageSource source, boolean causedByPlayer) {
+    }
 
     public ResourceKey<LootTable> getLootTable() {
         return this.getType().getDefaultLootTable();
@@ -2088,7 +2094,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     }
     // Leaf end - Configurable player knockback zombie
 
-    public void indicateDamage(double deltaX, double deltaZ) {}
+    public void indicateDamage(double deltaX, double deltaZ) {
+    }
 
     @Nullable
     protected SoundEvent getHurtSound(DamageSource source) {
@@ -2309,11 +2316,14 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         return Mth.floor(this.getAttributeValue(Attributes.ARMOR));
     }
 
-    protected void hurtArmor(DamageSource source, float amount) {}
+    protected void hurtArmor(DamageSource source, float amount) {
+    }
 
-    protected void hurtHelmet(DamageSource source, float amount) {}
+    protected void hurtHelmet(DamageSource source, float amount) {
+    }
 
-    protected void hurtCurrentlyUsedShield(float amount) {}
+    protected void hurtCurrentlyUsedShield(float amount) {
+    }
 
     protected void doHurtEquipment(DamageSource source, float amount, EquipmentSlot... slots) {
         if (amount > 0.0F) {
@@ -2971,6 +2981,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     }
 
     protected long lastJumpTime = 0L; // Paper - Prevent excessive velocity through repeated crits
+
     @VisibleForTesting
     public void jumpFromGround() {
         float f = this.getJumpPower();
@@ -2982,7 +2993,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             boolean canCrit = true;
             if (this instanceof net.minecraft.world.entity.player.Player) {
                 canCrit = false;
-                if (time - this.lastJumpTime > (long)(0.250e9)) {
+                if (time - this.lastJumpTime > (long) (0.250e9)) {
                     this.lastJumpTime = time;
                     canCrit = true;
                 }
@@ -2993,7 +3004,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
             if (this.isSprinting()) {
                 float f1 = this.getYRot() * 0.017453292F;
                 if (canCrit) // Paper - Prevent excessive velocity through repeated crits
-                this.addDeltaMovement(new Vec3((double) (-Mth.sin(f1)) * 0.2D, 0.0D, (double) Mth.cos(f1) * 0.2D));
+                    this.addDeltaMovement(new Vec3((double) (-Mth.sin(f1)) * 0.2D, 0.0D, (double) Mth.cos(f1) * 0.2D));
             }
 
             this.hasImpulse = true;
@@ -3129,13 +3140,13 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                     if (f3 > 0.0F) {
                         this.playSound(this.getFallDamageSound((int) f3), 1.0F, 1.0F);
                         if (level().purpurConfig.elytraKineticDamage) // Purpur
-                        this.hurt(this.damageSources().flyIntoWall(), f3);
+                            this.hurt(this.damageSources().flyIntoWall(), f3);
                     }
                 }
 
                 if (this.onGround() && !this.level().isClientSide) {
                     if (this.getSharedFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) // CraftBukkit
-                    this.setSharedFlag(7, false);
+                        this.setSharedFlag(7, false);
                 }
             } else {
                 BlockPos blockposition = this.getBlockPosBelowThatAffectsMyMovement();
@@ -3183,7 +3194,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
 
     }
 
-    protected void tickRidden(net.minecraft.world.entity.player.Player controllingPlayer, Vec3 movementInput) {}
+    protected void tickRidden(net.minecraft.world.entity.player.Player controllingPlayer, Vec3 movementInput) {
+    }
 
     protected Vec3 getRiddenInput(net.minecraft.world.entity.player.Player controllingPlayer, Vec3 movementInput) {
         return movementInput;
@@ -3387,7 +3399,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         Map<EquipmentSlot, ItemStack> map = this.collectEquipmentChanges();
 
         if (map != null) {
-            if (!(this instanceof net.minecraft.world.entity.player.Player)) this.equipmentChanged = false; // Leaf - Lithium equipment tracking
+            if (!(this instanceof net.minecraft.world.entity.player.Player))
+                this.equipmentChanged = false; // Leaf - Lithium equipment tracking
             this.handleHandSwap(map);
             if (!map.isEmpty()) {
                 this.handleEquipmentChanges(map);
@@ -3633,9 +3646,11 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
                 this.jumpInLiquid(FluidTags.LAVA);
             } else if ((this.onGround() || flag && d3 <= d4) && this.noJumpDelay == 0) {
                 if (new com.destroystokyo.paper.event.entity.EntityJumpEvent(getBukkitLivingEntity()).callEvent()) { // Paper - Entity Jump API
-                this.jumpFromGround();
-                this.noJumpDelay = 10;
-                } else { this.setJumping(false); } // Paper - Entity Jump API; setJumping(false) stops a potential loop
+                    this.jumpFromGround();
+                    this.noJumpDelay = 10;
+                } else {
+                    this.setJumping(false);
+                } // Paper - Entity Jump API; setJumping(false) stops a potential loop
             }
         } else {
             this.noJumpDelay = 0;
@@ -3745,7 +3760,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
 
                 if (flag) {
                     if (getRider() == null || !this.isControllable()) // Purpur - ignore mobs which are uncontrollable or without rider - API for any mob to burn daylight
-                    this.igniteForSeconds(8.0F);
+                        this.igniteForSeconds(8.0F);
                 }
             }
         }
@@ -3794,12 +3809,13 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
 
         if (!this.level().isClientSide) {
             if (flag != this.getSharedFlag(7) && !CraftEventFactory.callToggleGlideEvent(this, flag).isCancelled()) // CraftBukkit
-            this.setSharedFlag(7, flag);
+                this.setSharedFlag(7, flag);
         }
 
     }
 
-    protected void serverAiStep() {}
+    protected void serverAiStep() {
+    }
 
     protected void pushEntities() {
         if (this.level().isClientSide()) {
@@ -3888,7 +3904,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         entity.push((Entity) this);
     }
 
-    protected void doAutoAttackOnTouch(LivingEntity target) {}
+    protected void doAutoAttackOnTouch(LivingEntity target) {
+    }
 
     public boolean isAutoSpinAttack() {
         return ((Byte) this.entityData.get(LivingEntity.DATA_LIVING_ENTITY_FLAGS) & 4) != 0;
@@ -3899,6 +3916,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         // Paper start - Force entity dismount during teleportation
         this.stopRiding(false);
     }
+
     @Override
     public void stopRiding(boolean suppressCancellation) {
         // Paper end - Force entity dismount during teleportation
@@ -4067,9 +4085,11 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         this.absorptionAmount = absorptionAmount;
     }
 
-    public void onEnterCombat() {}
+    public void onEnterCombat() {
+    }
 
-    public void onLeaveCombat() {}
+    public void onLeaveCombat() {
+    }
 
     protected void updateEffectVisibility() {
         this.effectsDirty = true;
@@ -4089,10 +4109,12 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
     public void resyncUsingItem(ServerPlayer serverPlayer) {
         this.resendPossiblyDesyncedDataValues(java.util.List.of(DATA_LIVING_ENTITY_FLAGS), serverPlayer);
     }
+
     // Paper end - Properly cancel usable items
     // Paper start - lag compensate eating
     protected long eatStartTime;
     protected int totalEatTimeTicks;
+
     // Paper end - lag compensate eating
     private void updatingUsingItem() {
         if (this.isUsingItem()) {
@@ -4157,6 +4179,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         // Paper start - Prevent consuming the wrong itemstack
         this.startUsingItem(hand, false);
     }
+
     public void startUsingItem(InteractionHand hand, boolean forceUpdate) {
         // Paper end - Prevent consuming the wrong itemstack
         ItemStack itemstack = this.getItemInHand(hand);
@@ -4316,7 +4339,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
 
     public void releaseUsingItem() {
         if (!this.useItem.isEmpty()) {
-            if (this instanceof ServerPlayer) new io.papermc.paper.event.player.PlayerStopUsingItemEvent((Player) getBukkitEntity(), useItem.asBukkitMirror(), getTicksUsingItem()).callEvent(); // Paper - Add PlayerStopUsingItemEvent
+            if (this instanceof ServerPlayer)
+                new io.papermc.paper.event.player.PlayerStopUsingItemEvent((Player) getBukkitEntity(), useItem.asBukkitMirror(), getTicksUsingItem()).callEvent(); // Paper - Add PlayerStopUsingItemEvent
             this.useItem.releaseUsing(this.level(), this, this.getUseItemRemainingTicks());
             if (this.useItem.useOnRelease()) {
                 this.updatingUsingItem();
@@ -4516,7 +4540,8 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         return true;
     }
 
-    public void setRecordPlayingNearby(BlockPos songPosition, boolean playing) {}
+    public void setRecordPlayingNearby(BlockPos songPosition, boolean playing) {
+    }
 
     public boolean canTakeItem(ItemStack stack) {
         return false;
@@ -4858,6 +4883,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         flag = true;
         return flag;
     }
+
     // Leaf start - Lithium entity equipment tracking
     @Override
     public void updateHasTickableEnchantments(ItemStack oldStack, ItemStack newStack) {
@@ -4892,6 +4918,7 @@ public abstract class LivingEntity extends Entity implements Attackable, net.caf
         }
         return false;
     }
+
     @Override
     public void notify(@Nullable ItemStack publisher, int zero) {
         if (this instanceof EquipmentTrackingEntity equipmentTrackingEntity) {
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 2ba607df6ee0500a7ac51cefd076840ae35e4827..a13584db8c0902a8bcaba4e89d9fdfdfb95de0e9 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -1782,6 +1782,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
 
     protected void playAttackSound() {}
 
+    @Override
     public boolean isSunBurnTick() {
         // Purpur - implemented in Entity - API for any mob to burn daylight
         return super.isSunBurnTick();
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java b/src/main/java/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
index 8d4e206aa05b95b7bfec5d23496085cf55a3e1de..dbed59b16907f5e9fc43b6961e5b8aa73da3dc83 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
@@ -1,9 +1,6 @@
 package net.minecraft.world.entity.ai.behavior;
 
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.server.level.ServerLevel;
@@ -22,14 +19,15 @@ import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.gameevent.GameEvent;
-
-// CraftBukkit start
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.CropBlock;
 import net.minecraft.world.level.block.FarmBlock;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.gameevent.GameEvent;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
+
+import javax.annotation.Nullable;
+import java.util.List;
 // CraftBukkit end
 
 public class HarvestFarmland extends Behavior<Villager> {
@@ -40,20 +38,22 @@ public class HarvestFarmland extends Behavior<Villager> {
     private BlockPos aboveFarmlandPos;
     private long nextOkStartTime;
     private int timeWorkedSoFar;
-    private final List<BlockPos> validFarmlandAroundVillager = Lists.newArrayList();
+    private final List<BlockPos> validFarmlandAroundVillager = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private boolean clericWartFarmer = false; // Purpur
 
     public HarvestFarmland() {
         super(ImmutableMap.of(MemoryModuleType.LOOK_TARGET, MemoryStatus.VALUE_ABSENT, MemoryModuleType.WALK_TARGET, MemoryStatus.VALUE_ABSENT, MemoryModuleType.SECONDARY_JOB_SITE, MemoryStatus.VALUE_PRESENT));
     }
 
+    @Override
     protected boolean checkExtraStartConditions(ServerLevel world, Villager entity) {
         if (!world.purpurConfig.villagerBypassMobGriefing && !world.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) { // Purpur
             return false;
         } else if (entity.getVillagerData().getProfession() != VillagerProfession.FARMER && !(world.purpurConfig.villagerClericsFarmWarts && entity.getVillagerData().getProfession() == VillagerProfession.CLERIC)) { // Purpur
             return false;
         } else {
-            if (!this.clericWartFarmer && entity.getVillagerData().getProfession() == VillagerProfession.CLERIC) this.clericWartFarmer = true; // Purpur
+            if (!this.clericWartFarmer && entity.getVillagerData().getProfession() == VillagerProfession.CLERIC)
+                this.clericWartFarmer = true; // Purpur
             BlockPos.MutableBlockPos blockposition_mutableblockposition = entity.blockPosition().mutable();
 
             this.validFarmlandAroundVillager.clear();
@@ -84,10 +84,12 @@ public class HarvestFarmland extends Behavior<Villager> {
         Block block = iblockdata.getBlock();
         Block block1 = world.getBlockState(pos.below()).getBlock();
 
-        if (this.clericWartFarmer) return block == Blocks.NETHER_WART && iblockdata.getValue(net.minecraft.world.level.block.NetherWartBlock.AGE) == 3 || iblockdata.isAir() && block1 == Blocks.SOUL_SAND; // Purpur
+        if (this.clericWartFarmer)
+            return block == Blocks.NETHER_WART && iblockdata.getValue(net.minecraft.world.level.block.NetherWartBlock.AGE) == 3 || iblockdata.isAir() && block1 == Blocks.SOUL_SAND; // Purpur
         return block instanceof CropBlock && ((CropBlock) block).isMaxAge(iblockdata) || iblockdata.isAir() && block1 instanceof FarmBlock;
     }
 
+    @Override
     protected void start(ServerLevel worldserver, Villager entityvillager, long i) {
         if (i > this.nextOkStartTime && this.aboveFarmlandPos != null) {
             entityvillager.getBrain().setMemory(MemoryModuleType.LOOK_TARGET, (new BlockPosTracker(this.aboveFarmlandPos))); // CraftBukkit - decompile error
@@ -96,6 +98,7 @@ public class HarvestFarmland extends Behavior<Villager> {
 
     }
 
+    @Override
     protected void stop(ServerLevel world, Villager entity, long time) {
         entity.getBrain().eraseMemory(MemoryModuleType.LOOK_TARGET);
         entity.getBrain().eraseMemory(MemoryModuleType.WALK_TARGET);
@@ -103,6 +106,7 @@ public class HarvestFarmland extends Behavior<Villager> {
         this.nextOkStartTime = time + 40L;
     }
 
+    @Override
     protected void tick(ServerLevel world, Villager entity, long time) {
         if (this.aboveFarmlandPos == null || this.aboveFarmlandPos.closerToCenterThan(entity.position(), 1.0D)) {
             if (this.aboveFarmlandPos != null && time > this.nextOkStartTime) {
@@ -112,7 +116,7 @@ public class HarvestFarmland extends Behavior<Villager> {
 
                 if (block instanceof CropBlock && ((CropBlock) block).isMaxAge(iblockdata) && !this.clericWartFarmer || this.clericWartFarmer && block == Blocks.NETHER_WART && iblockdata.getValue(net.minecraft.world.level.block.NetherWartBlock.AGE) == 3) { // Purpur
                     if (CraftEventFactory.callEntityChangeBlockEvent(entity, this.aboveFarmlandPos, iblockdata.getFluidState().createLegacyBlock())) { // CraftBukkit // Paper - fix wrong block state
-                    world.destroyBlock(this.aboveFarmlandPos, true, entity);
+                        world.destroyBlock(this.aboveFarmlandPos, true, entity);
                     } // CraftBukkit
                 }
 
@@ -131,9 +135,9 @@ public class HarvestFarmland extends Behavior<Villager> {
                                 BlockState iblockdata1 = itemblock.getBlock().defaultBlockState();
 
                                 if (CraftEventFactory.callEntityChangeBlockEvent(entity, this.aboveFarmlandPos, iblockdata1)) { // CraftBukkit
-                                world.setBlockAndUpdate(this.aboveFarmlandPos, iblockdata1);
-                                world.gameEvent((Holder) GameEvent.BLOCK_PLACE, this.aboveFarmlandPos, GameEvent.Context.of(entity, iblockdata1));
-                                flag = true;
+                                    world.setBlockAndUpdate(this.aboveFarmlandPos, iblockdata1);
+                                    world.gameEvent((Holder) GameEvent.BLOCK_PLACE, this.aboveFarmlandPos, GameEvent.Context.of(entity, iblockdata1));
+                                    flag = true;
                                 } // CraftBukkit
                             }
                         }
@@ -164,6 +168,7 @@ public class HarvestFarmland extends Behavior<Villager> {
         }
     }
 
+    @Override
     protected boolean canStillUse(ServerLevel worldserver, Villager entityvillager, long i) {
         return this.timeWorkedSoFar < 200;
     }
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java b/src/main/java/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java
index a575ef70264337a20a47af8fd23c23565408a8df..ed3f1e6542a88bb1d7942cd6aaf5bc033bd62020 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/PrepareRamNearestTarget.java
@@ -1,15 +1,6 @@
 package net.minecraft.world.entity.ai.behavior;
 
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.function.Function;
-import java.util.function.ToIntFunction;
-import java.util.stream.Stream;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.server.level.ServerLevel;
@@ -34,6 +25,11 @@ import net.minecraft.world.phys.Vec3;
 import org.bukkit.craftbukkit.entity.CraftLivingEntity;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityTargetEvent;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.function.ToIntFunction;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public class PrepareRamNearestTarget<E extends PathfinderMob> extends Behavior<E> {
@@ -60,6 +56,7 @@ public class PrepareRamNearestTarget<E extends PathfinderMob> extends Behavior<E
         this.getPrepareRamSound = soundFactory;
     }
 
+    @Override
     protected void start(ServerLevel worldserver, PathfinderMob entitycreature, long i) {
         Brain<?> behaviorcontroller = entitycreature.getBrain();
 
@@ -79,6 +76,7 @@ public class PrepareRamNearestTarget<E extends PathfinderMob> extends Behavior<E
         });
     }
 
+    @Override
     protected void stop(ServerLevel world, E entity, long time) {
         Brain<?> behaviorcontroller = entity.getBrain();
 
@@ -89,10 +87,12 @@ public class PrepareRamNearestTarget<E extends PathfinderMob> extends Behavior<E
 
     }
 
+    @Override
     protected boolean canStillUse(ServerLevel worldserver, PathfinderMob entitycreature, long i) {
         return this.ramCandidate.isPresent() && ((PrepareRamNearestTarget.RamCandidate) this.ramCandidate.get()).getTarget().isAlive();
     }
 
+    @Override
     protected void tick(ServerLevel worldserver, E e0, long i) {
         if (!this.ramCandidate.isEmpty()) {
             e0.getBrain().setMemory(MemoryModuleType.WALK_TARGET, (new WalkTarget(((PrepareRamNearestTarget.RamCandidate) this.ramCandidate.get()).getStartPosition(), this.walkSpeed, 0))); // CraftBukkit - decompile error
@@ -137,7 +137,7 @@ public class PrepareRamNearestTarget<E extends PathfinderMob> extends Behavior<E
         if (!this.isWalkableBlock(entity, blockposition)) {
             return Optional.empty();
         } else {
-            List<BlockPos> list = Lists.newArrayList();
+            List<BlockPos> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             BlockPos.MutableBlockPos blockposition_mutableblockposition = blockposition.mutable();
             Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java b/src/main/java/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
index 6945992491027d43eca4f1ca697ad45ce06ded55..612406152fcc56489f2e39230f7502ed96ede894 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
@@ -1,9 +1,6 @@
 package net.minecraft.world.entity.ai.behavior;
 
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.EquipmentSlot;
@@ -15,12 +12,15 @@ import net.minecraft.world.entity.npc.Villager;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.trading.MerchantOffer;
 
+import javax.annotation.Nullable;
+import java.util.List;
+
 public class ShowTradesToPlayer extends Behavior<Villager> {
     private static final int MAX_LOOK_TIME = 900;
     private static final int STARTING_LOOK_TIME = 40;
     @Nullable
     private ItemStack playerItemStack;
-    private final List<ItemStack> displayItems = Lists.newArrayList();
+    private final List<ItemStack> displayItems = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private int cycleCounter;
     private int displayIndex;
     private int lookTime;
@@ -37,10 +37,10 @@ public class ShowTradesToPlayer extends Behavior<Villager> {
         } else {
             LivingEntity livingEntity = brain.getMemory(MemoryModuleType.INTERACTION_TARGET).get();
             return livingEntity.getType() == EntityType.PLAYER
-                && entity.isAlive()
-                && livingEntity.isAlive()
-                && !entity.isBaby()
-                && entity.distanceToSqr(livingEntity) <= 17.0;
+                    && entity.isAlive()
+                    && livingEntity.isAlive()
+                    && !entity.isBaby()
+                    && entity.distanceToSqr(livingEntity) <= 17.0;
         }
     }
 
@@ -48,8 +48,8 @@ public class ShowTradesToPlayer extends Behavior<Villager> {
     public boolean canStillUse(ServerLevel world, Villager entity, long time) {
         if (!entity.level().purpurConfig.villagerDisplayTradeItem) return false; // Purpur
         return this.checkExtraStartConditions(world, entity)
-            && this.lookTime > 0
-            && entity.getBrain().getMemory(MemoryModuleType.INTERACTION_TARGET).isPresent();
+                && this.lookTime > 0
+                && entity.getBrain().getMemory(MemoryModuleType.INTERACTION_TARGET).isPresent();
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java b/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java
index 3fac11bf02652b5f51f30f99bdf516504467d0d2..154d6e887926dff12eb51b9aeb5599e61d2953c5 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java
@@ -7,11 +7,12 @@ import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.DynamicOps;
+import net.minecraft.util.RandomSource;
+
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
 import java.util.stream.Stream;
-import net.minecraft.util.RandomSource;
 
 public class ShufflingList<U> implements Iterable<U> {
     protected final List<ShufflingList.WeightedEntry<U>> entries;
@@ -22,16 +23,18 @@ public class ShufflingList<U> implements Iterable<U> {
         // Paper start - Fix Concurrency issue in ShufflingList during worldgen
         this(true);
     }
+
     public ShufflingList(boolean isUnsafe) {
         this.isUnsafe = isUnsafe;
         // Paper end - Fix Concurrency issue in ShufflingList during worldgen
-        this.entries = Lists.newArrayList();
+        this.entries = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     }
 
     private ShufflingList(List<ShufflingList.WeightedEntry<U>> list) {
         // Paper start - Fix Concurrency issue in ShufflingList during worldgen
         this(list, true);
     }
+
     private ShufflingList(List<ShufflingList.WeightedEntry<U>> list, boolean isUnsafe) {
         this.isUnsafe = isUnsafe;
         // Paper end - Fix Concurrency issue in ShufflingList during worldgen
@@ -85,7 +88,7 @@ public class ShufflingList<U> implements Iterable<U> {
         }
 
         void setRandom(float random) {
-            this.randWeight = -Math.pow((double)random, (double)(1.0F / (float)this.weight));
+            this.randWeight = -Math.pow((double) random, (double) (1.0F / (float) this.weight));
         }
 
         public T getData() {
@@ -103,19 +106,21 @@ public class ShufflingList<U> implements Iterable<U> {
 
         public static <E> Codec<ShufflingList.WeightedEntry<E>> codec(Codec<E> codec) {
             return new Codec<ShufflingList.WeightedEntry<E>>() {
+                @Override
                 public <T> DataResult<Pair<ShufflingList.WeightedEntry<E>, T>> decode(DynamicOps<T> dynamicOps, T object) {
                     Dynamic<T> dynamic = new Dynamic<>(dynamicOps, object);
                     return dynamic.get("data")
-                        .flatMap(codec::parse)
-                        .map(data -> new ShufflingList.WeightedEntry<>(data, dynamic.get("weight").asInt(1)))
-                        .map(entry -> Pair.of((ShufflingList.WeightedEntry<E>)entry, dynamicOps.empty()));
+                            .flatMap(codec::parse)
+                            .map(data -> new ShufflingList.WeightedEntry<>(data, dynamic.get("weight").asInt(1)))
+                            .map(entry -> Pair.of((ShufflingList.WeightedEntry<E>) entry, dynamicOps.empty()));
                 }
 
+                @Override
                 public <T> DataResult<T> encode(ShufflingList.WeightedEntry<E> weightedEntry, DynamicOps<T> dynamicOps, T object) {
                     return dynamicOps.mapBuilder()
-                        .add("weight", dynamicOps.createInt(weightedEntry.weight))
-                        .add("data", codec.encodeStart(dynamicOps, weightedEntry.data))
-                        .build(object);
+                            .add("weight", dynamicOps.createInt(weightedEntry.weight))
+                            .add("data", codec.encodeStart(dynamicOps, weightedEntry.data))
+                            .build(object);
                 }
             };
         }
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
index 67f16bd710e0c04b4e2dac2c2cf5862853f3f4f4..2a58b2a3914c41f7c5a3ca7ec06f448115c60e1f 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
@@ -44,7 +44,7 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
                     // Gale start - optimize villager data storage
                     if (secondaryPoi == world.getBlockState(blockPos2).getBlock()) {
                         if (list == null) {
-                            list = Lists.newArrayList();
+                            list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                         }
                         // Gale end - optimize villager data storage
                         list.add(GlobalPos.of(resourceKey, blockPos2));
diff --git a/src/main/java/net/minecraft/world/entity/animal/Bee.java b/src/main/java/net/minecraft/world/entity/animal/Bee.java
index 1022ba7c522cc72cdbd73f7f98657072affebc01..04613da46ac3586bbadd73a4a252bb71af787863 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Bee.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Bee.java
@@ -1,17 +1,5 @@
 package net.minecraft.world.entity.animal;
 
-import com.google.common.collect.Lists;
-import java.util.Comparator;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.UUID;
-import java.util.function.Predicate;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.particles.ParticleTypes;
@@ -36,24 +24,11 @@ import net.minecraft.world.Difficulty;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.effect.MobEffects;
-import net.minecraft.world.entity.AgeableMob;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.NeutralMob;
-import net.minecraft.world.entity.PathfinderMob;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.control.FlyingMoveControl;
-import net.minecraft.world.entity.ai.control.LookControl;
-import net.minecraft.world.entity.ai.goal.BreedGoal;
-import net.minecraft.world.entity.ai.goal.FloatGoal;
-import net.minecraft.world.entity.ai.goal.FollowParentGoal;
-import net.minecraft.world.entity.ai.goal.Goal;
-import net.minecraft.world.entity.ai.goal.GoalSelector;
-import net.minecraft.world.entity.ai.goal.MeleeAttackGoal;
-import net.minecraft.world.entity.ai.goal.TemptGoal;
+import net.minecraft.world.entity.ai.goal.*;
 import net.minecraft.world.entity.ai.goal.target.HurtByTargetGoal;
 import net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal;
 import net.minecraft.world.entity.ai.goal.target.ResetUniversalAngerTargetGoal;
@@ -69,13 +44,7 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelReader;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.BonemealableBlock;
-import net.minecraft.world.level.block.CropBlock;
-import net.minecraft.world.level.block.DoublePlantBlock;
-import net.minecraft.world.level.block.StemBlock;
-import net.minecraft.world.level.block.SweetBerryBushBlock;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.entity.BeehiveBlockEntity;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.BlockEntityType;
@@ -86,10 +55,15 @@ import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.pathfinder.Path;
 import net.minecraft.world.level.pathfinder.PathType;
 import net.minecraft.world.phys.Vec3;
-// CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityPotionEffectEvent;
 import org.bukkit.event.entity.EntityTargetEvent;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public class Bee extends Animal implements NeutralMob, FlyingAnimal {
@@ -446,13 +420,14 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
             this.hurt(this.damageSources().drown(), 1.0F);
         }
 
-        if (flag && !this.level().purpurConfig.beeDiesAfterSting) setHasStung(false); else // Purpur
-        if (flag) {
-            ++this.timeSinceSting;
-            if (this.timeSinceSting % 5 == 0 && this.random.nextInt(Mth.clamp(1200 - this.timeSinceSting, 1, 1200)) == 0) {
-                this.hurt(this.damageSources().generic(), this.getHealth());
+        if (flag && !this.level().purpurConfig.beeDiesAfterSting) setHasStung(false);
+        else // Purpur
+            if (flag) {
+                ++this.timeSinceSting;
+                if (this.timeSinceSting % 5 == 0 && this.random.nextInt(Mth.clamp(1200 - this.timeSinceSting, 1, 1200)) == 0) {
+                    this.hurt(this.damageSources().generic(), this.getHealth());
+                }
             }
-        }
 
         if (!this.hasNectar()) {
             ++this.ticksWithoutNectarSinceExitingHive;
@@ -472,7 +447,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         if (this.hivePos == null) {
             return false;
         } else {
-            if (!this.level().isLoadedAndInBounds(this.hivePos)) return false; // Paper - Do not allow bees to load chunks for beehives
+            if (!this.level().isLoadedAndInBounds(this.hivePos))
+                return false; // Paper - Do not allow bees to load chunks for beehives
             BlockEntity tileentity = this.level().getBlockEntity(this.hivePos);
 
             return tileentity instanceof BeehiveBlockEntity && ((BeehiveBlockEntity) tileentity).isFireNearby();
@@ -527,7 +503,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     }
 
     private boolean doesHiveHaveSpace(BlockPos pos) {
-        if (!this.level().isLoadedAndInBounds(pos)) return false; // Paper - Do not allow bees to load chunks for beehives
+        if (!this.level().isLoadedAndInBounds(pos))
+            return false; // Paper - Do not allow bees to load chunks for beehives
         BlockEntity tileentity = this.level().getBlockEntity(pos);
 
         return tileentity instanceof BeehiveBlockEntity ? !((BeehiveBlockEntity) tileentity).isFull() : false;
@@ -599,7 +576,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         } else if (this.isTooFarAway(this.hivePos)) {
             return false;
         } else {
-            if (this.level().getChunkIfLoadedImmediately(this.hivePos.getX() >> 4, this.hivePos.getZ() >> 4) == null) return true; // Paper - just assume the hive is still there, no need to load the chunk(s)
+            if (this.level().getChunkIfLoadedImmediately(this.hivePos.getX() >> 4, this.hivePos.getZ() >> 4) == null)
+                return true; // Paper - just assume the hive is still there, no need to load the chunk(s)
             BlockEntity tileentity = this.level().getBlockEntity(this.hivePos);
 
             return tileentity != null && tileentity.getType() == BlockEntityType.BEEHIVE;
@@ -627,6 +605,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     }
 
     public net.kyori.adventure.util.TriState rollingOverride = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Rolling override
+
     public boolean isRolling() {
         return this.getFlag(2);
     }
@@ -689,7 +668,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     }
 
     @Override
-    protected void playStepSound(BlockPos pos, BlockState state) {}
+    protected void playStepSound(BlockPos pos, BlockState state) {
+    }
 
     @Override
     protected SoundEvent getAmbientSound() {
@@ -718,7 +698,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     }
 
     @Override
-    protected void checkFallDamage(double heightDifference, boolean onGround, BlockState state, BlockPos landedPosition) {}
+    protected void checkFallDamage(double heightDifference, boolean onGround, BlockState state, BlockPos landedPosition) {
+    }
 
     @Override
     public boolean isFlapping() {
@@ -743,7 +724,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
             // CraftBukkit start - Only stop pollinating if entity was damaged
             boolean result = super.hurt(source, amount);
             if (result && !this.level().isClientSide) {
-            // CraftBukkit end
+                // CraftBukkit end
                 this.beePollinateGoal.stopPollinating();
             }
 
@@ -913,7 +894,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                             this.setWantedPos();
                         }
 
-                        if (this.successfulPollinatingTicks == 0) new org.purpurmc.purpur.event.entity.BeeStartedPollinatingEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), io.papermc.paper.util.MCUtil.toLocation(Bee.this.level(), Bee.this.savedFlowerPos)).callEvent(); // Purpur
+                        if (this.successfulPollinatingTicks == 0)
+                            new org.purpurmc.purpur.event.entity.BeeStartedPollinatingEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), io.papermc.paper.util.MCUtil.toLocation(Bee.this.level(), Bee.this.savedFlowerPos)).callEvent(); // Purpur
                         ++this.successfulPollinatingTicks;
                         if (Bee.this.random.nextFloat() < 0.05F && this.successfulPollinatingTicks > this.lastSoundPlayedTick + 60) {
                             this.lastSoundPlayedTick = this.successfulPollinatingTicks;
@@ -1003,7 +985,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         @Override
         public boolean canBeeUse() {
             if (Bee.this.hasHive() && Bee.this.wantsToEnterHive() && Bee.this.hivePos.closerToCenterThan(Bee.this.position(), 2.0D)) {
-                if (!Bee.this.level().isLoadedAndInBounds(Bee.this.hivePos)) return false; // Paper - Do not allow bees to load chunks for beehives
+                if (!Bee.this.level().isLoadedAndInBounds(Bee.this.hivePos))
+                    return false; // Paper - Do not allow bees to load chunks for beehives
                 BlockEntity tileentity = Bee.this.level().getBlockEntity(Bee.this.hivePos);
 
                 if (tileentity instanceof BeehiveBlockEntity) {
@@ -1027,7 +1010,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
         @Override
         public void start() {
-            if (!Bee.this.level().isLoadedAndInBounds(Bee.this.hivePos)) return; // Paper - Do not allow bees to load chunks for beehives
+            if (!Bee.this.level().isLoadedAndInBounds(Bee.this.hivePos))
+                return; // Paper - Do not allow bees to load chunks for beehives
             BlockEntity tileentity = Bee.this.level().getBlockEntity(Bee.this.hivePos);
 
             if (tileentity instanceof BeehiveBlockEntity tileentitybeehive) {
@@ -1105,7 +1089,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         BeeGoToHiveGoal() {
             super();
             this.travellingTicks = Bee.this.random.nextInt(10); // CraftBukkit - SPIGOT-7495: Give Bees another chance and let them use their own random, avoid concurrency issues
-            this.blacklistedTargets = Lists.newArrayList();
+            this.blacklistedTargets = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             this.setFlags(EnumSet.of(Goal.Flag.MOVE));
         }
 
@@ -1433,7 +1417,8 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
     private abstract class BaseBeeGoal extends Goal {
 
-        BaseBeeGoal() {}
+        BaseBeeGoal() {
+        }
 
         public abstract boolean canBeeUse();
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/Fox.java b/src/main/java/net/minecraft/world/entity/animal/Fox.java
index 5d13c8827c0746d180b5a838b3f2be2cbd2cba14..4005462edf5ea666e2c807fe282e81beb606dbd1 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Fox.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Fox.java
@@ -1,14 +1,5 @@
 package net.minecraft.world.entity.animal;
 
-import com.google.common.collect.Lists;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Optional;
-import java.util.UUID;
-import java.util.function.IntFunction;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -38,39 +29,10 @@ import net.minecraft.util.StringRepresentable;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.AgeableMob;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityDimensions;
-import net.minecraft.world.entity.EntitySelector;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.ExperienceOrb;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.Pose;
-import net.minecraft.world.entity.SpawnGroupData;
-import net.minecraft.world.entity.TamableAnimal;
-import net.minecraft.world.entity.VariantHolder;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
-import net.minecraft.world.entity.ai.control.LookControl;
-import net.minecraft.world.entity.ai.control.MoveControl;
-import net.minecraft.world.entity.ai.goal.AvoidEntityGoal;
-import net.minecraft.world.entity.ai.goal.BreedGoal;
-import net.minecraft.world.entity.ai.goal.ClimbOnTopOfPowderSnowGoal;
-import net.minecraft.world.entity.ai.goal.FleeSunGoal;
-import net.minecraft.world.entity.ai.goal.FloatGoal;
-import net.minecraft.world.entity.ai.goal.FollowParentGoal;
-import net.minecraft.world.entity.ai.goal.Goal;
-import net.minecraft.world.entity.ai.goal.JumpGoal;
-import net.minecraft.world.entity.ai.goal.LeapAtTargetGoal;
-import net.minecraft.world.entity.ai.goal.LookAtPlayerGoal;
-import net.minecraft.world.entity.ai.goal.MeleeAttackGoal;
-import net.minecraft.world.entity.ai.goal.MoveToBlockGoal;
-import net.minecraft.world.entity.ai.goal.PanicGoal;
-import net.minecraft.world.entity.ai.goal.StrollThroughVillageGoal;
-import net.minecraft.world.entity.ai.goal.WaterAvoidingRandomStrollGoal;
+import net.minecraft.world.entity.ai.goal.*;
 import net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
 import net.minecraft.world.entity.item.ItemEntity;
@@ -78,11 +40,7 @@ import net.minecraft.world.entity.monster.Monster;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.LevelAccessor;
-import net.minecraft.world.level.LevelReader;
-import net.minecraft.world.level.ServerLevelAccessor;
+import net.minecraft.world.level.*;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
@@ -92,8 +50,12 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.pathfinder.PathType;
 import net.minecraft.world.phys.Vec3;
-// CraftBukkit start
 import org.bukkit.event.entity.EntityRemoveEvent;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
 // CraftBukkit end
 
 public class Fox extends Animal implements VariantHolder<Fox.Type> {
@@ -441,13 +403,14 @@ public class Fox extends Animal implements VariantHolder<Fox.Type> {
         return Fox.Type.byId((Integer) this.entityData.get(Fox.DATA_TYPE_ID));
     }
 
+    @Override
     public void setVariant(Fox.Type variant) {
         this.entityData.set(Fox.DATA_TYPE_ID, variant.getId());
         this.setTargetGoals(); // Purpur - fix API bug not updating pathfinders on type change
     }
 
     List<UUID> getTrustedUUIDs() {
-        List<UUID> list = Lists.newArrayList();
+        List<UUID> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         list.add((UUID) ((Optional) this.entityData.get(Fox.DATA_TRUSTED_ID_0)).orElse((Object) null));
         list.add((UUID) ((Optional) this.entityData.get(Fox.DATA_TRUSTED_ID_1)).orElse((Object) null));
@@ -515,8 +478,10 @@ public class Fox extends Animal implements VariantHolder<Fox.Type> {
         // Paper start - Add EntityToggleSitEvent
         this.setSitting(sitting, true);
     }
+
     public void setSitting(boolean sitting, boolean fireEvent) {
-        if (fireEvent && !new io.papermc.paper.event.entity.EntityToggleSitEvent(this.getBukkitEntity(), sitting).callEvent()) return;
+        if (fireEvent && !new io.papermc.paper.event.entity.EntityToggleSitEvent(this.getBukkitEntity(), sitting).callEvent())
+            return;
         // Paper end - Add EntityToggleSitEvent
         this.setFlag(1, sitting);
     }
@@ -1085,7 +1050,8 @@ public class Fox extends Animal implements VariantHolder<Fox.Type> {
 
     public class FoxPounceGoal extends JumpGoal {
 
-        public FoxPounceGoal() {}
+        public FoxPounceGoal() {
+        }
 
         @Override
         public boolean canUse() {
@@ -1675,7 +1641,8 @@ public class Fox extends Animal implements VariantHolder<Fox.Type> {
 
         private final TargetingConditions alertableTargeting = TargetingConditions.forCombat().range(12.0D).ignoreLineOfSight().selector(Fox.this.new FoxAlertableEntitiesSelector());
 
-        FoxBehaviorGoal() {}
+        FoxBehaviorGoal() {
+        }
 
         protected boolean hasShelter() {
             BlockPos blockposition = BlockPos.containing(Fox.this.getX(), Fox.this.getBoundingBox().maxY, Fox.this.getZ());
@@ -1690,8 +1657,10 @@ public class Fox extends Animal implements VariantHolder<Fox.Type> {
 
     public class FoxAlertableEntitiesSelector implements Predicate<LivingEntity> {
 
-        public FoxAlertableEntitiesSelector() {}
+        public FoxAlertableEntitiesSelector() {
+        }
 
+        @Override
         public boolean test(LivingEntity entityliving) {
             return entityliving instanceof Fox ? false : (!(entityliving instanceof Chicken) && !(entityliving instanceof Rabbit) && !(entityliving instanceof Monster) ? (entityliving instanceof TamableAnimal ? !((TamableAnimal) entityliving).isTame() : (entityliving instanceof Player && (entityliving.isSpectator() || ((Player) entityliving).isCreative()) ? false : (Fox.this.trusts(entityliving.getUUID()) ? false : !entityliving.isSleeping() && !entityliving.isDiscrete()))) : true);
         }
diff --git a/src/main/java/net/minecraft/world/entity/animal/Wolf.java b/src/main/java/net/minecraft/world/entity/animal/Wolf.java
index ba6036633c1977b7f41b3bd0dd31370924b4bf35..7265ce69e52270d478f3d06a807c8f49a18a4df9 100644
--- a/src/main/java/net/minecraft/world/entity/animal/Wolf.java
+++ b/src/main/java/net/minecraft/world/entity/animal/Wolf.java
@@ -169,6 +169,7 @@ public class Wolf extends TamableAnimal implements NeutralMob, VariantHolder<Hol
         return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.wolfRidableInWater;
     }
 
+    @Override
     public void onMount(Player rider) {
         super.onMount(rider);
         setInSittingPose(false);
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractChestedHorse.java b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractChestedHorse.java
index 5654c614f07f07ff642ba4851b0cb6fa185924ae..905ae7a99d83f6ab1ed18b0099f09acf41f762b6 100644
--- a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractChestedHorse.java
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractChestedHorse.java
@@ -76,6 +76,7 @@ public abstract class AbstractChestedHorse extends AbstractHorse {
     }
 
     // Paper start
+    @Override
     protected void postDeathDropItems(org.bukkit.event.entity.EntityDeathEvent event) {
         if (this.hasChest() && (event == null || !event.isCancelled())) {
             this.setChest(false);
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 573ec75b5fed1c3d30aa9dc64cf3a8a77ddfbcae..ccd5041df6531fe60562654a44a6aa57e0f10e21 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -1,10 +1,6 @@
 package net.minecraft.world.entity.boss.enderdragon;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
-import java.util.Iterator;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.nbt.CompoundTag;
@@ -21,13 +17,7 @@ import net.minecraft.tags.DamageTypeTags;
 import net.minecraft.util.Mth;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.effect.MobEffectInstance;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntitySelector;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.ExperienceOrb;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MoverType;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
@@ -37,33 +27,35 @@ import net.minecraft.world.entity.boss.enderdragon.phases.EnderDragonPhase;
 import net.minecraft.world.entity.boss.enderdragon.phases.EnderDragonPhaseManager;
 import net.minecraft.world.entity.monster.Enemy;
 import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import net.minecraft.world.level.Explosion;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.dimension.end.EndDragonFight;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.feature.EndPodiumFeature;
 import net.minecraft.world.level.pathfinder.BinaryHeap;
 import net.minecraft.world.level.pathfinder.Node;
 import net.minecraft.world.level.pathfinder.Path;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.enchantment.EnchantmentHelper;
-import net.minecraft.world.level.Explosion;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.entity.BlockEntity;
-import net.minecraft.world.level.block.state.BlockState;
-import net.minecraft.world.level.dimension.end.EndDragonFight;
 import net.minecraft.world.level.storage.loot.LootParams;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityExplodeEvent;
 import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.entity.EntityRemoveEvent;
-import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
 // CraftBukkit end
 
 public class EnderDragon extends Mob implements Enemy {
@@ -817,7 +809,8 @@ public class EnderDragon extends Mob implements Enemy {
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
                     final double soundRadiusSquared = this.level().getGlobalSoundRangeSquared(config -> config.dragonDeathSoundRadius); // Paper - respect global sound events gamerule
-                    if ( !this.level().getGameRules().getBoolean(GameRules.RULE_GLOBAL_SOUND_EVENTS) && distanceSquared > soundRadiusSquared ) continue; // Spigot // Paper - respect global sound events gamerule
+                    if (!this.level().getGameRules().getBoolean(GameRules.RULE_GLOBAL_SOUND_EVENTS) && distanceSquared > soundRadiusSquared)
+                        continue; // Spigot // Paper - respect global sound events gamerule
                     if (distanceSquared > viewDistance * viewDistance) {
                         double deltaLength = Math.sqrt(distanceSquared);
                         double relativeX = player.getX() + (deltaX / deltaLength) * viewDistance;
@@ -1036,7 +1029,7 @@ public class EnderDragon extends Mob implements Enemy {
     }
 
     private Path reconstructPath(Node unused, Node node) {
-        List<Node> list = Lists.newArrayList();
+        List<Node> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Node pathpoint2 = node;
 
         list.add(0, node);
@@ -1076,7 +1069,8 @@ public class EnderDragon extends Mob implements Enemy {
     }
 
     @Override
-    public void checkDespawn() {}
+    public void checkDespawn() {
+    }
 
     public EnderDragonPart[] getSubEntities() {
         return this.subEntities;
diff --git a/src/main/java/net/minecraft/world/entity/decoration/Painting.java b/src/main/java/net/minecraft/world/entity/decoration/Painting.java
index f45567aa7695da68f92809a6c208eb515c2f838a..503f96d8ace834d89e170f2806be6946af6cadc5 100644
--- a/src/main/java/net/minecraft/world/entity/decoration/Painting.java
+++ b/src/main/java/net/minecraft/world/entity/decoration/Painting.java
@@ -2,11 +2,6 @@ package net.minecraft.world.entity.decoration;
 
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -30,11 +25,15 @@ import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+
 public class Painting extends HangingEntity implements VariantHolder<Holder<PaintingVariant>> {
 
     private static final EntityDataAccessor<Holder<PaintingVariant>> DATA_PAINTING_VARIANT_ID = SynchedEntityData.defineId(Painting.class, EntityDataSerializers.PAINTING_VARIANT);
@@ -59,6 +58,7 @@ public class Painting extends HangingEntity implements VariantHolder<Holder<Pain
 
     }
 
+    @Override
     public void setVariant(Holder<PaintingVariant> variant) {
         this.entityData.set(Painting.DATA_PAINTING_VARIANT_ID, variant);
     }
@@ -70,7 +70,7 @@ public class Painting extends HangingEntity implements VariantHolder<Holder<Pain
 
     public static Optional<Painting> create(Level world, BlockPos pos, Direction facing) {
         Painting entitypainting = new Painting(world, pos);
-        List<Holder<PaintingVariant>> list = new ArrayList();
+        List<Holder<PaintingVariant>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Iterable<Holder<PaintingVariant>> iterable = world.registryAccess().registryOrThrow(Registries.PAINTING_VARIANT).getTagOrEmpty(PaintingVariantTags.PLACEABLE); // CraftBukkit - decompile error
 
         Objects.requireNonNull(list);
diff --git a/src/main/java/net/minecraft/world/entity/monster/AbstractSkeleton.java b/src/main/java/net/minecraft/world/entity/monster/AbstractSkeleton.java
index f9532a45419699585d1f20d27d5857a3e953ec55..2e352544ef441bc1e33744fbb4fca26bfc775a43 100644
--- a/src/main/java/net/minecraft/world/entity/monster/AbstractSkeleton.java
+++ b/src/main/java/net/minecraft/world/entity/monster/AbstractSkeleton.java
@@ -98,7 +98,9 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
 
     // Paper start - shouldBurnInDay API
     //private boolean shouldBurnInDay = true; // Purpur - moved to LivingEntity; keep methods for ABI compatibility - API for any mob to burn daylight
+    @Override
     public boolean shouldBurnInDay() { return shouldBurnInDay; }
+    @Override
     public void setShouldBurnInDay(boolean shouldBurnInDay) { this.shouldBurnInDay = shouldBurnInDay; }
     // Paper end - shouldBurnInDay API
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Phantom.java b/src/main/java/net/minecraft/world/entity/monster/Phantom.java
index 493e9ee0585ae419caffaa163f4975ab6408fad8..9d2ee37a787a0b33a89a38022d5df817bdcfe070 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Phantom.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Phantom.java
@@ -360,12 +360,14 @@ public class Phantom extends FlyingMob implements Enemy {
     public void setSpawningEntity(java.util.UUID entity) { this.spawningEntity = entity; }
     //private boolean shouldBurnInDay = true; // Purpur - moved to LivingEntity; keep methods for ABI compatibility - API for any mob to burn daylight
     // Purpur start - API for any mob to burn daylight
+    @Override
     public boolean shouldBurnInDay() {
         boolean burnFromDaylight = this.shouldBurnInDay && this.level().purpurConfig.phantomBurnInDaylight;
         boolean burnFromLightSource = this.level().purpurConfig.phantomBurnInLight > 0 && this.level().getMaxLocalRawBrightness(blockPosition()) >= this.level().purpurConfig.phantomBurnInLight;
         return burnFromDaylight || burnFromLightSource;
     }
     // Purpur end - API for any mob to burn daylight
+    @Override
     public void setShouldBurnInDay(boolean shouldBurnInDay) { this.shouldBurnInDay = shouldBurnInDay; }
     // Paper end
 
diff --git a/src/main/java/net/minecraft/world/entity/monster/Zombie.java b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
index 776e0295f0ba38157cabdc7ab5d0a3f845bad158..bbbcf1b8f9bce5b2917781513224daefe68baa34 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Zombie.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Zombie.java
@@ -346,12 +346,14 @@ public class Zombie extends Monster {
 
     }
 
+    @Override
     public boolean shouldBurnInDay() { return this.isSunSensitive(); } // Purpur - for ABI compatibility - API for any mob to burn daylight
     public boolean isSunSensitive() {
         return this.shouldBurnInDay; // Paper - Add more Zombie API
     }
 
     // Paper start - Add more Zombie API
+    @Override
     public void setShouldBurnInDay(boolean shouldBurnInDay) {
         this.shouldBurnInDay = shouldBurnInDay;
     }
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
index 3d792957f27fd4bdfad8d76262a8e2a2012bf35f..cfe175136d3feeff59ed81e285c58e0703ebf5b1 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
@@ -6,18 +6,9 @@ import com.mojang.datafixers.util.Pair;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Optional;
-import java.util.UUID;
-import java.util.function.Predicate;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import net.minecraft.core.UUIDUtil;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.ExtraCodecs;
@@ -27,6 +18,11 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.player.Player;
 
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
 public class AngerManagement {
     @VisibleForTesting
     protected static final int CONVERSION_DELAY = 2;
@@ -36,10 +32,10 @@ public class AngerManagement {
     private int conversionDelay = Mth.randomBetweenInclusive(RandomSource.create(), 0, 2);
     int highestAnger;
     private static final Codec<Pair<UUID, Integer>> SUSPECT_ANGER_PAIR = RecordCodecBuilder.create(
-        instance -> instance.group(
-                    UUIDUtil.CODEC.fieldOf("uuid").forGetter(Pair::getFirst), ExtraCodecs.NON_NEGATIVE_INT.fieldOf("anger").forGetter(Pair::getSecond)
-                )
-                .apply(instance, Pair::of)
+            instance -> instance.group(
+                            UUIDUtil.CODEC.fieldOf("uuid").forGetter(Pair::getFirst), ExtraCodecs.NON_NEGATIVE_INT.fieldOf("anger").forGetter(Pair::getSecond)
+                    )
+                    .apply(instance, Pair::of)
     );
     private final Predicate<Entity> filter;
     @VisibleForTesting
@@ -52,16 +48,16 @@ public class AngerManagement {
 
     public static Codec<AngerManagement> codec(Predicate<Entity> suspectPredicate) {
         return RecordCodecBuilder.create(
-            instance -> instance.group(
-                        SUSPECT_ANGER_PAIR.listOf().fieldOf("suspects").orElse(Collections.emptyList()).forGetter(AngerManagement::createUuidAngerPairs)
-                    )
-                    .apply(instance, suspectUuidsToAngerLevel -> new AngerManagement(suspectPredicate, suspectUuidsToAngerLevel))
+                instance -> instance.group(
+                                SUSPECT_ANGER_PAIR.listOf().fieldOf("suspects").orElse(Collections.emptyList()).forGetter(AngerManagement::createUuidAngerPairs)
+                        )
+                        .apply(instance, suspectUuidsToAngerLevel -> new AngerManagement(suspectPredicate, suspectUuidsToAngerLevel))
         );
     }
 
     public AngerManagement(Predicate<Entity> suspectPredicate, List<Pair<UUID, Integer>> suspectUuidsToAngerLevel) {
         this.filter = suspectPredicate;
-        this.suspects = new ArrayList<>();
+        this.suspects = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.suspectSorter = new AngerManagement.Sorter(this);
         this.angerBySuspect = new Object2IntOpenHashMap<>();
         this.angerByUuid = new Object2IntOpenHashMap<>(suspectUuidsToAngerLevel.size());
@@ -70,10 +66,10 @@ public class AngerManagement {
 
     private List<Pair<UUID, Integer>> createUuidAngerPairs() {
         return Streams.<Pair<UUID, Integer>>concat(
-                this.suspects.stream().map(suspect -> Pair.of(suspect.getUUID(), this.angerBySuspect.getInt(suspect))),
-                this.angerByUuid.object2IntEntrySet().stream().map(suspect -> Pair.of(suspect.getKey(), suspect.getIntValue()))
-            )
-            .collect(Collectors.toList());
+                        this.suspects.stream().map(suspect -> Pair.of(suspect.getUUID(), this.angerBySuspect.getInt(suspect))),
+                        this.angerByUuid.object2IntEntrySet().stream().map(suspect -> Pair.of(suspect.getKey(), suspect.getIntValue()))
+                )
+                .collect(Collectors.toList());
     }
 
     public void tick(ServerLevel world, Predicate<Entity> suspectPredicate) {
@@ -174,7 +170,7 @@ public class AngerManagement {
     }
 
     public Optional<LivingEntity> getActiveEntity() {
-        return Optional.ofNullable(this.getTopSuspect()).filter(suspect -> suspect instanceof LivingEntity).map(suspect -> (LivingEntity)suspect);
+        return Optional.ofNullable(this.getTopSuspect()).filter(suspect -> suspect instanceof LivingEntity).map(suspect -> (LivingEntity) suspect);
     }
 
     @VisibleForTesting
diff --git a/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
index 73a222d91dab1d5d1390b018f9537624aaff0798..d55a723d636f911b405432e821ad3c71c5b6b66e 100644
--- a/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
+++ b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
@@ -2,16 +2,9 @@ package net.minecraft.world.entity.npc;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -32,13 +25,7 @@ import net.minecraft.util.RandomSource;
 import net.minecraft.world.effect.MobEffect;
 import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.item.DyeColor;
-import net.minecraft.world.item.DyeItem;
-import net.minecraft.world.item.EnchantedBookItem;
-import net.minecraft.world.item.Item;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
-import net.minecraft.world.item.MapItem;
+import net.minecraft.world.item.*;
 import net.minecraft.world.item.alchemy.Potion;
 import net.minecraft.world.item.alchemy.PotionContents;
 import net.minecraft.world.item.alchemy.Potions;
@@ -61,6 +48,13 @@ import net.minecraft.world.level.saveddata.maps.MapDecorationTypes;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
 import org.apache.commons.lang3.tuple.Pair;
 
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
 public class VillagerTrades {
     private static final int DEFAULT_SUPPLY = 12;
     private static final int COMMON_ITEMS_SUPPLY = 16;
@@ -77,1310 +71,1310 @@ public class VillagerTrades {
     private static final float LOW_TIER_PRICE_MULTIPLIER = 0.05F;
     private static final float HIGH_TIER_PRICE_MULTIPLIER = 0.2F;
     public static final Map<VillagerProfession, Int2ObjectMap<VillagerTrades.ItemListing[]>> TRADES = Util.make(
-        Maps.newHashMap(),
-        map -> {
-            map.put(
-                VillagerProfession.FARMER,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.WHEAT, 20, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Items.POTATO, 26, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Items.CARROT, 22, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Items.BEETROOT, 15, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(Items.BREAD, 1, 6, 16, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Blocks.PUMPKIN, 6, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN_PIE, 1, 4, 5),
-                            new VillagerTrades.ItemsForEmeralds(Items.APPLE, 1, 4, 16, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.ItemsForEmeralds(Items.COOKIE, 3, 18, 10), new VillagerTrades.EmeraldForItems(Blocks.MELON, 4, 12, 20)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.ItemsForEmeralds(Blocks.CAKE, 1, 1, 12, 15),
-                            new VillagerTrades.SuspiciousStewForEmerald(MobEffects.NIGHT_VISION, 100, 15),
-                            new VillagerTrades.SuspiciousStewForEmerald(MobEffects.JUMP, 160, 15),
-                            new VillagerTrades.SuspiciousStewForEmerald(MobEffects.WEAKNESS, 140, 15),
-                            new VillagerTrades.SuspiciousStewForEmerald(MobEffects.BLINDNESS, 120, 15),
-                            new VillagerTrades.SuspiciousStewForEmerald(MobEffects.POISON, 280, 15),
-                            new VillagerTrades.SuspiciousStewForEmerald(MobEffects.SATURATION, 7, 15)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.ItemsForEmeralds(Items.GOLDEN_CARROT, 3, 3, 30),
-                            new VillagerTrades.ItemsForEmeralds(Items.GLISTERING_MELON_SLICE, 4, 3, 30)
-                        }
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.FISHERMAN,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.STRING, 20, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Items.COAL, 10, 16, 2),
-                            new VillagerTrades.ItemsAndEmeraldsToItems(Items.COD, 6, 1, Items.COOKED_COD, 6, 16, 1, 0.05F),
-                            new VillagerTrades.ItemsForEmeralds(Items.COD_BUCKET, 3, 1, 16, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.COD, 15, 16, 10),
-                            new VillagerTrades.ItemsAndEmeraldsToItems(Items.SALMON, 6, 1, Items.COOKED_SALMON, 6, 16, 5, 0.05F),
-                            new VillagerTrades.ItemsForEmeralds(Items.CAMPFIRE, 2, 1, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.SALMON, 13, 16, 20),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.FISHING_ROD, 3, 3, 10, 0.2F)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.TROPICAL_FISH, 6, 12, 30)},
-                        5,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.PUFFERFISH, 4, 12, 30),
-                            new VillagerTrades.EmeraldsForVillagerTypeItem(
-                                1,
-                                12,
-                                30,
-                                ImmutableMap.<VillagerType, Item>builder()
-                                    .put(VillagerType.PLAINS, Items.OAK_BOAT)
-                                    .put(VillagerType.TAIGA, Items.SPRUCE_BOAT)
-                                    .put(VillagerType.SNOW, Items.SPRUCE_BOAT)
-                                    .put(VillagerType.DESERT, Items.JUNGLE_BOAT)
-                                    .put(VillagerType.JUNGLE, Items.JUNGLE_BOAT)
-                                    .put(VillagerType.SAVANNA, Items.ACACIA_BOAT)
-                                    .put(VillagerType.SWAMP, Items.DARK_OAK_BOAT)
-                                    .build()
-                            )
-                        }
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.SHEPHERD,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Blocks.WHITE_WOOL, 18, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Blocks.BROWN_WOOL, 18, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Blocks.BLACK_WOOL, 18, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Blocks.GRAY_WOOL, 18, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(Items.SHEARS, 2, 1, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.WHITE_DYE, 12, 16, 10),
-                            new VillagerTrades.EmeraldForItems(Items.GRAY_DYE, 12, 16, 10),
-                            new VillagerTrades.EmeraldForItems(Items.BLACK_DYE, 12, 16, 10),
-                            new VillagerTrades.EmeraldForItems(Items.LIGHT_BLUE_DYE, 12, 16, 10),
-                            new VillagerTrades.EmeraldForItems(Items.LIME_DYE, 12, 16, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIME_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PINK_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.RED_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_WOOL, 1, 1, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIME_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PINK_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.RED_CARPET, 1, 4, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_CARPET, 1, 4, 16, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.YELLOW_DYE, 12, 16, 20),
-                            new VillagerTrades.EmeraldForItems(Items.LIGHT_GRAY_DYE, 12, 16, 20),
-                            new VillagerTrades.EmeraldForItems(Items.ORANGE_DYE, 12, 16, 20),
-                            new VillagerTrades.EmeraldForItems(Items.RED_DYE, 12, 16, 20),
-                            new VillagerTrades.EmeraldForItems(Items.PINK_DYE, 12, 16, 20),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.RED_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIME_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PINK_BED, 3, 1, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_BED, 3, 1, 12, 10)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.BROWN_DYE, 12, 16, 30),
-                            new VillagerTrades.EmeraldForItems(Items.PURPLE_DYE, 12, 16, 30),
-                            new VillagerTrades.EmeraldForItems(Items.BLUE_DYE, 12, 16, 30),
-                            new VillagerTrades.EmeraldForItems(Items.GREEN_DYE, 12, 16, 30),
-                            new VillagerTrades.EmeraldForItems(Items.MAGENTA_DYE, 12, 16, 30),
-                            new VillagerTrades.EmeraldForItems(Items.CYAN_DYE, 12, 16, 30),
-                            new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 12, 15)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.PAINTING, 2, 3, 30)}
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.FLETCHER,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.STICK, 32, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(Items.ARROW, 1, 16, 1),
-                            new VillagerTrades.ItemsAndEmeraldsToItems(Blocks.GRAVEL, 10, 1, Items.FLINT, 10, 12, 1, 0.05F)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.FLINT, 26, 12, 10), new VillagerTrades.ItemsForEmeralds(Items.BOW, 2, 1, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.STRING, 14, 16, 20), new VillagerTrades.ItemsForEmeralds(Items.CROSSBOW, 3, 1, 10)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.FEATHER, 24, 16, 30), new VillagerTrades.EnchantedItemForEmeralds(Items.BOW, 2, 3, 15)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.TRIPWIRE_HOOK, 8, 12, 30),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.CROSSBOW, 3, 3, 15),
-                            new VillagerTrades.TippedArrowForItemsAndEmeralds(Items.ARROW, 5, Items.TIPPED_ARROW, 5, 2, 12, 30)
-                        }
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.LIBRARIAN,
-                toIntMap(
-                    ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder()
-                        .put(
-                            1,
-                            new VillagerTrades.ItemListing[]{
-                                new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2),
-                                new VillagerTrades.EnchantBookForEmeralds(1, EnchantmentTags.TRADEABLE),
-                                new VillagerTrades.ItemsForEmeralds(Blocks.BOOKSHELF, 9, 1, 12, 1)
-                            }
+            Maps.newHashMap(),
+            map -> {
+                map.put(
+                        VillagerProfession.FARMER,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.WHEAT, 20, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Items.POTATO, 26, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Items.CARROT, 22, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Items.BEETROOT, 15, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(Items.BREAD, 1, 6, 16, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Blocks.PUMPKIN, 6, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN_PIE, 1, 4, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Items.APPLE, 1, 4, 16, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.ItemsForEmeralds(Items.COOKIE, 3, 18, 10), new VillagerTrades.EmeraldForItems(Blocks.MELON, 4, 12, 20)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.CAKE, 1, 1, 12, 15),
+                                                new VillagerTrades.SuspiciousStewForEmerald(MobEffects.NIGHT_VISION, 100, 15),
+                                                new VillagerTrades.SuspiciousStewForEmerald(MobEffects.JUMP, 160, 15),
+                                                new VillagerTrades.SuspiciousStewForEmerald(MobEffects.WEAKNESS, 140, 15),
+                                                new VillagerTrades.SuspiciousStewForEmerald(MobEffects.BLINDNESS, 120, 15),
+                                                new VillagerTrades.SuspiciousStewForEmerald(MobEffects.POISON, 280, 15),
+                                                new VillagerTrades.SuspiciousStewForEmerald(MobEffects.SATURATION, 7, 15)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.ItemsForEmeralds(Items.GOLDEN_CARROT, 3, 3, 30),
+                                                new VillagerTrades.ItemsForEmeralds(Items.GLISTERING_MELON_SLICE, 4, 3, 30)
+                                        }
+                                )
                         )
-                        .put(
-                            2,
-                            new VillagerTrades.ItemListing[]{
-                                new VillagerTrades.EmeraldForItems(Items.BOOK, 4, 12, 10),
-                                new VillagerTrades.EnchantBookForEmeralds(5, EnchantmentTags.TRADEABLE),
-                                new VillagerTrades.ItemsForEmeralds(Items.LANTERN, 1, 1, 5)
-                            }
+                );
+                map.put(
+                        VillagerProfession.FISHERMAN,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.STRING, 20, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Items.COAL, 10, 16, 2),
+                                                new VillagerTrades.ItemsAndEmeraldsToItems(Items.COD, 6, 1, Items.COOKED_COD, 6, 16, 1, 0.05F),
+                                                new VillagerTrades.ItemsForEmeralds(Items.COD_BUCKET, 3, 1, 16, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.COD, 15, 16, 10),
+                                                new VillagerTrades.ItemsAndEmeraldsToItems(Items.SALMON, 6, 1, Items.COOKED_SALMON, 6, 16, 5, 0.05F),
+                                                new VillagerTrades.ItemsForEmeralds(Items.CAMPFIRE, 2, 1, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.SALMON, 13, 16, 20),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.FISHING_ROD, 3, 3, 10, 0.2F)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.TROPICAL_FISH, 6, 12, 30)},
+                                        5,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.PUFFERFISH, 4, 12, 30),
+                                                new VillagerTrades.EmeraldsForVillagerTypeItem(
+                                                        1,
+                                                        12,
+                                                        30,
+                                                        ImmutableMap.<VillagerType, Item>builder()
+                                                                .put(VillagerType.PLAINS, Items.OAK_BOAT)
+                                                                .put(VillagerType.TAIGA, Items.SPRUCE_BOAT)
+                                                                .put(VillagerType.SNOW, Items.SPRUCE_BOAT)
+                                                                .put(VillagerType.DESERT, Items.JUNGLE_BOAT)
+                                                                .put(VillagerType.JUNGLE, Items.JUNGLE_BOAT)
+                                                                .put(VillagerType.SAVANNA, Items.ACACIA_BOAT)
+                                                                .put(VillagerType.SWAMP, Items.DARK_OAK_BOAT)
+                                                                .build()
+                                                )
+                                        }
+                                )
                         )
-                        .put(
-                            3,
-                            new VillagerTrades.ItemListing[]{
-                                new VillagerTrades.EmeraldForItems(Items.INK_SAC, 5, 12, 20),
-                                new VillagerTrades.EnchantBookForEmeralds(10, EnchantmentTags.TRADEABLE),
-                                new VillagerTrades.ItemsForEmeralds(Items.GLASS, 1, 4, 10)
-                            }
+                );
+                map.put(
+                        VillagerProfession.SHEPHERD,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Blocks.WHITE_WOOL, 18, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Blocks.BROWN_WOOL, 18, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Blocks.BLACK_WOOL, 18, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Blocks.GRAY_WOOL, 18, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(Items.SHEARS, 2, 1, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.WHITE_DYE, 12, 16, 10),
+                                                new VillagerTrades.EmeraldForItems(Items.GRAY_DYE, 12, 16, 10),
+                                                new VillagerTrades.EmeraldForItems(Items.BLACK_DYE, 12, 16, 10),
+                                                new VillagerTrades.EmeraldForItems(Items.LIGHT_BLUE_DYE, 12, 16, 10),
+                                                new VillagerTrades.EmeraldForItems(Items.LIME_DYE, 12, 16, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIME_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PINK_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.RED_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_WOOL, 1, 1, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIME_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PINK_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.RED_CARPET, 1, 4, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_CARPET, 1, 4, 16, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.YELLOW_DYE, 12, 16, 20),
+                                                new VillagerTrades.EmeraldForItems(Items.LIGHT_GRAY_DYE, 12, 16, 20),
+                                                new VillagerTrades.EmeraldForItems(Items.ORANGE_DYE, 12, 16, 20),
+                                                new VillagerTrades.EmeraldForItems(Items.RED_DYE, 12, 16, 20),
+                                                new VillagerTrades.EmeraldForItems(Items.PINK_DYE, 12, 16, 20),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.RED_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIME_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PINK_BED, 3, 1, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_BED, 3, 1, 12, 10)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.BROWN_DYE, 12, 16, 30),
+                                                new VillagerTrades.EmeraldForItems(Items.PURPLE_DYE, 12, 16, 30),
+                                                new VillagerTrades.EmeraldForItems(Items.BLUE_DYE, 12, 16, 30),
+                                                new VillagerTrades.EmeraldForItems(Items.GREEN_DYE, 12, 16, 30),
+                                                new VillagerTrades.EmeraldForItems(Items.MAGENTA_DYE, 12, 16, 30),
+                                                new VillagerTrades.EmeraldForItems(Items.CYAN_DYE, 12, 16, 30),
+                                                new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 12, 15)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.PAINTING, 2, 3, 30)}
+                                )
                         )
-                        .put(
-                            4,
-                            new VillagerTrades.ItemListing[]{
-                                new VillagerTrades.EmeraldForItems(Items.WRITABLE_BOOK, 2, 12, 30),
-                                new VillagerTrades.EnchantBookForEmeralds(15, EnchantmentTags.TRADEABLE),
-                                new VillagerTrades.ItemsForEmeralds(Items.CLOCK, 5, 1, 15),
-                                new VillagerTrades.ItemsForEmeralds(Items.COMPASS, 4, 1, 15)
-                            }
+                );
+                map.put(
+                        VillagerProfession.FLETCHER,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.STICK, 32, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(Items.ARROW, 1, 16, 1),
+                                                new VillagerTrades.ItemsAndEmeraldsToItems(Blocks.GRAVEL, 10, 1, Items.FLINT, 10, 12, 1, 0.05F)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.FLINT, 26, 12, 10), new VillagerTrades.ItemsForEmeralds(Items.BOW, 2, 1, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.STRING, 14, 16, 20), new VillagerTrades.ItemsForEmeralds(Items.CROSSBOW, 3, 1, 10)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.FEATHER, 24, 16, 30), new VillagerTrades.EnchantedItemForEmeralds(Items.BOW, 2, 3, 15)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.TRIPWIRE_HOOK, 8, 12, 30),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.CROSSBOW, 3, 3, 15),
+                                                new VillagerTrades.TippedArrowForItemsAndEmeralds(Items.ARROW, 5, Items.TIPPED_ARROW, 5, 2, 12, 30)
+                                        }
+                                )
                         )
-                        .put(5, new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.NAME_TAG, 20, 1, 30)})
-                        .build()
-                )
-            );
-            map.put(
-                VillagerProfession.CARTOGRAPHER,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.MAP, 7, 1, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.GLASS_PANE, 11, 16, 10),
-                            new VillagerTrades.TreasureMapForEmeralds(
-                                13, StructureTags.ON_OCEAN_EXPLORER_MAPS, "filled_map.monument", MapDecorationTypes.OCEAN_MONUMENT, 12, 5
-                            )
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.COMPASS, 1, 12, 20),
-                            new VillagerTrades.TreasureMapForEmeralds(
-                                14, StructureTags.ON_WOODLAND_EXPLORER_MAPS, "filled_map.mansion", MapDecorationTypes.WOODLAND_MANSION, 12, 10
-                            ),
-                            new VillagerTrades.TreasureMapForEmeralds(
-                                12, StructureTags.ON_TRIAL_CHAMBERS_MAPS, "filled_map.trial_chambers", MapDecorationTypes.TRIAL_CHAMBERS, 12, 10
-                            )
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.ItemsForEmeralds(Items.ITEM_FRAME, 7, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 15),
-                            new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 15)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.GLOBE_BANNER_PATTERN, 8, 1, 30)}
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.CLERIC,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.ROTTEN_FLESH, 32, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.REDSTONE, 1, 2, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.GOLD_INGOT, 3, 12, 10), new VillagerTrades.ItemsForEmeralds(Items.LAPIS_LAZULI, 1, 1, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.RABBIT_FOOT, 2, 12, 20),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GLOWSTONE, 4, 1, 12, 10)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.TURTLE_SCUTE, 4, 12, 30),
-                            new VillagerTrades.EmeraldForItems(Items.GLASS_BOTTLE, 9, 12, 30),
-                            new VillagerTrades.ItemsForEmeralds(Items.ENDER_PEARL, 5, 1, 15)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.NETHER_WART, 22, 12, 30),
-                            new VillagerTrades.ItemsForEmeralds(Items.EXPERIENCE_BOTTLE, 3, 1, 30)
-                        }
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.ARMORER,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_LEGGINGS), 7, 1, 12, 1, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_BOOTS), 4, 1, 12, 1, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_HELMET), 5, 1, 12, 1, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_CHESTPLATE), 9, 1, 12, 1, 0.2F)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 4, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.BELL), 36, 1, 12, 5, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_BOOTS), 1, 1, 12, 5, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_LEGGINGS), 3, 1, 12, 5, 0.2F)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.LAVA_BUCKET, 1, 12, 20),
-                            new VillagerTrades.EmeraldForItems(Items.DIAMOND, 1, 12, 20),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_HELMET), 1, 1, 12, 10, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_CHESTPLATE), 4, 1, 12, 10, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.SHIELD), 5, 1, 12, 10, 0.2F)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_LEGGINGS, 14, 3, 15, 0.2F),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_BOOTS, 8, 3, 15, 0.2F)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_HELMET, 8, 3, 30, 0.2F),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_CHESTPLATE, 16, 3, 30, 0.2F)
-                        }
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.WEAPONSMITH,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_AXE), 3, 1, 12, 1, 0.2F),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_SWORD, 2, 3, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 4, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.BELL), 36, 1, 12, 5, 0.2F)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.FLINT, 24, 12, 20)},
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.DIAMOND, 1, 12, 30),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_AXE, 12, 3, 15, 0.2F)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_SWORD, 8, 3, 30, 0.2F)}
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.TOOLSMITH,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_AXE), 1, 1, 12, 1, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_SHOVEL), 1, 1, 12, 1, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_PICKAXE), 1, 1, 12, 1, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_HOE), 1, 1, 12, 1, 0.2F)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 4, 12, 10),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.BELL), 36, 1, 12, 5, 0.2F)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.FLINT, 30, 12, 20),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_AXE, 1, 3, 10, 0.2F),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_SHOVEL, 2, 3, 10, 0.2F),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_PICKAXE, 3, 3, 10, 0.2F),
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.DIAMOND_HOE), 4, 1, 3, 10, 0.2F)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.DIAMOND, 1, 12, 30),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_AXE, 12, 3, 15, 0.2F),
-                            new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_SHOVEL, 5, 3, 15, 0.2F)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_PICKAXE, 13, 3, 30, 0.2F)}
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.BUTCHER,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.CHICKEN, 14, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Items.PORKCHOP, 7, 16, 2),
-                            new VillagerTrades.EmeraldForItems(Items.RABBIT, 4, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(Items.RABBIT_STEW, 1, 1, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
-                            new VillagerTrades.ItemsForEmeralds(Items.COOKED_PORKCHOP, 1, 5, 16, 5),
-                            new VillagerTrades.ItemsForEmeralds(Items.COOKED_CHICKEN, 1, 8, 16, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.MUTTON, 7, 16, 20), new VillagerTrades.EmeraldForItems(Items.BEEF, 10, 16, 20)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.DRIED_KELP_BLOCK, 10, 12, 30)},
-                        5,
-                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.SWEET_BERRIES, 10, 12, 30)}
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.LEATHERWORKER,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.LEATHER, 6, 16, 2),
-                            new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_LEGGINGS, 3),
-                            new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_CHESTPLATE, 7)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.FLINT, 26, 12, 10),
-                            new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_HELMET, 5, 12, 5),
-                            new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_BOOTS, 4, 12, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.RABBIT_HIDE, 9, 12, 20),
-                            new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_CHESTPLATE, 7)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.TURTLE_SCUTE, 4, 12, 30),
-                            new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_HORSE_ARMOR, 6, 12, 15)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.SADDLE), 6, 1, 12, 30, 0.2F),
-                            new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_HELMET, 5, 12, 30)
-                        }
-                    )
-                )
-            );
-            map.put(
-                VillagerProfession.MASON,
-                toIntMap(
-                    ImmutableMap.of(
-                        1,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.CLAY_BALL, 10, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.BRICK, 1, 10, 16, 1)
-                        },
-                        2,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Blocks.STONE, 20, 16, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.CHISELED_STONE_BRICKS, 1, 4, 16, 5)
-                        },
-                        3,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Blocks.GRANITE, 16, 16, 20),
-                            new VillagerTrades.EmeraldForItems(Blocks.ANDESITE, 16, 16, 20),
-                            new VillagerTrades.EmeraldForItems(Blocks.DIORITE, 16, 16, 20),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.DRIPSTONE_BLOCK, 1, 4, 16, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.POLISHED_ANDESITE, 1, 4, 16, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.POLISHED_DIORITE, 1, 4, 16, 10),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.POLISHED_GRANITE, 1, 4, 16, 10)
-                        },
-                        4,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.EmeraldForItems(Items.QUARTZ, 12, 12, 30),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.RED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PINK_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIME_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.RED_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PINK_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.LIME_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_GLAZED_TERRACOTTA, 1, 1, 12, 15),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_GLAZED_TERRACOTTA, 1, 1, 12, 15)
-                        },
-                        5,
-                        new VillagerTrades.ItemListing[]{
-                            new VillagerTrades.ItemsForEmeralds(Blocks.QUARTZ_PILLAR, 1, 1, 12, 30),
-                            new VillagerTrades.ItemsForEmeralds(Blocks.QUARTZ_BLOCK, 1, 1, 12, 30)
-                        }
-                    )
-                )
-            );
-        }
+                );
+                map.put(
+                        VillagerProfession.LIBRARIAN,
+                        toIntMap(
+                                ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder()
+                                        .put(
+                                                1,
+                                                new VillagerTrades.ItemListing[]{
+                                                        new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2),
+                                                        new VillagerTrades.EnchantBookForEmeralds(1, EnchantmentTags.TRADEABLE),
+                                                        new VillagerTrades.ItemsForEmeralds(Blocks.BOOKSHELF, 9, 1, 12, 1)
+                                                }
+                                        )
+                                        .put(
+                                                2,
+                                                new VillagerTrades.ItemListing[]{
+                                                        new VillagerTrades.EmeraldForItems(Items.BOOK, 4, 12, 10),
+                                                        new VillagerTrades.EnchantBookForEmeralds(5, EnchantmentTags.TRADEABLE),
+                                                        new VillagerTrades.ItemsForEmeralds(Items.LANTERN, 1, 1, 5)
+                                                }
+                                        )
+                                        .put(
+                                                3,
+                                                new VillagerTrades.ItemListing[]{
+                                                        new VillagerTrades.EmeraldForItems(Items.INK_SAC, 5, 12, 20),
+                                                        new VillagerTrades.EnchantBookForEmeralds(10, EnchantmentTags.TRADEABLE),
+                                                        new VillagerTrades.ItemsForEmeralds(Items.GLASS, 1, 4, 10)
+                                                }
+                                        )
+                                        .put(
+                                                4,
+                                                new VillagerTrades.ItemListing[]{
+                                                        new VillagerTrades.EmeraldForItems(Items.WRITABLE_BOOK, 2, 12, 30),
+                                                        new VillagerTrades.EnchantBookForEmeralds(15, EnchantmentTags.TRADEABLE),
+                                                        new VillagerTrades.ItemsForEmeralds(Items.CLOCK, 5, 1, 15),
+                                                        new VillagerTrades.ItemsForEmeralds(Items.COMPASS, 4, 1, 15)
+                                                }
+                                        )
+                                        .put(5, new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.NAME_TAG, 20, 1, 30)})
+                                        .build()
+                        )
+                );
+                map.put(
+                        VillagerProfession.CARTOGRAPHER,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.MAP, 7, 1, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.GLASS_PANE, 11, 16, 10),
+                                                new VillagerTrades.TreasureMapForEmeralds(
+                                                        13, StructureTags.ON_OCEAN_EXPLORER_MAPS, "filled_map.monument", MapDecorationTypes.OCEAN_MONUMENT, 12, 5
+                                                )
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.COMPASS, 1, 12, 20),
+                                                new VillagerTrades.TreasureMapForEmeralds(
+                                                        14, StructureTags.ON_WOODLAND_EXPLORER_MAPS, "filled_map.mansion", MapDecorationTypes.WOODLAND_MANSION, 12, 10
+                                                ),
+                                                new VillagerTrades.TreasureMapForEmeralds(
+                                                        12, StructureTags.ON_TRIAL_CHAMBERS_MAPS, "filled_map.trial_chambers", MapDecorationTypes.TRIAL_CHAMBERS, 12, 10
+                                                )
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.ItemsForEmeralds(Items.ITEM_FRAME, 7, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 15)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.GLOBE_BANNER_PATTERN, 8, 1, 30)}
+                                )
+                        )
+                );
+                map.put(
+                        VillagerProfession.CLERIC,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.ROTTEN_FLESH, 32, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.REDSTONE, 1, 2, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.GOLD_INGOT, 3, 12, 10), new VillagerTrades.ItemsForEmeralds(Items.LAPIS_LAZULI, 1, 1, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.RABBIT_FOOT, 2, 12, 20),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GLOWSTONE, 4, 1, 12, 10)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.TURTLE_SCUTE, 4, 12, 30),
+                                                new VillagerTrades.EmeraldForItems(Items.GLASS_BOTTLE, 9, 12, 30),
+                                                new VillagerTrades.ItemsForEmeralds(Items.ENDER_PEARL, 5, 1, 15)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.NETHER_WART, 22, 12, 30),
+                                                new VillagerTrades.ItemsForEmeralds(Items.EXPERIENCE_BOTTLE, 3, 1, 30)
+                                        }
+                                )
+                        )
+                );
+                map.put(
+                        VillagerProfession.ARMORER,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_LEGGINGS), 7, 1, 12, 1, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_BOOTS), 4, 1, 12, 1, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_HELMET), 5, 1, 12, 1, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_CHESTPLATE), 9, 1, 12, 1, 0.2F)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 4, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.BELL), 36, 1, 12, 5, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_BOOTS), 1, 1, 12, 5, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_LEGGINGS), 3, 1, 12, 5, 0.2F)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.LAVA_BUCKET, 1, 12, 20),
+                                                new VillagerTrades.EmeraldForItems(Items.DIAMOND, 1, 12, 20),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_HELMET), 1, 1, 12, 10, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_CHESTPLATE), 4, 1, 12, 10, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.SHIELD), 5, 1, 12, 10, 0.2F)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_LEGGINGS, 14, 3, 15, 0.2F),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_BOOTS, 8, 3, 15, 0.2F)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_HELMET, 8, 3, 30, 0.2F),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_CHESTPLATE, 16, 3, 30, 0.2F)
+                                        }
+                                )
+                        )
+                );
+                map.put(
+                        VillagerProfession.WEAPONSMITH,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_AXE), 3, 1, 12, 1, 0.2F),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_SWORD, 2, 3, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 4, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.BELL), 36, 1, 12, 5, 0.2F)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.FLINT, 24, 12, 20)},
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.DIAMOND, 1, 12, 30),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_AXE, 12, 3, 15, 0.2F)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_SWORD, 8, 3, 30, 0.2F)}
+                                )
+                        )
+                );
+                map.put(
+                        VillagerProfession.TOOLSMITH,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_AXE), 1, 1, 12, 1, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_SHOVEL), 1, 1, 12, 1, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_PICKAXE), 1, 1, 12, 1, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.STONE_HOE), 1, 1, 12, 1, 0.2F)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 4, 12, 10),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.BELL), 36, 1, 12, 5, 0.2F)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.FLINT, 30, 12, 20),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_AXE, 1, 3, 10, 0.2F),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_SHOVEL, 2, 3, 10, 0.2F),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_PICKAXE, 3, 3, 10, 0.2F),
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.DIAMOND_HOE), 4, 1, 3, 10, 0.2F)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.DIAMOND, 1, 12, 30),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_AXE, 12, 3, 15, 0.2F),
+                                                new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_SHOVEL, 5, 3, 15, 0.2F)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_PICKAXE, 13, 3, 30, 0.2F)}
+                                )
+                        )
+                );
+                map.put(
+                        VillagerProfession.BUTCHER,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.CHICKEN, 14, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Items.PORKCHOP, 7, 16, 2),
+                                                new VillagerTrades.EmeraldForItems(Items.RABBIT, 4, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(Items.RABBIT_STEW, 1, 1, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2),
+                                                new VillagerTrades.ItemsForEmeralds(Items.COOKED_PORKCHOP, 1, 5, 16, 5),
+                                                new VillagerTrades.ItemsForEmeralds(Items.COOKED_CHICKEN, 1, 8, 16, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.MUTTON, 7, 16, 20), new VillagerTrades.EmeraldForItems(Items.BEEF, 10, 16, 20)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.DRIED_KELP_BLOCK, 10, 12, 30)},
+                                        5,
+                                        new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.SWEET_BERRIES, 10, 12, 30)}
+                                )
+                        )
+                );
+                map.put(
+                        VillagerProfession.LEATHERWORKER,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.LEATHER, 6, 16, 2),
+                                                new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_LEGGINGS, 3),
+                                                new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_CHESTPLATE, 7)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.FLINT, 26, 12, 10),
+                                                new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_HELMET, 5, 12, 5),
+                                                new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_BOOTS, 4, 12, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.RABBIT_HIDE, 9, 12, 20),
+                                                new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_CHESTPLATE, 7)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.TURTLE_SCUTE, 4, 12, 30),
+                                                new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_HORSE_ARMOR, 6, 12, 15)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.SADDLE), 6, 1, 12, 30, 0.2F),
+                                                new VillagerTrades.DyedArmorForEmeralds(Items.LEATHER_HELMET, 5, 12, 30)
+                                        }
+                                )
+                        )
+                );
+                map.put(
+                        VillagerProfession.MASON,
+                        toIntMap(
+                                ImmutableMap.of(
+                                        1,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.CLAY_BALL, 10, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.BRICK, 1, 10, 16, 1)
+                                        },
+                                        2,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Blocks.STONE, 20, 16, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.CHISELED_STONE_BRICKS, 1, 4, 16, 5)
+                                        },
+                                        3,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Blocks.GRANITE, 16, 16, 20),
+                                                new VillagerTrades.EmeraldForItems(Blocks.ANDESITE, 16, 16, 20),
+                                                new VillagerTrades.EmeraldForItems(Blocks.DIORITE, 16, 16, 20),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.DRIPSTONE_BLOCK, 1, 4, 16, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.POLISHED_ANDESITE, 1, 4, 16, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.POLISHED_DIORITE, 1, 4, 16, 10),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.POLISHED_GRANITE, 1, 4, 16, 10)
+                                        },
+                                        4,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.EmeraldForItems(Items.QUARTZ, 12, 12, 30),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.RED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PINK_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIME_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.RED_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PINK_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.LIME_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_GLAZED_TERRACOTTA, 1, 1, 12, 15),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_GLAZED_TERRACOTTA, 1, 1, 12, 15)
+                                        },
+                                        5,
+                                        new VillagerTrades.ItemListing[]{
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.QUARTZ_PILLAR, 1, 1, 12, 30),
+                                                new VillagerTrades.ItemsForEmeralds(Blocks.QUARTZ_BLOCK, 1, 1, 12, 30)
+                                        }
+                                )
+                        )
+                );
+            }
     );
     public static final Int2ObjectMap<VillagerTrades.ItemListing[]> WANDERING_TRADER_TRADES = toIntMap(
-        ImmutableMap.of(
-            1,
-            new VillagerTrades.ItemListing[]{
-                new VillagerTrades.ItemsForEmeralds(Items.SEA_PICKLE, 2, 1, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.SLIME_BALL, 4, 1, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.GLOWSTONE, 2, 1, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.NAUTILUS_SHELL, 5, 1, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.FERN, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.SUGAR_CANE, 1, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN, 1, 1, 4, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.KELP, 3, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.CACTUS, 3, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.DANDELION, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.POPPY, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BLUE_ORCHID, 1, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.ALLIUM, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.AZURE_BLUET, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.RED_TULIP, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.ORANGE_TULIP, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.WHITE_TULIP, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PINK_TULIP, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.OXEYE_DAISY, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.CORNFLOWER, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.LILY_OF_THE_VALLEY, 1, 1, 7, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.WHEAT_SEEDS, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BEETROOT_SEEDS, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN_SEEDS, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.MELON_SEEDS, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.ACACIA_SAPLING, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BIRCH_SAPLING, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.DARK_OAK_SAPLING, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.JUNGLE_SAPLING, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.OAK_SAPLING, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.SPRUCE_SAPLING, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.CHERRY_SAPLING, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.MANGROVE_PROPAGULE, 5, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.RED_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.WHITE_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BLUE_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PINK_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BLACK_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.GREEN_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.YELLOW_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.GRAY_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PURPLE_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.LIME_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.ORANGE_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BROWN_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.CYAN_DYE, 1, 3, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BRAIN_CORAL_BLOCK, 3, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BUBBLE_CORAL_BLOCK, 3, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.FIRE_CORAL_BLOCK, 3, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.HORN_CORAL_BLOCK, 3, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.TUBE_CORAL_BLOCK, 3, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.VINE, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BROWN_MUSHROOM, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.RED_MUSHROOM, 1, 1, 12, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.LILY_PAD, 1, 2, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.SMALL_DRIPLEAF, 1, 2, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.SAND, 1, 8, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.RED_SAND, 1, 4, 6, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.POINTED_DRIPSTONE, 1, 2, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.ROOTED_DIRT, 1, 2, 5, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.MOSS_BLOCK, 1, 2, 5, 1)
-            },
-            2,
-            new VillagerTrades.ItemListing[]{
-                new VillagerTrades.ItemsForEmeralds(Items.TROPICAL_FISH_BUCKET, 5, 1, 4, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PUFFERFISH_BUCKET, 5, 1, 4, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PACKED_ICE, 3, 1, 6, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.BLUE_ICE, 6, 1, 6, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.GUNPOWDER, 1, 1, 8, 1),
-                new VillagerTrades.ItemsForEmeralds(Items.PODZOL, 3, 3, 6, 1)
-            }
-        )
+            ImmutableMap.of(
+                    1,
+                    new VillagerTrades.ItemListing[]{
+                            new VillagerTrades.ItemsForEmeralds(Items.SEA_PICKLE, 2, 1, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.SLIME_BALL, 4, 1, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.GLOWSTONE, 2, 1, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.NAUTILUS_SHELL, 5, 1, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.FERN, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.SUGAR_CANE, 1, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN, 1, 1, 4, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.KELP, 3, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.CACTUS, 3, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.DANDELION, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.POPPY, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BLUE_ORCHID, 1, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.ALLIUM, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.AZURE_BLUET, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.RED_TULIP, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.ORANGE_TULIP, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.WHITE_TULIP, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PINK_TULIP, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.OXEYE_DAISY, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.CORNFLOWER, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.LILY_OF_THE_VALLEY, 1, 1, 7, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.WHEAT_SEEDS, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BEETROOT_SEEDS, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN_SEEDS, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.MELON_SEEDS, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.ACACIA_SAPLING, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BIRCH_SAPLING, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.DARK_OAK_SAPLING, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.JUNGLE_SAPLING, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.OAK_SAPLING, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.SPRUCE_SAPLING, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.CHERRY_SAPLING, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.MANGROVE_PROPAGULE, 5, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.RED_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.WHITE_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BLUE_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PINK_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BLACK_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.GREEN_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.YELLOW_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.GRAY_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PURPLE_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.LIME_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.ORANGE_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BROWN_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.CYAN_DYE, 1, 3, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BRAIN_CORAL_BLOCK, 3, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BUBBLE_CORAL_BLOCK, 3, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.FIRE_CORAL_BLOCK, 3, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.HORN_CORAL_BLOCK, 3, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.TUBE_CORAL_BLOCK, 3, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.VINE, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BROWN_MUSHROOM, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.RED_MUSHROOM, 1, 1, 12, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.LILY_PAD, 1, 2, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.SMALL_DRIPLEAF, 1, 2, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.SAND, 1, 8, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.RED_SAND, 1, 4, 6, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.POINTED_DRIPSTONE, 1, 2, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.ROOTED_DIRT, 1, 2, 5, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.MOSS_BLOCK, 1, 2, 5, 1)
+                    },
+                    2,
+                    new VillagerTrades.ItemListing[]{
+                            new VillagerTrades.ItemsForEmeralds(Items.TROPICAL_FISH_BUCKET, 5, 1, 4, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PUFFERFISH_BUCKET, 5, 1, 4, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PACKED_ICE, 3, 1, 6, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.BLUE_ICE, 6, 1, 6, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.GUNPOWDER, 1, 1, 8, 1),
+                            new VillagerTrades.ItemsForEmeralds(Items.PODZOL, 3, 3, 6, 1)
+                    }
+            )
     );
     private static final VillagerTrades.TreasureMapForEmeralds DESERT_MAP = new VillagerTrades.TreasureMapForEmeralds(
-        8, StructureTags.ON_DESERT_VILLAGE_MAPS, "filled_map.village_desert", MapDecorationTypes.DESERT_VILLAGE, 12, 5
+            8, StructureTags.ON_DESERT_VILLAGE_MAPS, "filled_map.village_desert", MapDecorationTypes.DESERT_VILLAGE, 12, 5
     );
     private static final VillagerTrades.TreasureMapForEmeralds SAVANNA_MAP = new VillagerTrades.TreasureMapForEmeralds(
-        8, StructureTags.ON_SAVANNA_VILLAGE_MAPS, "filled_map.village_savanna", MapDecorationTypes.SAVANNA_VILLAGE, 12, 5
+            8, StructureTags.ON_SAVANNA_VILLAGE_MAPS, "filled_map.village_savanna", MapDecorationTypes.SAVANNA_VILLAGE, 12, 5
     );
     private static final VillagerTrades.TreasureMapForEmeralds PLAINS_MAP = new VillagerTrades.TreasureMapForEmeralds(
-        8, StructureTags.ON_PLAINS_VILLAGE_MAPS, "filled_map.village_plains", MapDecorationTypes.PLAINS_VILLAGE, 12, 5
+            8, StructureTags.ON_PLAINS_VILLAGE_MAPS, "filled_map.village_plains", MapDecorationTypes.PLAINS_VILLAGE, 12, 5
     );
     private static final VillagerTrades.TreasureMapForEmeralds TAIGA_MAP = new VillagerTrades.TreasureMapForEmeralds(
-        8, StructureTags.ON_TAIGA_VILLAGE_MAPS, "filled_map.village_taiga", MapDecorationTypes.TAIGA_VILLAGE, 12, 5
+            8, StructureTags.ON_TAIGA_VILLAGE_MAPS, "filled_map.village_taiga", MapDecorationTypes.TAIGA_VILLAGE, 12, 5
     );
     private static final VillagerTrades.TreasureMapForEmeralds SNOWY_MAP = new VillagerTrades.TreasureMapForEmeralds(
-        8, StructureTags.ON_SNOWY_VILLAGE_MAPS, "filled_map.village_snowy", MapDecorationTypes.SNOWY_VILLAGE, 12, 5
+            8, StructureTags.ON_SNOWY_VILLAGE_MAPS, "filled_map.village_snowy", MapDecorationTypes.SNOWY_VILLAGE, 12, 5
     );
     private static final VillagerTrades.TreasureMapForEmeralds JUNGLE_MAP = new VillagerTrades.TreasureMapForEmeralds(
-        8, StructureTags.ON_JUNGLE_EXPLORER_MAPS, "filled_map.explorer_jungle", MapDecorationTypes.JUNGLE_TEMPLE, 12, 5
+            8, StructureTags.ON_JUNGLE_EXPLORER_MAPS, "filled_map.explorer_jungle", MapDecorationTypes.JUNGLE_TEMPLE, 12, 5
     );
     private static final VillagerTrades.TreasureMapForEmeralds SWAMP_MAP = new VillagerTrades.TreasureMapForEmeralds(
-        8, StructureTags.ON_SWAMP_EXPLORER_MAPS, "filled_map.explorer_swamp", MapDecorationTypes.SWAMP_HUT, 12, 5
+            8, StructureTags.ON_SWAMP_EXPLORER_MAPS, "filled_map.explorer_swamp", MapDecorationTypes.SWAMP_HUT, 12, 5
     );
     public static final Map<VillagerProfession, Int2ObjectMap<VillagerTrades.ItemListing[]>> EXPERIMENTAL_TRADES = Map.of(
-        VillagerProfession.LIBRARIAN,
-        toIntMap(
-            ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder()
-                .put(
-                    1,
-                    new VillagerTrades.ItemListing[]{
-                        new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2),
-                        commonBooks(1),
-                        new VillagerTrades.ItemsForEmeralds(Blocks.BOOKSHELF, 9, 1, 12, 1)
-                    }
-                )
-                .put(
-                    2,
-                    new VillagerTrades.ItemListing[]{
-                        new VillagerTrades.EmeraldForItems(Items.BOOK, 4, 12, 10), commonBooks(5), new VillagerTrades.ItemsForEmeralds(Items.LANTERN, 1, 1, 5)
-                    }
-                )
-                .put(
-                    3,
-                    new VillagerTrades.ItemListing[]{
-                        new VillagerTrades.EmeraldForItems(Items.INK_SAC, 5, 12, 20),
-                        commonBooks(10),
-                        new VillagerTrades.ItemsForEmeralds(Items.GLASS, 1, 4, 10)
-                    }
-                )
-                .put(
-                    4,
-                    new VillagerTrades.ItemListing[]{
-                        new VillagerTrades.EmeraldForItems(Items.WRITABLE_BOOK, 2, 12, 30),
-                        new VillagerTrades.ItemsForEmeralds(Items.CLOCK, 5, 1, 15),
-                        new VillagerTrades.ItemsForEmeralds(Items.COMPASS, 4, 1, 15)
-                    }
-                )
-                .put(5, new VillagerTrades.ItemListing[]{specialBooks(), new VillagerTrades.ItemsForEmeralds(Items.NAME_TAG, 20, 1, 30)})
-                .build()
-        ),
-        VillagerProfession.ARMORER,
-        toIntMap(
-            ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder()
-                .put(
-                    1,
-                    new VillagerTrades.ItemListing[]{
-                        new VillagerTrades.EmeraldForItems(Items.COAL, 15, 12, 2), new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 5, 12, 2)
-                    }
-                )
-                .put(
-                    2,
-                    new VillagerTrades.ItemListing[]{
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.IRON_BOOTS, 4, 1, 12, 5, 0.05F),
-                            VillagerType.DESERT,
-                            VillagerType.PLAINS,
-                            VillagerType.SAVANNA,
-                            VillagerType.SNOW,
-                            VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_BOOTS, 4, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.IRON_HELMET, 5, 1, 12, 5, 0.05F),
-                            VillagerType.DESERT,
-                            VillagerType.PLAINS,
-                            VillagerType.SAVANNA,
-                            VillagerType.SNOW,
-                            VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_HELMET, 5, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.IRON_LEGGINGS, 7, 1, 12, 5, 0.05F),
-                            VillagerType.DESERT,
-                            VillagerType.PLAINS,
-                            VillagerType.SAVANNA,
-                            VillagerType.SNOW,
-                            VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_LEGGINGS, 7, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.IRON_CHESTPLATE, 9, 1, 12, 5, 0.05F),
-                            VillagerType.DESERT,
-                            VillagerType.PLAINS,
-                            VillagerType.SAVANNA,
-                            VillagerType.SNOW,
-                            VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_CHESTPLATE, 9, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
-                        )
-                    }
-                )
-                .put(
-                    3,
-                    new VillagerTrades.ItemListing[]{
-                        new VillagerTrades.EmeraldForItems(Items.LAVA_BUCKET, 1, 12, 20),
-                        new VillagerTrades.ItemsForEmeralds(Items.SHIELD, 5, 1, 12, 10, 0.05F),
-                        new VillagerTrades.ItemsForEmeralds(Items.BELL, 36, 1, 12, 10, 0.2F)
-                    }
-                )
-                .put(
-                    4,
-                    new VillagerTrades.ItemListing[]{
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_BOOTS_4
-                            ),
-                            VillagerType.DESERT
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_HELMET_4
-                            ),
-                            VillagerType.DESERT
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_LEGGINGS_4
-                            ),
-                            VillagerType.DESERT
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_CHESTPLATE_4
-                            ),
-                            VillagerType.DESERT
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_BOOTS_4
-                            ),
-                            VillagerType.PLAINS
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_HELMET_4
-                            ),
-                            VillagerType.PLAINS
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_LEGGINGS_4
-                            ),
-                            VillagerType.PLAINS
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_CHESTPLATE_4
-                            ),
-                            VillagerType.PLAINS
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_BOOTS, 2, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_BOOTS_4
-                            ),
-                            VillagerType.SAVANNA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_HELMET, 3, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_HELMET_4
-                            ),
-                            VillagerType.SAVANNA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_LEGGINGS, 5, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_LEGGINGS_4
-                            ),
-                            VillagerType.SAVANNA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_CHESTPLATE, 7, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_CHESTPLATE_4
-                            ),
-                            VillagerType.SAVANNA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_BOOTS_4
-                            ),
-                            VillagerType.SNOW
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.IRON_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_HELMET_4
-                            ),
-                            VillagerType.SNOW
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_BOOTS_4
-                            ),
-                            VillagerType.JUNGLE
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_HELMET_4
-                            ),
-                            VillagerType.JUNGLE
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_LEGGINGS_4
-                            ),
-                            VillagerType.JUNGLE
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_CHESTPLATE_4
-                            ),
-                            VillagerType.JUNGLE
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_BOOTS_4
-                            ),
-                            VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_HELMET_4
-                            ),
-                            VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_LEGGINGS_4
-                            ),
-                            VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_CHESTPLATE_4
-                            ),
-                            VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_BOOTS, 1, 4, Items.DIAMOND_LEGGINGS, 1, 3, 15, 0.05F), VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_LEGGINGS, 1, 4, Items.DIAMOND_CHESTPLATE, 1, 3, 15, 0.05F),
-                            VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_HELMET, 1, 4, Items.DIAMOND_BOOTS, 1, 3, 15, 0.05F), VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_CHESTPLATE, 1, 2, Items.DIAMOND_HELMET, 1, 3, 15, 0.05F),
-                            VillagerType.TAIGA
-                        )
-                    }
-                )
-                .put(
-                    5,
-                    new VillagerTrades.ItemListing[]{
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND,
-                                4,
-                                16,
-                                Items.DIAMOND_CHESTPLATE,
-                                1,
-                                3,
-                                30,
-                                0.05F,
-                                TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_CHESTPLATE_5
-                            ),
-                            VillagerType.DESERT
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND,
-                                3,
-                                16,
-                                Items.DIAMOND_LEGGINGS,
-                                1,
-                                3,
-                                30,
-                                0.05F,
-                                TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_LEGGINGS_5
-                            ),
-                            VillagerType.DESERT
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND,
-                                3,
-                                16,
-                                Items.DIAMOND_LEGGINGS,
-                                1,
-                                3,
-                                30,
-                                0.05F,
-                                TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_LEGGINGS_5
-                            ),
-                            VillagerType.PLAINS
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND, 2, 12, Items.DIAMOND_BOOTS, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_BOOTS_5
-                            ),
-                            VillagerType.PLAINS
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND, 2, 6, Items.DIAMOND_HELMET, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_HELMET_5
-                            ),
-                            VillagerType.SAVANNA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND,
-                                3,
-                                8,
-                                Items.DIAMOND_CHESTPLATE,
-                                1,
-                                3,
-                                30,
-                                0.05F,
-                                TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_CHESTPLATE_5
-                            ),
-                            VillagerType.SAVANNA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND, 2, 12, Items.DIAMOND_BOOTS, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_BOOTS_5
-                            ),
-                            VillagerType.SNOW
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND, 3, 12, Items.DIAMOND_HELMET, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_HELMET_5
-                            ),
-                            VillagerType.SNOW
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_HELMET, 9, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_HELMET_5
-                            ),
-                            VillagerType.JUNGLE
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_BOOTS, 8, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_BOOTS_5
-                            ),
-                            VillagerType.JUNGLE
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_HELMET, 9, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_HELMET_5
-                            ),
-                            VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsForEmeralds(
-                                Items.CHAINMAIL_BOOTS, 8, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_BOOTS_5
-                            ),
-                            VillagerType.SWAMP
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND,
-                                4,
-                                18,
-                                Items.DIAMOND_CHESTPLATE,
-                                1,
-                                3,
-                                30,
-                                0.05F,
-                                TradeRebalanceEnchantmentProviders.TRADES_TAIGA_ARMORER_CHESTPLATE_5
-                            ),
-                            VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.ItemsAndEmeraldsToItems(
-                                Items.DIAMOND,
-                                3,
-                                18,
-                                Items.DIAMOND_LEGGINGS,
-                                1,
-                                3,
-                                30,
-                                0.05F,
-                                TradeRebalanceEnchantmentProviders.TRADES_TAIGA_ARMORER_LEGGINGS_5
-                            ),
-                            VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.EmeraldForItems(Items.DIAMOND_BLOCK, 1, 12, 30, 42), VillagerType.TAIGA
-                        ),
-                        VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
-                            new VillagerTrades.EmeraldForItems(Items.IRON_BLOCK, 1, 12, 30, 4),
-                            VillagerType.DESERT,
-                            VillagerType.JUNGLE,
-                            VillagerType.PLAINS,
-                            VillagerType.SAVANNA,
-                            VillagerType.SNOW,
-                            VillagerType.SWAMP
-                        )
-                    }
-                )
-                .build()
-        ),
-        VillagerProfession.CARTOGRAPHER,
-        toIntMap(
-            ImmutableMap.of(
-                1,
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.MAP, 7, 1, 1)
-                },
-                2,
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.EmeraldForItems(Items.GLASS_PANE, 11, 16, 10),
-                    new VillagerTrades.TypeSpecificTrade(
-                        ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
-                            .put(VillagerType.DESERT, SAVANNA_MAP)
-                            .put(VillagerType.SAVANNA, PLAINS_MAP)
-                            .put(VillagerType.PLAINS, TAIGA_MAP)
-                            .put(VillagerType.TAIGA, SNOWY_MAP)
-                            .put(VillagerType.SNOW, PLAINS_MAP)
-                            .put(VillagerType.JUNGLE, SAVANNA_MAP)
-                            .put(VillagerType.SWAMP, SNOWY_MAP)
-                            .build()
-                    ),
-                    new VillagerTrades.TypeSpecificTrade(
-                        ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
-                            .put(VillagerType.DESERT, PLAINS_MAP)
-                            .put(VillagerType.SAVANNA, DESERT_MAP)
-                            .put(VillagerType.PLAINS, SAVANNA_MAP)
-                            .put(VillagerType.TAIGA, PLAINS_MAP)
-                            .put(VillagerType.SNOW, TAIGA_MAP)
-                            .put(VillagerType.JUNGLE, DESERT_MAP)
-                            .put(VillagerType.SWAMP, TAIGA_MAP)
+            VillagerProfession.LIBRARIAN,
+            toIntMap(
+                    ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder()
+                            .put(
+                                    1,
+                                    new VillagerTrades.ItemListing[]{
+                                            new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2),
+                                            commonBooks(1),
+                                            new VillagerTrades.ItemsForEmeralds(Blocks.BOOKSHELF, 9, 1, 12, 1)
+                                    }
+                            )
+                            .put(
+                                    2,
+                                    new VillagerTrades.ItemListing[]{
+                                            new VillagerTrades.EmeraldForItems(Items.BOOK, 4, 12, 10), commonBooks(5), new VillagerTrades.ItemsForEmeralds(Items.LANTERN, 1, 1, 5)
+                                    }
+                            )
+                            .put(
+                                    3,
+                                    new VillagerTrades.ItemListing[]{
+                                            new VillagerTrades.EmeraldForItems(Items.INK_SAC, 5, 12, 20),
+                                            commonBooks(10),
+                                            new VillagerTrades.ItemsForEmeralds(Items.GLASS, 1, 4, 10)
+                                    }
+                            )
+                            .put(
+                                    4,
+                                    new VillagerTrades.ItemListing[]{
+                                            new VillagerTrades.EmeraldForItems(Items.WRITABLE_BOOK, 2, 12, 30),
+                                            new VillagerTrades.ItemsForEmeralds(Items.CLOCK, 5, 1, 15),
+                                            new VillagerTrades.ItemsForEmeralds(Items.COMPASS, 4, 1, 15)
+                                    }
+                            )
+                            .put(5, new VillagerTrades.ItemListing[]{specialBooks(), new VillagerTrades.ItemsForEmeralds(Items.NAME_TAG, 20, 1, 30)})
                             .build()
-                    ),
-                    new VillagerTrades.TypeSpecificTrade(
-                        ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
-                            .put(VillagerType.DESERT, JUNGLE_MAP)
-                            .put(VillagerType.SAVANNA, JUNGLE_MAP)
-                            .put(VillagerType.PLAINS, new VillagerTrades.FailureItemListing())
-                            .put(VillagerType.TAIGA, SWAMP_MAP)
-                            .put(VillagerType.SNOW, SWAMP_MAP)
-                            .put(VillagerType.JUNGLE, SWAMP_MAP)
-                            .put(VillagerType.SWAMP, JUNGLE_MAP)
+            ),
+            VillagerProfession.ARMORER,
+            toIntMap(
+                    ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder()
+                            .put(
+                                    1,
+                                    new VillagerTrades.ItemListing[]{
+                                            new VillagerTrades.EmeraldForItems(Items.COAL, 15, 12, 2), new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 5, 12, 2)
+                                    }
+                            )
+                            .put(
+                                    2,
+                                    new VillagerTrades.ItemListing[]{
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.IRON_BOOTS, 4, 1, 12, 5, 0.05F),
+                                                    VillagerType.DESERT,
+                                                    VillagerType.PLAINS,
+                                                    VillagerType.SAVANNA,
+                                                    VillagerType.SNOW,
+                                                    VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_BOOTS, 4, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.IRON_HELMET, 5, 1, 12, 5, 0.05F),
+                                                    VillagerType.DESERT,
+                                                    VillagerType.PLAINS,
+                                                    VillagerType.SAVANNA,
+                                                    VillagerType.SNOW,
+                                                    VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_HELMET, 5, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.IRON_LEGGINGS, 7, 1, 12, 5, 0.05F),
+                                                    VillagerType.DESERT,
+                                                    VillagerType.PLAINS,
+                                                    VillagerType.SAVANNA,
+                                                    VillagerType.SNOW,
+                                                    VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_LEGGINGS, 7, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.IRON_CHESTPLATE, 9, 1, 12, 5, 0.05F),
+                                                    VillagerType.DESERT,
+                                                    VillagerType.PLAINS,
+                                                    VillagerType.SAVANNA,
+                                                    VillagerType.SNOW,
+                                                    VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(Items.CHAINMAIL_CHESTPLATE, 9, 1, 12, 5, 0.05F), VillagerType.JUNGLE, VillagerType.SWAMP
+                                            )
+                                    }
+                            )
+                            .put(
+                                    3,
+                                    new VillagerTrades.ItemListing[]{
+                                            new VillagerTrades.EmeraldForItems(Items.LAVA_BUCKET, 1, 12, 20),
+                                            new VillagerTrades.ItemsForEmeralds(Items.SHIELD, 5, 1, 12, 10, 0.05F),
+                                            new VillagerTrades.ItemsForEmeralds(Items.BELL, 36, 1, 12, 10, 0.2F)
+                                    }
+                            )
+                            .put(
+                                    4,
+                                    new VillagerTrades.ItemListing[]{
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_BOOTS_4
+                                                    ),
+                                                    VillagerType.DESERT
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_HELMET_4
+                                                    ),
+                                                    VillagerType.DESERT
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_LEGGINGS_4
+                                                    ),
+                                                    VillagerType.DESERT
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_CHESTPLATE_4
+                                                    ),
+                                                    VillagerType.DESERT
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_BOOTS_4
+                                                    ),
+                                                    VillagerType.PLAINS
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_HELMET_4
+                                                    ),
+                                                    VillagerType.PLAINS
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_LEGGINGS_4
+                                                    ),
+                                                    VillagerType.PLAINS
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_CHESTPLATE_4
+                                                    ),
+                                                    VillagerType.PLAINS
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_BOOTS, 2, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_BOOTS_4
+                                                    ),
+                                                    VillagerType.SAVANNA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_HELMET, 3, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_HELMET_4
+                                                    ),
+                                                    VillagerType.SAVANNA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_LEGGINGS, 5, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_LEGGINGS_4
+                                                    ),
+                                                    VillagerType.SAVANNA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_CHESTPLATE, 7, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_CHESTPLATE_4
+                                                    ),
+                                                    VillagerType.SAVANNA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_BOOTS_4
+                                                    ),
+                                                    VillagerType.SNOW
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.IRON_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_HELMET_4
+                                                    ),
+                                                    VillagerType.SNOW
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_BOOTS_4
+                                                    ),
+                                                    VillagerType.JUNGLE
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_HELMET_4
+                                                    ),
+                                                    VillagerType.JUNGLE
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_LEGGINGS_4
+                                                    ),
+                                                    VillagerType.JUNGLE
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_CHESTPLATE_4
+                                                    ),
+                                                    VillagerType.JUNGLE
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_BOOTS, 8, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_BOOTS_4
+                                                    ),
+                                                    VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_HELMET, 9, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_HELMET_4
+                                                    ),
+                                                    VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_LEGGINGS, 11, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_LEGGINGS_4
+                                                    ),
+                                                    VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_CHESTPLATE, 13, 1, 3, 15, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_CHESTPLATE_4
+                                                    ),
+                                                    VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_BOOTS, 1, 4, Items.DIAMOND_LEGGINGS, 1, 3, 15, 0.05F), VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_LEGGINGS, 1, 4, Items.DIAMOND_CHESTPLATE, 1, 3, 15, 0.05F),
+                                                    VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_HELMET, 1, 4, Items.DIAMOND_BOOTS, 1, 3, 15, 0.05F), VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(Items.DIAMOND_CHESTPLATE, 1, 2, Items.DIAMOND_HELMET, 1, 3, 15, 0.05F),
+                                                    VillagerType.TAIGA
+                                            )
+                                    }
+                            )
+                            .put(
+                                    5,
+                                    new VillagerTrades.ItemListing[]{
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND,
+                                                            4,
+                                                            16,
+                                                            Items.DIAMOND_CHESTPLATE,
+                                                            1,
+                                                            3,
+                                                            30,
+                                                            0.05F,
+                                                            TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_CHESTPLATE_5
+                                                    ),
+                                                    VillagerType.DESERT
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND,
+                                                            3,
+                                                            16,
+                                                            Items.DIAMOND_LEGGINGS,
+                                                            1,
+                                                            3,
+                                                            30,
+                                                            0.05F,
+                                                            TradeRebalanceEnchantmentProviders.TRADES_DESERT_ARMORER_LEGGINGS_5
+                                                    ),
+                                                    VillagerType.DESERT
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND,
+                                                            3,
+                                                            16,
+                                                            Items.DIAMOND_LEGGINGS,
+                                                            1,
+                                                            3,
+                                                            30,
+                                                            0.05F,
+                                                            TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_LEGGINGS_5
+                                                    ),
+                                                    VillagerType.PLAINS
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND, 2, 12, Items.DIAMOND_BOOTS, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_PLAINS_ARMORER_BOOTS_5
+                                                    ),
+                                                    VillagerType.PLAINS
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND, 2, 6, Items.DIAMOND_HELMET, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_HELMET_5
+                                                    ),
+                                                    VillagerType.SAVANNA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND,
+                                                            3,
+                                                            8,
+                                                            Items.DIAMOND_CHESTPLATE,
+                                                            1,
+                                                            3,
+                                                            30,
+                                                            0.05F,
+                                                            TradeRebalanceEnchantmentProviders.TRADES_SAVANNA_ARMORER_CHESTPLATE_5
+                                                    ),
+                                                    VillagerType.SAVANNA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND, 2, 12, Items.DIAMOND_BOOTS, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_BOOTS_5
+                                                    ),
+                                                    VillagerType.SNOW
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND, 3, 12, Items.DIAMOND_HELMET, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SNOW_ARMORER_HELMET_5
+                                                    ),
+                                                    VillagerType.SNOW
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_HELMET, 9, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_HELMET_5
+                                                    ),
+                                                    VillagerType.JUNGLE
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_BOOTS, 8, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_JUNGLE_ARMORER_BOOTS_5
+                                                    ),
+                                                    VillagerType.JUNGLE
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_HELMET, 9, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_HELMET_5
+                                                    ),
+                                                    VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsForEmeralds(
+                                                            Items.CHAINMAIL_BOOTS, 8, 1, 3, 30, 0.05F, TradeRebalanceEnchantmentProviders.TRADES_SWAMP_ARMORER_BOOTS_5
+                                                    ),
+                                                    VillagerType.SWAMP
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND,
+                                                            4,
+                                                            18,
+                                                            Items.DIAMOND_CHESTPLATE,
+                                                            1,
+                                                            3,
+                                                            30,
+                                                            0.05F,
+                                                            TradeRebalanceEnchantmentProviders.TRADES_TAIGA_ARMORER_CHESTPLATE_5
+                                                    ),
+                                                    VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.ItemsAndEmeraldsToItems(
+                                                            Items.DIAMOND,
+                                                            3,
+                                                            18,
+                                                            Items.DIAMOND_LEGGINGS,
+                                                            1,
+                                                            3,
+                                                            30,
+                                                            0.05F,
+                                                            TradeRebalanceEnchantmentProviders.TRADES_TAIGA_ARMORER_LEGGINGS_5
+                                                    ),
+                                                    VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.EmeraldForItems(Items.DIAMOND_BLOCK, 1, 12, 30, 42), VillagerType.TAIGA
+                                            ),
+                                            VillagerTrades.TypeSpecificTrade.oneTradeInBiomes(
+                                                    new VillagerTrades.EmeraldForItems(Items.IRON_BLOCK, 1, 12, 30, 4),
+                                                    VillagerType.DESERT,
+                                                    VillagerType.JUNGLE,
+                                                    VillagerType.PLAINS,
+                                                    VillagerType.SAVANNA,
+                                                    VillagerType.SNOW,
+                                                    VillagerType.SWAMP
+                                            )
+                                    }
+                            )
                             .build()
+            ),
+            VillagerProfession.CARTOGRAPHER,
+            toIntMap(
+                    ImmutableMap.of(
+                            1,
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.MAP, 7, 1, 1)
+                            },
+                            2,
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.EmeraldForItems(Items.GLASS_PANE, 11, 16, 10),
+                                    new VillagerTrades.TypeSpecificTrade(
+                                            ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
+                                                    .put(VillagerType.DESERT, SAVANNA_MAP)
+                                                    .put(VillagerType.SAVANNA, PLAINS_MAP)
+                                                    .put(VillagerType.PLAINS, TAIGA_MAP)
+                                                    .put(VillagerType.TAIGA, SNOWY_MAP)
+                                                    .put(VillagerType.SNOW, PLAINS_MAP)
+                                                    .put(VillagerType.JUNGLE, SAVANNA_MAP)
+                                                    .put(VillagerType.SWAMP, SNOWY_MAP)
+                                                    .build()
+                                    ),
+                                    new VillagerTrades.TypeSpecificTrade(
+                                            ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
+                                                    .put(VillagerType.DESERT, PLAINS_MAP)
+                                                    .put(VillagerType.SAVANNA, DESERT_MAP)
+                                                    .put(VillagerType.PLAINS, SAVANNA_MAP)
+                                                    .put(VillagerType.TAIGA, PLAINS_MAP)
+                                                    .put(VillagerType.SNOW, TAIGA_MAP)
+                                                    .put(VillagerType.JUNGLE, DESERT_MAP)
+                                                    .put(VillagerType.SWAMP, TAIGA_MAP)
+                                                    .build()
+                                    ),
+                                    new VillagerTrades.TypeSpecificTrade(
+                                            ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
+                                                    .put(VillagerType.DESERT, JUNGLE_MAP)
+                                                    .put(VillagerType.SAVANNA, JUNGLE_MAP)
+                                                    .put(VillagerType.PLAINS, new VillagerTrades.FailureItemListing())
+                                                    .put(VillagerType.TAIGA, SWAMP_MAP)
+                                                    .put(VillagerType.SNOW, SWAMP_MAP)
+                                                    .put(VillagerType.JUNGLE, SWAMP_MAP)
+                                                    .put(VillagerType.SWAMP, JUNGLE_MAP)
+                                                    .build()
+                                    )
+                            },
+                            3,
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.EmeraldForItems(Items.COMPASS, 1, 12, 20),
+                                    new VillagerTrades.TreasureMapForEmeralds(
+                                            13, StructureTags.ON_OCEAN_EXPLORER_MAPS, "filled_map.monument", MapDecorationTypes.OCEAN_MONUMENT, 12, 10
+                                    ),
+                                    new VillagerTrades.TreasureMapForEmeralds(
+                                            12, StructureTags.ON_TRIAL_CHAMBERS_MAPS, "filled_map.trial_chambers", MapDecorationTypes.TRIAL_CHAMBERS, 12, 10
+                                    )
+                            },
+                            4,
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.ItemsForEmeralds(Items.ITEM_FRAME, 7, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 15),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 15)
+                            },
+                            5,
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.ItemsForEmeralds(Items.GLOBE_BANNER_PATTERN, 8, 1, 30),
+                                    new VillagerTrades.TreasureMapForEmeralds(
+                                            14, StructureTags.ON_WOODLAND_EXPLORER_MAPS, "filled_map.mansion", MapDecorationTypes.WOODLAND_MANSION, 1, 30
+                                    )
+                            }
                     )
-                },
-                3,
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.EmeraldForItems(Items.COMPASS, 1, 12, 20),
-                    new VillagerTrades.TreasureMapForEmeralds(
-                        13, StructureTags.ON_OCEAN_EXPLORER_MAPS, "filled_map.monument", MapDecorationTypes.OCEAN_MONUMENT, 12, 10
-                    ),
-                    new VillagerTrades.TreasureMapForEmeralds(
-                        12, StructureTags.ON_TRIAL_CHAMBERS_MAPS, "filled_map.trial_chambers", MapDecorationTypes.TRIAL_CHAMBERS, 12, 10
-                    )
-                },
-                4,
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.ItemsForEmeralds(Items.ITEM_FRAME, 7, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 15),
-                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 15)
-                },
-                5,
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.ItemsForEmeralds(Items.GLOBE_BANNER_PATTERN, 8, 1, 30),
-                    new VillagerTrades.TreasureMapForEmeralds(
-                        14, StructureTags.ON_WOODLAND_EXPLORER_MAPS, "filled_map.mansion", MapDecorationTypes.WOODLAND_MANSION, 1, 30
-                    )
-                }
             )
-        )
     );
     public static final List<Pair<VillagerTrades.ItemListing[], Integer>> EXPERIMENTAL_WANDERING_TRADER_TRADES = ImmutableList.<Pair<VillagerTrades.ItemListing[], Integer>>builder()
-        .add(
-            Pair.of(
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.EmeraldForItems(potionCost(Potions.WATER), 1, 1, 1),
-                    new VillagerTrades.EmeraldForItems(Items.WATER_BUCKET, 1, 1, 1, 2),
-                    new VillagerTrades.EmeraldForItems(Items.MILK_BUCKET, 1, 1, 1, 2),
-                    new VillagerTrades.EmeraldForItems(Items.FERMENTED_SPIDER_EYE, 1, 1, 1, 3),
-                    new VillagerTrades.EmeraldForItems(Items.BAKED_POTATO, 4, 1, 1),
-                    new VillagerTrades.EmeraldForItems(Items.HAY_BLOCK, 1, 1, 1)
-                },
-                2
+            .add(
+                    Pair.of(
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.EmeraldForItems(potionCost(Potions.WATER), 1, 1, 1),
+                                    new VillagerTrades.EmeraldForItems(Items.WATER_BUCKET, 1, 1, 1, 2),
+                                    new VillagerTrades.EmeraldForItems(Items.MILK_BUCKET, 1, 1, 1, 2),
+                                    new VillagerTrades.EmeraldForItems(Items.FERMENTED_SPIDER_EYE, 1, 1, 1, 3),
+                                    new VillagerTrades.EmeraldForItems(Items.BAKED_POTATO, 4, 1, 1),
+                                    new VillagerTrades.EmeraldForItems(Items.HAY_BLOCK, 1, 1, 1)
+                            },
+                            2
+                    )
             )
-        )
-        .add(
-            Pair.of(
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.ItemsForEmeralds(Items.PACKED_ICE, 1, 1, 6, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_ICE, 6, 1, 6, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.GUNPOWDER, 1, 4, 2, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.PODZOL, 3, 3, 6, 1),
-                    new VillagerTrades.ItemsForEmeralds(Blocks.ACACIA_LOG, 1, 8, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Blocks.BIRCH_LOG, 1, 8, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Blocks.DARK_OAK_LOG, 1, 8, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Blocks.JUNGLE_LOG, 1, 8, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Blocks.OAK_LOG, 1, 8, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Blocks.SPRUCE_LOG, 1, 8, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Blocks.CHERRY_LOG, 1, 8, 4, 1),
-                    new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_PICKAXE, 1, 1, 1, 0.2F),
-                    new VillagerTrades.ItemsForEmeralds(potion(Potions.LONG_INVISIBILITY), 5, 1, 1, 1)
-                },
-                2
+            .add(
+                    Pair.of(
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.ItemsForEmeralds(Items.PACKED_ICE, 1, 1, 6, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_ICE, 6, 1, 6, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.GUNPOWDER, 1, 4, 2, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PODZOL, 3, 3, 6, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Blocks.ACACIA_LOG, 1, 8, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Blocks.BIRCH_LOG, 1, 8, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Blocks.DARK_OAK_LOG, 1, 8, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Blocks.JUNGLE_LOG, 1, 8, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Blocks.OAK_LOG, 1, 8, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Blocks.SPRUCE_LOG, 1, 8, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Blocks.CHERRY_LOG, 1, 8, 4, 1),
+                                    new VillagerTrades.EnchantedItemForEmeralds(Items.IRON_PICKAXE, 1, 1, 1, 0.2F),
+                                    new VillagerTrades.ItemsForEmeralds(potion(Potions.LONG_INVISIBILITY), 5, 1, 1, 1)
+                            },
+                            2
+                    )
             )
-        )
-        .add(
-            Pair.of(
-                new VillagerTrades.ItemListing[]{
-                    new VillagerTrades.ItemsForEmeralds(Items.TROPICAL_FISH_BUCKET, 3, 1, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.PUFFERFISH_BUCKET, 3, 1, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.SEA_PICKLE, 2, 1, 5, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.SLIME_BALL, 4, 1, 5, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.GLOWSTONE, 2, 1, 5, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.NAUTILUS_SHELL, 5, 1, 5, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.FERN, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.SUGAR_CANE, 1, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN, 1, 1, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.KELP, 3, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.CACTUS, 3, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.DANDELION, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.POPPY, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_ORCHID, 1, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.ALLIUM, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.AZURE_BLUET, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.RED_TULIP, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.ORANGE_TULIP, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.WHITE_TULIP, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.PINK_TULIP, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.OXEYE_DAISY, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.CORNFLOWER, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.LILY_OF_THE_VALLEY, 1, 1, 7, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.WHEAT_SEEDS, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BEETROOT_SEEDS, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN_SEEDS, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.MELON_SEEDS, 1, 1, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.ACACIA_SAPLING, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BIRCH_SAPLING, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.DARK_OAK_SAPLING, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.JUNGLE_SAPLING, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.OAK_SAPLING, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.SPRUCE_SAPLING, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.CHERRY_SAPLING, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.MANGROVE_PROPAGULE, 5, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.RED_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.WHITE_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.PINK_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BLACK_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.GREEN_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.YELLOW_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.GRAY_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.PURPLE_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.LIME_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.ORANGE_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BROWN_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.CYAN_DYE, 1, 3, 12, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BRAIN_CORAL_BLOCK, 3, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BUBBLE_CORAL_BLOCK, 3, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.FIRE_CORAL_BLOCK, 3, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.HORN_CORAL_BLOCK, 3, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.TUBE_CORAL_BLOCK, 3, 1, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.VINE, 1, 3, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.BROWN_MUSHROOM, 1, 3, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.RED_MUSHROOM, 1, 3, 4, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.LILY_PAD, 1, 5, 2, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.SMALL_DRIPLEAF, 1, 2, 5, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.SAND, 1, 8, 8, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.RED_SAND, 1, 4, 6, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.POINTED_DRIPSTONE, 1, 2, 5, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.ROOTED_DIRT, 1, 2, 5, 1),
-                    new VillagerTrades.ItemsForEmeralds(Items.MOSS_BLOCK, 1, 2, 5, 1)
-                },
-                5
+            .add(
+                    Pair.of(
+                            new VillagerTrades.ItemListing[]{
+                                    new VillagerTrades.ItemsForEmeralds(Items.TROPICAL_FISH_BUCKET, 3, 1, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PUFFERFISH_BUCKET, 3, 1, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.SEA_PICKLE, 2, 1, 5, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.SLIME_BALL, 4, 1, 5, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.GLOWSTONE, 2, 1, 5, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.NAUTILUS_SHELL, 5, 1, 5, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.FERN, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.SUGAR_CANE, 1, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN, 1, 1, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.KELP, 3, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.CACTUS, 3, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.DANDELION, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.POPPY, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_ORCHID, 1, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.ALLIUM, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.AZURE_BLUET, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.RED_TULIP, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.ORANGE_TULIP, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.WHITE_TULIP, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PINK_TULIP, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.OXEYE_DAISY, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.CORNFLOWER, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LILY_OF_THE_VALLEY, 1, 1, 7, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.WHEAT_SEEDS, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BEETROOT_SEEDS, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PUMPKIN_SEEDS, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.MELON_SEEDS, 1, 1, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.ACACIA_SAPLING, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BIRCH_SAPLING, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.DARK_OAK_SAPLING, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.JUNGLE_SAPLING, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.OAK_SAPLING, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.SPRUCE_SAPLING, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.CHERRY_SAPLING, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.MANGROVE_PROPAGULE, 5, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.RED_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.WHITE_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BLUE_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PINK_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BLACK_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.GREEN_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.YELLOW_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.GRAY_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.PURPLE_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LIME_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.ORANGE_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BROWN_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.CYAN_DYE, 1, 3, 12, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BRAIN_CORAL_BLOCK, 3, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BUBBLE_CORAL_BLOCK, 3, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.FIRE_CORAL_BLOCK, 3, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.HORN_CORAL_BLOCK, 3, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.TUBE_CORAL_BLOCK, 3, 1, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.VINE, 1, 3, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.BROWN_MUSHROOM, 1, 3, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.RED_MUSHROOM, 1, 3, 4, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.LILY_PAD, 1, 5, 2, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.SMALL_DRIPLEAF, 1, 2, 5, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.SAND, 1, 8, 8, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.RED_SAND, 1, 4, 6, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.POINTED_DRIPSTONE, 1, 2, 5, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.ROOTED_DIRT, 1, 2, 5, 1),
+                                    new VillagerTrades.ItemsForEmeralds(Items.MOSS_BLOCK, 1, 2, 5, 1)
+                            },
+                            5
+                    )
             )
-        )
-        .build();
+            .build();
 
     private static VillagerTrades.ItemListing commonBooks(int experience) {
         return new VillagerTrades.TypeSpecificTrade(
-            ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
-                .put(VillagerType.DESERT, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_DESERT_COMMON))
-                .put(VillagerType.JUNGLE, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_JUNGLE_COMMON))
-                .put(VillagerType.PLAINS, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_PLAINS_COMMON))
-                .put(VillagerType.SAVANNA, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_SAVANNA_COMMON))
-                .put(VillagerType.SNOW, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_SNOW_COMMON))
-                .put(VillagerType.SWAMP, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_SWAMP_COMMON))
-                .put(VillagerType.TAIGA, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_TAIGA_COMMON))
-                .build()
+                ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
+                        .put(VillagerType.DESERT, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_DESERT_COMMON))
+                        .put(VillagerType.JUNGLE, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_JUNGLE_COMMON))
+                        .put(VillagerType.PLAINS, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_PLAINS_COMMON))
+                        .put(VillagerType.SAVANNA, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_SAVANNA_COMMON))
+                        .put(VillagerType.SNOW, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_SNOW_COMMON))
+                        .put(VillagerType.SWAMP, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_SWAMP_COMMON))
+                        .put(VillagerType.TAIGA, new VillagerTrades.EnchantBookForEmeralds(experience, EnchantmentTags.TRADES_TAIGA_COMMON))
+                        .build()
         );
     }
 
     private static VillagerTrades.ItemListing specialBooks() {
         return new VillagerTrades.TypeSpecificTrade(
-            ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
-                .put(VillagerType.DESERT, new VillagerTrades.EnchantBookForEmeralds(30, 3, 3, EnchantmentTags.TRADES_DESERT_SPECIAL))
-                .put(VillagerType.JUNGLE, new VillagerTrades.EnchantBookForEmeralds(30, 2, 2, EnchantmentTags.TRADES_JUNGLE_SPECIAL))
-                .put(VillagerType.PLAINS, new VillagerTrades.EnchantBookForEmeralds(30, 3, 3, EnchantmentTags.TRADES_PLAINS_SPECIAL))
-                .put(VillagerType.SAVANNA, new VillagerTrades.EnchantBookForEmeralds(30, 3, 3, EnchantmentTags.TRADES_SAVANNA_SPECIAL))
-                .put(VillagerType.SNOW, new VillagerTrades.EnchantBookForEmeralds(30, EnchantmentTags.TRADES_SNOW_SPECIAL))
-                .put(VillagerType.SWAMP, new VillagerTrades.EnchantBookForEmeralds(30, EnchantmentTags.TRADES_SWAMP_SPECIAL))
-                .put(VillagerType.TAIGA, new VillagerTrades.EnchantBookForEmeralds(30, 2, 2, EnchantmentTags.TRADES_TAIGA_SPECIAL))
-                .build()
+                ImmutableMap.<VillagerType, VillagerTrades.ItemListing>builder()
+                        .put(VillagerType.DESERT, new VillagerTrades.EnchantBookForEmeralds(30, 3, 3, EnchantmentTags.TRADES_DESERT_SPECIAL))
+                        .put(VillagerType.JUNGLE, new VillagerTrades.EnchantBookForEmeralds(30, 2, 2, EnchantmentTags.TRADES_JUNGLE_SPECIAL))
+                        .put(VillagerType.PLAINS, new VillagerTrades.EnchantBookForEmeralds(30, 3, 3, EnchantmentTags.TRADES_PLAINS_SPECIAL))
+                        .put(VillagerType.SAVANNA, new VillagerTrades.EnchantBookForEmeralds(30, 3, 3, EnchantmentTags.TRADES_SAVANNA_SPECIAL))
+                        .put(VillagerType.SNOW, new VillagerTrades.EnchantBookForEmeralds(30, EnchantmentTags.TRADES_SNOW_SPECIAL))
+                        .put(VillagerType.SWAMP, new VillagerTrades.EnchantBookForEmeralds(30, EnchantmentTags.TRADES_SWAMP_SPECIAL))
+                        .put(VillagerType.TAIGA, new VillagerTrades.EnchantBookForEmeralds(30, 2, 2, EnchantmentTags.TRADES_TAIGA_SPECIAL))
+                        .build()
         );
     }
 
@@ -1418,7 +1412,7 @@ public class VillagerTrades {
             ItemCost itemCost = new ItemCost(Items.EMERALD, this.value);
             ItemStack itemStack = new ItemStack(this.item);
             if (itemStack.is(ItemTags.DYEABLE)) {
-                List<DyeItem> list = Lists.newArrayList();
+                List<DyeItem> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 list.add(getRandomDye(random));
                 if (random.nextFloat() > 0.7F) {
                     list.add(getRandomDye(random));
@@ -1516,9 +1510,9 @@ public class VillagerTrades {
         @Override
         public MerchantOffer getOffer(Entity entity, RandomSource random) {
             Optional<Holder<Enchantment>> optional = entity.level()
-                .registryAccess()
-                .registryOrThrow(Registries.ENCHANTMENT)
-                .getRandomElementOf(this.tradeableEnchantments, random);
+                    .registryAccess()
+                    .registryOrThrow(Registries.ENCHANTMENT)
+                    .getRandomElementOf(this.tradeableEnchantments, random);
             int l;
             ItemStack itemStack;
             if (!optional.isEmpty()) {
@@ -1569,7 +1563,7 @@ public class VillagerTrades {
             int i = 5 + random.nextInt(15);
             RegistryAccess registryAccess = entity.level().registryAccess();
             Optional<HolderSet.Named<Enchantment>> optional = registryAccess.registryOrThrow(Registries.ENCHANTMENT)
-                .getTag(EnchantmentTags.ON_TRADED_EQUIPMENT);
+                    .getTag(EnchantmentTags.ON_TRADED_EQUIPMENT);
             ItemStack itemStack = EnchantmentHelper.enchantItem(random, new ItemStack(this.itemStack.getItem()), i, registryAccess, optional);
             int j = Math.min(this.baseEmeraldCost + i, 64);
             ItemCost itemCost = new ItemCost(Items.EMERALD, j);
@@ -1603,41 +1597,41 @@ public class VillagerTrades {
         }
 
         private ItemsAndEmeraldsToItems(
-            ItemLike item, int count, int price, ItemStack processed, int processedCount, int maxUses, int experience, float multiplier
+                ItemLike item, int count, int price, ItemStack processed, int processedCount, int maxUses, int experience, float multiplier
         ) {
             this(new ItemCost(item, count), price, processed.copyWithCount(processedCount), maxUses, experience, multiplier, Optional.empty());
         }
 
         ItemsAndEmeraldsToItems(
-            ItemLike item,
-            int count,
-            int price,
-            ItemLike processed,
-            int processedCount,
-            int maxUses,
-            int experience,
-            float multiplier,
-            ResourceKey<EnchantmentProvider> enchantmentProviderKey
+                ItemLike item,
+                int count,
+                int price,
+                ItemLike processed,
+                int processedCount,
+                int maxUses,
+                int experience,
+                float multiplier,
+                ResourceKey<EnchantmentProvider> enchantmentProviderKey
         ) {
             this(
-                new ItemCost(item, count),
-                price,
-                new ItemStack(processed, processedCount),
-                maxUses,
-                experience,
-                multiplier,
-                Optional.of(enchantmentProviderKey)
+                    new ItemCost(item, count),
+                    price,
+                    new ItemStack(processed, processedCount),
+                    maxUses,
+                    experience,
+                    multiplier,
+                    Optional.of(enchantmentProviderKey)
             );
         }
 
         public ItemsAndEmeraldsToItems(
-            ItemCost toBeProcessed,
-            int count,
-            ItemStack processed,
-            int maxUses,
-            int processedCount,
-            float multiplier,
-            Optional<ResourceKey<EnchantmentProvider>> enchantmentProviderKey
+                ItemCost toBeProcessed,
+                int count,
+                ItemStack processed,
+                int maxUses,
+                int processedCount,
+                float multiplier,
+                Optional<ResourceKey<EnchantmentProvider>> enchantmentProviderKey
         ) {
             this.fromItem = toBeProcessed;
             this.emeraldCost = count;
@@ -1654,17 +1648,17 @@ public class VillagerTrades {
             ItemStack itemStack = this.toItem.copy();
             Level level = entity.level();
             this.enchantmentProvider
-                .ifPresent(
-                    key -> EnchantmentHelper.enchantItemFromProvider(
-                            itemStack,
-                            level.registryAccess(),
-                            (ResourceKey<EnchantmentProvider>)key,
-                            level.getCurrentDifficultyAt(entity.blockPosition()),
-                            random
-                        )
-                );
+                    .ifPresent(
+                            key -> EnchantmentHelper.enchantItemFromProvider(
+                                    itemStack,
+                                    level.registryAccess(),
+                                    (ResourceKey<EnchantmentProvider>) key,
+                                    level.getCurrentDifficultyAt(entity.blockPosition()),
+                                    random
+                            )
+                    );
             return new MerchantOffer(
-                new ItemCost(Items.EMERALD, this.emeraldCost), Optional.of(this.fromItem), itemStack, 0, this.maxUses, this.villagerXp, this.priceMultiplier
+                    new ItemCost(Items.EMERALD, this.emeraldCost), Optional.of(this.fromItem), itemStack, 0, this.maxUses, this.villagerXp, this.priceMultiplier
             );
         }
     }
@@ -1698,7 +1692,7 @@ public class VillagerTrades {
         }
 
         public ItemsForEmeralds(
-            Item item, int price, int count, int maxUses, int experience, float multiplier, ResourceKey<EnchantmentProvider> enchantmentProviderKey
+                Item item, int price, int count, int maxUses, int experience, float multiplier, ResourceKey<EnchantmentProvider> enchantmentProviderKey
         ) {
             this(new ItemStack(item), price, count, maxUses, experience, multiplier, Optional.of(enchantmentProviderKey));
         }
@@ -1708,13 +1702,13 @@ public class VillagerTrades {
         }
 
         public ItemsForEmeralds(
-            ItemStack sell,
-            int price,
-            int count,
-            int maxUses,
-            int experience,
-            float multiplier,
-            Optional<ResourceKey<EnchantmentProvider>> enchantmentProviderKey
+                ItemStack sell,
+                int price,
+                int count,
+                int maxUses,
+                int experience,
+                float multiplier,
+                Optional<ResourceKey<EnchantmentProvider>> enchantmentProviderKey
         ) {
             this.itemStack = sell;
             this.emeraldCost = price;
@@ -1730,15 +1724,15 @@ public class VillagerTrades {
             ItemStack itemStack = this.itemStack.copy();
             Level level = entity.level();
             this.enchantmentProvider
-                .ifPresent(
-                    key -> EnchantmentHelper.enchantItemFromProvider(
-                            itemStack,
-                            level.registryAccess(),
-                            (ResourceKey<EnchantmentProvider>)key,
-                            level.getCurrentDifficultyAt(entity.blockPosition()),
-                            random
-                        )
-                );
+                    .ifPresent(
+                            key -> EnchantmentHelper.enchantItemFromProvider(
+                                    itemStack,
+                                    level.registryAccess(),
+                                    (ResourceKey<EnchantmentProvider>) key,
+                                    level.getCurrentDifficultyAt(entity.blockPosition()),
+                                    random
+                            )
+                    );
             return new MerchantOffer(new ItemCost(Items.EMERALD, this.emeraldCost), itemStack, this.maxUses, this.villagerXp, this.priceMultiplier);
         }
     }
@@ -1792,14 +1786,14 @@ public class VillagerTrades {
         public MerchantOffer getOffer(Entity entity, RandomSource random) {
             ItemCost itemCost = new ItemCost(Items.EMERALD, this.emeraldCost);
             List<Holder<Potion>> list = BuiltInRegistries.POTION
-                .holders()
-                .filter(entry -> !entry.value().getEffects().isEmpty() && entity.level().potionBrewing().isBrewablePotion(entry))
-                .collect(Collectors.toList());
+                    .holders()
+                    .filter(entry -> !entry.value().getEffects().isEmpty() && entity.level().potionBrewing().isBrewablePotion(entry))
+                    .collect(Collectors.toList());
             Holder<Potion> holder = Util.getRandom(list, random);
             ItemStack itemStack = new ItemStack(this.toItem.getItem(), this.toCount);
             itemStack.set(DataComponents.POTION_CONTENTS, new PotionContents(holder));
             return new MerchantOffer(
-                itemCost, Optional.of(new ItemCost(this.fromItem, this.fromCount)), itemStack, this.maxUses, this.villagerXp, this.priceMultiplier
+                    itemCost, Optional.of(new ItemCost(this.fromItem, this.fromCount)), itemStack, this.maxUses, this.villagerXp, this.priceMultiplier
             );
         }
     }
@@ -1827,16 +1821,17 @@ public class VillagerTrades {
             if (!(entity.level() instanceof ServerLevel)) {
                 return null;
             } else {
-                ServerLevel serverLevel = (ServerLevel)entity.level();
-                if (!serverLevel.paperConfig().environment.treasureMaps.enabled) return null; // Paper - Configurable cartographer treasure maps
+                ServerLevel serverLevel = (ServerLevel) entity.level();
+                if (!serverLevel.paperConfig().environment.treasureMaps.enabled)
+                    return null; // Paper - Configurable cartographer treasure maps
                 BlockPos blockPos = serverLevel.findNearestMapStructure(this.destination, entity.blockPosition(), 100, !serverLevel.paperConfig().environment.treasureMaps.findAlreadyDiscoveredVillager); // Paper - Configurable cartographer treasure maps
                 if (blockPos != null) {
-                    ItemStack itemStack = MapItem.create(serverLevel, blockPos.getX(), blockPos.getZ(), (byte)2, true, true);
+                    ItemStack itemStack = MapItem.create(serverLevel, blockPos.getX(), blockPos.getZ(), (byte) 2, true, true);
                     MapItem.renderBiomePreviewMap(serverLevel, itemStack);
                     MapItemSavedData.addTargetDecoration(itemStack, blockPos, "+", this.destinationType);
                     itemStack.set(DataComponents.ITEM_NAME, Component.translatable(this.displayName));
                     return new MerchantOffer(
-                        new ItemCost(Items.EMERALD, this.emeraldCost), Optional.of(new ItemCost(Items.COMPASS)), itemStack, this.maxUses, this.villagerXp, 0.2F
+                            new ItemCost(Items.EMERALD, this.emeraldCost), Optional.of(new ItemCost(Items.COMPASS)), itemStack, this.maxUses, this.villagerXp, 0.2F
                     );
                 } else {
                     return null;
@@ -1845,9 +1840,10 @@ public class VillagerTrades {
         }
     }
 
-    static record TypeSpecificTrade(Map<VillagerType, VillagerTrades.ItemListing> trades) implements VillagerTrades.ItemListing {
+    static record TypeSpecificTrade(
+            Map<VillagerType, VillagerTrades.ItemListing> trades) implements VillagerTrades.ItemListing {
         public static VillagerTrades.TypeSpecificTrade oneTradeInBiomes(VillagerTrades.ItemListing factory, VillagerType... types) {
-            return new VillagerTrades.TypeSpecificTrade(Arrays.stream(types).collect(Collectors.toMap(type -> (VillagerType)type, type -> factory)));
+            return new VillagerTrades.TypeSpecificTrade(Arrays.stream(types).collect(Collectors.toMap(type -> (VillagerType) type, type -> factory)));
         }
 
         @Nullable
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 865c83af67fee690e4d3a62c7c145c308e619ed1..0f52cbbaeafbf2a5868d4d817c5f2672148517db 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -7,16 +7,6 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.function.Predicate;
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
@@ -24,11 +14,7 @@ import net.minecraft.core.Direction;
 import net.minecraft.core.GlobalPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.particles.ParticleTypes;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.nbt.ListTag;
-import net.minecraft.nbt.NbtOps;
-import net.minecraft.nbt.NbtUtils;
-import net.minecraft.nbt.Tag;
+import net.minecraft.nbt.*;
 import net.minecraft.network.chat.ClickEvent;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
@@ -50,27 +36,12 @@ import net.minecraft.tags.EntityTypeTags;
 import net.minecraft.tags.FluidTags;
 import net.minecraft.util.Mth;
 import net.minecraft.util.Unit;
-import net.minecraft.world.Container;
-import net.minecraft.world.Difficulty;
-import net.minecraft.world.InteractionHand;
-import net.minecraft.world.InteractionResult;
-import net.minecraft.world.MenuProvider;
+import net.minecraft.world.*;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.effect.MobEffectUtil;
 import net.minecraft.world.effect.MobEffects;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityAttachment;
-import net.minecraft.world.entity.EntityAttachments;
-import net.minecraft.world.entity.EntityDimensions;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.HumanoidArm;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.MoverType;
-import net.minecraft.world.entity.Pose;
-import net.minecraft.world.entity.SlotAccess;
-import net.minecraft.world.entity.TamableAnimal;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.animal.Parrot;
@@ -88,12 +59,7 @@ import net.minecraft.world.inventory.AbstractContainerMenu;
 import net.minecraft.world.inventory.ClickAction;
 import net.minecraft.world.inventory.InventoryMenu;
 import net.minecraft.world.inventory.PlayerEnderChestContainer;
-import net.minecraft.world.item.ElytraItem;
-import net.minecraft.world.item.ItemCooldowns;
-import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.Items;
-import net.minecraft.world.item.ProjectileWeaponItem;
-import net.minecraft.world.item.SwordItem;
+import net.minecraft.world.item.*;
 import net.minecraft.world.item.crafting.RecipeHolder;
 import net.minecraft.world.item.enchantment.EnchantmentEffectComponents;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
@@ -113,19 +79,22 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Scoreboard;
-import org.slf4j.Logger;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftVector;
 import org.bukkit.entity.Item;
 import org.bukkit.event.entity.CreatureSpawnEvent;
-import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.entity.EntityExhaustionEvent;
-import org.bukkit.event.entity.EntityKnockbackEvent;
 import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.player.PlayerDropItemEvent;
 import org.bukkit.event.player.PlayerVelocityEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Predicate;
 // CraftBukkit end
 
 public abstract class Player extends LivingEntity {
@@ -329,20 +298,20 @@ public abstract class Player extends LivingEntity {
             this.foodData.tick(this);
             // Gale start - Hydrinity - increase time statistics in intervals
             if (increaseTimeStatisticsInterval == 1 || this.tickCount % increaseTimeStatisticsInterval == 0) {
-            this.awardStat(Stats.PLAY_TIME, increaseTimeStatisticsInterval);
-            this.awardStat(Stats.TOTAL_WORLD_TIME, increaseTimeStatisticsInterval);
-            // Gale end - Hydrinity - increase time statistics in intervals
-            if (this.isAlive()) {
-                this.awardStat(Stats.TIME_SINCE_DEATH, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
-            }
+                this.awardStat(Stats.PLAY_TIME, increaseTimeStatisticsInterval);
+                this.awardStat(Stats.TOTAL_WORLD_TIME, increaseTimeStatisticsInterval);
+                // Gale end - Hydrinity - increase time statistics in intervals
+                if (this.isAlive()) {
+                    this.awardStat(Stats.TIME_SINCE_DEATH, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
+                }
 
-            if (this.isDiscrete()) {
-                this.awardStat(Stats.CROUCH_TIME, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
-            }
+                if (this.isDiscrete()) {
+                    this.awardStat(Stats.CROUCH_TIME, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
+                }
 
-            if (!this.isSleeping()) {
-                this.awardStat(Stats.TIME_SINCE_REST, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
-            }
+                if (!this.isSleeping()) {
+                    this.awardStat(Stats.TIME_SINCE_REST, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
+                }
             } // Gale - Hydrinity - increase time statistics in intervals
         }
 
@@ -526,7 +495,8 @@ public abstract class Player extends LivingEntity {
         this.level().playSound(this, this.getX(), this.getY(), this.getZ(), sound, this.getSoundSource(), volume, pitch);
     }
 
-    public void playNotifySound(SoundEvent sound, SoundSource category, float volume, float pitch) {}
+    public void playNotifySound(SoundEvent sound, SoundSource category, float volume, float pitch) {
+    }
 
     @Override
     public SoundSource getSoundSource() {
@@ -557,6 +527,7 @@ public abstract class Player extends LivingEntity {
         closeContainer();
         this.containerMenu = this.inventoryMenu;
     }
+
     // Paper end - Inventory close reason
     // Paper start - special close for unloaded inventory
     public void closeUnloadedInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
@@ -568,7 +539,8 @@ public abstract class Player extends LivingEntity {
         this.containerMenu = this.inventoryMenu;
     }
 
-    protected void doCloseContainer() {}
+    protected void doCloseContainer() {
+    }
 
     @Override
     public void rideTick() {
@@ -639,7 +611,7 @@ public abstract class Player extends LivingEntity {
             }
 
             List<Entity> list = this.level().getEntities(this, axisalignedbb);
-            List<Entity> list1 = Lists.newArrayList();
+            List<Entity> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             Iterator iterator = list.iterator();
 
             while (iterator.hasNext()) {
@@ -661,7 +633,7 @@ public abstract class Player extends LivingEntity {
         this.playShoulderEntityAmbientSound(this.getShoulderEntityRight());
         if (!this.level().isClientSide && (this.fallDistance > 0.5F || this.isInWater()) || this.abilities.flying || this.isSleeping() || this.isInPowderSnow) {
             if (!this.level().paperConfig().entities.behavior.parrotsAreUnaffectedByPlayerMovement) // Paper - Add option to make parrots stay
-            this.removeEntitiesOnShoulder();
+                this.removeEntitiesOnShoulder();
         }
 
     }
@@ -1171,25 +1143,33 @@ public abstract class Player extends LivingEntity {
         return false;
     }
 
-    public void openTextEdit(SignBlockEntity sign, boolean front) {}
+    public void openTextEdit(SignBlockEntity sign, boolean front) {
+    }
 
-    public void openMinecartCommandBlock(BaseCommandBlock commandBlockExecutor) {}
+    public void openMinecartCommandBlock(BaseCommandBlock commandBlockExecutor) {
+    }
 
-    public void openCommandBlock(CommandBlockEntity commandBlock) {}
+    public void openCommandBlock(CommandBlockEntity commandBlock) {
+    }
 
-    public void openStructureBlock(StructureBlockEntity structureBlock) {}
+    public void openStructureBlock(StructureBlockEntity structureBlock) {
+    }
 
-    public void openJigsawBlock(JigsawBlockEntity jigsaw) {}
+    public void openJigsawBlock(JigsawBlockEntity jigsaw) {
+    }
 
-    public void openHorseInventory(AbstractHorse horse, Container inventory) {}
+    public void openHorseInventory(AbstractHorse horse, Container inventory) {
+    }
 
     public OptionalInt openMenu(@Nullable MenuProvider factory) {
         return OptionalInt.empty();
     }
 
-    public void sendMerchantOffers(int syncId, MerchantOffers offers, int levelProgress, int experience, boolean leveled, boolean refreshable) {}
+    public void sendMerchantOffers(int syncId, MerchantOffers offers, int levelProgress, int experience, boolean leveled, boolean refreshable) {
+    }
 
-    public void openItemGui(ItemStack book, InteractionHand hand) {}
+    public void openItemGui(ItemStack book, InteractionHand hand) {
+    }
 
     public InteractionResult interactOn(Entity entity, InteractionHand hand) {
         if (this.isSpectator()) {
@@ -1237,6 +1217,7 @@ public abstract class Player extends LivingEntity {
         // Paper start - Force entity dismount during teleportation
         this.removeVehicle(false);
     }
+
     @Override
     public void removeVehicle(boolean suppressCancellation) {
         super.removeVehicle(suppressCancellation);
@@ -1316,14 +1297,14 @@ public abstract class Player extends LivingEntity {
         // Paper start - PlayerAttackEntityEvent
         boolean willAttack = target.isAttackable() && !target.skipAttackInteraction(this); // Vanilla logic
         io.papermc.paper.event.player.PrePlayerAttackEntityEvent playerAttackEntityEvent = new io.papermc.paper.event.player.PrePlayerAttackEntityEvent(
-            (org.bukkit.entity.Player) this.getBukkitEntity(),
-            target.getBukkitEntity(),
-            willAttack
+                (org.bukkit.entity.Player) this.getBukkitEntity(),
+                target.getBukkitEntity(),
+                willAttack
         );
 
         if (playerAttackEntityEvent.callEvent() && willAttack) { // Logic moved to willAttack local variable.
             {
-        // Paper end - PlayerAttackEntityEvent
+                // Paper end - PlayerAttackEntityEvent
                 float f = this.isAutoSpinAttack() ? this.autoSpinAttackDmg : (float) this.getAttributeValue(Attributes.ATTACK_DAMAGE);
                 ItemStack itemstack = this.getWeaponItem();
                 DamageSource damagesource = this.damageSources().playerAttack(this);
@@ -1405,7 +1386,7 @@ public abstract class Player extends LivingEntity {
                             this.setDeltaMovement(this.getDeltaMovement().multiply(0.6D, 1.0D, 0.6D));
                             // Paper start - Configurable sprint interruption on attack
                             if (!this.level().paperConfig().misc.disableSprintInterruptionOnAttack) {
-                            this.setSprinting(false);
+                                this.setSprinting(false);
                             }
                             // Paper end - Configurable sprint interruption on attack
                         }
@@ -1459,9 +1440,9 @@ public abstract class Player extends LivingEntity {
                             }
 
                             if (!cancelled) {
-                            ((ServerPlayer) target).connection.send(new ClientboundSetEntityMotionPacket(target));
-                            target.hurtMarked = false;
-                            target.setDeltaMovement(vec3d);
+                                ((ServerPlayer) target).connection.send(new ClientboundSetEntityMotionPacket(target));
+                                target.hurtMarked = false;
+                                target.setDeltaMovement(vec3d);
                             }
                             // CraftBukkit end
                         }
@@ -1553,11 +1534,13 @@ public abstract class Player extends LivingEntity {
         this.attack(target);
     }
 
-    @io.papermc.paper.annotation.DoNotUse @Deprecated // Paper - Add PlayerShieldDisableEvent
+    @io.papermc.paper.annotation.DoNotUse
+    @Deprecated // Paper - Add PlayerShieldDisableEvent
     public void disableShield() {
         // Paper start - Add PlayerShieldDisableEvent
         this.disableShield(null);
     }
+
     public void disableShield(@Nullable LivingEntity attacker) {
         final org.bukkit.entity.Entity finalAttacker = attacker != null ? attacker.getBukkitEntity() : null;
         if (finalAttacker != null) {
@@ -1572,9 +1555,11 @@ public abstract class Player extends LivingEntity {
         this.level().broadcastEntityEvent(this, (byte) 30);
     }
 
-    public void crit(Entity target) {}
+    public void crit(Entity target) {
+    }
 
-    public void magicCrit(Entity target) {}
+    public void magicCrit(Entity target) {
+    }
 
     public void sweepAttack() {
         double d0 = (double) (-Mth.sin(this.getYRot() * 0.017453292F));
@@ -1586,7 +1571,8 @@ public abstract class Player extends LivingEntity {
 
     }
 
-    public void respawn() {}
+    public void respawn() {
+    }
 
     @Override
     public void remove(Entity.RemovalReason reason) {
@@ -1626,7 +1612,8 @@ public abstract class Player extends LivingEntity {
         return this.abilities.instabuild;
     }
 
-    public void updateTutorialInventoryAction(ItemStack cursorStack, ItemStack slotStack, ClickAction clickType) {}
+    public void updateTutorialInventoryAction(ItemStack cursorStack, ItemStack slotStack, ClickAction clickType) {
+    }
 
     public boolean hasContainerOpen() {
         return this.containerMenu != this.inventoryMenu;
@@ -1666,7 +1653,8 @@ public abstract class Player extends LivingEntity {
         return this.sleepCounter;
     }
 
-    public void displayClientMessage(Component message, boolean overlay) {}
+    public void displayClientMessage(Component message, boolean overlay) {
+    }
 
     public void awardStat(ResourceLocation stat) {
         this.awardStat(Stats.CUSTOM.get(stat));
@@ -1680,17 +1668,21 @@ public abstract class Player extends LivingEntity {
         this.awardStat(stat, 1);
     }
 
-    public void awardStat(Stat<?> stat, int amount) {}
+    public void awardStat(Stat<?> stat, int amount) {
+    }
 
-    public void resetStat(Stat<?> stat) {}
+    public void resetStat(Stat<?> stat) {
+    }
 
     public int awardRecipes(Collection<RecipeHolder<?>> recipes) {
         return 0;
     }
 
-    public void triggerRecipeCrafted(RecipeHolder<?> recipe, List<ItemStack> ingredients) {}
+    public void triggerRecipeCrafted(RecipeHolder<?> recipe, List<ItemStack> ingredients) {
+    }
 
-    public void awardRecipesByKey(List<ResourceLocation> recipes) {}
+    public void awardRecipesByKey(List<ResourceLocation> recipes) {
+    }
 
     public int resetRecipes(Collection<RecipeHolder<?>> recipes) {
         return 0;
@@ -1822,8 +1814,8 @@ public abstract class Player extends LivingEntity {
     public void stopFallFlying() {
         // CraftBukkit start
         if (!org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
-        this.setSharedFlag(7, true);
-        this.setSharedFlag(7, false);
+            this.setSharedFlag(7, true);
+            this.setSharedFlag(7, false);
         }
         // CraftBukkit end
     }
@@ -1939,6 +1931,7 @@ public abstract class Player extends LivingEntity {
     public int getXpNeededForNextLevel() {
         return this.experienceLevel >= 30 ? 112 + (this.experienceLevel - 30) * 9 : (this.experienceLevel >= 15 ? 37 + (this.experienceLevel - 15) * 5 : 7 + this.experienceLevel * 2); // Paper - diff on change; calculateTotalExperiencePoints
     }
+
     // Paper start - send while respecting visibility
     private static void sendSoundEffect(Player fromEntity, double x, double y, double z, SoundEvent soundEffect, SoundSource soundCategory, float volume, float pitch) {
         fromEntity.level().playSound(fromEntity, x, y, z, soundEffect, soundCategory, volume, pitch); // This will not send the effect to the entity itself
@@ -2040,7 +2033,8 @@ public abstract class Player extends LivingEntity {
         return !this.abilities.flying && (!this.onGround() || !this.isDiscrete()) ? Entity.MovementEmission.ALL : Entity.MovementEmission.NONE;
     }
 
-    public void onUpdateAbilities() {}
+    public void onUpdateAbilities() {
+    }
 
     @Override
     public Component getName() {
@@ -2367,9 +2361,9 @@ public abstract class Player extends LivingEntity {
     protected boolean tryReadyArrow(ItemStack bow, ItemStack itemstack) {
         return !(this instanceof ServerPlayer) ||
                 new com.destroystokyo.paper.event.player.PlayerReadyArrowEvent(
-                    ((ServerPlayer) this).getBukkitEntity(),
-                    org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(bow),
-                    org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)
+                        ((ServerPlayer) this).getBukkitEntity(),
+                        org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(bow),
+                        org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)
                 ).callEvent();
     }
     // Paper end - PlayerReadyArrowEvent
diff --git a/src/main/java/net/minecraft/world/entity/player/StackedContents.java b/src/main/java/net/minecraft/world/entity/player/StackedContents.java
index fcabf630ce1e4949d00f485a5bff66dd1e54a277..516f5db98e62f1ec6eb00b8da2b59a08db1a231d 100644
--- a/src/main/java/net/minecraft/world/entity/player/StackedContents.java
+++ b/src/main/java/net/minecraft/world/entity/player/StackedContents.java
@@ -1,16 +1,6 @@
 package net.minecraft.world.entity.player;
 
-import com.google.common.collect.Lists;
-import it.unimi.dsi.fastutil.ints.Int2IntMap;
-import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
-import it.unimi.dsi.fastutil.ints.IntAVLTreeSet;
-import it.unimi.dsi.fastutil.ints.IntArrayList;
-import it.unimi.dsi.fastutil.ints.IntCollection;
-import it.unimi.dsi.fastutil.ints.IntIterator;
-import it.unimi.dsi.fastutil.ints.IntList;
-import java.util.BitSet;
-import java.util.List;
-import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.ints.*;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.world.item.Item;
@@ -19,13 +9,19 @@ import net.minecraft.world.item.crafting.Ingredient;
 import net.minecraft.world.item.crafting.Recipe;
 import net.minecraft.world.item.crafting.RecipeHolder;
 
+import javax.annotation.Nullable;
+import java.util.BitSet;
+import java.util.List;
+
 public class StackedContents {
     private static final int EMPTY = 0;
     public final Int2IntMap contents = new Int2IntOpenHashMap();
-    @Nullable public io.papermc.paper.inventory.recipe.StackedContentsExtraMap extrasMap = null; // Paper - Improve exact choice recipe ingredients
+    @Nullable
+    public io.papermc.paper.inventory.recipe.StackedContentsExtraMap extrasMap = null; // Paper - Improve exact choice recipe ingredients
 
     public void accountSimpleStack(ItemStack stack) {
-        if (this.extrasMap != null && !stack.getComponentsPatch().isEmpty() && this.extrasMap.accountStack(stack, Math.min(64, stack.getCount()))) return; // Paper - Improve exact choice recipe ingredients; max of 64 due to accountStack method below
+        if (this.extrasMap != null && !stack.getComponentsPatch().isEmpty() && this.extrasMap.accountStack(stack, Math.min(64, stack.getCount())))
+            return; // Paper - Improve exact choice recipe ingredients; max of 64 due to accountStack method below
         if (!stack.isDamaged() && !stack.isEnchanted() && !stack.has(DataComponents.CUSTOM_NAME)) {
             this.accountStack(stack);
         }
@@ -39,7 +35,8 @@ public class StackedContents {
         if (!stack.isEmpty()) {
             int i = getStackingIndex(stack);
             int j = Math.min(maxCount, stack.getCount());
-            if (this.extrasMap != null && !stack.getComponentsPatch().isEmpty() && this.extrasMap.accountStack(stack, j)) return; // Paper - Improve exact choice recipe ingredients; if an exact ingredient, don't include it
+            if (this.extrasMap != null && !stack.getComponentsPatch().isEmpty() && this.extrasMap.accountStack(stack, j))
+                return; // Paper - Improve exact choice recipe ingredients; if an exact ingredient, don't include it
             this.put(i, j);
         }
     }
@@ -117,7 +114,7 @@ public class StackedContents {
 
     class RecipePicker {
         private final Recipe<?> recipe;
-        private final List<Ingredient> ingredients = Lists.newArrayList();
+        private final List<Ingredient> ingredients = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         private final int ingredientCount;
         private final int[] items;
         private final int itemCount;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java b/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java
index 7fde1807640d0b02d417f48f1f6758f8ae32e04b..ef9a9675b5673c57473b50804729fa616a71beff 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ShulkerBullet.java
@@ -1,10 +1,6 @@
 package net.minecraft.world.entity.projectile;
 
 import com.google.common.base.MoreObjects;
-import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.UUID;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -31,8 +27,11 @@ import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
-// CraftBukkit start
 import org.bukkit.event.entity.EntityRemoveEvent;
+
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.UUID;
 // CraftBukkit end
 
 public class ShulkerBullet extends Projectile {
@@ -118,7 +117,8 @@ public class ShulkerBullet extends Projectile {
     }
 
     @Override
-    protected void defineSynchedData(SynchedEntityData.Builder builder) {}
+    protected void defineSynchedData(SynchedEntityData.Builder builder) {
+    }
 
     @Nullable
     private Direction getMoveDirection() {
@@ -147,7 +147,7 @@ public class ShulkerBullet extends Projectile {
 
         if (!blockposition.closerToCenterThan(this.position(), 2.0D)) {
             BlockPos blockposition1 = this.blockPosition();
-            List<Direction> list = Lists.newArrayList();
+            List<Direction> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             if (axis != Direction.Axis.X) {
                 if (blockposition1.getX() < blockposition.getX() && this.level().isEmptyBlock(blockposition1.east())) {
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raider.java b/src/main/java/net/minecraft/world/entity/raid/Raider.java
index 06487fc9ea416d8256e0c2cd1969d4e0283ffb05..69da2917b443af70652b1ef05182833b9964a4ff 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raider.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raider.java
@@ -1,13 +1,5 @@
 package net.minecraft.world.entity.raid;
 
-import com.google.common.collect.Lists;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
@@ -18,12 +10,7 @@ import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.SpawnGroupData;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.goal.Goal;
 import net.minecraft.world.entity.ai.goal.PathfindToRaidGoal;
 import net.minecraft.world.entity.ai.targeting.TargetingConditions;
@@ -37,8 +24,11 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.phys.Vec3;
-// CraftBukkit start
 import org.bukkit.event.entity.EntityRemoveEvent;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Predicate;
 // CraftBukkit end
 
 public abstract class Raider extends PatrollingMonster {
@@ -299,7 +289,8 @@ public abstract class Raider extends PatrollingMonster {
 
         @Override
         public boolean canUse() {
-            if ((!this.mob.level().purpurConfig.pillagerBypassMobGriefing && !this.mob.level().getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_MOBGRIEFING)) || !this.mob.canPickUpLoot()) return false; // Paper - respect game and entity rules for picking up items // Purpur
+            if ((!this.mob.level().purpurConfig.pillagerBypassMobGriefing && !this.mob.level().getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_MOBGRIEFING)) || !this.mob.canPickUpLoot())
+                return false; // Paper - respect game and entity rules for picking up items // Purpur
             Raid raid = this.mob.getCurrentRaid();
 
             if (this.mob.hasActiveRaid() && !this.mob.getCurrentRaid().isOver() && this.mob.canBeLeader() && !ItemStack.matches(this.mob.getItemBySlot(EquipmentSlot.HEAD), Raid.getLeaderBannerInstance(this.mob.registryAccess().lookupOrThrow(Registries.BANNER_PATTERN)))) {
@@ -337,7 +328,7 @@ public abstract class Raider extends PatrollingMonster {
         private final Raider raider;
         private final double speedModifier;
         private BlockPos poiPos;
-        private final List<BlockPos> visited = Lists.newArrayList();
+        private final List<BlockPos> visited = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         private final int distanceToPoi;
         private boolean stuck;
 
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/Boat.java b/src/main/java/net/minecraft/world/entity/vehicle/Boat.java
index 5f3d58099d83fef4a9230e680b5e199d00eb7c7b..c65748e021a257d393242640c0b85293ea1c89b3 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/Boat.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/Boat.java
@@ -1,11 +1,6 @@
 package net.minecraft.world.entity.vehicle;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.UnmodifiableIterator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.function.IntFunction;
-import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -25,15 +20,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.StringRepresentable;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityDimensions;
-import net.minecraft.world.entity.EntitySelector;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.Leashable;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.MoverType;
-import net.minecraft.world.entity.Pose;
-import net.minecraft.world.entity.VariantHolder;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.animal.Animal;
 import net.minecraft.world.entity.animal.WaterAnimal;
 import net.minecraft.world.entity.player.Player;
@@ -54,7 +41,6 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
-// CraftBukkit start
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.util.CraftLocation;
 import org.bukkit.entity.Vehicle;
@@ -62,6 +48,11 @@ import org.bukkit.event.entity.EntityRemoveEvent;
 import org.bukkit.event.vehicle.VehicleDestroyEvent;
 import org.bukkit.event.vehicle.VehicleEntityCollisionEvent;
 import org.bukkit.event.vehicle.VehicleMoveEvent;
+
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.IntFunction;
 // CraftBukkit end
 
 public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat.Type> {
@@ -204,7 +195,8 @@ public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat
 
     @Override
     public void push(Entity entity) {
-        if (!this.level().paperConfig().collisions.allowVehicleCollisions && this.level().paperConfig().collisions.onlyPlayersCollide && !(entity instanceof Player)) return; // Paper - Collision option for requiring a player participant
+        if (!this.level().paperConfig().collisions.allowVehicleCollisions && this.level().paperConfig().collisions.onlyPlayersCollide && !(entity instanceof Player))
+            return; // Paper - Collision option for requiring a player participant
         if (entity instanceof Boat) {
             if (entity.getBoundingBox().minY < this.getBoundingBox().maxY) {
                 // CraftBukkit start
@@ -324,6 +316,7 @@ public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat
     }
 
     private Location lastLocation; // CraftBukkit
+
     @Override
     public void tick() {
         this.oldStatus = this.status;
@@ -821,7 +814,7 @@ public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat
         BlockPos blockposition1 = blockposition.below();
 
         if (!this.level().isWaterAt(blockposition1)) {
-            List<Vec3> list = Lists.newArrayList();
+            List<Vec3> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             double d2 = this.level().getBlockFloorHeight(blockposition);
 
             if (DismountHelper.isBlockFloorValid(d2)) {
@@ -920,24 +913,24 @@ public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat
 
                     this.causeFallDamage(this.fallDistance, 1.0F, this.damageSources().fall());
                     if (!this.level().isClientSide && !this.isRemoved()) {
-                    // CraftBukkit start
-                    Vehicle vehicle = (Vehicle) this.getBukkitEntity();
-                    VehicleDestroyEvent destroyEvent = new VehicleDestroyEvent(vehicle, null);
-                    this.level().getCraftServer().getPluginManager().callEvent(destroyEvent);
-                    if (!destroyEvent.isCancelled()) {
-                        this.kill();
-                        if (this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
-                            int i;
-
-                            for (i = 0; i < 3; ++i) {
-                                this.spawnAtLocation((ItemLike) this.getVariant().getPlanks());
-                            }
-
-                            for (i = 0; i < 2; ++i) {
-                                this.spawnAtLocation((ItemLike) Items.STICK);
+                        // CraftBukkit start
+                        Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                        VehicleDestroyEvent destroyEvent = new VehicleDestroyEvent(vehicle, null);
+                        this.level().getCraftServer().getPluginManager().callEvent(destroyEvent);
+                        if (!destroyEvent.isCancelled()) {
+                            this.kill();
+                            if (this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
+                                int i;
+
+                                for (i = 0; i < 3; ++i) {
+                                    this.spawnAtLocation((ItemLike) this.getVariant().getPlanks());
+                                }
+
+                                for (i = 0; i < 2; ++i) {
+                                    this.spawnAtLocation((ItemLike) Items.STICK);
+                                }
                             }
                         }
-                    }
                     } // CraftBukkit end
                 }
 
@@ -965,6 +958,7 @@ public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat
         return Mth.lerp(tickDelta, this.bubbleAngleO, this.bubbleAngle);
     }
 
+    @Override
     public void setVariant(Boat.Type variant) {
         this.entityData.set(Boat.DATA_ID_TYPE, variant.ordinal());
     }
@@ -1053,6 +1047,7 @@ public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat
             return this.planks;
         }
 
+        @Override
         public String toString() {
             return this.name;
         }
@@ -1070,6 +1065,7 @@ public class Boat extends VehicleEntity implements Leashable, VariantHolder<Boat
 
         IN_WATER, UNDER_WATER, UNDER_FLOWING_WATER, ON_LAND, IN_AIR;
 
-        private Status() {}
+        private Status() {
+        }
     }
 }
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index f1b4adeeb4dad5178a5e52870f420beaa8e13034..2574e4d4d1833199b787122c4af6dd1a7431cf34 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -1,21 +1,13 @@
 package net.minecraft.world.inventory;
 
+import com.google.common.base.Preconditions;
 import com.google.common.base.Suppliers;
 import com.google.common.collect.HashBasedTable;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.Table;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.Set;
-import java.util.function.Supplier;
-import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -33,18 +25,17 @@ import net.minecraft.world.flag.FeatureFlagSet;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.entity.BlockEntity;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import com.google.common.base.Preconditions;
-import java.util.HashMap;
-import java.util.Map;
 import org.bukkit.craftbukkit.inventory.CraftInventory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.Event.Result;
 import org.bukkit.event.inventory.InventoryDragEvent;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.inventory.InventoryView;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Supplier;
 // CraftBukkit end
 
 public abstract class AbstractContainerMenu {
@@ -60,7 +51,7 @@ public abstract class AbstractContainerMenu {
     public static final int CARRIED_SLOT_SIZE = Integer.MAX_VALUE;
     public NonNullList<ItemStack> lastSlots = NonNullList.create();
     public NonNullList<Slot> slots = NonNullList.create();
-    public List<DataSlot> dataSlots = Lists.newArrayList();
+    public List<DataSlot> dataSlots = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private ItemStack carried;
     public NonNullList<ItemStack> remoteSlots;
     public IntList remoteDataSlots;
@@ -76,11 +67,14 @@ public abstract class AbstractContainerMenu {
     @Nullable
     private ContainerSynchronizer synchronizer;
     private boolean suppressRemoteUpdates;
-    @Nullable protected ItemStack activeQuickItem = null; // Purpur - Anvil API
+    @Nullable
+    protected ItemStack activeQuickItem = null; // Purpur - Anvil API
 
     // CraftBukkit start
     public boolean checkReachable = true;
+
     public abstract InventoryView getBukkitView();
+
     public void transferTo(AbstractContainerMenu other, org.bukkit.craftbukkit.entity.CraftHumanEntity player) {
         InventoryView source = this.getBukkitView(), destination = other.getBukkitView();
         ((CraftInventory) source.getTopInventory()).getInventory().onClose(player);
@@ -88,16 +82,19 @@ public abstract class AbstractContainerMenu {
         ((CraftInventory) destination.getTopInventory()).getInventory().onOpen(player);
         ((CraftInventory) destination.getBottomInventory()).getInventory().onOpen(player);
     }
+
     private Component title;
+
     public final Component getTitle() {
         // Paper start - return chat component with empty text instead of throwing error
         // Preconditions.checkState(this.title != null, "Title not set");
-        if (this.title == null){
+        if (this.title == null) {
             return Component.literal("");
         }
         // Paper end - return chat component with empty text instead of throwing error
         return this.title;
     }
+
     public final void setTitle(Component title) {
         Preconditions.checkState(this.title == null, "Title already set");
         this.title = title;
@@ -111,7 +108,7 @@ public abstract class AbstractContainerMenu {
         this.remoteCarried = ItemStack.EMPTY;
         this.quickcraftType = -1;
         this.quickcraftSlots = Sets.newHashSet();
-        this.containerListeners = Lists.newArrayList();
+        this.containerListeners = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.menuType = type;
         this.containerId = syncId;
     }
@@ -538,7 +535,6 @@ public abstract class AbstractContainerMenu {
                     }
 
                     for (itemstack = this.quickMoveStack(player, slotIndex); !itemstack.isEmpty() && ItemStack.isSameItem(slot.getItem(), itemstack); itemstack = this.quickMoveStack(player, slotIndex)) {
-                        ;
                     }
                 } else {
                     if (slotIndex < 0) {
@@ -772,6 +768,7 @@ public abstract class AbstractContainerMenu {
         // Paper start - Add PlayerTradeEvent and PlayerPurchaseEvent
         return this.moveItemStackTo(stack, startIndex, endIndex, fromLast, false);
     }
+
     protected boolean moveItemStackTo(ItemStack stack, int startIndex, int endIndex, boolean fromLast, boolean isCheck) {
         if (isCheck) {
             stack = stack.copy();
@@ -813,14 +810,14 @@ public abstract class AbstractContainerMenu {
                         stack.setCount(0);
                         itemstack1.setCount(l);
                         if (!isCheck) { // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
-                        slot.setChanged();
+                            slot.setChanged();
                         } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                         flag1 = true;
                     } else if (itemstack1.getCount() < i1) {
                         stack.shrink(i1 - itemstack1.getCount());
                         itemstack1.setCount(i1);
                         if (!isCheck) { // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
-                        slot.setChanged();
+                            slot.setChanged();
                         } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                         flag1 = true;
                     }
@@ -863,9 +860,9 @@ public abstract class AbstractContainerMenu {
                     if (isCheck) {
                         stack.shrink(Math.min(stack.getCount(), l));
                     } else {
-                    // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
-                    slot.setByPlayer(stack.split(Math.min(stack.getCount(), l)));
-                    slot.setChanged();
+                        // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
+                        slot.setByPlayer(stack.split(Math.min(stack.getCount(), l)));
+                        slot.setChanged();
                     } // Paper - Add PlayerTradeEvent and PlayerPurchaseEvent
                     flag1 = true;
                     break;
diff --git a/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java b/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
index bd056f001e5efc34ad5c8cedc9e891514cfe5853..a9352adde84cbfa2c23cc7c18072c54c34326656 100644
--- a/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
@@ -1,7 +1,5 @@
 package net.minecraft.world.inventory;
 
-import com.google.common.collect.Lists;
-import java.util.List;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.world.Container;
@@ -15,12 +13,12 @@ import net.minecraft.world.item.crafting.SingleRecipeInput;
 import net.minecraft.world.item.crafting.StonecutterRecipe;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
-
-// CraftBukkit start
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.inventory.CraftInventoryStonecutter;
 import org.bukkit.craftbukkit.inventory.view.CraftStonecutterView;
 import org.bukkit.entity.Player;
+
+import java.util.List;
 // CraftBukkit end
 
 public class StonecutterMenu extends AbstractContainerMenu {
@@ -65,7 +63,7 @@ public class StonecutterMenu extends AbstractContainerMenu {
     public StonecutterMenu(int syncId, Inventory playerInventory, final ContainerLevelAccess context) {
         super(MenuType.STONECUTTER, syncId);
         this.selectedRecipeIndex = DataSlot.shared(new int[1], 0); // Paper - Add PlayerStonecutterRecipeSelectEvent
-        this.recipes = Lists.newArrayList();
+        this.recipes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.input = ItemStack.EMPTY;
         this.slotUpdateListener = () -> {
         };
diff --git a/src/main/java/net/minecraft/world/item/CrossbowItem.java b/src/main/java/net/minecraft/world/item/CrossbowItem.java
index 4e60c2102e3e838c68e4b9db41c8bca365d22923..8843c71f9867a47d4988ea470310596d2d61d18c 100644
--- a/src/main/java/net/minecraft/world/item/CrossbowItem.java
+++ b/src/main/java/net/minecraft/world/item/CrossbowItem.java
@@ -1,12 +1,7 @@
 package net.minecraft.world.item;
 
-import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import java.util.List;
-import java.util.Optional;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.Holder;
@@ -36,6 +31,11 @@ import net.minecraft.world.phys.Vec3;
 import org.joml.Quaternionf;
 import org.joml.Vector3f;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+
 public class CrossbowItem extends ProjectileWeaponItem {
     private static final float MAX_CHARGE_DURATION = 1.25F;
     public static final int DEFAULT_RANGE = 8;
@@ -47,7 +47,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
     public static final float FIREWORK_POWER = 1.6F;
     public static final float MOB_ARROW_POWER = 1.6F;
     private static final CrossbowItem.ChargingSounds DEFAULT_SOUNDS = new CrossbowItem.ChargingSounds(
-        Optional.of(SoundEvents.CROSSBOW_LOADING_START), Optional.of(SoundEvents.CROSSBOW_LOADING_MIDDLE), Optional.of(SoundEvents.CROSSBOW_LOADING_END)
+            Optional.of(SoundEvents.CROSSBOW_LOADING_START), Optional.of(SoundEvents.CROSSBOW_LOADING_MIDDLE), Optional.of(SoundEvents.CROSSBOW_LOADING_END)
     );
 
     public CrossbowItem(Item.Properties settings) {
@@ -99,26 +99,27 @@ public class CrossbowItem extends ProjectileWeaponItem {
             // Paper end - Add EntityLoadCrossbowEvent
             CrossbowItem.ChargingSounds chargingSounds = this.getChargingSounds(stack);
             chargingSounds.end()
-                .ifPresent(
-                    sound -> world.playSound(
-                            null,
-                            user.getX(),
-                            user.getY(),
-                            user.getZ(),
-                            sound.value(),
-                            user.getSoundSource(),
-                            1.0F,
-                            1.0F / (world.getRandom().nextFloat() * 0.5F + 1.0F) + 0.2F
-                        )
-                );
+                    .ifPresent(
+                            sound -> world.playSound(
+                                    null,
+                                    user.getX(),
+                                    user.getY(),
+                                    user.getZ(),
+                                    sound.value(),
+                                    user.getSoundSource(),
+                                    1.0F,
+                                    1.0F / (world.getRandom().nextFloat() * 0.5F + 1.0F) + 0.2F
+                            )
+                    );
         }
     }
 
     @io.papermc.paper.annotation.DoNotUse // Paper - Add EntityLoadCrossbowEvent
-    private static boolean tryLoadProjectiles(LivingEntity shooter, ItemStack crossbow)  {
+    private static boolean tryLoadProjectiles(LivingEntity shooter, ItemStack crossbow) {
         // Paper start - Add EntityLoadCrossbowEvent
         return CrossbowItem.tryLoadProjectiles(shooter, crossbow, true);
     }
+
     private static boolean tryLoadProjectiles(LivingEntity shooter, ItemStack crossbow, boolean consume) {
         List<ItemStack> list = draw(crossbow, shooter.getProjectile(crossbow), shooter, consume);
         // Paper end - Add EntityLoadCrossbowEvent
@@ -137,7 +138,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
 
     @Override
     protected void shootProjectile(
-        LivingEntity shooter, Projectile projectile, int index, float speed, float divergence, float yaw, @Nullable LivingEntity target
+            LivingEntity shooter, Projectile projectile, int index, float speed, float divergence, float yaw, @Nullable LivingEntity target
     ) {
         Vector3f vector3f;
         if (target != null) {
@@ -148,12 +149,12 @@ public class CrossbowItem extends ProjectileWeaponItem {
             vector3f = getProjectileShotVector(shooter, new Vec3(d, g, e), yaw);
         } else {
             Vec3 vec3 = shooter.getUpVector(1.0F);
-            Quaternionf quaternionf = new Quaternionf().setAngleAxis((double)(yaw * (float) (Math.PI / 180.0)), vec3.x, vec3.y, vec3.z);
+            Quaternionf quaternionf = new Quaternionf().setAngleAxis((double) (yaw * (float) (Math.PI / 180.0)), vec3.x, vec3.y, vec3.z);
             Vec3 vec32 = shooter.getViewVector(1.0F);
             vector3f = vec32.toVector3f().rotate(quaternionf);
         }
 
-        projectile.shoot((double)vector3f.x(), (double)vector3f.y(), (double)vector3f.z(), speed, divergence);
+        projectile.shoot((double) vector3f.x(), (double) vector3f.y(), (double) vector3f.z(), speed, divergence);
         float h = getShotPitch(shooter.getRandom(), index);
         shooter.level().playSound(null, shooter.getX(), shooter.getY(), shooter.getZ(), SoundEvents.CROSSBOW_SHOOT, shooter.getSoundSource(), 1.0F, h);
     }
@@ -161,7 +162,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
     private static Vector3f getProjectileShotVector(LivingEntity shooter, Vec3 direction, float yaw) {
         Vector3f vector3f = direction.toVector3f().normalize();
         Vector3f vector3f2 = new Vector3f(vector3f).cross(new Vector3f(0.0F, 1.0F, 0.0F));
-        if ((double)vector3f2.lengthSquared() <= 1.0E-7) {
+        if ((double) vector3f2.lengthSquared() <= 1.0E-7) {
             Vec3 vec3 = shooter.getUpVector(1.0F);
             vector3f2 = new Vector3f(vector3f).cross(vec3.toVector3f());
         }
@@ -174,7 +175,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
     protected Projectile createProjectile(Level world, LivingEntity shooter, ItemStack weaponStack, ItemStack projectileStack, boolean critical) {
         if (projectileStack.is(Items.FIREWORK_ROCKET)) {
             // Paper start
-            FireworkRocketEntity entity =  new FireworkRocketEntity(world, projectileStack, shooter, shooter.getX(), shooter.getEyeY() - 0.15F, shooter.getZ(), true);
+            FireworkRocketEntity entity = new FireworkRocketEntity(world, projectileStack, shooter, shooter.getX(), shooter.getEyeY() - 0.15F, shooter.getZ(), true);
             entity.spawningEntity = shooter.getUUID(); // Paper
             return entity;
             // Paper end
@@ -194,7 +195,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
     }
 
     public void performShooting(
-        Level world, LivingEntity shooter, InteractionHand hand, ItemStack stack, float speed, float divergence, @Nullable LivingEntity target
+            Level world, LivingEntity shooter, InteractionHand hand, ItemStack stack, float speed, float divergence, @Nullable LivingEntity target
     ) {
         if (world instanceof ServerLevel serverLevel) {
             ChargedProjectiles chargedProjectiles = stack.set(DataComponents.CHARGED_PROJECTILES, ChargedProjectiles.EMPTY);
@@ -221,7 +222,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
     public void onUseTick(Level world, LivingEntity user, ItemStack stack, int remainingUseTicks) {
         if (!world.isClientSide) {
             CrossbowItem.ChargingSounds chargingSounds = this.getChargingSounds(stack);
-            float f = (float)(stack.getUseDuration(user) - remainingUseTicks) / (float)getChargeDuration(stack, user);
+            float f = (float) (stack.getUseDuration(user) - remainingUseTicks) / (float) getChargeDuration(stack, user);
             if (f < 0.2F) {
                 this.startSoundPlayed = false;
                 this.midLoadSoundPlayed = false;
@@ -230,13 +231,13 @@ public class CrossbowItem extends ProjectileWeaponItem {
             if (f >= 0.2F && !this.startSoundPlayed) {
                 this.startSoundPlayed = true;
                 chargingSounds.start()
-                    .ifPresent(sound -> world.playSound(null, user.getX(), user.getY(), user.getZ(), sound.value(), SoundSource.PLAYERS, 0.5F, 1.0F));
+                        .ifPresent(sound -> world.playSound(null, user.getX(), user.getY(), user.getZ(), sound.value(), SoundSource.PLAYERS, 0.5F, 1.0F));
             }
 
             if (f >= 0.5F && !this.midLoadSoundPlayed) {
                 this.midLoadSoundPlayed = true;
                 chargingSounds.mid()
-                    .ifPresent(sound -> world.playSound(null, user.getX(), user.getY(), user.getZ(), sound.value(), SoundSource.PLAYERS, 0.5F, 1.0F));
+                        .ifPresent(sound -> world.playSound(null, user.getX(), user.getY(), user.getZ(), sound.value(), SoundSource.PLAYERS, 0.5F, 1.0F));
             }
         }
     }
@@ -261,7 +262,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
     }
 
     private static float getPowerForTime(int useTicks, ItemStack stack, LivingEntity user) {
-        float f = (float)useTicks / (float)getChargeDuration(stack, user);
+        float f = (float) useTicks / (float) getChargeDuration(stack, user);
         if (f > 1.0F) {
             f = 1.0F;
         }
@@ -276,7 +277,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
             ItemStack itemStack = chargedProjectiles.getItems().get(0);
             tooltip.add(Component.translatable("item.minecraft.crossbow.projectile").append(CommonComponents.SPACE).append(itemStack.getDisplayName()));
             if (type.isAdvanced() && itemStack.is(Items.FIREWORK_ROCKET)) {
-                List<Component> list = Lists.newArrayList();
+                List<Component> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 Items.FIREWORK_ROCKET.appendHoverText(itemStack, context, list, type);
                 if (!list.isEmpty()) {
                     for (int i = 0; i < list.size(); i++) {
@@ -299,14 +300,15 @@ public class CrossbowItem extends ProjectileWeaponItem {
         return 8;
     }
 
-    public static record ChargingSounds(Optional<Holder<SoundEvent>> start, Optional<Holder<SoundEvent>> mid, Optional<Holder<SoundEvent>> end) {
+    public static record ChargingSounds(Optional<Holder<SoundEvent>> start, Optional<Holder<SoundEvent>> mid,
+                                        Optional<Holder<SoundEvent>> end) {
         public static final Codec<CrossbowItem.ChargingSounds> CODEC = RecordCodecBuilder.create(
-            instance -> instance.group(
-                        SoundEvent.CODEC.optionalFieldOf("start").forGetter(CrossbowItem.ChargingSounds::start),
-                        SoundEvent.CODEC.optionalFieldOf("mid").forGetter(CrossbowItem.ChargingSounds::mid),
-                        SoundEvent.CODEC.optionalFieldOf("end").forGetter(CrossbowItem.ChargingSounds::end)
-                    )
-                    .apply(instance, CrossbowItem.ChargingSounds::new)
+                instance -> instance.group(
+                                SoundEvent.CODEC.optionalFieldOf("start").forGetter(CrossbowItem.ChargingSounds::start),
+                                SoundEvent.CODEC.optionalFieldOf("mid").forGetter(CrossbowItem.ChargingSounds::mid),
+                                SoundEvent.CODEC.optionalFieldOf("end").forGetter(CrossbowItem.ChargingSounds::end)
+                        )
+                        .apply(instance, CrossbowItem.ChargingSounds::new)
         );
     }
 }
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index e5579b15f305fb216dadd8023c16178a342b4add..defc4bac2ad15e5eb9528d04a8cd3e8081735142 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -1,6 +1,5 @@
 package net.minecraft.world.item;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
@@ -9,45 +8,19 @@ import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.EncoderException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.function.BiConsumer;
-import java.util.function.BiFunction;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
-import java.util.function.UnaryOperator;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.advancements.CriteriaTriggers;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderLookup;
-import net.minecraft.core.HolderSet;
-import net.minecraft.core.NonNullList;
-import net.minecraft.core.component.DataComponentHolder;
-import net.minecraft.core.component.DataComponentMap;
-import net.minecraft.core.component.DataComponentPatch;
-import net.minecraft.core.component.DataComponentType;
-import net.minecraft.core.component.DataComponents;
-import net.minecraft.core.component.PatchedDataComponentMap;
+import net.minecraft.core.*;
+import net.minecraft.core.component.*;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.RegistryFriendlyByteBuf;
-import net.minecraft.network.chat.CommonComponents;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.chat.HoverEvent;
-import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.*;
 import net.minecraft.network.codec.ByteBufCodecs;
 import net.minecraft.network.codec.StreamCodec;
-import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.resources.RegistryOps;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
@@ -64,11 +37,7 @@ import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.InteractionResultHolder;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EquipmentSlot;
-import net.minecraft.world.entity.EquipmentSlotGroup;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.SlotAccess;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.attributes.Attribute;
 import net.minecraft.world.entity.ai.attributes.AttributeModifier;
 import net.minecraft.world.entity.ai.attributes.Attributes;
@@ -85,27 +54,15 @@ import net.minecraft.world.item.context.UseOnContext;
 import net.minecraft.world.item.enchantment.Enchantment;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
 import net.minecraft.world.item.enchantment.ItemEnchantments;
-import net.minecraft.world.level.saveddata.maps.MapId;
-import org.apache.commons.lang3.mutable.MutableBoolean;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import java.util.Map;
-import java.util.Objects;
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.BaseEntityBlock;
-import net.minecraft.world.level.block.BedBlock;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.SaplingBlock;
-import net.minecraft.world.level.block.SignBlock;
-import net.minecraft.world.level.block.SoundType;
-import net.minecraft.world.level.block.WitherSkullBlock;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.entity.SkullBlockEntity;
 import net.minecraft.world.level.block.state.pattern.BlockInWorld;
-import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.saveddata.maps.MapId;
+import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.bukkit.Location;
 import org.bukkit.TreeType;
 import org.bukkit.block.BlockState;
@@ -118,6 +75,12 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.block.BlockFertilizeEvent;
 import org.bukkit.event.player.PlayerItemDamageEvent;
 import org.bukkit.event.world.StructureGrowEvent;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.*;
+import java.util.stream.Stream;
 // CraftBukkit end
 
 public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods.lithium.common.util.change_tracking.ChangePublisher<ItemStack>, net.caffeinemc.mods.lithium.common.util.change_tracking.ChangeSubscriber<PatchedDataComponentMap> { // Leaf - Lithium equipment tracking
@@ -154,6 +117,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
     public static final StreamCodec<RegistryFriendlyByteBuf, ItemStack> OPTIONAL_STREAM_CODEC = new StreamCodec<RegistryFriendlyByteBuf, ItemStack>() {
         private static final StreamCodec<RegistryFriendlyByteBuf, Holder<Item>> ITEM_STREAM_CODEC = ByteBufCodecs.holderRegistry(Registries.ITEM);
 
+        @Override
         public ItemStack decode(RegistryFriendlyByteBuf registryfriendlybytebuf) {
             int i = registryfriendlybytebuf.readVarInt();
 
@@ -173,6 +137,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
             }
         }
 
+        @Override
         public void encode(RegistryFriendlyByteBuf registryfriendlybytebuf, ItemStack itemstack) {
             if (itemstack.isEmpty() || itemstack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
                 registryfriendlybytebuf.writeVarInt(0);
@@ -187,7 +152,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
                 boolean prev = net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.get();
                 try {
                     net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.set(true);
-                DataComponentPatch.STREAM_CODEC.encode(registryfriendlybytebuf, itemstack.components.asPatch());
+                    DataComponentPatch.STREAM_CODEC.encode(registryfriendlybytebuf, itemstack.components.asPatch());
                 } finally {
                     net.minecraft.network.chat.ComponentSerialization.DONT_RENDER_TRANSLATABLES.set(prev);
                 }
@@ -196,6 +161,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
         }
     };
     public static final StreamCodec<RegistryFriendlyByteBuf, ItemStack> STREAM_CODEC = new StreamCodec<RegistryFriendlyByteBuf, ItemStack>() {
+        @Override
         public ItemStack decode(RegistryFriendlyByteBuf registryfriendlybytebuf) {
             ItemStack itemstack = (ItemStack) ItemStack.OPTIONAL_STREAM_CODEC.decode(registryfriendlybytebuf);
 
@@ -206,6 +172,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
             }
         }
 
+        @Override
         public void encode(RegistryFriendlyByteBuf registryfriendlybytebuf, ItemStack itemstack) {
             if (itemstack.isEmpty()) {
                 throw new EncoderException("Empty ItemStack not allowed");
@@ -221,7 +188,9 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
     private static final Component DISABLED_ITEM_TOOLTIP = Component.translatable("item.disabled").withStyle(ChatFormatting.RED);
     private int count;
     private int popTime;
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     @Nullable
     private Item item;
@@ -248,6 +217,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
 
     public static StreamCodec<RegistryFriendlyByteBuf, ItemStack> validatedStreamCodec(final StreamCodec<RegistryFriendlyByteBuf, ItemStack> basePacketCodec) {
         return new StreamCodec<RegistryFriendlyByteBuf, ItemStack>() {
+            @Override
             public ItemStack decode(RegistryFriendlyByteBuf registryfriendlybytebuf) {
                 ItemStack itemstack = (ItemStack) basePacketCodec.decode(registryfriendlybytebuf);
 
@@ -260,6 +230,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
                 return itemstack;
             }
 
+            @Override
             public void encode(RegistryFriendlyByteBuf registryfriendlybytebuf, ItemStack itemstack) {
                 basePacketCodec.encode(registryfriendlybytebuf, itemstack);
             }
@@ -454,11 +425,11 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
                 StructureGrowEvent structureEvent = null;
                 if (treeType != null) {
                     boolean isBonemeal = this.getItem() == Items.BONE_MEAL;
-                    structureEvent = new StructureGrowEvent(location, treeType, isBonemeal, (Player) entityhuman.getBukkitEntity(), (List< BlockState>) (List<? extends BlockState>) blocks);
+                    structureEvent = new StructureGrowEvent(location, treeType, isBonemeal, (Player) entityhuman.getBukkitEntity(), (List<BlockState>) (List<? extends BlockState>) blocks);
                     org.bukkit.Bukkit.getPluginManager().callEvent(structureEvent);
                 }
 
-                BlockFertilizeEvent fertilizeEvent = new BlockFertilizeEvent(CraftBlock.at(world, blockposition), (Player) entityhuman.getBukkitEntity(), (List< BlockState>) (List<? extends BlockState>) blocks);
+                BlockFertilizeEvent fertilizeEvent = new BlockFertilizeEvent(CraftBlock.at(world, blockposition), (Player) entityhuman.getBukkitEntity(), (List<BlockState>) (List<? extends BlockState>) blocks);
                 fertilizeEvent.setCancelled(structureEvent != null && structureEvent.isCancelled());
                 org.bukkit.Bukkit.getPluginManager().callEvent(fertilizeEvent);
 
@@ -573,7 +544,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
                     // SPIGOT-7315: Moved from BlockBed#setPlacedBy
                     if (placeEvent != null && this.item instanceof BedItem) {
                         BlockPos position = ((CraftBlock) placeEvent.getBlock()).getPosition();
-                        net.minecraft.world.level.block.state.BlockState blockData =  world.getBlockState(position);
+                        net.minecraft.world.level.block.state.BlockState blockData = world.getBlockState(position);
 
                         if (blockData.getBlock() instanceof BedBlock) {
                             world.blockUpdated(position, Blocks.AIR);
@@ -686,6 +657,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
         // Paper start - add param to skip infinite mats check
         this.hurtAndBreak(amount, world, player, breakCallback, false);
     }
+
     public void hurtAndBreak(int amount, ServerLevel world, @Nullable LivingEntity player, Consumer<Item> breakCallback, boolean force) {
         // Paper end - add param to skip infinite mats check
         if (this.isDamageableItem()) {
@@ -754,6 +726,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
         // Paper start - add param to skip infinite mats check
         this.hurtAndBreak(amount, entity, slot, false);
     }
+
     public void hurtAndBreak(int amount, LivingEntity entity, EquipmentSlot slot, boolean force) {
         // Paper end - add param to skip infinite mats check
         Level world = entity.level();
@@ -768,7 +741,8 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
             }
 
             this.hurtAndBreak(amount, worldserver, entity, (item) -> { // Paper - Add EntityDamageItemEvent
-                if (slot != null) entity.onEquippedItemBroken(item, slot); // Paper - itemstack damage API - do not process entity related callbacks when damaging from API
+                if (slot != null)
+                    entity.onEquippedItemBroken(item, slot); // Paper - itemstack damage API - do not process entity related callbacks when damaging from API
             }, force); // Paper - itemstack damage API
         }
 
@@ -885,7 +859,9 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
         return left == right || (left.getCount() == right.getCount() && ItemStack.isSameItemSameComponents(left, right)); // Gale - optimize identical item checks
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     public static boolean listMatches(List<ItemStack> left, List<ItemStack> right) {
         if (left.size() != right.size()) {
@@ -927,7 +903,9 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
         }
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     public static int hashStackList(List<ItemStack> stacks) {
         int i = 0;
@@ -945,6 +923,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
         return this.getItem().getDescriptionId(this);
     }
 
+    @Override
     public String toString() {
         int i = this.getCount();
 
@@ -1033,13 +1012,17 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
     public org.bukkit.inventory.ItemStack asBukkitMirror() {
         return CraftItemStack.asCraftMirror(this);
     }
+
     public org.bukkit.inventory.ItemStack asBukkitCopy() {
         return CraftItemStack.asCraftMirror(this.copy());
     }
+
     public static ItemStack fromBukkitCopy(org.bukkit.inventory.ItemStack itemstack) {
         return CraftItemStack.asNMSCopy(itemstack);
     }
+
     private org.bukkit.craftbukkit.inventory.CraftItemStack bukkitStack;
+
     public org.bukkit.inventory.ItemStack getBukkitStack() {
         if (bukkitStack == null || bukkitStack.handle != this) {
             bukkitStack = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(this);
@@ -1083,7 +1066,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
         if (!type.isCreative() && this.has(DataComponents.HIDE_TOOLTIP)) {
             return List.of();
         } else {
-            List<Component> list = Lists.newArrayList();
+            List<Component> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             MutableComponent ichatmutablecomponent = Component.empty().append(this.getHoverName()).withStyle(this.getRarity().color());
 
             if (this.has(DataComponents.CUSTOM_NAME)) {
@@ -1443,7 +1426,7 @@ public final class ItemStack implements DataComponentHolder, net.caffeinemc.mods
     public boolean canBeHurtBy(DamageSource source) {
         return !this.has(DataComponents.FIRE_RESISTANT) || !source.is(DamageTypeTags.IS_FIRE);
     }
-    
+
     // Leaf start - Lithium equipment tracking
     @Override
     public void subscribe(net.caffeinemc.mods.lithium.common.util.change_tracking.ChangeSubscriber<ItemStack> subscriber, int subscriberData) {
diff --git a/src/main/java/net/minecraft/world/item/SuspiciousStewItem.java b/src/main/java/net/minecraft/world/item/SuspiciousStewItem.java
index 9523db353df026f33d7e859788612b97542bd001..01ed02ee9c9f4fe9d9ec824d429280494cc12b0b 100644
--- a/src/main/java/net/minecraft/world/item/SuspiciousStewItem.java
+++ b/src/main/java/net/minecraft/world/item/SuspiciousStewItem.java
@@ -24,7 +24,7 @@ public class SuspiciousStewItem extends Item {
     public void appendHoverText(ItemStack stack, Item.TooltipContext context, List<Component> tooltip, TooltipFlag type) {
         super.appendHoverText(stack, context, tooltip, type);
         if (type.isCreative()) {
-            List<MobEffectInstance> list1 = new ArrayList();
+            List<MobEffectInstance> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             SuspiciousStewEffects suspicioussteweffects = (SuspiciousStewEffects) stack.getOrDefault(DataComponents.SUSPICIOUS_STEW_EFFECTS, SuspiciousStewEffects.EMPTY);
             Iterator iterator = suspicioussteweffects.effects().iterator();
 
diff --git a/src/main/java/net/minecraft/world/item/alchemy/PotionBrewing.java b/src/main/java/net/minecraft/world/item/alchemy/PotionBrewing.java
index ca01f3344005b295c7ae98f6d5b03f79513b12a4..d4ffdc56785003a428992a6f3450dc9c6872c343 100644
--- a/src/main/java/net/minecraft/world/item/alchemy/PotionBrewing.java
+++ b/src/main/java/net/minecraft/world/item/alchemy/PotionBrewing.java
@@ -1,8 +1,5 @@
 package net.minecraft.world.item.alchemy;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Optional;
 import net.minecraft.core.Holder;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -13,6 +10,9 @@ import net.minecraft.world.item.Items;
 import net.minecraft.world.item.PotionItem;
 import net.minecraft.world.item.crafting.Ingredient;
 
+import java.util.List;
+import java.util.Optional;
+
 public class PotionBrewing {
     public static final int BREWING_TIME_SECONDS = 20;
     public static final PotionBrewing EMPTY = new PotionBrewing(List.of(), List.of(), List.of());
@@ -248,9 +248,9 @@ public class PotionBrewing {
     // Paper end - Custom Potion Mixes
 
     public static class Builder {
-        private final List<Ingredient> containers = new ArrayList<>();
-        private final List<PotionBrewing.Mix<Potion>> potionMixes = new ArrayList<>();
-        private final List<PotionBrewing.Mix<Item>> containerMixes = new ArrayList<>();
+        private final List<Ingredient> containers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        private final List<PotionBrewing.Mix<Potion>> potionMixes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        private final List<PotionBrewing.Mix<Item>> containerMixes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         private final FeatureFlagSet enabledFeatures;
 
         public Builder(FeatureFlagSet enabledFeatures) {
diff --git a/src/main/java/net/minecraft/world/item/crafting/FireworkRocketRecipe.java b/src/main/java/net/minecraft/world/item/crafting/FireworkRocketRecipe.java
index 93c2268ea1be1727c2939d5730427e24d4e03e2f..eace542cf94869b3ca9af99294236d31cea2088c 100644
--- a/src/main/java/net/minecraft/world/item/crafting/FireworkRocketRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/FireworkRocketRecipe.java
@@ -48,7 +48,7 @@ public class FireworkRocketRecipe extends CustomRecipe {
 
     @Override
     public ItemStack assemble(CraftingInput input, HolderLookup.Provider lookup) {
-        List<FireworkExplosion> list = new ArrayList<>();
+        List<FireworkExplosion> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         int i = 0;
 
         for (int j = 0; j < input.size(); j++) {
diff --git a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
index 21dfb8e91c5427ac12133de2c05d923d87adf5ba..14f60b7899439c5e0365b444f8602a8719533d70 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
@@ -1,6 +1,5 @@
 package net.minecraft.world.item.crafting;
 
-import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Either;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
@@ -8,14 +7,6 @@ import com.mojang.serialization.codecs.RecordCodecBuilder;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntComparators;
 import it.unimi.dsi.fastutil.ints.IntList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.function.Predicate;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
@@ -27,6 +18,11 @@ import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.ItemLike;
 
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
 public final class Ingredient implements Predicate<ItemStack> {
 
     public static final Ingredient EMPTY = new Ingredient(Stream.empty());
@@ -67,6 +63,7 @@ public final class Ingredient implements Predicate<ItemStack> {
         return this.itemStacks;
     }
 
+    @Override
     public boolean test(@Nullable ItemStack itemstack) {
         if (itemstack == null) {
             return false;
@@ -127,6 +124,7 @@ public final class Ingredient implements Predicate<ItemStack> {
         return this.values.length == 0;
     }
 
+    @Override
     public boolean equals(Object object) {
         if (object instanceof Ingredient recipeitemstack) {
             return Arrays.equals(this.values, recipeitemstack.values);
@@ -210,6 +208,7 @@ public final class Ingredient implements Predicate<ItemStack> {
             })).apply(instance, Ingredient.TagValue::new);
         });
 
+        @Override
         public boolean equals(Object object) {
             if (object instanceof Ingredient.TagValue recipeitemstack_b) {
                 return recipeitemstack_b.tag.location().equals(this.tag.location());
@@ -220,7 +219,7 @@ public final class Ingredient implements Predicate<ItemStack> {
 
         @Override
         public Collection<ItemStack> getItems() {
-            List<ItemStack> list = Lists.newArrayList();
+            List<ItemStack> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             Iterator iterator = BuiltInRegistries.ITEM.getTagOrEmpty(this.tag).iterator();
 
             while (iterator.hasNext()) {
@@ -241,6 +240,7 @@ public final class Ingredient implements Predicate<ItemStack> {
             })).apply(instance, Ingredient.ItemValue::new);
         });
 
+        @Override
         public boolean equals(Object object) {
             if (!(object instanceof Ingredient.ItemValue recipeitemstack_stackprovider)) {
                 return false;
diff --git a/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java b/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java
index 161990842f19fc123fd9feca7231afec83802f47..abce07cf330346301cae1c62259ada7f031d69bc 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/Enchantment.java
@@ -5,13 +5,6 @@ import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import it.unimi.dsi.fastutil.objects.ObjectArraySet;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.function.Consumer;
 import net.minecraft.ChatFormatting;
 import net.minecraft.Util;
 import net.minecraft.core.Holder;
@@ -21,12 +14,7 @@ import net.minecraft.core.component.DataComponentMap;
 import net.minecraft.core.component.DataComponentType;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.network.RegistryFriendlyByteBuf;
-import net.minecraft.network.chat.CommonComponents;
-import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.ComponentSerialization;
-import net.minecraft.network.chat.ComponentUtils;
-import net.minecraft.network.chat.MutableComponent;
-import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.*;
 import net.minecraft.network.codec.ByteBufCodecs;
 import net.minecraft.network.codec.StreamCodec;
 import net.minecraft.resources.RegistryFixedCodec;
@@ -43,11 +31,7 @@ import net.minecraft.world.entity.EquipmentSlotGroup;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
-import net.minecraft.world.item.enchantment.effects.DamageImmunity;
-import net.minecraft.world.item.enchantment.effects.EnchantmentAttributeEffect;
-import net.minecraft.world.item.enchantment.effects.EnchantmentEntityEffect;
-import net.minecraft.world.item.enchantment.effects.EnchantmentLocationBasedEffect;
-import net.minecraft.world.item.enchantment.effects.EnchantmentValueEffect;
+import net.minecraft.world.item.enchantment.effects.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.storage.loot.LootContext;
 import net.minecraft.world.level.storage.loot.LootParams;
@@ -57,18 +41,22 @@ import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
 import net.minecraft.world.phys.Vec3;
 import org.apache.commons.lang3.mutable.MutableFloat;
 
-public record Enchantment(Component description, Enchantment.EnchantmentDefinition definition, HolderSet<Enchantment> exclusiveSet, DataComponentMap effects) {
+import java.util.*;
+import java.util.function.Consumer;
+
+public record Enchantment(Component description, Enchantment.EnchantmentDefinition definition,
+                          HolderSet<Enchantment> exclusiveSet, DataComponentMap effects) {
     public static final int MAX_LEVEL = 255;
     public static final Codec<Enchantment> DIRECT_CODEC = RecordCodecBuilder.create(
-        instance -> instance.group(
-                    ComponentSerialization.CODEC.fieldOf("description").forGetter(Enchantment::description),
-                    Enchantment.EnchantmentDefinition.CODEC.forGetter(Enchantment::definition),
-                    RegistryCodecs.homogeneousList(Registries.ENCHANTMENT)
-                        .optionalFieldOf("exclusive_set", HolderSet.direct())
-                        .forGetter(Enchantment::exclusiveSet),
-                    EnchantmentEffectComponents.CODEC.optionalFieldOf("effects", DataComponentMap.EMPTY).forGetter(Enchantment::effects)
-                )
-                .apply(instance, Enchantment::new)
+            instance -> instance.group(
+                            ComponentSerialization.CODEC.fieldOf("description").forGetter(Enchantment::description),
+                            Enchantment.EnchantmentDefinition.CODEC.forGetter(Enchantment::definition),
+                            RegistryCodecs.homogeneousList(Registries.ENCHANTMENT)
+                                    .optionalFieldOf("exclusive_set", HolderSet.direct())
+                                    .forGetter(Enchantment::exclusiveSet),
+                            EnchantmentEffectComponents.CODEC.optionalFieldOf("effects", DataComponentMap.EMPTY).forGetter(Enchantment::effects)
+                    )
+                    .apply(instance, Enchantment::new)
     );
     public static final Codec<Holder<Enchantment>> CODEC = RegistryFixedCodec.create(Registries.ENCHANTMENT);
     public static final StreamCodec<RegistryFriendlyByteBuf, Holder<Enchantment>> STREAM_CODEC = ByteBufCodecs.holderRegistry(Registries.ENCHANTMENT);
@@ -82,26 +70,26 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
     }
 
     public static Enchantment.EnchantmentDefinition definition(
-        HolderSet<Item> supportedItems,
-        HolderSet<Item> primaryItems,
-        int weight,
-        int maxLevel,
-        Enchantment.Cost minCost,
-        Enchantment.Cost maxCost,
-        int anvilCost,
-        EquipmentSlotGroup... slots
+            HolderSet<Item> supportedItems,
+            HolderSet<Item> primaryItems,
+            int weight,
+            int maxLevel,
+            Enchantment.Cost minCost,
+            Enchantment.Cost maxCost,
+            int anvilCost,
+            EquipmentSlotGroup... slots
     ) {
         return new Enchantment.EnchantmentDefinition(supportedItems, Optional.of(primaryItems), weight, maxLevel, minCost, maxCost, anvilCost, List.of(slots));
     }
 
     public static Enchantment.EnchantmentDefinition definition(
-        HolderSet<Item> supportedItems,
-        int weight,
-        int maxLevel,
-        Enchantment.Cost minCost,
-        Enchantment.Cost maxCost,
-        int anvilCost,
-        EquipmentSlotGroup... slots
+            HolderSet<Item> supportedItems,
+            int weight,
+            int maxLevel,
+            Enchantment.Cost minCost,
+            Enchantment.Cost maxCost,
+            int anvilCost,
+            EquipmentSlotGroup... slots
     ) {
         return new Enchantment.EnchantmentDefinition(supportedItems, Optional.empty(), weight, maxLevel, minCost, maxCost, anvilCost, List.of(slots));
     }
@@ -260,10 +248,10 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
     }
 
     public void modifyFallBasedDamage(
-        ServerLevel world, int level, ItemStack stack, Entity user, DamageSource damageSource, MutableFloat smashDamagePerFallenBlock
+            ServerLevel world, int level, ItemStack stack, Entity user, DamageSource damageSource, MutableFloat smashDamagePerFallenBlock
     ) {
         this.modifyDamageFilteredValue(
-            EnchantmentEffectComponents.SMASH_DAMAGE_PER_FALLEN_BLOCK, world, level, stack, user, damageSource, smashDamagePerFallenBlock
+                EnchantmentEffectComponents.SMASH_DAMAGE_PER_FALLEN_BLOCK, world, level, stack, user, damageSource, smashDamagePerFallenBlock
         );
     }
 
@@ -276,12 +264,12 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
     }
 
     public static void doPostAttack(
-        TargetedConditionalEffect<EnchantmentEntityEffect> effect,
-        ServerLevel world,
-        int level,
-        EnchantedItemInUse context,
-        Entity user,
-        DamageSource damageSource
+            TargetedConditionalEffect<EnchantmentEntityEffect> effect,
+            ServerLevel world,
+            int level,
+            EnchantedItemInUse context,
+            Entity user,
+            DamageSource damageSource
     ) {
         if (effect.matches(damageContext(world, level, user, damageSource))) {
             Entity entity = switch (effect.affected()) {
@@ -324,108 +312,108 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
 
     public void tick(ServerLevel world, int level, EnchantedItemInUse context, Entity user) {
         applyEffects(
-            this.getEffects(EnchantmentEffectComponents.TICK),
-            entityContext(world, level, user, user.position()),
-            effect -> effect.apply(world, level, context, user, user.position())
+                this.getEffects(EnchantmentEffectComponents.TICK),
+                entityContext(world, level, user, user.position()),
+                effect -> effect.apply(world, level, context, user, user.position())
         );
     }
 
     public void onProjectileSpawned(ServerLevel world, int level, EnchantedItemInUse context, Entity user) {
         applyEffects(
-            this.getEffects(EnchantmentEffectComponents.PROJECTILE_SPAWNED),
-            entityContext(world, level, user, user.position()),
-            effect -> effect.apply(world, level, context, user, user.position())
+                this.getEffects(EnchantmentEffectComponents.PROJECTILE_SPAWNED),
+                entityContext(world, level, user, user.position()),
+                effect -> effect.apply(world, level, context, user, user.position())
         );
     }
 
     public void onHitBlock(ServerLevel world, int level, EnchantedItemInUse context, Entity enchantedEntity, Vec3 pos, BlockState state) {
         applyEffects(
-            this.getEffects(EnchantmentEffectComponents.HIT_BLOCK),
-            blockHitContext(world, level, enchantedEntity, pos, state),
-            effect -> effect.apply(world, level, context, enchantedEntity, pos)
+                this.getEffects(EnchantmentEffectComponents.HIT_BLOCK),
+                blockHitContext(world, level, enchantedEntity, pos, state),
+                effect -> effect.apply(world, level, context, enchantedEntity, pos)
         );
     }
 
     private void modifyItemFilteredCount(
-        DataComponentType<List<ConditionalEffect<EnchantmentValueEffect>>> type, ServerLevel world, int level, ItemStack stack, MutableFloat value
+            DataComponentType<List<ConditionalEffect<EnchantmentValueEffect>>> type, ServerLevel world, int level, ItemStack stack, MutableFloat value
     ) {
         applyEffects(
-            this.getEffects(type), itemContext(world, level, stack), effect -> value.setValue(effect.process(level, world.getRandom(), value.getValue()))
+                this.getEffects(type), itemContext(world, level, stack), effect -> value.setValue(effect.process(level, world.getRandom(), value.getValue()))
         );
     }
 
     private void modifyEntityFilteredValue(
-        DataComponentType<List<ConditionalEffect<EnchantmentValueEffect>>> type, ServerLevel world, int level, ItemStack stack, Entity user, MutableFloat value
+            DataComponentType<List<ConditionalEffect<EnchantmentValueEffect>>> type, ServerLevel world, int level, ItemStack stack, Entity user, MutableFloat value
     ) {
         applyEffects(
-            this.getEffects(type),
-            entityContext(world, level, user, user.position()),
-            effect -> value.setValue(effect.process(level, user.getRandom(), value.floatValue()))
+                this.getEffects(type),
+                entityContext(world, level, user, user.position()),
+                effect -> value.setValue(effect.process(level, user.getRandom(), value.floatValue()))
         );
     }
 
     private void modifyDamageFilteredValue(
-        DataComponentType<List<ConditionalEffect<EnchantmentValueEffect>>> type,
-        ServerLevel world,
-        int level,
-        ItemStack stack,
-        Entity user,
-        DamageSource damageSource,
-        MutableFloat value
+            DataComponentType<List<ConditionalEffect<EnchantmentValueEffect>>> type,
+            ServerLevel world,
+            int level,
+            ItemStack stack,
+            Entity user,
+            DamageSource damageSource,
+            MutableFloat value
     ) {
         applyEffects(
-            this.getEffects(type),
-            damageContext(world, level, user, damageSource),
-            effect -> value.setValue(effect.process(level, user.getRandom(), value.floatValue()))
+                this.getEffects(type),
+                damageContext(world, level, user, damageSource),
+                effect -> value.setValue(effect.process(level, user.getRandom(), value.floatValue()))
         );
     }
 
     public static LootContext damageContext(ServerLevel world, int level, Entity entity, DamageSource damageSource) {
         LootParams lootParams = new LootParams.Builder(world)
-            .withParameter(LootContextParams.THIS_ENTITY, entity)
-            .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
-            .withParameter(LootContextParams.ORIGIN, entity.position())
-            .withParameter(LootContextParams.DAMAGE_SOURCE, damageSource)
-            .withOptionalParameter(LootContextParams.ATTACKING_ENTITY, damageSource.getEntity())
-            .withOptionalParameter(LootContextParams.DIRECT_ATTACKING_ENTITY, damageSource.getDirectEntity())
-            .create(LootContextParamSets.ENCHANTED_DAMAGE);
+                .withParameter(LootContextParams.THIS_ENTITY, entity)
+                .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
+                .withParameter(LootContextParams.ORIGIN, entity.position())
+                .withParameter(LootContextParams.DAMAGE_SOURCE, damageSource)
+                .withOptionalParameter(LootContextParams.ATTACKING_ENTITY, damageSource.getEntity())
+                .withOptionalParameter(LootContextParams.DIRECT_ATTACKING_ENTITY, damageSource.getDirectEntity())
+                .create(LootContextParamSets.ENCHANTED_DAMAGE);
         return new LootContext.Builder(lootParams).create(Optional.empty());
     }
 
     private static LootContext itemContext(ServerLevel world, int level, ItemStack stack) {
         LootParams lootParams = new LootParams.Builder(world)
-            .withParameter(LootContextParams.TOOL, stack)
-            .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
-            .create(LootContextParamSets.ENCHANTED_ITEM);
+                .withParameter(LootContextParams.TOOL, stack)
+                .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
+                .create(LootContextParamSets.ENCHANTED_ITEM);
         return new LootContext.Builder(lootParams).create(Optional.empty());
     }
 
     private static LootContext locationContext(ServerLevel world, int level, Entity entity, boolean enchantmentActive) {
         LootParams lootParams = new LootParams.Builder(world)
-            .withParameter(LootContextParams.THIS_ENTITY, entity)
-            .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
-            .withParameter(LootContextParams.ORIGIN, entity.position())
-            .withParameter(LootContextParams.ENCHANTMENT_ACTIVE, enchantmentActive)
-            .create(LootContextParamSets.ENCHANTED_LOCATION);
+                .withParameter(LootContextParams.THIS_ENTITY, entity)
+                .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
+                .withParameter(LootContextParams.ORIGIN, entity.position())
+                .withParameter(LootContextParams.ENCHANTMENT_ACTIVE, enchantmentActive)
+                .create(LootContextParamSets.ENCHANTED_LOCATION);
         return new LootContext.Builder(lootParams).create(Optional.empty());
     }
 
     private static LootContext entityContext(ServerLevel world, int level, Entity entity, Vec3 pos) {
         LootParams lootParams = new LootParams.Builder(world)
-            .withParameter(LootContextParams.THIS_ENTITY, entity)
-            .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
-            .withParameter(LootContextParams.ORIGIN, pos)
-            .create(LootContextParamSets.ENCHANTED_ENTITY);
+                .withParameter(LootContextParams.THIS_ENTITY, entity)
+                .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
+                .withParameter(LootContextParams.ORIGIN, pos)
+                .create(LootContextParamSets.ENCHANTED_ENTITY);
         return new LootContext.Builder(lootParams).create(Optional.empty());
     }
 
     private static LootContext blockHitContext(ServerLevel world, int level, Entity entity, Vec3 pos, BlockState state) {
         LootParams lootParams = new LootParams.Builder(world)
-            .withParameter(LootContextParams.THIS_ENTITY, entity)
-            .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
-            .withParameter(LootContextParams.ORIGIN, pos)
-            .withParameter(LootContextParams.BLOCK_STATE, state)
-            .create(LootContextParamSets.HIT_BLOCK);
+                .withParameter(LootContextParams.THIS_ENTITY, entity)
+                .withParameter(LootContextParams.ENCHANTMENT_LEVEL, level)
+                .withParameter(LootContextParams.ORIGIN, pos)
+                .withParameter(LootContextParams.BLOCK_STATE, state)
+                .create(LootContextParamSets.HIT_BLOCK);
         return new LootContext.Builder(lootParams).create(Optional.empty());
     }
 
@@ -510,18 +498,18 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
         }
 
         public <E> Enchantment.Builder withEffect(
-            DataComponentType<List<TargetedConditionalEffect<E>>> type,
-            EnchantmentTarget enchanted,
-            EnchantmentTarget affected,
-            E effect,
-            LootItemCondition.Builder requirements
+                DataComponentType<List<TargetedConditionalEffect<E>>> type,
+                EnchantmentTarget enchanted,
+                EnchantmentTarget affected,
+                E effect,
+                LootItemCondition.Builder requirements
         ) {
             this.getEffectsList(type).add(new TargetedConditionalEffect<>(enchanted, affected, effect, Optional.of(requirements.build())));
             return this;
         }
 
         public <E> Enchantment.Builder withEffect(
-            DataComponentType<List<TargetedConditionalEffect<E>>> type, EnchantmentTarget enchanted, EnchantmentTarget affected, E effect
+                DataComponentType<List<TargetedConditionalEffect<E>>> type, EnchantmentTarget enchanted, EnchantmentTarget affected, E effect
         ) {
             this.getEffectsList(type).add(new TargetedConditionalEffect<>(enchanted, affected, effect, Optional.empty()));
             return this;
@@ -543,8 +531,8 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
         }
 
         private <E> List<E> getEffectsList(DataComponentType<List<E>> type) {
-            return (List<E>)this.effectLists.computeIfAbsent(type, typex -> {
-                ArrayList<E> arrayList = new ArrayList<>();
+            return (List<E>) this.effectLists.computeIfAbsent(type, typex -> {
+                ArrayList<E> arrayList = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 this.effectMapBuilder.set(type, arrayList);
                 return arrayList;
             });
@@ -552,18 +540,18 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
 
         public Enchantment build(ResourceLocation id) {
             return new Enchantment(
-                Component.translatable(Util.makeDescriptionId("enchantment", id)), this.definition, this.exclusiveSet, this.effectMapBuilder.build()
+                    Component.translatable(Util.makeDescriptionId("enchantment", id)), this.definition, this.exclusiveSet, this.effectMapBuilder.build()
             );
         }
     }
 
     public static record Cost(int base, int perLevelAboveFirst) {
         public static final Codec<Enchantment.Cost> CODEC = RecordCodecBuilder.create(
-            instance -> instance.group(
-                        Codec.INT.fieldOf("base").forGetter(Enchantment.Cost::base),
-                        Codec.INT.fieldOf("per_level_above_first").forGetter(Enchantment.Cost::perLevelAboveFirst)
-                    )
-                    .apply(instance, Enchantment.Cost::new)
+                instance -> instance.group(
+                                Codec.INT.fieldOf("base").forGetter(Enchantment.Cost::base),
+                                Codec.INT.fieldOf("per_level_above_first").forGetter(Enchantment.Cost::perLevelAboveFirst)
+                        )
+                        .apply(instance, Enchantment.Cost::new)
         );
 
         public int calculate(int level) {
@@ -572,29 +560,29 @@ public record Enchantment(Component description, Enchantment.EnchantmentDefiniti
     }
 
     public static record EnchantmentDefinition(
-        HolderSet<Item> supportedItems,
-        Optional<HolderSet<Item>> primaryItems,
-        int weight,
-        int maxLevel,
-        Enchantment.Cost minCost,
-        Enchantment.Cost maxCost,
-        int anvilCost,
-        List<EquipmentSlotGroup> slots
+            HolderSet<Item> supportedItems,
+            Optional<HolderSet<Item>> primaryItems,
+            int weight,
+            int maxLevel,
+            Enchantment.Cost minCost,
+            Enchantment.Cost maxCost,
+            int anvilCost,
+            List<EquipmentSlotGroup> slots
     ) {
         public static final MapCodec<Enchantment.EnchantmentDefinition> CODEC = RecordCodecBuilder.mapCodec(
-            instance -> instance.group(
-                        RegistryCodecs.homogeneousList(Registries.ITEM).fieldOf("supported_items").forGetter(Enchantment.EnchantmentDefinition::supportedItems),
-                        RegistryCodecs.homogeneousList(Registries.ITEM)
-                            .optionalFieldOf("primary_items")
-                            .forGetter(Enchantment.EnchantmentDefinition::primaryItems),
-                        ExtraCodecs.intRange(1, 1024).fieldOf("weight").forGetter(Enchantment.EnchantmentDefinition::weight),
-                        ExtraCodecs.intRange(1, 255).fieldOf("max_level").forGetter(Enchantment.EnchantmentDefinition::maxLevel),
-                        Enchantment.Cost.CODEC.fieldOf("min_cost").forGetter(Enchantment.EnchantmentDefinition::minCost),
-                        Enchantment.Cost.CODEC.fieldOf("max_cost").forGetter(Enchantment.EnchantmentDefinition::maxCost),
-                        ExtraCodecs.NON_NEGATIVE_INT.fieldOf("anvil_cost").forGetter(Enchantment.EnchantmentDefinition::anvilCost),
-                        EquipmentSlotGroup.CODEC.listOf().fieldOf("slots").forGetter(Enchantment.EnchantmentDefinition::slots)
-                    )
-                    .apply(instance, Enchantment.EnchantmentDefinition::new)
+                instance -> instance.group(
+                                RegistryCodecs.homogeneousList(Registries.ITEM).fieldOf("supported_items").forGetter(Enchantment.EnchantmentDefinition::supportedItems),
+                                RegistryCodecs.homogeneousList(Registries.ITEM)
+                                        .optionalFieldOf("primary_items")
+                                        .forGetter(Enchantment.EnchantmentDefinition::primaryItems),
+                                ExtraCodecs.intRange(1, 1024).fieldOf("weight").forGetter(Enchantment.EnchantmentDefinition::weight),
+                                ExtraCodecs.intRange(1, 255).fieldOf("max_level").forGetter(Enchantment.EnchantmentDefinition::maxLevel),
+                                Enchantment.Cost.CODEC.fieldOf("min_cost").forGetter(Enchantment.EnchantmentDefinition::minCost),
+                                Enchantment.Cost.CODEC.fieldOf("max_cost").forGetter(Enchantment.EnchantmentDefinition::maxCost),
+                                ExtraCodecs.NON_NEGATIVE_INT.fieldOf("anvil_cost").forGetter(Enchantment.EnchantmentDefinition::anvilCost),
+                                EquipmentSlotGroup.CODEC.listOf().fieldOf("slots").forGetter(Enchantment.EnchantmentDefinition::slots)
+                        )
+                        .apply(instance, Enchantment.EnchantmentDefinition::new)
         );
     }
 }
diff --git a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
index 332500cb937f4a3eecb14e8daac44b33a15f9115..092720f3ea358e95afe7423274953b468d1b3e04 100644
--- a/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
+++ b/src/main/java/net/minecraft/world/item/enchantment/EnchantmentHelper.java
@@ -1,18 +1,7 @@
 package net.minecraft.world.item.enchantment;
 
-import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderSet;
@@ -46,6 +35,15 @@ import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableFloat;
 import org.apache.commons.lang3.mutable.MutableObject;
 
+import javax.annotation.Nullable;
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
 public class EnchantmentHelper {
     public static int getItemEnchantmentLevel(Holder<Enchantment> enchantment, ItemStack stack) {
         ItemEnchantments itemEnchantments = stack.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY);
@@ -84,32 +82,32 @@ public class EnchantmentHelper {
 
     public static boolean hasAnyEnchantments(ItemStack stack) {
         return !stack.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY).isEmpty()
-            || !stack.getOrDefault(DataComponents.STORED_ENCHANTMENTS, ItemEnchantments.EMPTY).isEmpty();
+                || !stack.getOrDefault(DataComponents.STORED_ENCHANTMENTS, ItemEnchantments.EMPTY).isEmpty();
     }
 
     public static int processDurabilityChange(ServerLevel world, ItemStack stack, int baseItemDamage) {
-        MutableFloat mutableFloat = new MutableFloat((float)baseItemDamage);
+        MutableFloat mutableFloat = new MutableFloat((float) baseItemDamage);
         runIterationOnItem(stack, (enchantment, level) -> enchantment.value().modifyDurabilityChange(world, level, stack, mutableFloat));
         return mutableFloat.intValue();
     }
 
     public static int processAmmoUse(ServerLevel world, ItemStack rangedWeaponStack, ItemStack projectileStack, int baseAmmoUse) {
-        MutableFloat mutableFloat = new MutableFloat((float)baseAmmoUse);
+        MutableFloat mutableFloat = new MutableFloat((float) baseAmmoUse);
         runIterationOnItem(rangedWeaponStack, (enchantment, level) -> enchantment.value().modifyAmmoCount(world, level, projectileStack, mutableFloat));
         return mutableFloat.intValue();
     }
 
     public static int processBlockExperience(ServerLevel world, ItemStack stack, int baseBlockExperience) {
-        MutableFloat mutableFloat = new MutableFloat((float)baseBlockExperience);
+        MutableFloat mutableFloat = new MutableFloat((float) baseBlockExperience);
         runIterationOnItem(stack, (enchantment, level) -> enchantment.value().modifyBlockExperience(world, level, stack, mutableFloat));
         return mutableFloat.intValue();
     }
 
     public static int processMobExperience(ServerLevel world, @Nullable Entity attacker, Entity mob, int baseMobExperience) {
         if (attacker instanceof LivingEntity livingEntity) {
-            MutableFloat mutableFloat = new MutableFloat((float)baseMobExperience);
+            MutableFloat mutableFloat = new MutableFloat((float) baseMobExperience);
             runIterationOnEquipment(
-                livingEntity, (enchantment, level, context) -> enchantment.value().modifyMobExperience(world, level, context.itemStack(), mob, mutableFloat)
+                    livingEntity, (enchantment, level, context) -> enchantment.value().modifyMobExperience(world, level, context.itemStack(), mob, mutableFloat)
             );
             return mutableFloat.intValue();
         } else {
@@ -126,7 +124,7 @@ public class EnchantmentHelper {
     }
 
     private static void runIterationOnItem(
-        ItemStack stack, EquipmentSlot slot, LivingEntity entity, EnchantmentHelper.EnchantmentInSlotVisitor contextAwareConsumer
+            ItemStack stack, EquipmentSlot slot, LivingEntity entity, EnchantmentHelper.EnchantmentInSlotVisitor contextAwareConsumer
     ) {
         if (!stack.isEmpty()) {
             ItemEnchantments itemEnchantments = stack.get(DataComponents.ENCHANTMENTS);
@@ -152,9 +150,9 @@ public class EnchantmentHelper {
     public static boolean isImmuneToDamage(ServerLevel world, LivingEntity user, DamageSource damageSource) {
         MutableBoolean mutableBoolean = new MutableBoolean();
         runIterationOnEquipment(
-            user,
-            (enchantment, level, context) -> mutableBoolean.setValue(
-                    mutableBoolean.isTrue() || enchantment.value().isImmuneToDamage(world, level, user, damageSource)
+                user,
+                (enchantment, level, context) -> mutableBoolean.setValue(
+                        mutableBoolean.isTrue() || enchantment.value().isImmuneToDamage(world, level, user, damageSource)
                 )
         );
         return mutableBoolean.isTrue();
@@ -163,8 +161,8 @@ public class EnchantmentHelper {
     public static float getDamageProtection(ServerLevel world, LivingEntity user, DamageSource damageSource) {
         MutableFloat mutableFloat = new MutableFloat(0.0F);
         runIterationOnEquipment(
-            user,
-            (enchantment, level, context) -> enchantment.value().modifyDamageProtection(world, level, context.itemStack(), user, damageSource, mutableFloat)
+                user,
+                (enchantment, level, context) -> enchantment.value().modifyDamageProtection(world, level, context.itemStack(), user, damageSource, mutableFloat)
         );
         return mutableFloat.floatValue();
     }
@@ -204,17 +202,17 @@ public class EnchantmentHelper {
     public static void doPostAttackEffectsWithItemSource(ServerLevel world, Entity target, DamageSource damageSource, @Nullable ItemStack weapon) {
         if (target instanceof LivingEntity livingEntity) {
             runIterationOnEquipment(
-                livingEntity,
-                (enchantment, level, context) -> enchantment.value().doPostAttack(world, level, context, EnchantmentTarget.VICTIM, target, damageSource)
+                    livingEntity,
+                    (enchantment, level, context) -> enchantment.value().doPostAttack(world, level, context, EnchantmentTarget.VICTIM, target, damageSource)
             );
         }
 
         if (weapon != null && damageSource.getEntity() instanceof LivingEntity livingEntity2) {
             runIterationOnItem(
-                weapon,
-                EquipmentSlot.MAINHAND,
-                livingEntity2,
-                (enchantment, level, context) -> enchantment.value().doPostAttack(world, level, context, EnchantmentTarget.ATTACKER, target, damageSource)
+                    weapon,
+                    EquipmentSlot.MAINHAND,
+                    livingEntity2,
+                    (enchantment, level, context) -> enchantment.value().doPostAttack(world, level, context, EnchantmentTarget.ATTACKER, target, damageSource)
             );
         }
     }
@@ -254,7 +252,7 @@ public class EnchantmentHelper {
     }
 
     public static int processProjectileCount(ServerLevel world, ItemStack stack, Entity user, int baseProjectileCount) {
-        MutableFloat mutableFloat = new MutableFloat((float)baseProjectileCount);
+        MutableFloat mutableFloat = new MutableFloat((float) baseProjectileCount);
         runIterationOnItem(stack, (enchantment, level) -> enchantment.value().modifyProjectileCount(world, level, stack, user, mutableFloat));
         return Math.max(0, mutableFloat.intValue());
     }
@@ -278,21 +276,21 @@ public class EnchantmentHelper {
     }
 
     public static void onHitBlock(
-        ServerLevel world,
-        ItemStack stack,
-        @Nullable LivingEntity user,
-        Entity enchantedEntity,
-        @Nullable EquipmentSlot slot,
-        Vec3 pos,
-        BlockState state,
-        Consumer<Item> onBreak
+            ServerLevel world,
+            ItemStack stack,
+            @Nullable LivingEntity user,
+            Entity enchantedEntity,
+            @Nullable EquipmentSlot slot,
+            Vec3 pos,
+            BlockState state,
+            Consumer<Item> onBreak
     ) {
         EnchantedItemInUse enchantedItemInUse = new EnchantedItemInUse(stack, slot, user, onBreak);
         runIterationOnItem(stack, (enchantment, level) -> enchantment.value().onHitBlock(world, level, enchantedItemInUse, enchantedEntity, pos, state));
     }
 
     public static int modifyDurabilityToRepairFromXp(ServerLevel world, ItemStack stack, int baseRepairWithXp) {
-        MutableFloat mutableFloat = new MutableFloat((float)baseRepairWithXp);
+        MutableFloat mutableFloat = new MutableFloat((float) baseRepairWithXp);
         runIterationOnItem(stack, (enchantment, level) -> enchantment.value().modifyDurabilityToRepairFromXp(world, level, stack, mutableFloat));
         return Math.max(0, mutableFloat.intValue());
     }
@@ -324,18 +322,18 @@ public class EnchantmentHelper {
 
     public static void forEachModifier(ItemStack stack, EquipmentSlotGroup slot, BiConsumer<Holder<Attribute>, AttributeModifier> attributeModifierConsumer) {
         runIterationOnItem(stack, (enchantment, level) -> enchantment.value().getEffects(EnchantmentEffectComponents.ATTRIBUTES).forEach(effect -> {
-                if (((Enchantment)enchantment.value()).definition().slots().contains(slot)) {
-                    attributeModifierConsumer.accept(effect.attribute(), effect.getModifier(level, slot));
-                }
-            }));
+            if (((Enchantment) enchantment.value()).definition().slots().contains(slot)) {
+                attributeModifierConsumer.accept(effect.attribute(), effect.getModifier(level, slot));
+            }
+        }));
     }
 
     public static void forEachModifier(ItemStack stack, EquipmentSlot slot, BiConsumer<Holder<Attribute>, AttributeModifier> attributeModifierConsumer) {
         runIterationOnItem(stack, (enchantment, level) -> enchantment.value().getEffects(EnchantmentEffectComponents.ATTRIBUTES).forEach(effect -> {
-                if (((Enchantment)enchantment.value()).matchingSlot(slot)) {
-                    attributeModifierConsumer.accept(effect.attribute(), effect.getModifier(level, slot));
-                }
-            }));
+            if (((Enchantment) enchantment.value()).matchingSlot(slot)) {
+                attributeModifierConsumer.accept(effect.attribute(), effect.getModifier(level, slot));
+            }
+        }));
     }
 
     public static int getFishingLuckBonus(ServerLevel world, ItemStack stack, Entity user) {
@@ -417,7 +415,7 @@ public class EnchantmentHelper {
     }
 
     public static Optional<EnchantedItemInUse> getRandomItemWith(DataComponentType<?> componentType, LivingEntity entity, Predicate<ItemStack> stackPredicate) {
-        List<EnchantedItemInUse> list = new ArrayList<>();
+        List<EnchantedItemInUse> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (EquipmentSlot equipmentSlot : EquipmentSlot.VALUES) { // Gale - JettPack - reduce array allocations
             ItemStack itemStack = entity.getItemBySlot(equipmentSlot);
@@ -456,14 +454,14 @@ public class EnchantmentHelper {
     }
 
     public static ItemStack enchantItem(
-        RandomSource random, ItemStack stack, int level, RegistryAccess dynamicRegistryManager, Optional<? extends HolderSet<Enchantment>> enchantments
+            RandomSource random, ItemStack stack, int level, RegistryAccess dynamicRegistryManager, Optional<? extends HolderSet<Enchantment>> enchantments
     ) {
         return enchantItem(
-            random,
-            stack,
-            level,
-            enchantments.map(HolderSet::stream)
-                .orElseGet(() -> dynamicRegistryManager.registryOrThrow(Registries.ENCHANTMENT).holders().map(reference -> (Holder<Enchantment>)reference))
+                random,
+                stack,
+                level,
+                enchantments.map(HolderSet::stream)
+                        .orElseGet(() -> dynamicRegistryManager.registryOrThrow(Registries.ENCHANTMENT).holders().map(reference -> (Holder<Enchantment>) reference))
         );
     }
 
@@ -481,7 +479,7 @@ public class EnchantmentHelper {
     }
 
     public static List<EnchantmentInstance> selectEnchantment(RandomSource random, ItemStack stack, int level, Stream<Holder<Enchantment>> possibleEnchantments) {
-        List<EnchantmentInstance> list = Lists.newArrayList();
+        List<EnchantmentInstance> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Item item = stack.getItem();
         int i = item.getEnchantmentValue();
         if (i <= 0) {
@@ -489,7 +487,7 @@ public class EnchantmentHelper {
         } else {
             level += 1 + random.nextInt(i / 4 + 1) + random.nextInt(i / 4 + 1);
             float f = (random.nextFloat() + random.nextFloat() - 1.0F) * 0.15F;
-            level = Mth.clamp(Math.round((float)level + (float)level * f), 1, Integer.MAX_VALUE);
+            level = Mth.clamp(Math.round((float) level + (float) level * f), 1, Integer.MAX_VALUE);
             List<EnchantmentInstance> list2 = getAvailableEnchantmentResults(level, stack, possibleEnchantments);
             if (!list2.isEmpty()) {
                 WeightedRandom.getRandomItem(random, list2).ifPresent(list::add);
@@ -527,14 +525,14 @@ public class EnchantmentHelper {
     }
 
     public static List<EnchantmentInstance> getAvailableEnchantmentResults(int level, ItemStack stack, Stream<Holder<Enchantment>> possibleEnchantments) {
-        List<EnchantmentInstance> list = Lists.newArrayList();
+        List<EnchantmentInstance> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         boolean bl = stack.is(Items.BOOK);
         possibleEnchantments.filter(enchantment -> enchantment.value().isPrimaryItem(stack) || bl).forEach(enchantmentx -> {
             Enchantment enchantment = enchantmentx.value();
 
             for (int j = enchantment.getMaxLevel(); j >= enchantment.getMinLevel(); j--) {
                 if (level >= enchantment.getMinCost(j) && level <= enchantment.getMaxCost(j)) {
-                    list.add(new EnchantmentInstance((Holder<Enchantment>)enchantmentx, j));
+                    list.add(new EnchantmentInstance((Holder<Enchantment>) enchantmentx, j));
                     break;
                 }
             }
@@ -543,7 +541,7 @@ public class EnchantmentHelper {
     }
 
     public static void enchantItemFromProvider(
-        ItemStack stack, RegistryAccess registryManager, ResourceKey<EnchantmentProvider> providerKey, DifficultyInstance localDifficulty, RandomSource random
+            ItemStack stack, RegistryAccess registryManager, ResourceKey<EnchantmentProvider> providerKey, DifficultyInstance localDifficulty, RandomSource random
     ) {
         EnchantmentProvider enchantmentProvider = registryManager.registryOrThrow(Registries.ENCHANTMENT_PROVIDER).get(providerKey);
         if (enchantmentProvider != null) {
@@ -610,8 +608,8 @@ public class EnchantmentHelper {
         }
 
         return maxStack != null
-            ? Optional.of(new EnchantedItemInUse(maxStack, maxSlot, entity))
-            : Optional.empty();
+                ? Optional.of(new EnchantedItemInUse(maxStack, maxSlot, entity))
+                : Optional.empty();
     }
     // Purpur end - Add option to mend the most damaged equipment first
 }
diff --git a/src/main/java/net/minecraft/world/level/EntityGetter.java b/src/main/java/net/minecraft/world/level/EntityGetter.java
index d654059a52c269e0c7cb1fa4b3fa769a2bc32cf9..86037cf6bc88432edf9dabbcbbd65f0a8949b931 100644
--- a/src/main/java/net/minecraft/world/level/EntityGetter.java
+++ b/src/main/java/net/minecraft/world/level/EntityGetter.java
@@ -1,12 +1,5 @@
 package net.minecraft.world.level;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
-import com.google.common.collect.ImmutableList.Builder;
-import java.util.List;
-import java.util.UUID;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntitySelector;
 import net.minecraft.world.entity.LivingEntity;
@@ -14,10 +7,14 @@ import net.minecraft.world.entity.ai.targeting.TargetingConditions;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.phys.AABB;
-import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
+import javax.annotation.Nullable;
+import java.util.List;
+import java.util.UUID;
+import java.util.function.Predicate;
+
 public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter { // Paper - rewrite chunk system
     List<Entity> getEntities(@Nullable Entity except, AABB box, Predicate<? super Entity> predicate);
 
@@ -46,10 +43,10 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
             return false;
         }
 
-        final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)voxel).moonrise$getSingleAABBRepresentation();
+        final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape) voxel).moonrise$getSingleAABBRepresentation();
         final List<Entity> entities = this.getEntities(
-            entity,
-            singleAABB == null ? voxel.bounds() : singleAABB.inflate(-ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON)
+                entity,
+                singleAABB == null ? voxel.bounds() : singleAABB.inflate(-ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON)
         );
 
         for (int i = 0, len = entities.size(); i < len; ++i) {
@@ -91,10 +88,10 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
         box = box.inflate(-ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON);
 
         final List<Entity> entities;
-        if (entity != null && ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)entity).moonrise$isHardColliding()) {
+        if (entity != null && ((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity) entity).moonrise$isHardColliding()) {
             entities = this.getEntities(entity, box, null);
         } else {
-            entities = ((ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter)this).moonrise$getHardCollidingEntities(entity, box, null);
+            entities = ((ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter) this).moonrise$getHardCollidingEntities(entity, box, null);
         }
 
         final List<VoxelShape> ret = new java.util.ArrayList<>(Math.min(25, entities.size()));
@@ -119,6 +116,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
     default @Nullable Player findNearbyPlayer(Entity entity, double maxDistance, @Nullable Predicate<Entity> predicate) {
         return this.getNearestPlayer(entity.getX(), entity.getY(), entity.getZ(), maxDistance, predicate);
     }
+
     // Paper end - Affects Spawning API
     @Nullable
     default Player getNearestPlayer(double x, double y, double z, double maxDistance, @Nullable Predicate<Entity> targetPredicate) {
@@ -298,14 +296,14 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
 
     @Nullable
     default <T extends LivingEntity> T getNearestEntity(
-        Class<? extends T> entityClass, TargetingConditions targetPredicate, @Nullable LivingEntity entity, double x, double y, double z, AABB box
+            Class<? extends T> entityClass, TargetingConditions targetPredicate, @Nullable LivingEntity entity, double x, double y, double z, AABB box
     ) {
         return this.getNearestEntity(this.getEntitiesOfClass(entityClass, box, entityOfClass -> true), targetPredicate, entity, x, y, z);
     }
 
     @Nullable
     default <T extends LivingEntity> T getNearestEntity(
-        List<? extends T> entityList, TargetingConditions targetPredicate, @Nullable LivingEntity entity, double x, double y, double z
+            List<? extends T> entityList, TargetingConditions targetPredicate, @Nullable LivingEntity entity, double x, double y, double z
     ) {
         double d = -1.0;
         T livingEntity = null;
@@ -324,7 +322,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
     }
 
     default List<Player> getNearbyPlayers(TargetingConditions targetPredicate, LivingEntity entity, AABB box) {
-        List<Player> list = Lists.newArrayList();
+        List<Player> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Player player : this.players()) {
             if (box.contains(player.getX(), player.getY(), player.getZ()) && targetPredicate.test(entity, player)) {
@@ -336,10 +334,10 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
     }
 
     default <T extends LivingEntity> List<T> getNearbyEntities(
-        Class<T> entityClass, TargetingConditions targetPredicate, LivingEntity targetingEntity, AABB box
+            Class<T> entityClass, TargetingConditions targetPredicate, LivingEntity targetingEntity, AABB box
     ) {
         List<T> list = this.getEntitiesOfClass(entityClass, box, livingEntityx -> true);
-        List<T> list2 = Lists.newArrayList();
+        List<T> list2 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (T livingEntity : list) {
             if (targetPredicate.test(targetingEntity, livingEntity)) {
diff --git a/src/main/java/net/minecraft/world/level/Explosion.java b/src/main/java/net/minecraft/world/level/Explosion.java
index 72ec914d6653db200eb1dfadf28a27b608adc9f9..d97bf7ed935befc7710ef5ce53139dc3142e67d2 100644
--- a/src/main/java/net/minecraft/world/level/Explosion.java
+++ b/src/main/java/net/minecraft/world/level/Explosion.java
@@ -1,17 +1,9 @@
 package net.minecraft.world.level;
 
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectListIterator;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -36,17 +28,23 @@ import net.minecraft.world.entity.projectile.Projectile;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.block.BaseFireBlock;
 import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.state.BlockState;
-import org.bukkit.craftbukkit.event.CraftEventFactory;
-import org.bukkit.event.entity.EntityExplodeEvent;
 import org.bukkit.Location;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.block.BlockExplodeEvent;
+import org.bukkit.event.entity.EntityExplodeEvent;
+
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 // CraftBukkit end
 
 public class Explosion {
@@ -78,6 +76,7 @@ public class Explosion {
 
     // Paper start - optimise collisions
     private static final double[] CACHED_RAYS;
+
     static {
         final it.unimi.dsi.fastutil.doubles.DoubleArrayList rayCoords = new it.unimi.dsi.fastutil.doubles.DoubleArrayList();
 
@@ -85,17 +84,17 @@ public class Explosion {
             for (int y = 0; y <= 15; ++y) {
                 for (int z = 0; z <= 15; ++z) {
                     if ((x == 0 || x == 15) || (y == 0 || y == 15) || (z == 0 || z == 15)) {
-                        double xDir = (double)((float)x / 15.0F * 2.0F - 1.0F);
-                        double yDir = (double)((float)y / 15.0F * 2.0F - 1.0F);
-                        double zDir = (double)((float)z / 15.0F * 2.0F - 1.0F);
+                        double xDir = (double) ((float) x / 15.0F * 2.0F - 1.0F);
+                        double yDir = (double) ((float) y / 15.0F * 2.0F - 1.0F);
+                        double zDir = (double) ((float) z / 15.0F * 2.0F - 1.0F);
 
                         double mag = Math.sqrt(
-                            xDir * xDir + yDir * yDir + zDir * zDir
+                                xDir * xDir + yDir * yDir + zDir * zDir
                         );
 
-                        rayCoords.add((xDir / mag) * (double)0.3F);
-                        rayCoords.add((yDir / mag) * (double)0.3F);
-                        rayCoords.add((zDir / mag) * (double)0.3F);
+                        rayCoords.add((xDir / mag) * (double) 0.3F);
+                        rayCoords.add((yDir / mag) * (double) 0.3F);
+                        rayCoords.add((zDir / mag) * (double) 0.3F);
                     }
                 }
             }
@@ -118,6 +117,7 @@ public class Explosion {
     private it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache> blockCache = null;
     private long[] chunkPosCache = null;
     private net.minecraft.world.level.chunk.LevelChunk[] chunkCache = null;
+
     private ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache getOrCacheExplosionBlock(final int x, final int y, final int z,
                                                                                                     final long key, final boolean calculateResistance) {
         ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache ret = this.blockCache.get(key);
@@ -140,15 +140,15 @@ public class Explosion {
                 this.chunkCache[chunkCacheKey] = chunk = this.level.getChunk(x >> 4, z >> 4);
             }
 
-            BlockState blockState = ((ca.spottedleaf.moonrise.patches.chunk_getblock.GetBlockChunk)chunk).moonrise$getBlock(x, y, z);
+            BlockState blockState = ((ca.spottedleaf.moonrise.patches.chunk_getblock.GetBlockChunk) chunk).moonrise$getBlock(x, y, z);
             FluidState fluidState = blockState.getFluidState();
 
-            Optional<Float> resistance = !calculateResistance ? Optional.empty() : this.damageCalculator.getBlockExplosionResistance((Explosion)(Object)this, this.level, pos, blockState, fluidState);
+            Optional<Float> resistance = !calculateResistance ? Optional.empty() : this.damageCalculator.getBlockExplosionResistance((Explosion) (Object) this, this.level, pos, blockState, fluidState);
 
             ret = new ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache(
-                key, pos, blockState, fluidState,
-                (resistance.orElse(ZERO_RESISTANCE).floatValue() + 0.3f) * 0.3f,
-                false
+                    key, pos, blockState, fluidState,
+                    (resistance.orElse(ZERO_RESISTANCE).floatValue() + 0.3f) * 0.3f,
+                    false
             );
         }
 
@@ -189,9 +189,9 @@ public class Explosion {
         final double dyDouble = Math.signum(diffY);
         final double dzDouble = Math.signum(diffZ);
 
-        final int dx = (int)dxDouble;
-        final int dy = (int)dyDouble;
-        final int dz = (int)dzDouble;
+        final int dx = (int) dxDouble;
+        final int dy = (int) dyDouble;
+        final int dz = (int) dzDouble;
 
         final double normalizedDiffX = diffX == 0.0 ? Double.MAX_VALUE : dxDouble / diffX;
         final double normalizedDiffY = diffY == 0.0 ? Double.MAX_VALUE : dyDouble / diffY;
@@ -201,7 +201,7 @@ public class Explosion {
         double normalizedCurrY = normalizedDiffY * (diffY > 0.0 ? (1.0 - Mth.frac(fromYAdj)) : Mth.frac(fromYAdj));
         double normalizedCurrZ = normalizedDiffZ * (diffZ > 0.0 ? (1.0 - Mth.frac(fromZAdj)) : Mth.frac(fromZAdj));
 
-        for (;;) {
+        for (; ; ) {
             currPos.set(currX, currY, currZ);
 
             // ClipContext.Block.COLLIDER -> BlockBehaviour.BlockStateBase::getCollisionShape
@@ -211,19 +211,19 @@ public class Explosion {
             final long key = BlockPos.asLong(currX, currY, currZ);
 
             final int cacheKey =
-                (currX & BLOCK_EXPLOSION_CACHE_MASK) |
-                    (currY & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT) |
-                    (currZ & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT + BLOCK_EXPLOSION_CACHE_SHIFT);
+                    (currX & BLOCK_EXPLOSION_CACHE_MASK) |
+                            (currY & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT) |
+                            (currZ & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT + BLOCK_EXPLOSION_CACHE_SHIFT);
             ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache cachedBlock = blockCache[cacheKey];
             if (cachedBlock == null || cachedBlock.key != key) {
                 blockCache[cacheKey] = cachedBlock = this.getOrCacheExplosionBlock(currX, currY, currZ, key, false);
             }
 
             final BlockState blockState = cachedBlock.blockState;
-            if (blockState != null && !((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)blockState).moonrise$emptyCollisionShape()) {
+            if (blockState != null && !((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState) blockState).moonrise$emptyCollisionShape()) {
                 net.minecraft.world.phys.shapes.VoxelShape collision = cachedBlock.cachedCollisionShape;
                 if (collision == null) {
-                    collision = ((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)blockState).moonrise$getConstantCollisionShape();
+                    collision = ((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState) blockState).moonrise$getConstantCollisionShape();
                     if (collision == null) {
                         collision = blockState.getCollisionShape(this.level, currPos, context);
                         if (!context.isDelegated()) {
@@ -301,9 +301,9 @@ public class Explosion {
                     ++totalRays;
 
                     final Vec3 from = new Vec3(
-                        fromX,
-                        fromY,
-                        Math.fma(dz, diffZ, offZ)
+                            fromX,
+                            fromY,
+                            Math.fma(dz, diffZ, offZ)
                     );
 
                     if (!this.clipsAnything(from, source, context, blockCache, blockPos)) {
@@ -313,7 +313,7 @@ public class Explosion {
             }
         }
 
-        return (float)missedRays / (float)totalRays;
+        return (float) missedRays / (float) totalRays;
     }
     // Paper end - optimise collisions
 
@@ -410,17 +410,17 @@ public class Explosion {
         // CraftBukkit end
 
         // Purpur start - add PreExplodeEvents
-        if(this.source != null){
+        if (this.source != null) {
             Location location = new Location(this.level.getWorld(), this.x, this.y, this.z);
-            if(!new org.purpurmc.purpur.event.entity.PreEntityExplodeEvent(this.source.getBukkitEntity(), location, this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, org.bukkit.craftbukkit.CraftExplosionResult.toBukkit(getBlockInteraction())).callEvent()) {
+            if (!new org.purpurmc.purpur.event.entity.PreEntityExplodeEvent(this.source.getBukkitEntity(), location, this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, org.bukkit.craftbukkit.CraftExplosionResult.toBukkit(getBlockInteraction())).callEvent()) {
                 this.wasCanceled = true;
                 return;
             }
-        }else {
+        } else {
             Location location = new Location(this.level.getWorld(), this.x, this.y, this.z);
             org.bukkit.block.Block block = location.getBlock();
             org.bukkit.block.BlockState blockState = (this.damageSource.getDirectBlockState() != null) ? this.damageSource.getDirectBlockState() : block.getState();
-            if(!new org.purpurmc.purpur.event.PreBlockExplodeEvent(location.getBlock(), this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, blockState, org.bukkit.craftbukkit.CraftExplosionResult.toBukkit(getBlockInteraction())).callEvent()) {
+            if (!new org.purpurmc.purpur.event.PreBlockExplodeEvent(location.getBlock(), this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, blockState, org.bukkit.craftbukkit.CraftExplosionResult.toBukkit(getBlockInteraction())).callEvent()) {
                 this.wasCanceled = true;
                 return;
             }
@@ -458,7 +458,7 @@ public class Explosion {
         int j;
 
         // Paper start - collision optimisations
-        for (int ray = 0, len = CACHED_RAYS.length; ray < len;) {
+        for (int ray = 0, len = CACHED_RAYS.length; ray < len; ) {
             ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache cachedBlock = initialCache;
 
             double currX = this.x;
@@ -470,63 +470,63 @@ public class Explosion {
             final double incZ = CACHED_RAYS[ray + 2];
 
             ray += 3;
-                        float power = this.radius * (0.7F + this.level.random.nextFloat() * 0.6F);
-                        do {
-                            final int blockX = Mth.floor(currX);
-                            final int blockY = Mth.floor(currY);
-                            final int blockZ = Mth.floor(currZ);
-
-                            final long key = BlockPos.asLong(blockX, blockY, blockZ);
-
-                            if (cachedBlock.key != key) {
-                                final int cacheKey =
-                                    (blockX & BLOCK_EXPLOSION_CACHE_MASK) |
-                                        (blockY & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT) |
-                                        (blockZ & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT + BLOCK_EXPLOSION_CACHE_SHIFT);
-                                cachedBlock = blockCache[cacheKey];
-                                if (cachedBlock == null || cachedBlock.key != key) {
-                                    blockCache[cacheKey] = cachedBlock = this.getOrCacheExplosionBlock(blockX, blockY, blockZ, key, true);
-                                }
-                            }
+            float power = this.radius * (0.7F + this.level.random.nextFloat() * 0.6F);
+            do {
+                final int blockX = Mth.floor(currX);
+                final int blockY = Mth.floor(currY);
+                final int blockZ = Mth.floor(currZ);
+
+                final long key = BlockPos.asLong(blockX, blockY, blockZ);
+
+                if (cachedBlock.key != key) {
+                    final int cacheKey =
+                            (blockX & BLOCK_EXPLOSION_CACHE_MASK) |
+                                    (blockY & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT) |
+                                    (blockZ & BLOCK_EXPLOSION_CACHE_MASK) << (BLOCK_EXPLOSION_CACHE_SHIFT + BLOCK_EXPLOSION_CACHE_SHIFT);
+                    cachedBlock = blockCache[cacheKey];
+                    if (cachedBlock == null || cachedBlock.key != key) {
+                        blockCache[cacheKey] = cachedBlock = this.getOrCacheExplosionBlock(blockX, blockY, blockZ, key, true);
+                    }
+                }
 
-                            if (cachedBlock.outOfWorld) {
-                                break;
-                            }
-                            // Paper end - collision optimisations
-                            BlockState iblockdata = cachedBlock.blockState; // Paper - optimise collisions
-                            // Paper - collision optimisations
-
-                            // Paper start - collision optimisations
-                            power -= cachedBlock.resistance;
-
-                            if (power > 0.0f && cachedBlock.shouldExplode == null && iblockdata.isDestroyable()) { // Paper - Protect Bedrock and End Portal/Frames from being destroyed
-                                // note: we expect shouldBlockExplode to be pure with respect to power, as Vanilla currently is.
-                                // basically, it is unused, which allows us to cache the result
-                                final boolean shouldExplode = this.damageCalculator.shouldBlockExplode((Explosion)(Object)this, this.level, cachedBlock.immutablePos, cachedBlock.blockState, power);
-                                cachedBlock.shouldExplode = shouldExplode ? Boolean.TRUE : Boolean.FALSE;
-                                if (shouldExplode) {
-                                    if (this.fire || !cachedBlock.blockState.isAir()) {
-                                        this.toBlow.add(cachedBlock.immutablePos);
-                                        // Paper start - prevent headless pistons from forming
-                                        if (!io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowHeadlessPistons && iblockdata.getBlock() == Blocks.MOVING_PISTON) {
-                                            net.minecraft.world.level.block.entity.BlockEntity extension = this.level.getBlockEntity(cachedBlock.immutablePos); // Paper - optimise collisions
-                                            if (extension instanceof net.minecraft.world.level.block.piston.PistonMovingBlockEntity blockEntity && blockEntity.isSourcePiston()) {
-                                                net.minecraft.core.Direction direction = iblockdata.getValue(net.minecraft.world.level.block.piston.PistonHeadBlock.FACING);
-                                                this.toBlow.add(cachedBlock.immutablePos.relative(direction.getOpposite())); // Paper - optimise collisions
-                                            }
-                                        }
-                                        // Paper end - prevent headless pistons from forming
-                                    }
+                if (cachedBlock.outOfWorld) {
+                    break;
+                }
+                // Paper end - collision optimisations
+                BlockState iblockdata = cachedBlock.blockState; // Paper - optimise collisions
+                // Paper - collision optimisations
+
+                // Paper start - collision optimisations
+                power -= cachedBlock.resistance;
+
+                if (power > 0.0f && cachedBlock.shouldExplode == null && iblockdata.isDestroyable()) { // Paper - Protect Bedrock and End Portal/Frames from being destroyed
+                    // note: we expect shouldBlockExplode to be pure with respect to power, as Vanilla currently is.
+                    // basically, it is unused, which allows us to cache the result
+                    final boolean shouldExplode = this.damageCalculator.shouldBlockExplode((Explosion) (Object) this, this.level, cachedBlock.immutablePos, cachedBlock.blockState, power);
+                    cachedBlock.shouldExplode = shouldExplode ? Boolean.TRUE : Boolean.FALSE;
+                    if (shouldExplode) {
+                        if (this.fire || !cachedBlock.blockState.isAir()) {
+                            this.toBlow.add(cachedBlock.immutablePos);
+                            // Paper start - prevent headless pistons from forming
+                            if (!io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowHeadlessPistons && iblockdata.getBlock() == Blocks.MOVING_PISTON) {
+                                net.minecraft.world.level.block.entity.BlockEntity extension = this.level.getBlockEntity(cachedBlock.immutablePos); // Paper - optimise collisions
+                                if (extension instanceof net.minecraft.world.level.block.piston.PistonMovingBlockEntity blockEntity && blockEntity.isSourcePiston()) {
+                                    net.minecraft.core.Direction direction = iblockdata.getValue(net.minecraft.world.level.block.piston.PistonHeadBlock.FACING);
+                                    this.toBlow.add(cachedBlock.immutablePos.relative(direction.getOpposite())); // Paper - optimise collisions
                                 }
                             }
-
-                            power -= 0.22500001F;
-                            currX += incX;
-                            currY += incY;
-                            currZ += incZ;
-                        } while (power > 0.0f);
-                        // Paper end - collision optimisations
+                            // Paper end - prevent headless pistons from forming
+                        }
                     }
+                }
+
+                power -= 0.22500001F;
+                currX += incX;
+                currY += incY;
+                currZ += incZ;
+            } while (power > 0.0f);
+            // Paper end - collision optimisations
+        }
 
         // Paper - optimise collisions
         float f2 = this.radius * 2.0F;
@@ -577,7 +577,7 @@ public class Explosion {
 
                             entity.lastDamageCancelled = false;
 
-                            seenFraction = (double)this.getBlockDensity(vec3d, entity, blockCache, blockPos); // Paper - optimise collisions
+                            seenFraction = (double) this.getBlockDensity(vec3d, entity, blockCache, blockPos); // Paper - optimise collisions
 
                             if (entity instanceof EnderDragon) {
                                 for (EnderDragonPart entityComplexPart : ((EnderDragon) entity).subEntities) {
@@ -591,7 +591,7 @@ public class Explosion {
                                 // inline getEntityDamageAmount so that we can avoid double calling getSeenPercent, which is the MOST
                                 // expensive part of this loop!!!!
                                 final double factor = (1.0 - d7) * seenFraction;
-                                entity.hurt(this.damageSource, (float)((factor * factor + factor) / 2.0 * 7.0 * (double)f2 + 1.0));
+                                entity.hurt(this.damageSource, (float) ((factor * factor + factor) / 2.0 * 7.0 * (double) f2 + 1.0));
                                 // Paper end - optimise collisions
                             }
 
@@ -599,7 +599,9 @@ public class Explosion {
                                 continue;
                             }
                             // CraftBukkit end
-                        } else { seenFraction = (double)this.getBlockDensity(vec3d, entity, blockCache, blockPos); } // Paper - optimise collisions
+                        } else {
+                            seenFraction = (double) this.getBlockDensity(vec3d, entity, blockCache, blockPos);
+                        } // Paper - optimise collisions
 
                         double d12 = (1.0D - d7) * seenFraction * (double) this.damageCalculator.getKnockbackMultiplier(entity); // Paper - Optimize explosions // Paper - optimise collisions
                         double d13;
@@ -666,7 +668,7 @@ public class Explosion {
         }
 
         if (flag1) {
-            List<Pair<ItemStack, BlockPos>> list = new ArrayList();
+            List<Pair<ItemStack, BlockPos>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             Util.shuffle(this.toBlow, this.level.random);
             ObjectListIterator objectlistiterator = this.toBlow.iterator();
@@ -855,8 +857,10 @@ public class Explosion {
 
         KEEP, DESTROY, DESTROY_WITH_DECAY, TRIGGER_BLOCK;
 
-        private BlockInteraction() {}
+        private BlockInteraction() {
+        }
     }
+
     // Paper start - Optimize explosions
     private float getBlockDensity(Vec3 vec3d, Entity entity, ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache[] blockCache, BlockPos.MutableBlockPos blockPos) { // Paper - optimise collisions
         if (!this.level.paperConfig().environment.optimizeExplosions) {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 704631730cf7679446a98cea6faeb70eb89c9849..ef89ae494b933c3dc836c08641948f074896b1df 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,38 +1,23 @@
 package net.minecraft.world.level;
 
-import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.Holder;
-import net.minecraft.core.RegistryAccess;
-import net.minecraft.core.SectionPos;
+import net.minecraft.core.*;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.FullChunkStatus;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.StringRepresentable;
@@ -42,8 +27,6 @@ import net.minecraft.world.TickRateManager;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.damagesource.DamageSources;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -83,15 +66,6 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.Scoreboard;
-
-// CraftBukkit start
-import java.util.HashMap;
-import java.util.Map;
-import net.minecraft.network.protocol.game.ClientboundSetBorderCenterPacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -101,6 +75,13 @@ import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftSpawnCategory;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel, ca.spottedleaf.moonrise.patches.chunk_system.world.ChunkSystemEntityGetter, ca.spottedleaf.moonrise.patches.collisions.world.CollisionLevel { // Paper - rewrite chunk system // Paper - optimise collisions
@@ -116,9 +97,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
-    public final List<TickingBlockEntity> blockEntityTickers = new org.dreeam.leaf.util.HashedReferenceList<>(Lists.newArrayList()); // Paper - public // Leaf - Lithium - hashed list
+    public final List<TickingBlockEntity> blockEntityTickers = new org.dreeam.leaf.util.HashedReferenceList<>(new net.vansen.norspaper.collections.DynamicObjectArrayList<>()); // Paper - public // Leaf - Lithium - hashed list
     protected final NeighborUpdater neighborUpdater;
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = new org.dreeam.leaf.util.HashedReferenceList<>(Lists.newArrayList()); // Leaf - Lithium - hashed list
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = new org.dreeam.leaf.util.HashedReferenceList<>(new net.vansen.norspaper.collections.DynamicObjectArrayList<>()); // Leaf - Lithium - hashed list
     private boolean tickingBlockEntities;
     public final Thread thread;
     private final boolean isDebug;
@@ -131,7 +112,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public float thunderLevel;
     public final RandomSource random = RandomSource.create();
     public final RandomSource randomFaster = RandomSource.createFaster(); // Leaf - Generate random seed faster
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     private final RandomSource threadSafeRandom = RandomSource.createThreadSafe();
     private final Holder<DimensionType> dimensionTypeRegistration;
@@ -167,12 +150,15 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
     // Paper start - add paper world config
     private final io.papermc.paper.configuration.WorldConfiguration paperConfig;
+
     public io.papermc.paper.configuration.WorldConfiguration paperConfig() {
         return this.paperConfig;
     }
+
     // Paper end - add paper world config
     // Gale start - Gale configuration
     private final org.galemc.gale.configuration.GaleWorldConfiguration galeConfig;
+
     public org.galemc.gale.configuration.GaleWorldConfiguration galeConfig() {
         return this.galeConfig;
     }
@@ -243,6 +229,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public boolean hasChunk(int chunkX, int chunkZ) {
         return this.getChunkIfLoaded(chunkX, chunkZ) != null;
     }
+
     // Paper end - Use getChunkIfLoadedImmediately
     // Paper start - per world ticks per spawn
     private int getTicksPerSpawn(SpawnCategory spawnCategory) {
@@ -276,7 +263,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public final <T extends Entity> List<T> getEntitiesOfClass(final Class<T> entityClass, final AABB boundingBox, final Predicate<? super T> predicate) {
         final List<T> ret = new java.util.ArrayList<>();
 
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(entityClass, null, boundingBox, ret, predicate);
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities(entityClass, null, boundingBox, ret, predicate);
 
         return ret;
     }
@@ -285,7 +272,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public final List<Entity> moonrise$getHardCollidingEntities(final Entity entity, final AABB box, final Predicate<? super Entity> predicate) {
         final List<Entity> ret = new java.util.ArrayList<>();
 
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getHardCollidingEntities(entity, box, ret, predicate);
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getHardCollidingEntities(entity, box, ret, predicate);
 
         return ret;
     }
@@ -309,22 +296,24 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public void moonrise$midTickTasks() {
         // no-op on ClientLevel
     }
+
     /**
      * @reason Turn all getChunk(x, z, status) calls into virtual invokes, instead of interface invokes:
-     *         1. The interface invoke is expensive
-     *         2. The method makes other interface invokes (again, expensive)
-     *         Instead, we just directly call getChunk(x, z, status, true) which avoids the interface invokes entirely.
+     * 1. The interface invoke is expensive
+     * 2. The method makes other interface invokes (again, expensive)
+     * Instead, we just directly call getChunk(x, z, status, true) which avoids the interface invokes entirely.
      * @author Spottedleaf
      */
     @Override
     public ChunkAccess getChunk(final int x, final int z, final ChunkStatus status) {
-        return ((Level)(Object)this).getChunk(x, z, status, true);
+        return ((Level) (Object) this).getChunk(x, z, status, true);
     }
 
     @Override
     public BlockPos getHeightmapPos(Heightmap.Types types, BlockPos blockPos) {
         return new BlockPos(blockPos.getX(), this.getHeight(types, blockPos.getX(), blockPos.getZ()), blockPos.getZ());
     }
+
     // Paper end - rewrite chunk system
     // Paper start - optimise collisions
     private final int minSection;
@@ -343,6 +332,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     /**
      * Route to faster lookup.
      * See {@link EntityGetter#isUnobstructed(Entity, VoxelShape)} for expected behavior
+     *
      * @author Spottedleaf
      */
     @Override
@@ -353,9 +343,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         }
 
         final List<Entity> entities = this.getEntities(
-            entity,
-            boundingBox.inflate(-ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON),
-            null
+                entity,
+                boundingBox.inflate(-ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON, -ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_EPSILON),
+                null
         );
 
         for (int i = 0, len = entities.size(); i < len; ++i) {
@@ -412,9 +402,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         final double dyDouble = Math.signum(diffY);
         final double dzDouble = Math.signum(diffZ);
 
-        final int dx = (int)dxDouble;
-        final int dy = (int)dyDouble;
-        final int dz = (int)dzDouble;
+        final int dx = (int) dxDouble;
+        final int dy = (int) dyDouble;
+        final int dz = (int) dzDouble;
 
         final double normalizedDiffX = diffX == 0.0 ? Double.MAX_VALUE : dxDouble / diffX;
         final double normalizedDiffY = diffY == 0.0 ? Double.MAX_VALUE : dyDouble / diffY;
@@ -430,9 +420,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         int lastChunkY = Integer.MIN_VALUE;
         int lastChunkZ = Integer.MIN_VALUE;
 
-        final int minSection = ((ca.spottedleaf.moonrise.patches.collisions.world.CollisionLevel)level).moonrise$getMinSection();
+        final int minSection = ((ca.spottedleaf.moonrise.patches.collisions.world.CollisionLevel) level).moonrise$getMinSection();
 
-        for (;;) {
+        for (; ; ) {
             currPos.set(currX, currY, currZ);
 
             final int newChunkX = currX >> 4;
@@ -455,7 +445,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             }
 
             final BlockState blockState;
-            if (lastSection != null && !(blockState = lastSection.get((currX & 15) | ((currZ & 15) << 4) | ((currY & 15) << (4+4)))).isAir()) {
+            if (lastSection != null && !(blockState = lastSection.get((currX & 15) | ((currZ & 15) << 4) | ((currY & 15) << (4 + 4)))).isAir()) {
                 final VoxelShape blockCollision = clipContext.getBlockShape(blockState, level, currPos);
 
                 final net.minecraft.world.phys.BlockHitResult blockHit = blockCollision.isEmpty() ? null : level.clipWithInteractionOverride(from, to, currPos, blockCollision, blockState);
@@ -515,7 +505,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     @Override
     public final net.minecraft.world.phys.BlockHitResult clip(final ClipContext clipContext) {
         // can only do this in this class, as not everything that implements BlockGetter can retrieve chunks
-        return fastClip(clipContext.getFrom(), clipContext.getTo(), (Level)(Object)this, clipContext);
+        return fastClip(clipContext.getFrom(), clipContext.getTo(), (Level) (Object) this, clipContext);
     }
 
     /**
@@ -524,23 +514,23 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
      */
     @Override
     public final boolean collidesWithSuffocatingBlock(final Entity entity, final AABB box) {
-        return ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder((Level)(Object)this, entity, box, null, null,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY,
-            (final BlockState state, final BlockPos pos) -> {
-                return state.isSuffocating((Level)(Object)Level.this, pos);
-            }
+        return ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder((Level) (Object) this, entity, box, null, null,
+                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY,
+                (final BlockState state, final BlockPos pos) -> {
+                    return state.isSuffocating((Level) (Object) Level.this, pos);
+                }
         );
     }
 
     private static VoxelShape inflateAABBToVoxel(final AABB aabb, final double x, final double y, final double z) {
         return net.minecraft.world.phys.shapes.Shapes.create(
-            aabb.minX - x,
-            aabb.minY - y,
-            aabb.minZ - z,
+                aabb.minX - x,
+                aabb.minY - y,
+                aabb.minZ - z,
 
-            aabb.maxX + x,
-            aabb.maxY + y,
-            aabb.maxZ + z
+                aabb.maxX + x,
+                aabb.maxY + y,
+                aabb.maxZ + z
         );
     }
 
@@ -566,9 +556,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         final List<VoxelShape> voxels = new java.util.ArrayList<>();
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
-            (Level)(Object)this, entity, collectionVolume, voxels, aabbs,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
-            null
+                (Level) (Object) this, entity, collectionVolume, voxels, aabbs,
+                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
+                null
         );
 
         final WorldBorder worldBorder = this.getWorldBorder();
@@ -644,7 +634,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 if (((newChunkX ^ lastChunkX) | (newChunkZ ^ lastChunkZ)) != 0) {
                     lastChunkX = newChunkX;
                     lastChunkZ = newChunkZ;
-                    lastChunk = (LevelChunk)chunkSource.getChunk(newChunkX, newChunkZ, ChunkStatus.FULL, false);
+                    lastChunk = (LevelChunk) chunkSource.getChunk(newChunkX, newChunkZ, ChunkStatus.FULL, false);
                 }
 
                 if (lastChunk == null) {
@@ -652,8 +642,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 }
                 for (int currY = minBlockY; currY <= maxBlockY; ++currY) {
                     int edgeCount = ((currX == minBlockX || currX == maxBlockX) ? 1 : 0) +
-                        ((currY == minBlockY || currY == maxBlockY) ? 1 : 0) +
-                        ((currZ == minBlockZ || currZ == maxBlockZ) ? 1 : 0);
+                            ((currY == minBlockY || currY == maxBlockY) ? 1 : 0) +
+                            ((currZ == minBlockZ || currZ == maxBlockZ) ? 1 : 0);
                     if (edgeCount == 3) {
                         continue;
                     }
@@ -665,12 +655,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                         continue;
                     }
 
-                    final BlockState state = ((ca.spottedleaf.moonrise.patches.chunk_getblock.GetBlockChunk)lastChunk).moonrise$getBlock(currX, currY, currZ);
-                    if (((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)state).moonrise$emptyCollisionShape()) {
+                    final BlockState state = ((ca.spottedleaf.moonrise.patches.chunk_getblock.GetBlockChunk) lastChunk).moonrise$getBlock(currX, currY, currZ);
+                    if (((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState) state).moonrise$emptyCollisionShape()) {
                         continue;
                     }
 
-                    VoxelShape blockCollision = ((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)state).moonrise$getConstantCollisionShape();
+                    VoxelShape blockCollision = ((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState) state).moonrise$getConstantCollisionShape();
 
                     if ((edgeCount != 1 || state.hasLargeCollisionShape()) && (edgeCount != 2 || state.getBlock() == Blocks.MOVING_PISTON)) {
                         if (collisionContext == null) {
@@ -678,7 +668,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                         }
 
                         if (blockCollision == null) {
-                            blockCollision = state.getCollisionShape((Level)(Object)this, pos, collisionContext);
+                            blockCollision = state.getCollisionShape((Level) (Object) this, pos, collisionContext);
                         }
 
                         if (blockCollision.isEmpty()) {
@@ -686,9 +676,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                         }
 
                         // avoid VoxelShape#move by shifting the entity collision shape instead
-                        final AABB shiftedAABB = aabb.move(-(double)currX, -(double)currY, -(double)currZ);
+                        final AABB shiftedAABB = aabb.move(-(double) currX, -(double) currY, -(double) currZ);
 
-                        final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)blockCollision).moonrise$getSingleAABBRepresentation();
+                        final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape) blockCollision).moonrise$getSingleAABBRepresentation();
                         if (singleAABB != null) {
                             if (!ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersect(singleAABB, shiftedAABB)) {
                                 continue;
@@ -713,6 +703,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
         return java.util.Optional.ofNullable(selected);
     }
+
     // Paper end - optimise collisions
     // Paper start - optimise random ticking
     @Override
@@ -720,7 +711,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     /**
      * @reason Make getChunk and getUncachedNoiseBiome virtual calls instead of interface calls
-     *         by implementing the superclass method in this class.
+     * by implementing the superclass method in this class.
      * @author Spottedleaf
      */
     @Override
@@ -733,11 +724,32 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     // Gale start - Airplane - inline level height
     private final int minBuildHeight, levelHeightAccessorMinSection, height, maxBuildHeight, levelHeightAccessorMaxSection;
-    @Override public final int getMaxBuildHeight() { return maxBuildHeight; }
-    @Override public final int getMinSection() { return levelHeightAccessorMinSection; }
-    @Override public final int getMaxSection() { return levelHeightAccessorMaxSection; }
-    @Override public final int getMinBuildHeight() { return minBuildHeight; }
-    @Override public final int getHeight() { return height; }
+
+    @Override
+    public final int getMaxBuildHeight() {
+        return maxBuildHeight;
+    }
+
+    @Override
+    public final int getMinSection() {
+        return levelHeightAccessorMinSection;
+    }
+
+    @Override
+    public final int getMaxSection() {
+        return levelHeightAccessorMaxSection;
+    }
+
+    @Override
+    public final int getMinBuildHeight() {
+        return minBuildHeight;
+    }
+
+    @Override
+    public final int getHeight() {
+        return height;
+    }
+
     // Gale end - Airplane - inline level height
     protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.function.Function<org.spigotmc.SpigotWorldConfig, org.galemc.gale.configuration.GaleWorldConfiguration> galeWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - create paper world config & Anti-Xray // Gale - Gale configuration // Gale - Purpur - remove vanilla profiler
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
@@ -821,10 +833,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             }
 
             @Override
-            public void onBorderSetDamagePerBlock(WorldBorder border, double damagePerBlock) {}
+            public void onBorderSetDamagePerBlock(WorldBorder border, double damagePerBlock) {
+            }
 
             @Override
-            public void onBorderSetDamageSafeZOne(WorldBorder border, double safeZoneRadius) {}
+            public void onBorderSetDamageSafeZOne(WorldBorder border, double safeZoneRadius) {
+            }
         });
         // CraftBukkit end
         this.entityLimiter = new org.spigotmc.TickLimiter(this.spigotConfig.entityMaxTickTime);
@@ -866,7 +880,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             // Leaf end
 
             if (checkCanSee && source instanceof net.minecraft.server.level.ServerPlayer && entity instanceof net.minecraft.server.level.ServerPlayer
-                && !((net.minecraft.server.level.ServerPlayer) source).getBukkitEntity().canSee(((net.minecraft.server.level.ServerPlayer) entity).getBukkitEntity())) {
+                    && !((net.minecraft.server.level.ServerPlayer) source).getBukkitEntity().canSee(((net.minecraft.server.level.ServerPlayer) entity).getBukkitEntity())) {
                 continue;
             }
 
@@ -877,6 +891,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
         return true;
     }
+
     // Paper end - Cancel hit for vanished players
     @Override
     public boolean isClientSide() {
@@ -996,7 +1011,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     @Override
     public final LevelChunk getChunk(int chunkX, int chunkZ) { // Paper - final to help inline
         // Paper start - Perf: make sure loaded chunks get the inlined variant of this function
-        net.minecraft.server.level.ServerChunkCache cps = ((ServerLevel)this).getChunkSource();
+        net.minecraft.server.level.ServerChunkCache cps = ((ServerLevel) this).getChunkSource();
         LevelChunk ifLoaded = cps.getChunkAtIfLoadedImmediately(chunkX, chunkZ);
         if (ifLoaded != null) {
             return ifLoaded;
@@ -1009,7 +1024,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     @Nullable
     @Override
     public final ChunkAccess getChunkIfLoadedImmediately(int x, int z) {
-        return ((ServerLevel)this).chunkSource.getChunkAtIfLoadedImmediately(x, z);
+        return ((ServerLevel) this).chunkSource.getChunkAtIfLoadedImmediately(x, z);
     }
 
     @Override
@@ -1051,6 +1066,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public @Nullable LevelChunk getChunkIfLoaded(int x, int z) { // Overridden in WorldServer for ABI compat which has final
         return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(x, z);
     }
+
     public final @Nullable LevelChunk getChunkIfLoaded(BlockPos blockposition) {
         return ((ServerLevel) this).getChunkSource().getChunkAtIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
     }
@@ -1201,7 +1217,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 iblockdata1.updateIndirectNeighbourShapes(this, blockposition, k, j - 1); // Don't call an event for the old block to limit event spam
                 CraftWorld world = ((ServerLevel) this).getWorld();
                 boolean cancelledUpdates = false; // Paper - Fix block place logic
-                if (world != null && ((ServerLevel)this).hasPhysicsEvent) { // Paper - BlockPhysicsEvent
+                if (world != null && ((ServerLevel) this).hasPhysicsEvent) { // Paper - BlockPhysicsEvent
                     BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftBlockData.fromData(iblockdata));
                     this.getCraftServer().getPluginManager().callEvent(event);
 
@@ -1209,8 +1225,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 }
                 // CraftBukkit end
                 if (!cancelledUpdates) { // Paper - Fix block place logic
-                iblockdata.updateNeighbourShapes(this, blockposition, k, j - 1);
-                iblockdata.updateIndirectNeighbourShapes(this, blockposition, k, j - 1);
+                    iblockdata.updateNeighbourShapes(this, blockposition, k, j - 1);
+                    iblockdata.updateIndirectNeighbourShapes(this, blockposition, k, j - 1);
                 } // Paper - Fix block place logic
             }
 
@@ -1223,7 +1239,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
     // CraftBukkit end
 
-    public void onBlockStateChange(BlockPos pos, BlockState oldBlock, BlockState newBlock) {}
+    public void onBlockStateChange(BlockPos pos, BlockState oldBlock, BlockState newBlock) {
+    }
 
     @Override
     public boolean removeBlock(BlockPos pos, boolean move) {
@@ -1279,7 +1296,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         }
     }
 
-    public void addDestroyBlockEffect(BlockPos pos, BlockState state) {}
+    public void addDestroyBlockEffect(BlockPos pos, BlockState state) {
+    }
 
     public boolean setBlockAndUpdate(BlockPos pos, BlockState state) {
         return this.setBlock(pos, state, 3);
@@ -1287,15 +1305,20 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     public abstract void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags);
 
-    public void setBlocksDirty(BlockPos pos, BlockState old, BlockState updated) {}
+    public void setBlocksDirty(BlockPos pos, BlockState old, BlockState updated) {
+    }
 
-    public void updateNeighborsAt(BlockPos pos, Block sourceBlock) {}
+    public void updateNeighborsAt(BlockPos pos, Block sourceBlock) {
+    }
 
-    public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block sourceBlock, Direction direction) {}
+    public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block sourceBlock, Direction direction) {
+    }
 
-    public void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {}
+    public void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {
+    }
 
-    public void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {}
+    public void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
+    }
 
     @Override
     public void neighborShapeChanged(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
@@ -1407,18 +1430,24 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         this.playLocalSound((double) pos.getX() + 0.5D, (double) pos.getY() + 0.5D, (double) pos.getZ() + 0.5D, sound, category, volume, pitch, useDistance);
     }
 
-    public void playLocalSound(Entity entity, SoundEvent sound, SoundSource category, float volume, float pitch) {}
+    public void playLocalSound(Entity entity, SoundEvent sound, SoundSource category, float volume, float pitch) {
+    }
 
-    public void playLocalSound(double x, double y, double z, SoundEvent sound, SoundSource category, float volume, float pitch, boolean useDistance) {}
+    public void playLocalSound(double x, double y, double z, SoundEvent sound, SoundSource category, float volume, float pitch, boolean useDistance) {
+    }
 
     @Override
-    public void addParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
+    public void addParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
+    }
 
-    public void addParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
+    public void addParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
+    }
 
-    public void addAlwaysVisibleParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
+    public void addAlwaysVisibleParticle(ParticleOptions parameters, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
+    }
 
-    public void addAlwaysVisibleParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {}
+    public void addAlwaysVisibleParticle(ParticleOptions parameters, boolean alwaysSpawn, double x, double y, double z, double velocityX, double velocityY, double velocityZ) {
+    }
 
     public float getSunAngle(float tickDelta) {
         float f1 = this.getTimeOfDay(tickDelta);
@@ -1460,7 +1489,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                 tickingblockentity.tick();
                 // Paper start - rewrite chunk system
                 if ((++tickedEntities & 7) == 0) {
-                    ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)(Level)(Object)this).moonrise$midTickTasks();
+                    ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) (Level) (Object) this).moonrise$midTickTasks();
                 }
                 // Paper end - rewrite chunk system
             }
@@ -1475,7 +1504,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         try {
             tickConsumer.accept(entity);
         } catch (Throwable throwable) {
-            if (throwable instanceof ThreadDeath) throw throwable; // Paper // Gale - Airplane - remove lambda from ticking guard - diff on change ServerLevel#tick
+            if (throwable instanceof ThreadDeath)
+                throw throwable; // Paper // Gale - Airplane - remove lambda from ticking guard - diff on change ServerLevel#tick
             // Paper start - Prevent block entity and entity crashes
             final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level().getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
             MinecraftServer.LOGGER.error(msg, throwable);
@@ -1485,17 +1515,19 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         }
         this.moonrise$midTickTasks(); // Paper - rewrite chunk system // Gale - Airplane - remove lambda from ticking guard - diff on change ServerLevel#tick
     }
+
     // Paper start - Option to prevent armor stands from doing entity lookups
     @Override
     public boolean noCollision(@Nullable Entity entity, AABB box) {
-        if (entity instanceof net.minecraft.world.entity.decoration.ArmorStand && !entity.level().paperConfig().entities.armorStands.doCollisionEntityLookups) return false;
+        if (entity instanceof net.minecraft.world.entity.decoration.ArmorStand && !entity.level().paperConfig().entities.armorStands.doCollisionEntityLookups)
+            return false;
         // Paper start - optimise collisions
         final int flags = entity == null ? (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER | ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY) : ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_ONLY;
-        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder((Level)(Object)this, entity, box, null, null, flags, null)) {
+        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder((Level) (Object) this, entity, box, null, null, flags, null)) {
             return false;
         }
 
-        return !ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions((Level)(Object)this, entity, box, null, flags, null);
+        return !ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions((Level) (Object) this, entity, box, null, flags, null);
         // Paper end - optimise collisions
     }
     // Paper end - Option to prevent armor stands from doing entity lookups
@@ -1517,12 +1549,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     public Explosion explode(@Nullable Entity entity, double x, double y, double z, float power, boolean createFire, Level.ExplosionInteraction explosionSourceType) {
-    // Paper start - Allow explosions to damage source
+        // Paper start - Allow explosions to damage source
         return this.explode(entity, x, y, z, power, createFire, explosionSourceType, null);
     }
+
     public Explosion explode(@Nullable Entity entity, double x, double y, double z, float power, boolean createFire, Level.ExplosionInteraction explosionSourceType, @Nullable Consumer<Explosion> configurator) {
         return this.explode(entity, Explosion.getDefaultDamageSource(this, entity), (ExplosionDamageCalculator) null, x, y, z, power, createFire, explosionSourceType, ParticleTypes.EXPLOSION, ParticleTypes.EXPLOSION_EMITTER, SoundEvents.GENERIC_EXPLODE, configurator);
-    // Paper end - Allow explosions to damage source
+        // Paper end - Allow explosions to damage source
     }
 
     public Explosion explode(@Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, Vec3 pos, float power, boolean createFire, Level.ExplosionInteraction explosionSourceType) {
@@ -1534,21 +1567,22 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     public Explosion explode(@Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, double x, double y, double z, float power, boolean createFire, Level.ExplosionInteraction explosionSourceType, ParticleOptions particle, ParticleOptions emitterParticle, Holder<SoundEvent> soundEvent) {
-    // Paper start - Allow explosions to damage source
+        // Paper start - Allow explosions to damage source
         return this.explode(entity, damageSource, behavior, x, y, z, power, createFire, explosionSourceType, particle, emitterParticle, soundEvent, null);
     }
 
     public Explosion explode(@Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, double x, double y, double z, float power, boolean createFire, Level.ExplosionInteraction explosionSourceType, ParticleOptions particle, ParticleOptions emitterParticle, Holder<SoundEvent> soundEvent, @Nullable Consumer<Explosion> configurator) {
         return this.explode(entity, damageSource, behavior, x, y, z, power, createFire, explosionSourceType, true, particle, emitterParticle, soundEvent, configurator);
-    // Paper end - Allow explosions to damage source
+        // Paper end - Allow explosions to damage source
     }
 
     public Explosion explode(@Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, double x, double y, double z, float power, boolean createFire, Level.ExplosionInteraction explosionSourceType, boolean particles, ParticleOptions particle, ParticleOptions emitterParticle, Holder<SoundEvent> soundEvent) {
-    // Paper start - Allow explosions to damage source
+        // Paper start - Allow explosions to damage source
         return this.explode(entity, damageSource, behavior, x, y, z, power, createFire, explosionSourceType, particle, emitterParticle, soundEvent, null);
     }
+
     public Explosion explode(@Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, double x, double y, double z, float power, boolean createFire, Level.ExplosionInteraction explosionSourceType, boolean particles, ParticleOptions particle, ParticleOptions emitterParticle, Holder<SoundEvent> soundEvent, @Nullable Consumer<Explosion> configurator) {
-    // Paper end - Allow explosions to damage source
+        // Paper end - Allow explosions to damage source
         Explosion.BlockInteraction explosion_effect;
 
         switch (explosionSourceType.ordinal()) {
@@ -1684,6 +1718,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     }
 
+    @Override
     public void close() throws IOException {
         this.getChunkSource().close();
     }
@@ -1699,7 +1734,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         // Paper start - rewrite chunk system
         final List<Entity> ret = new java.util.ArrayList<>();
 
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(except, box, ret, predicate);
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities(except, box, ret, predicate);
 
         return ret;
         // Paper end - rewrite chunk system
@@ -1707,7 +1742,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public <T extends Entity> List<T> getEntities(EntityTypeTest<Entity, T> filter, AABB box, Predicate<? super T> predicate) {
-        List<T> list = Lists.newArrayList();
+        List<T> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         this.getEntities(filter, box, predicate, list);
         return list;
@@ -1723,20 +1758,20 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
                                                final List<? super T> into, final int maxCount) {
         if (entityTypeTest instanceof net.minecraft.world.entity.EntityType<T> byType) {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate, maxCount);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate, maxCount);
                 return;
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities(byType, boundingBox, into, predicate);
                 return;
             }
         }
 
         if (entityTypeTest == null) {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)predicate, maxCount);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities((Entity) null, boundingBox, (List) into, (Predicate) predicate, maxCount);
                 return;
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)predicate);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities((Entity) null, boundingBox, (List) into, (Predicate) predicate);
                 return;
             }
         }
@@ -1761,25 +1796,25 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
         if (base == null || base == Entity.class) {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)modifiedPredicate, maxCount);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities((Entity) null, boundingBox, (List) into, (Predicate) modifiedPredicate, maxCount);
                 return;
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities((Entity)null, boundingBox, (List)into, (Predicate)modifiedPredicate);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities((Entity) null, boundingBox, (List) into, (Predicate) modifiedPredicate);
                 return;
             }
         } else {
             if (maxCount != Integer.MAX_VALUE) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List)into, (Predicate)modifiedPredicate, maxCount);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List) into, (Predicate) modifiedPredicate, maxCount);
                 return;
             } else {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this).moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List)into, (Predicate)modifiedPredicate);
+                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel) this).moonrise$getEntityLookup().getEntities(base, null, boundingBox, (List) into, (Predicate) modifiedPredicate);
                 return;
             }
         }
     }
 
     public org.bukkit.entity.Entity[] getChunkEntities(int chunkX, int chunkZ) {
-        ca.spottedleaf.moonrise.patches.chunk_system.level.entity.ChunkEntitySlices slices = ((ServerLevel)this).moonrise$getEntityLookup().getChunk(chunkX, chunkZ);
+        ca.spottedleaf.moonrise.patches.chunk_system.level.entity.ChunkEntitySlices slices = ((ServerLevel) this).moonrise$getEntityLookup().getChunk(chunkX, chunkZ);
         if (slices == null) {
             return me.titaniumtown.ArrayConstants.emptyBukkitEntityArray; // Gale - JettPack - reduce array allocations
         }
@@ -1802,7 +1837,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return 63;
     }
 
-    public void disconnect() {}
+    public void disconnect() {
+    }
 
     public long getGameTime() {
         return this.levelData.getGameTime();
@@ -1816,9 +1852,11 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return true;
     }
 
-    public void broadcastEntityEvent(Entity entity, byte status) {}
+    public void broadcastEntityEvent(Entity entity, byte status) {
+    }
 
-    public void broadcastDamageEvent(Entity entity, DamageSource damageSource) {}
+    public void broadcastDamageEvent(Entity entity, DamageSource damageSource) {
+    }
 
     public void blockEvent(BlockPos pos, Block block, int type, int data) {
         this.getBlockState(pos).triggerEvent(this, pos, type, data);
@@ -1886,7 +1924,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     public abstract MapId getFreeMapId();
 
-    public void globalLevelEvent(int eventId, BlockPos pos, int data) {}
+    public void globalLevelEvent(int eventId, BlockPos pos, int data) {
+    }
 
     public CrashReportCategory fillReportDetails(CrashReport report) {
         CrashReportCategory crashreportsystemdetails = report.addCategory("Affected level", 1);
@@ -1915,7 +1954,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     public abstract void destroyBlockProgress(int entityId, BlockPos pos, int progress);
 
-    public void createFireworks(double x, double y, double z, double velocityX, double velocityY, double velocityZ, List<FireworkExplosion> explosions) {}
+    public void createFireworks(double x, double y, double z, double velocityX, double velocityY, double velocityZ, List<FireworkExplosion> explosions) {
+    }
 
     public abstract Scoreboard getScoreboard();
 
@@ -1961,7 +2001,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return this.skyDarken;
     }
 
-    public void setSkyFlashTime(int lightningTicksLeft) {}
+    public void setSkyFlashTime(int lightningTicksLeft) {
+    }
 
     @Override
     public WorldBorder getWorldBorder() {
@@ -2064,6 +2105,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             return this.id;
         }
     }
+
     // Paper start - respect global sound events gamerule
     public List<net.minecraft.server.level.ServerPlayer> getPlayersForGlobalSoundGamerule() {
         return this.getGameRules().getBoolean(GameRules.RULE_GLOBAL_SOUND_EVENTS) ? ((ServerLevel) this).getServer().getPlayerList().players : ((ServerLevel) this).players();
@@ -2073,6 +2115,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         final double range = rangeFunction.apply(this.spigotConfig);
         return range <= 0 ? 64.0 * 64.0 : range * range; // 64 is taken from default in ServerLevel#levelEvent
     }
+
     // Paper end - respect global sound events gamerule
     // Paper start - notify observers even if grow failed
     public void checkCapturedTreeStateForObserverNotify(final BlockPos pos, final CraftBlockState craftBlockState) {
@@ -2083,6 +2126,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             this.notifyAndUpdatePhysics(craftBlockState.getPosition(), null, craftBlockState.getHandle(), craftBlockState.getHandle(), craftBlockState.getHandle(), craftBlockState.getFlag(), 512);
         }
     }
+
     // Paper end - notify observers even if grow failed
     // Paper start - optimize redstone (Alternate Current)
     public alternate.current.wire.WireHandler getWireHandler() {
@@ -2093,6 +2137,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         // an instance of Level to ServerLevel.
         return null;
     }
+
     // Paper end - optimize redstone (Alternate Current)
     // Purpur start
     public boolean isNether() {
diff --git a/src/main/java/net/minecraft/world/level/block/LiquidBlock.java b/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
index 1851035b9fdcc076442d0699567a3b020e6425d6..d1b08694df6e39d9aef79013d7a885b029e8ac1d 100644
--- a/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/LiquidBlock.java
@@ -1,16 +1,11 @@
 package net.minecraft.world.level.block;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import java.util.Collections;
-import java.util.List;
-import java.util.Optional;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -36,6 +31,11 @@ import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+
 public class LiquidBlock extends Block implements BucketPickup {
 
     private static final Codec<FlowingFluid> FLOWING_FLUID = BuiltInRegistries.FLUID.byNameCodec().comapFlatMap((fluidtype) -> {
@@ -72,7 +72,7 @@ public class LiquidBlock extends Block implements BucketPickup {
     protected LiquidBlock(FlowingFluid fluid, BlockBehaviour.Properties settings) {
         super(settings);
         this.fluid = fluid;
-        this.stateCache = Lists.newArrayList();
+        this.stateCache = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.stateCache.add(fluid.getSource(false));
 
         for (int i = 1; i < 8; ++i) {
@@ -147,16 +147,17 @@ public class LiquidBlock extends Block implements BucketPickup {
     public int getFlowSpeed(Level world, BlockPos blockposition) {
         if (net.minecraft.core.registries.BuiltInRegistries.FLUID.wrapAsHolder(this.fluid).is(FluidTags.WATER)) {
             if (
-                isLava(world, blockposition.north(1)) ||
-                isLava(world, blockposition.south(1)) ||
-                isLava(world, blockposition.west(1)) ||
-                isLava(world, blockposition.east(1))
+                    isLava(world, blockposition.north(1)) ||
+                            isLava(world, blockposition.south(1)) ||
+                            isLava(world, blockposition.west(1)) ||
+                            isLava(world, blockposition.east(1))
             ) {
                 return world.paperConfig().environment.waterOverLavaFlowSpeed;
             }
         }
         return this.fluid.getTickDelay(world);
     }
+
     private static boolean isLava(Level world, BlockPos blockPos) {
         final FluidState fluidState = world.getFluidIfLoaded(blockPos);
         return fluidState != null && fluidState.is(FluidTags.LAVA);
diff --git a/src/main/java/net/minecraft/world/level/block/RailState.java b/src/main/java/net/minecraft/world/level/block/RailState.java
index aa7ebaccad8dc555d9e1dee300e75fcd968a3608..84464a4c575560aec817bca5762451fe7cdeba78 100644
--- a/src/main/java/net/minecraft/world/level/block/RailState.java
+++ b/src/main/java/net/minecraft/world/level/block/RailState.java
@@ -1,21 +1,21 @@
 package net.minecraft.world.level.block;
 
-import com.google.common.collect.Lists;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.RailShape;
 
+import javax.annotation.Nullable;
+import java.util.List;
+
 public class RailState {
     private final Level level;
     private final BlockPos pos;
     private final BaseRailBlock block;
     private BlockState state;
     private final boolean isStraight;
-    private final List<BlockPos> connections = Lists.newArrayList();
+    private final List<BlockPos> connections = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     // Paper start - Fix some rails connecting improperly
     public boolean isValid() {
@@ -27,7 +27,7 @@ public class RailState {
         this.level = world;
         this.pos = pos;
         this.state = state;
-        this.block = (BaseRailBlock)state.getBlock();
+        this.block = (BaseRailBlock) state.getBlock();
         RailShape railShape = state.getValue(this.block.getShapeProperty());
         this.isStraight = this.block.isStraight();
         this.updateConnections(railShape);
diff --git a/src/main/java/net/minecraft/world/level/block/SculkSpreader.java b/src/main/java/net/minecraft/world/level/block/SculkSpreader.java
index 427e9bcb1fa9436543d7ff974eb8642ccce4a6a3..faf4aea2ca0cb4a46f3941f4e36cb175db85b49d 100644
--- a/src/main/java/net/minecraft/world/level/block/SculkSpreader.java
+++ b/src/main/java/net/minecraft/world/level/block/SculkSpreader.java
@@ -60,7 +60,7 @@ public class SculkSpreader {
     private final int noGrowthRadius;
     private final int chargeDecayRate;
     private final int additionalDecayRate;
-    private List<SculkSpreader.ChargeCursor> cursors = new ArrayList();
+    private List<SculkSpreader.ChargeCursor> cursors = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private static final Logger LOGGER = LogUtils.getLogger();
     public Level level; // CraftBukkit
 
@@ -172,7 +172,7 @@ public class SculkSpreader {
 
     public void updateCursors(LevelAccessor world, BlockPos pos, RandomSource random, boolean shouldConvertToBlock) {
         if (!this.cursors.isEmpty()) {
-            List<SculkSpreader.ChargeCursor> list = new ArrayList();
+            List<SculkSpreader.ChargeCursor> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             Map<BlockPos, SculkSpreader.ChargeCursor> map = new HashMap();
             Object2IntMap<BlockPos> object2intmap = new Object2IntOpenHashMap();
             Iterator iterator = this.cursors.iterator();
diff --git a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index cce1606a27ed3ac381b53e406caeb5a02c4b8965..1b95ec78a961445aa268e135fe187cc71d0b8c00 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -1,22 +1,12 @@
 package net.minecraft.world.level.block.entity;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderLookup;
-import net.minecraft.core.NonNullList;
-import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.*;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.resources.ResourceLocation;
@@ -35,18 +25,13 @@ import net.minecraft.world.inventory.StackedContentsCompatible;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
-import net.minecraft.world.item.crafting.AbstractCookingRecipe;
-import net.minecraft.world.item.crafting.RecipeHolder;
-import net.minecraft.world.item.crafting.RecipeManager;
-import net.minecraft.world.item.crafting.RecipeType;
-import net.minecraft.world.item.crafting.SingleRecipeInput;
+import net.minecraft.world.item.crafting.*;
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.AbstractFurnaceBlock;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.Vec3;
-// CraftBukkit start
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
@@ -59,6 +44,11 @@ import org.bukkit.event.inventory.FurnaceExtractEvent;
 import org.bukkit.event.inventory.FurnaceSmeltEvent;
 import org.bukkit.event.inventory.FurnaceStartSmeltEvent;
 import org.bukkit.inventory.CookingRecipe;
+
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 // CraftBukkit end
 
 public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntity implements WorldlyContainer, RecipeCraftingHolder, StackedContentsCompatible {
@@ -233,18 +223,22 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
     private int maxStack = MAX_STACK;
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
 
+    @Override
     public List<ItemStack> getContents() {
         return this.items;
     }
 
+    @Override
     public void onOpen(CraftHumanEntity who) {
         this.transaction.add(who);
     }
 
+    @Override
     public void onClose(CraftHumanEntity who) {
         this.transaction.remove(who);
     }
 
+    @Override
     public List<HumanEntity> getViewers() {
         return this.transaction;
     }
@@ -254,6 +248,7 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         return this.maxStack;
     }
 
+    @Override
     public void setMaxStackSize(int size) {
         this.maxStack = size;
     }
@@ -314,7 +309,7 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
             // Paper start - Validate ResourceLocation
             final ResourceLocation resourceLocation = ResourceLocation.tryParse(s);
             if (resourceLocation != null) {
-            this.recipesUsed.put(resourceLocation, nbttagcompound1.getInt(s));
+                this.recipesUsed.put(resourceLocation, nbttagcompound1.getInt(s));
             }
             // Paper end - Validate ResourceLocation
         }
@@ -537,7 +532,7 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         // Paper start - cook speed multiplier API
         /* Scale the recipe's cooking time to the current cookSpeedMultiplier */
         int cookTime = world != null ? furnace.quickCheck.getRecipeFor(singlerecipeinput, world).map(holder -> holder.value().getCookingTime()).orElse(200) : (net.minecraft.server.MinecraftServer.getServer().getRecipeManager().getRecipeFor(recipeType, singlerecipeinput, world /* passing a null level here is safe. world is only used for map extending recipes which won't happen here */).map(holder -> holder.value().getCookingTime()).orElse(200));
-        return (int) Math.ceil (cookTime / cookSpeedMultiplier);
+        return (int) Math.ceil(cookTime / cookSpeedMultiplier);
         // Paper end - cook speed multiplier API
     }
 
@@ -620,7 +615,8 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
     }
 
     @Override
-    public void awardUsedRecipes(net.minecraft.world.entity.player.Player player, List<ItemStack> ingredients) {}
+    public void awardUsedRecipes(net.minecraft.world.entity.player.Player player, List<ItemStack> ingredients) {
+    }
 
     public void awardUsedRecipesAndPopExperience(ServerPlayer entityplayer, ItemStack itemstack, int amount) { // CraftBukkit
         List<RecipeHolder<?>> list = this.getRecipesToAwardAndPopExperience(entityplayer.serverLevel(), entityplayer.position(), this.worldPosition, entityplayer, itemstack, amount); // CraftBukkit
@@ -646,14 +642,15 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
 
     public List<RecipeHolder<?>> getRecipesToAwardAndPopExperience(ServerLevel worldserver, Vec3 vec3d, BlockPos blockposition, ServerPlayer entityplayer, ItemStack itemstack, int amount) {
         // CraftBukkit end
-        List<RecipeHolder<?>> list = Lists.newArrayList();
+        List<RecipeHolder<?>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         ObjectIterator objectiterator = this.recipesUsed.object2IntEntrySet().iterator();
 
         while (objectiterator.hasNext()) {
             Entry<ResourceLocation> entry = (Entry) objectiterator.next();
 
             worldserver.getRecipeManager().byKey((ResourceLocation) entry.getKey()).ifPresent((recipeholder) -> {
-                if (!(recipeholder.value() instanceof AbstractCookingRecipe)) return; // Paper - don't process non-cooking recipes
+                if (!(recipeholder.value() instanceof AbstractCookingRecipe))
+                    return; // Paper - don't process non-cooking recipes
                 list.add(recipeholder);
                 AbstractFurnaceBlockEntity.createExperience(worldserver, vec3d, entry.getIntValue(), ((AbstractCookingRecipe) recipeholder.value()).getExperience(), blockposition, entityplayer, itemstack, amount); // CraftBukkit
             });
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
index f4f11292d6d00f4a7c65e3e2a157bba595f70889..c7c0d8725cbf64d0515d4f71ea03cfc918b46b09 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
@@ -30,7 +30,7 @@ import org.bukkit.entity.HumanEntity;
 public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
 
     // CraftBukkit start - add fields and methods
-    public List<HumanEntity> transaction = new ArrayList<>();
+    public List<HumanEntity> transaction = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private int maxStack = MAX_STACK;
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BeaconBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
index df02a78855f1d0c32d1f744c20803fc97a8085c0..03c659af07569ed3e75e2e10722b3dc208cd8d4a 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
@@ -2,14 +2,6 @@ package net.minecraft.world.level.block.entity;
 
 import com.destroystokyo.paper.event.block.BeaconEffectEvent;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -46,10 +38,13 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.phys.AABB;
-// CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.potion.CraftPotionUtil;
 import org.bukkit.potion.PotionEffect;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.stream.Collectors;
 // CraftBukkit end
 
 public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Nameable {
@@ -65,8 +60,8 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
     private static final Component DEFAULT_NAME = Component.translatable("container.beacon");
     private static final String TAG_PRIMARY = "primary_effect";
     private static final String TAG_SECONDARY = "secondary_effect";
-    List<BeaconBlockEntity.BeaconBeamSection> beamSections = Lists.newArrayList();
-    private List<BeaconBlockEntity.BeaconBeamSection> checkingBeamSections = Lists.newArrayList();
+    List<BeaconBlockEntity.BeaconBeamSection> beamSections = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private List<BeaconBlockEntity.BeaconBeamSection> checkingBeamSections = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     public int levels;
     private int lastCheckY;
     @Nullable
@@ -77,6 +72,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
     public Component name;
     public LockCode lockKey;
     private final ContainerData dataAccess;
+
     // CraftBukkit start - add fields and methods
     public PotionEffect getPrimaryEffect() {
         return (this.primaryPower != null) ? CraftPotionUtil.toBukkit(new MobEffectInstance(this.primaryPower, BeaconBlockEntity.getLevel(this.levels), BeaconBlockEntity.getAmplification(this.levels, this.primaryPower, this.secondaryPower), true, true)) : null;
@@ -85,6 +81,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
     public PotionEffect getSecondaryEffect() {
         return (BeaconBlockEntity.hasSecondaryEffect(this.levels, this.primaryPower, this.secondaryPower)) ? CraftPotionUtil.toBukkit(new MobEffectInstance(this.secondaryPower, BeaconBlockEntity.getLevel(this.levels), BeaconBlockEntity.getAmplification(this.levels, this.primaryPower, this.secondaryPower), true, true)) : null;
     }
+
     // CraftBukkit end
     // Paper start - Custom beacon ranges
     private final String PAPER_RANGE_TAG = "Paper.Range";
@@ -95,10 +92,14 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
             // Purpur Start
             if (this.level != null) {
                 switch (this.levels) {
-                    case 1: return this.level.purpurConfig.beaconLevelOne;
-                    case 2: return this.level.purpurConfig.beaconLevelTwo;
-                    case 3: return this.level.purpurConfig.beaconLevelThree;
-                    case 4: return this.level.purpurConfig.beaconLevelFour;
+                    case 1:
+                        return this.level.purpurConfig.beaconLevelOne;
+                    case 2:
+                        return this.level.purpurConfig.beaconLevelTwo;
+                    case 3:
+                        return this.level.purpurConfig.beaconLevelThree;
+                    case 4:
+                        return this.level.purpurConfig.beaconLevelFour;
                 }
             }
             // Purpur End
@@ -182,7 +183,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
 
         if (blockEntity.lastCheckY < j) {
             blockposition1 = pos;
-            blockEntity.checkingBeamSections = Lists.newArrayList();
+            blockEntity.checkingBeamSections = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             blockEntity.lastCheckY = pos.getY() - 1;
         } else {
             blockposition1 = new BlockPos(i, blockEntity.lastCheckY + 1, k);
@@ -311,7 +312,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
         // Paper end - beacon activation/deactivation events
         // Paper start - fix MC-153086
         if (this.levels > 0 && !this.beamSections.isEmpty()) {
-        BeaconBlockEntity.playSound(this.level, this.worldPosition, SoundEvents.BEACON_DEACTIVATE);
+            BeaconBlockEntity.playSound(this.level, this.worldPosition, SoundEvents.BEACON_DEACTIVATE);
         }
         // Paper end
         super.setRemoved();
@@ -341,6 +342,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
         // Paper start - Custom beacon ranges
         return BeaconBlockEntity.getHumansInRange(world, blockposition, i, null);
     }
+
     public static List getHumansInRange(Level world, BlockPos blockposition, int i, @Nullable BeaconBlockEntity blockEntity) {
         // Paper end - Custom beacon ranges
         {
@@ -400,9 +402,10 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
     }
 
     private static void applyEffects(Level world, BlockPos pos, int beaconLevel, @Nullable Holder<MobEffect> primaryEffect, @Nullable Holder<MobEffect> secondaryEffect) {
-    // Paper start - Custom beacon ranges
+        // Paper start - Custom beacon ranges
         BeaconBlockEntity.applyEffects(world, pos, beaconLevel, primaryEffect, secondaryEffect, null);
     }
+
     private static void applyEffects(Level world, BlockPos pos, int beaconLevel, @Nullable Holder<MobEffect> primaryEffect, @Nullable Holder<MobEffect> secondaryEffect, @Nullable BeaconBlockEntity blockEntity) {
         // Paper end - Custom beacon ranges
         if (!world.isClientSide && primaryEffect != null) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
index a9cff34c85e1907bcbca2b051289781484580a15..0d57cca736bdea0e0912b3713ee2f8ed05560257 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
@@ -1,15 +1,9 @@
 package net.minecraft.world.level.block.entity;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import io.netty.buffer.ByteBuf;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -40,10 +34,14 @@ import net.minecraft.world.level.block.CampfireBlock;
 import net.minecraft.world.level.block.FireBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
+import org.bukkit.event.entity.EntityRemoveEvent;
 import org.slf4j.Logger;
 
-// CraftBukkit start
-import org.bukkit.event.entity.EntityRemoveEvent;
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
 // CraftBukkit end
 
 public class BeehiveBlockEntity extends BlockEntity {
@@ -56,7 +54,7 @@ public class BeehiveBlockEntity extends BlockEntity {
     private static final int MIN_TICKS_BEFORE_REENTERING_HIVE = 400;
     private static final int MIN_OCCUPATION_TICKS_NECTAR = 2400;
     public static final int MIN_OCCUPATION_TICKS_NECTARLESS = 600;
-    private List<BeehiveBlockEntity.BeeData> stored = Lists.newArrayList();
+    private List<BeehiveBlockEntity.BeeData> stored = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     @Nullable
     public BlockPos savedFlowerPos;
     public int maxBees = org.purpurmc.purpur.PurpurConfig.beeInsideBeeHive; // CraftBukkit - allow setting max amount of bees a hive can hold // Purpur
@@ -133,7 +131,7 @@ public class BeehiveBlockEntity extends BlockEntity {
     }
 
     public List<Entity> releaseBees(BlockState iblockdata, BeehiveBlockEntity.BeeReleaseStatus tileentitybeehive_releasestatus, boolean force) {
-        List<Entity> list = Lists.newArrayList();
+        List<Entity> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         this.stored.removeIf((tileentitybeehive_hivebee) -> {
             return BeehiveBlockEntity.releaseOccupant(this.level, this.worldPosition, iblockdata, tileentitybeehive_hivebee.toOccupant(), list, tileentitybeehive_releasestatus, this.savedFlowerPos, force);
@@ -148,7 +146,7 @@ public class BeehiveBlockEntity extends BlockEntity {
 
     // Purpur start
     public List<Entity> releaseBee(BlockState iblockdata, BeehiveBlockEntity.BeeData data, BeehiveBlockEntity.BeeReleaseStatus tileentitybeehive_releasestatus, boolean force) {
-        List<Entity> list = Lists.newArrayList();
+        List<Entity> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         BeehiveBlockEntity.releaseOccupant(this.level, this.worldPosition, iblockdata, data.occupant, list, tileentitybeehive_releasestatus, this.savedFlowerPos, force);
 
@@ -177,6 +175,7 @@ public class BeehiveBlockEntity extends BlockEntity {
     public void clearBees() {
         this.stored.clear();
     }
+
     // Paper end - Add EntityBlockStorage clearEntities
     public static int getHoneyLevel(BlockState state) {
         return (Integer) state.getValue(BeehiveBlock.HONEY_LEVEL);
@@ -258,7 +257,8 @@ public class BeehiveBlockEntity extends BlockEntity {
 
                         entity.moveTo(d1, d2, d3, entity.getYRot(), entity.getXRot());
                     }
-                    if (!world.addFreshEntity(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BEEHIVE)) return false; // CraftBukkit - SpawnReason, moved from below
+                    if (!world.addFreshEntity(entity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BEEHIVE))
+                        return false; // CraftBukkit - SpawnReason, moved from below
                     // CraftBukkit end
                     if (entity instanceof Bee) {
                         Bee entitybee = (Bee) entity;
@@ -364,7 +364,7 @@ public class BeehiveBlockEntity extends BlockEntity {
     @Override
     protected void loadAdditional(CompoundTag nbt, HolderLookup.Provider registryLookup) {
         super.loadAdditional(nbt, registryLookup);
-        this.stored = Lists.newArrayList(); // CraftBukkit - SPIGOT-7790: create new copy (may be modified in physics event triggered by honey change)
+        this.stored = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // CraftBukkit - SPIGOT-7790: create new copy (may be modified in physics event triggered by honey change)
         if (nbt.contains("bees")) {
             BeehiveBlockEntity.Occupant.LIST_CODEC.parse(NbtOps.INSTANCE, nbt.get("bees")).resultOrPartial((s) -> {
                 BeehiveBlockEntity.LOGGER.error("Failed to parse bees: '{}'", s);
@@ -395,7 +395,7 @@ public class BeehiveBlockEntity extends BlockEntity {
     @Override
     protected void applyImplicitComponents(BlockEntity.DataComponentInput components) {
         super.applyImplicitComponents(components);
-        this.stored = Lists.newArrayList(); // CraftBukkit - SPIGOT-7790: create new copy (may be modified in physics event triggered by honey change)
+        this.stored = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // CraftBukkit - SPIGOT-7790: create new copy (may be modified in physics event triggered by honey change)
         List<BeehiveBlockEntity.Occupant> list = (List) components.getOrDefault(DataComponents.BEES, List.of());
 
         list.forEach(this::storeBee);
@@ -421,7 +421,8 @@ public class BeehiveBlockEntity extends BlockEntity {
 
         HONEY_DELIVERED, BEE_RELEASED, EMERGENCY;
 
-        private BeeReleaseStatus() {}
+        private BeeReleaseStatus() {
+        }
     }
 
     public static record Occupant(CustomData entityData, int ticksInHive, int minTicksInHive) {
@@ -480,15 +481,15 @@ public class BeehiveBlockEntity extends BlockEntity {
 
         private static void setBeeReleaseData(int ticksInHive, Bee beeEntity) {
             if (!beeEntity.ageLocked) { // Paper - Honor ageLock
-            int j = beeEntity.getAge();
+                int j = beeEntity.getAge();
 
-            if (j < 0) {
-                beeEntity.setAge(Math.min(0, j + ticksInHive));
-            } else if (j > 0) {
-                beeEntity.setAge(Math.max(0, j - ticksInHive));
-            }
+                if (j < 0) {
+                    beeEntity.setAge(Math.min(0, j + ticksInHive));
+                } else if (j > 0) {
+                    beeEntity.setAge(Math.max(0, j - ticksInHive));
+                }
 
-            beeEntity.setInLoveTime(Math.max(0, beeEntity.getInLoveTime() - ticksInHive));
+                beeEntity.setInLoveTime(Math.max(0, beeEntity.getInLoveTime() - ticksInHive));
             } // Paper - Honor ageLock
         }
     }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
index ff6fea842ca80c2ba51693fe62e5b74f9affdc19..3a940a8577cebe9d90659b0972bbfb268be3eb3c 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
@@ -1,10 +1,5 @@
 package net.minecraft.world.level.block.entity;
 
-import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
-import java.util.UUID;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.HolderLookup;
 import net.minecraft.core.particles.ParticleTypes;
@@ -28,6 +23,11 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+import java.util.UUID;
+
 public class ConduitBlockEntity extends BlockEntity {
 
     private static final int BLOCK_REFRESH_RATE = 2;
@@ -41,7 +41,7 @@ public class ConduitBlockEntity extends BlockEntity {
     private float activeRotation;
     private boolean isActive;
     private boolean isHunting;
-    public final List<BlockPos> effectBlocks = Lists.newArrayList();
+    public final List<BlockPos> effectBlocks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     @Nullable
     public LivingEntity destroyTarget;
     @Nullable
diff --git a/src/main/java/net/minecraft/world/level/block/entity/DecoratedPotBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/DecoratedPotBlockEntity.java
index 629795f2d4278902ba7375465b41f551d15697a8..a362be17ff374d75b4fdfb497144120b98c225b8 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/DecoratedPotBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/DecoratedPotBlockEntity.java
@@ -1,7 +1,5 @@
 package net.minecraft.world.level.block.entity;
 
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.HolderLookup;
@@ -19,21 +17,20 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.storage.loot.LootTable;
 import net.minecraft.world.ticks.ContainerSingleItem;
-
-// CraftBukkit start
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.util.CraftLocation;
 import org.bukkit.entity.HumanEntity;
+
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.List;
 // CraftBukkit end
 
 public class DecoratedPotBlockEntity extends BlockEntity implements RandomizableContainer, ContainerSingleItem.BlockContainerSingleItem {
 
     // CraftBukkit start - add fields and methods
-    public List<HumanEntity> transaction = new ArrayList<>();
+    public List<HumanEntity> transaction = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private int maxStack = MAX_STACK;
 
     @Override
@@ -58,7 +55,7 @@ public class DecoratedPotBlockEntity extends BlockEntity implements Randomizable
 
     @Override
     public int getMaxStackSize() {
-       return this.maxStack;
+        return this.maxStack;
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/entity/LecternBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/LecternBlockEntity.java
index a42a23585e5c4808bc1d2354888121cc2aa0f7a8..773e2edd0a56da2aad49a2edf9d133c73ac6cc28 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/LecternBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/LecternBlockEntity.java
@@ -1,6 +1,5 @@
 package net.minecraft.world.level.block.entity;
 
-import javax.annotation.Nullable;
 import net.minecraft.commands.CommandSource;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.core.BlockPos;
@@ -28,16 +27,16 @@ import net.minecraft.world.level.block.LecternBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
-// CraftBukkit start
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
 import org.bukkit.Location;
 import org.bukkit.block.Lectern;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.util.CraftLocation;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.inventory.InventoryHolder;
+
+import javax.annotation.Nullable;
+import java.util.Arrays;
+import java.util.List;
 // CraftBukkit end
 
 public class LecternBlockEntity extends BlockEntity implements Clearable, MenuProvider, CommandSource { // CraftBukkit - ICommandListener
@@ -48,9 +47,10 @@ public class LecternBlockEntity extends BlockEntity implements Clearable, MenuPr
     public static final int NUM_SLOTS = 1;
     // CraftBukkit start - add fields and methods
     public final Container bookAccess = new LecternInventory();
+
     public class LecternInventory implements Container {
 
-        public List<HumanEntity> transaction = new ArrayList<>();
+        public List<HumanEntity> transaction = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         private int maxStack = 1;
 
         @Override
@@ -170,8 +170,10 @@ public class LecternBlockEntity extends BlockEntity implements Clearable, MenuPr
         }
 
         @Override
-        public void clearContent() {}
-    };
+        public void clearContent() {
+        }
+    }
+
     private final ContainerData dataAccess = new ContainerData() {
         @Override
         public int get(int index) {
@@ -231,7 +233,8 @@ public class LecternBlockEntity extends BlockEntity implements Clearable, MenuPr
         if (j != this.page) {
             this.page = j;
             this.setChanged();
-            if (this.level != null) LecternBlock.signalPageChange(this.getLevel(), this.getBlockPos(), this.getBlockState()); // CraftBukkit
+            if (this.level != null)
+                LecternBlock.signalPageChange(this.getLevel(), this.getBlockPos(), this.getBlockState()); // CraftBukkit
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index e0c62227b279a5fe0f3868fbf9ce8c78c515a09c..9cfabb7f4531c370130be5e1fe712088d92494ce 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -1,14 +1,9 @@
 package net.minecraft.world.level.block.piston;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -23,11 +18,7 @@ import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.SignalGetter;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.DirectionalBlock;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
@@ -41,12 +32,15 @@ import net.minecraft.world.level.pathfinder.PathComputationType;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
-// CraftBukkit start
-import com.google.common.collect.ImmutableList;
-import java.util.AbstractList;
 import org.bukkit.craftbukkit.block.CraftBlock;
-import org.bukkit.event.block.BlockPistonRetractEvent;
 import org.bukkit.event.block.BlockPistonExtendEvent;
+import org.bukkit.event.block.BlockPistonRetractEvent;
+
+import java.util.AbstractList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
 // CraftBukkit end
 
 public class PistonBaseBlock extends DirectionalBlock {
@@ -363,7 +357,7 @@ public class PistonBaseBlock extends DirectionalBlock {
         } else {
             Map<BlockPos, BlockState> map = Maps.newHashMap();
             List<BlockPos> list = pistonextendschecker.getToPush();
-            List<BlockState> list1 = Lists.newArrayList();
+            List<BlockState> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             Iterator iterator = list.iterator();
 
             while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java b/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java
index bea05cb928d540a2f19b51bb7352d032b2dd69cd..07898ec114f1d228273f876bae758cf19b21d80a 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonStructureResolver.java
@@ -1,7 +1,5 @@
 package net.minecraft.world.level.block.piston;
 
-import com.google.common.collect.Lists;
-import java.util.List;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.world.level.Level;
@@ -9,6 +7,8 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.PushReaction;
 
+import java.util.List;
+
 public class PistonStructureResolver {
     public static final int MAX_PUSH_DEPTH = 12;
     private final Level level;
@@ -16,8 +16,8 @@ public class PistonStructureResolver {
     private final boolean extending;
     private final BlockPos startPos;
     private final Direction pushDirection;
-    private final List<BlockPos> toPush = Lists.newArrayList();
-    private final List<BlockPos> toDestroy = Lists.newArrayList();
+    private final List<BlockPos> toPush = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private final List<BlockPos> toDestroy = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final Direction pistonDirection;
 
     public PistonStructureResolver(Level world, BlockPos pos, Direction dir, boolean retracted) {
@@ -65,8 +65,8 @@ public class PistonStructureResolver {
 
     private static boolean canStickToEachOther(BlockState state, BlockState adjacentState) {
         return (!state.is(Blocks.HONEY_BLOCK) || !adjacentState.is(Blocks.SLIME_BLOCK))
-            && (!state.is(Blocks.SLIME_BLOCK) || !adjacentState.is(Blocks.HONEY_BLOCK))
-            && (isSticky(state) || isSticky(adjacentState));
+                && (!state.is(Blocks.SLIME_BLOCK) || !adjacentState.is(Blocks.HONEY_BLOCK))
+                && (isSticky(state) || isSticky(adjacentState));
     }
 
     private boolean addBlockLine(BlockPos pos, Direction dir) {
@@ -89,9 +89,9 @@ public class PistonStructureResolver {
                     BlockState blockState2 = blockState;
                     blockState = this.level.getBlockState(blockPos);
                     if (blockState.isAir()
-                        || !canStickToEachOther(blockState2, blockState)
-                        || !PistonBaseBlock.isPushable(blockState, this.level, blockPos, this.pushDirection, false, this.pushDirection.getOpposite())
-                        || blockPos.equals(this.pistonPos)) {
+                            || !canStickToEachOther(blockState2, blockState)
+                            || !PistonBaseBlock.isPushable(blockState, this.level, blockPos, this.pushDirection, false, this.pushDirection.getOpposite())
+                            || blockPos.equals(this.pistonPos)) {
                         break;
                     }
 
@@ -131,7 +131,7 @@ public class PistonStructureResolver {
                     }
 
                     if (!PistonBaseBlock.isPushable(blockState, this.level, blockPos2, this.pushDirection, true, this.pushDirection)
-                        || blockPos2.equals(this.pistonPos)) {
+                            || blockPos2.equals(this.pistonPos)) {
                         return false;
                     }
 
@@ -153,9 +153,9 @@ public class PistonStructureResolver {
     }
 
     private void reorderListAtCollision(int from, int to) {
-        List<BlockPos> list = Lists.newArrayList();
-        List<BlockPos> list2 = Lists.newArrayList();
-        List<BlockPos> list3 = Lists.newArrayList();
+        List<BlockPos> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        List<BlockPos> list2 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        List<BlockPos> list3 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         list.addAll(this.toPush.subList(0, to));
         list2.addAll(this.toPush.subList(this.toPush.size() - from, this.toPush.size()));
         list3.addAll(this.toPush.subList(to, this.toPush.size() - from));
diff --git a/src/main/java/net/minecraft/world/level/border/WorldBorder.java b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
index 04e62c54f224f7949fde9ceded208e700db55aa1..d7552d677ed012528987163ebf0c587e0b389707 100644
--- a/src/main/java/net/minecraft/world/level/border/WorldBorder.java
+++ b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
@@ -2,8 +2,6 @@ package net.minecraft.world.level.border;
 
 import com.google.common.collect.Lists;
 import com.mojang.serialization.DynamicLike;
-import java.util.Iterator;
-import java.util.List;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
@@ -16,11 +14,14 @@ import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class WorldBorder {
 
     public static final double MAX_SIZE = 5.9999968E7D;
     public static final double MAX_CENTER_COORDINATE = 2.9999984E7D;
-    private final List<BorderChangeListener> listeners = Lists.newArrayList();
+    private final List<BorderChangeListener> listeners = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private double damagePerBlock = 0.2D;
     private double damageSafeZone = 5.0D;
     private int warningTime = 15;
@@ -32,7 +33,8 @@ public class WorldBorder {
     public static final WorldBorder.Settings DEFAULT_SETTINGS = new WorldBorder.Settings(0.0D, 0.0D, 0.2D, 5.0D, 5, 15, 5.9999968E7D, 0L, 0.0D);
     public net.minecraft.server.level.ServerLevel world; // CraftBukkit
 
-    public WorldBorder() {}
+    public WorldBorder() {
+    }
 
     public boolean isWithinBounds(BlockPos pos) {
         return this.isWithinBounds((double) pos.getX(), (double) pos.getZ());
@@ -48,10 +50,12 @@ public class WorldBorder {
 
     // Paper start - Bound treasure maps to world border
     private final BlockPos.MutableBlockPos mutPos = new BlockPos.MutableBlockPos();
+
     public boolean isBlockInBounds(int chunkX, int chunkZ) {
         this.mutPos.set(chunkX, 64, chunkZ);
         return this.isWithinBounds(this.mutPos);
     }
+
     public boolean isChunkInBounds(int chunkX, int chunkZ) {
         this.mutPos.set(((chunkX << 4) + 15), 64, (chunkZ << 4) + 15);
         return this.isWithinBounds(this.mutPos);
@@ -515,14 +519,17 @@ public class WorldBorder {
         }
 
         @Override
-        public void onCenterChange() {}
+        public void onCenterChange() {
+        }
 
         @Override
-        public void onAbsoluteMaxSizeChange() {}
+        public void onAbsoluteMaxSizeChange() {
+        }
 
         @Override
         public WorldBorder.BorderExtent update() {
-            if (world != null && this.getLerpRemainingTime() <= 0L) new io.papermc.paper.event.world.border.WorldBorderBoundsChangeFinishEvent(world.getWorld(), world.getWorld().getWorldBorder(), this.from, this.to, this.lerpDuration).callEvent(); // Paper - Add worldborder events
+            if (world != null && this.getLerpRemainingTime() <= 0L)
+                new io.papermc.paper.event.world.border.WorldBorderBoundsChangeFinishEvent(world.getWorld(), world.getWorld().getWorldBorder(), this.from, this.to, this.lerpDuration).callEvent(); // Paper - Add worldborder events
             return (WorldBorder.BorderExtent) (this.getLerpRemainingTime() <= 0L ? WorldBorder.this.new StaticBorderExtent(this.to) : this);
         }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
index 49229294eb3b562fba3b48baf5fca9c18ad2be8f..879e3b65f750dcf12bb932e0a102c3e704e9e0b6 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGeneratorStructureState.java
@@ -6,23 +6,8 @@ import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.TimeUnit;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.Util;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderLookup;
-import net.minecraft.core.HolderSet;
-import net.minecraft.core.SectionPos;
+import net.minecraft.core.*;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.biome.Biome;
@@ -31,12 +16,17 @@ import net.minecraft.world.level.levelgen.RandomState;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructureSet;
 import net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStructurePlacement;
+import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement;
 import net.minecraft.world.level.levelgen.structure.placement.StructurePlacement;
 import org.slf4j.Logger;
-
-// Spigot start
-import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement;
 import org.spigotmc.SpigotWorldConfig;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 // Spigot end
 
 public class ChunkGeneratorStructureState {
@@ -67,9 +57,11 @@ public class ChunkGeneratorStructureState {
 
         return new ChunkGeneratorStructureState(randomstate, worldchunkmanager, i, i, ChunkGeneratorStructureState.injectSpigot(list, conf), conf); // Spigot
     }
+
     // Paper start - Add missing structure set seed configs; horrible hack because spigot creates a ton of direct Holders which lose track of the identifying key
     public static final class KeyedRandomSpreadStructurePlacement extends RandomSpreadStructurePlacement {
         public final net.minecraft.resources.ResourceKey<StructureSet> key;
+
         public KeyedRandomSpreadStructurePlacement(net.minecraft.resources.ResourceKey<StructureSet> key, net.minecraft.core.Vec3i locateOffset, FrequencyReductionMethod frequencyReductionMethod, float frequency, int salt, java.util.Optional<StructurePlacement.ExclusionZone> exclusionZone, int spacing, int separation, net.minecraft.world.level.levelgen.structure.placement.RandomSpreadType spreadType) {
             super(locateOffset, frequencyReductionMethod, frequency, salt, exclusionZone, spacing, separation, spreadType);
             this.key = key;
@@ -142,7 +134,7 @@ public class ChunkGeneratorStructureState {
                     // Paper end - Add missing structure set seed configs
                 }
 
-            // Paper start - Add missing structure set seed configs
+                // Paper start - Add missing structure set seed configs
                 structureset = new StructureSet(structureset.structures(), new KeyedRandomSpreadStructurePlacement(holder.unwrapKey().orElseThrow(), randomConfig.locateOffset, randomConfig.frequencyReductionMethod, randomConfig.frequency, seed, randomConfig.exclusionZone, randomConfig.spacing(), randomConfig.separation(), randomConfig.spreadType()));
                 newHolder = Holder.direct(structureset); // I really wish we didn't have to do this here
             } else {
@@ -195,7 +187,7 @@ public class ChunkGeneratorStructureState {
                 Objects.requireNonNull(set);
                 if (stream.anyMatch(set::contains)) {
                     ((List) this.placementsForStructure.computeIfAbsent(structure, (structure1) -> {
-                        return new ArrayList();
+                        return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                     })).add(structureset.placement());
                     flag = true;
                 }
@@ -230,13 +222,13 @@ public class ChunkGeneratorStructureState {
                     : RandomSource.create();
 
             if (!org.dreeam.leaf.config.modules.misc.SecureSeed.enabled) {
-            // Paper start - Add missing structure set seed configs
-            if (this.conf.strongholdSeed != null && structureSetEntry.is(net.minecraft.world.level.levelgen.structure.BuiltinStructureSets.STRONGHOLDS)) {
-                randomsource.setSeed(this.conf.strongholdSeed);
-            } else {
-            // Paper end - Add missing structure set seed configs
-            randomsource.setSeed(this.concentricRingsSeed);
-            } // Paper - Add missing structure set seed configs
+                // Paper start - Add missing structure set seed configs
+                if (this.conf.strongholdSeed != null && structureSetEntry.is(net.minecraft.world.level.levelgen.structure.BuiltinStructureSets.STRONGHOLDS)) {
+                    randomsource.setSeed(this.conf.strongholdSeed);
+                } else {
+                    // Paper end - Add missing structure set seed configs
+                    randomsource.setSeed(this.concentricRingsSeed);
+                } // Paper - Add missing structure set seed configs
             }// Leaf end - Matter - Feature Secure Seed
             double d0 = randomsource.nextDouble() * Math.PI * 2.0D;
             int l = 0;
diff --git a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
index 02b97e22fd9a122cc8f1628ef3205e87145a89fb..33ec2b168e54e690117439a88409866814e8ce88 100644
--- a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
@@ -1,13 +1,14 @@
 package net.minecraft.world.level.chunk;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Predicate;
 import net.minecraft.core.IdMap;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.VarInt;
 import net.minecraft.util.CrudeIncrementalIntIdentityHashBiMap;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+
 public class HashMapPalette<T> implements Palette<T>, ca.spottedleaf.moonrise.patches.fast_palette.FastPalette<T> { // Moonrise - optimise palette reads
     private final IdMap<T> registry;
     private final CrudeIncrementalIntIdentityHashBiMap<T> values;
@@ -113,7 +114,7 @@ public class HashMapPalette<T> implements Palette<T>, ca.spottedleaf.moonrise.pa
     }
 
     public List<T> getEntries() {
-        ArrayList<T> arrayList = new ArrayList<>();
+        ArrayList<T> arrayList = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.values.iterator().forEachRemaining(arrayList::add);
         return arrayList;
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index 082eae7032d5a8055a0f67b8a5583bbbf6fa9916..38e1fac4ffeb39bb2dd159cef355fe586e096eb9 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -1,17 +1,7 @@
 package net.minecraft.world.level.chunk;
 
-import com.google.common.collect.Lists;
 import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderLookup;
-import net.minecraft.core.Registry;
-import net.minecraft.core.SectionPos;
+import net.minecraft.core.*;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
@@ -38,11 +28,17 @@ import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.ProtoChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
 
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Map;
+
 public class ProtoChunk extends ChunkAccess {
     @Nullable
     private volatile LevelLightEngine lightEngine;
     private volatile ChunkStatus status = ChunkStatus.EMPTY;
-    private final List<CompoundTag> entities = Lists.newArrayList();
+    private final List<CompoundTag> entities = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final Map<GenerationStep.Carving, CarvingMask> carvingMasks = new Object2ObjectArrayMap<>();
     @Nullable
     private BelowZeroRetrogen belowZeroRetrogen;
@@ -54,14 +50,14 @@ public class ProtoChunk extends ChunkAccess {
     }
 
     public ProtoChunk(
-        ChunkPos pos,
-        UpgradeData upgradeData,
-        @Nullable LevelChunkSection[] sections,
-        ProtoChunkTicks<Block> blockTickScheduler,
-        ProtoChunkTicks<Fluid> fluidTickScheduler,
-        LevelHeightAccessor world,
-        Registry<Biome> biomeRegistry,
-        @Nullable BlendingData blendingData
+            ChunkPos pos,
+            UpgradeData upgradeData,
+            @Nullable LevelChunkSection[] sections,
+            ProtoChunkTicks<Block> blockTickScheduler,
+            ProtoChunkTicks<Fluid> fluidTickScheduler,
+            LevelHeightAccessor world,
+            Registry<Biome> biomeRegistry,
+            @Nullable BlendingData blendingData
     ) {
         super(pos, upgradeData, world, biomeRegistry, 0L, sections, blendingData);
         this.blockTicks = blockTickScheduler;
@@ -100,6 +96,8 @@ public class ProtoChunk extends ChunkAccess {
         // Paper start
         return getBlockState(pos.getX(), pos.getY(), pos.getZ());
     }
+
+    @Override
     public BlockState getBlockState(final int x, final int y, final int z) {
         if (this.isOutsideBuildHeight(y)) {
             return Blocks.VOID_AIR.defaultBlockState();
@@ -118,8 +116,8 @@ public class ProtoChunk extends ChunkAccess {
         } else {
             LevelChunkSection levelChunkSection = this.getSection(this.getSectionIndex(i));
             return levelChunkSection.hasOnlyAir()
-                ? Fluids.EMPTY.defaultFluidState()
-                : levelChunkSection.getFluidState(pos.getX() & 15, i & 15, pos.getZ() & 15);
+                    ? Fluids.EMPTY.defaultFluidState()
+                    : levelChunkSection.getFluidState(pos.getX() & 15, i & 15, pos.getZ() & 15);
         }
     }
 
@@ -257,7 +255,7 @@ public class ProtoChunk extends ChunkAccess {
         int l = i & 15;
         int m = j & 15;
         int n = k & 15;
-        return (short)(l | m << 4 | n << 8);
+        return (short) (l | m << 4 | n << 8);
     }
 
     public static BlockPos unpackOffsetCoordinates(short sectionRel, int sectionY, ChunkPos chunkPos) {
@@ -337,6 +335,6 @@ public class ProtoChunk extends ChunkAccess {
 
     @Override
     public LevelHeightAccessor getHeightAccessorForGeneration() {
-        return (LevelHeightAccessor)(this.isUpgrading() ? BelowZeroRetrogen.UPGRADE_HEIGHT_ACCESSOR : this);
+        return (LevelHeightAccessor) (this.isUpgrading() ? BelowZeroRetrogen.UPGRADE_HEIGHT_ACCESSOR : this);
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/UpgradeData.java b/src/main/java/net/minecraft/world/level/chunk/UpgradeData.java
index cd9b65f278a750a0177a3252271015d43172b2e9..9ead81145377e27bf19da9bf7fad8100b86b8f39 100644
--- a/src/main/java/net/minecraft/world/level/chunk/UpgradeData.java
+++ b/src/main/java/net/minecraft/world/level/chunk/UpgradeData.java
@@ -5,13 +5,6 @@ import com.google.common.collect.Sets;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
-import java.util.EnumSet;
-import java.util.IdentityHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.function.Function;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Direction8;
@@ -21,16 +14,8 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.resources.ResourceLocation;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.EmptyBlockGetter;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.LevelAccessor;
-import net.minecraft.world.level.LevelHeightAccessor;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.ChestBlock;
-import net.minecraft.world.level.block.HorizontalDirectionalBlock;
-import net.minecraft.world.level.block.StemBlock;
+import net.minecraft.world.level.*;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.ChestBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
@@ -41,14 +26,17 @@ import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.ticks.SavedTick;
 import org.slf4j.Logger;
 
+import java.util.*;
+import java.util.function.Function;
+
 public class UpgradeData {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final UpgradeData EMPTY = new UpgradeData(EmptyBlockGetter.INSTANCE);
     private static final String TAG_INDICES = "Indices";
     private static final Direction8[] DIRECTIONS = Direction8.values();
     private final EnumSet<Direction8> sides = EnumSet.noneOf(Direction8.class);
-    private final List<SavedTick<Block>> neighborBlockTicks = Lists.newArrayList();
-    private final List<SavedTick<Fluid>> neighborFluidTicks = Lists.newArrayList();
+    private final List<SavedTick<Block>> neighborBlockTicks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private final List<SavedTick<Fluid>> neighborFluidTicks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final int[][] index;
     static final Map<Block, UpgradeData.BlockFixer> MAP = new IdentityHashMap<>();
     static final Set<UpgradeData.BlockFixer> CHUNKY_FIXERS = Sets.newHashSet();
@@ -79,23 +67,23 @@ public class UpgradeData {
         }
 
         loadTicks(
-            nbt,
-            "neighbor_block_ticks",
-            id -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(id)).or(() -> Optional.of(Blocks.AIR)),
-            this.neighborBlockTicks
+                nbt,
+                "neighbor_block_ticks",
+                id -> BuiltInRegistries.BLOCK.getOptional(ResourceLocation.tryParse(id)).or(() -> Optional.of(Blocks.AIR)),
+                this.neighborBlockTicks
         );
         loadTicks(
-            nbt,
-            "neighbor_fluid_ticks",
-            id -> BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(id)).or(() -> Optional.of(Fluids.EMPTY)),
-            this.neighborFluidTicks
+                nbt,
+                "neighbor_fluid_ticks",
+                id -> BuiltInRegistries.FLUID.getOptional(ResourceLocation.tryParse(id)).or(() -> Optional.of(Fluids.EMPTY)),
+                this.neighborFluidTicks
         );
     }
 
     private static <T> void loadTicks(CompoundTag nbt, String key, Function<String, Optional<T>> nameToType, List<SavedTick<T>> ticks) {
         if (nbt.contains(key, 9)) {
             for (Tag tag : nbt.getList(key, 10)) {
-                SavedTick.loadTick((CompoundTag)tag, nameToType).ifPresent(ticks::add);
+                SavedTick.loadTick((CompoundTag) tag, nameToType).ifPresent(ticks::add);
             }
         }
     }
@@ -103,7 +91,7 @@ public class UpgradeData {
     // Paper start - filter out relocated neighbour ticks
     // The lists are only supposed to contain ticks for the 1 radius neighbours of the chunk
     private static <T> void filterTickList(int chunkX, int chunkZ, List<SavedTick<T>> ticks) {
-        for (java.util.Iterator<SavedTick<T>> iterator = ticks.iterator(); iterator.hasNext();) {
+        for (java.util.Iterator<SavedTick<T>> iterator = ticks.iterator(); iterator.hasNext(); ) {
             SavedTick<T> tick = iterator.next();
             BlockPos tickPos = tick.pos();
             int tickCX = tickPos.getX() >> 4;
@@ -179,7 +167,7 @@ public class UpgradeData {
 
     private static BlockState updateState(BlockState oldState, Direction dir, LevelAccessor world, BlockPos currentPos, BlockPos otherPos) {
         return MAP.getOrDefault(oldState.getBlock(), UpgradeData.BlockFixers.DEFAULT)
-            .updateShape(oldState, dir, world.getBlockState(otherPos), world, currentPos, otherPos);
+                .updateShape(oldState, dir, world.getBlockState(otherPos), world, currentPos, otherPos);
     }
 
     private void upgradeInside(LevelChunk chunk) {
@@ -209,7 +197,7 @@ public class UpgradeData {
                     for (Direction direction : directions) {
                         mutableBlockPos2.setWithOffset(mutableBlockPos, direction);
                         if (SectionPos.blockToSectionCoord(mutableBlockPos.getX()) == chunkPos.x
-                            && SectionPos.blockToSectionCoord(mutableBlockPos.getZ()) == chunkPos.z) {
+                                && SectionPos.blockToSectionCoord(mutableBlockPos.getZ()) == chunkPos.z) {
                             blockState2 = updateState(blockState2, direction, levelAccessor, mutableBlockPos, mutableBlockPos2);
                         }
                     }
@@ -259,7 +247,7 @@ public class UpgradeData {
             j |= 1 << direction8.ordinal();
         }
 
-        compoundTag.putByte("Sides", (byte)j);
+        compoundTag.putByte("Sides", (byte) j);
         if (!this.neighborBlockTicks.isEmpty()) {
             ListTag listTag = new ListTag();
             this.neighborBlockTicks.forEach(blockTick -> listTag.add(blockTick.save(block -> BuiltInRegistries.BLOCK.getKey(block).toString())));
@@ -284,60 +272,60 @@ public class UpgradeData {
 
     static enum BlockFixers implements UpgradeData.BlockFixer {
         BLACKLIST(
-            Blocks.OBSERVER,
-            Blocks.NETHER_PORTAL,
-            Blocks.WHITE_CONCRETE_POWDER,
-            Blocks.ORANGE_CONCRETE_POWDER,
-            Blocks.MAGENTA_CONCRETE_POWDER,
-            Blocks.LIGHT_BLUE_CONCRETE_POWDER,
-            Blocks.YELLOW_CONCRETE_POWDER,
-            Blocks.LIME_CONCRETE_POWDER,
-            Blocks.PINK_CONCRETE_POWDER,
-            Blocks.GRAY_CONCRETE_POWDER,
-            Blocks.LIGHT_GRAY_CONCRETE_POWDER,
-            Blocks.CYAN_CONCRETE_POWDER,
-            Blocks.PURPLE_CONCRETE_POWDER,
-            Blocks.BLUE_CONCRETE_POWDER,
-            Blocks.BROWN_CONCRETE_POWDER,
-            Blocks.GREEN_CONCRETE_POWDER,
-            Blocks.RED_CONCRETE_POWDER,
-            Blocks.BLACK_CONCRETE_POWDER,
-            Blocks.ANVIL,
-            Blocks.CHIPPED_ANVIL,
-            Blocks.DAMAGED_ANVIL,
-            Blocks.DRAGON_EGG,
-            Blocks.GRAVEL,
-            Blocks.SAND,
-            Blocks.RED_SAND,
-            Blocks.OAK_SIGN,
-            Blocks.SPRUCE_SIGN,
-            Blocks.BIRCH_SIGN,
-            Blocks.ACACIA_SIGN,
-            Blocks.CHERRY_SIGN,
-            Blocks.JUNGLE_SIGN,
-            Blocks.DARK_OAK_SIGN,
-            Blocks.OAK_WALL_SIGN,
-            Blocks.SPRUCE_WALL_SIGN,
-            Blocks.BIRCH_WALL_SIGN,
-            Blocks.ACACIA_WALL_SIGN,
-            Blocks.JUNGLE_WALL_SIGN,
-            Blocks.DARK_OAK_WALL_SIGN,
-            Blocks.OAK_HANGING_SIGN,
-            Blocks.SPRUCE_HANGING_SIGN,
-            Blocks.BIRCH_HANGING_SIGN,
-            Blocks.ACACIA_HANGING_SIGN,
-            Blocks.JUNGLE_HANGING_SIGN,
-            Blocks.DARK_OAK_HANGING_SIGN,
-            Blocks.OAK_WALL_HANGING_SIGN,
-            Blocks.SPRUCE_WALL_HANGING_SIGN,
-            Blocks.BIRCH_WALL_HANGING_SIGN,
-            Blocks.ACACIA_WALL_HANGING_SIGN,
-            Blocks.JUNGLE_WALL_HANGING_SIGN,
-            Blocks.DARK_OAK_WALL_HANGING_SIGN
+                Blocks.OBSERVER,
+                Blocks.NETHER_PORTAL,
+                Blocks.WHITE_CONCRETE_POWDER,
+                Blocks.ORANGE_CONCRETE_POWDER,
+                Blocks.MAGENTA_CONCRETE_POWDER,
+                Blocks.LIGHT_BLUE_CONCRETE_POWDER,
+                Blocks.YELLOW_CONCRETE_POWDER,
+                Blocks.LIME_CONCRETE_POWDER,
+                Blocks.PINK_CONCRETE_POWDER,
+                Blocks.GRAY_CONCRETE_POWDER,
+                Blocks.LIGHT_GRAY_CONCRETE_POWDER,
+                Blocks.CYAN_CONCRETE_POWDER,
+                Blocks.PURPLE_CONCRETE_POWDER,
+                Blocks.BLUE_CONCRETE_POWDER,
+                Blocks.BROWN_CONCRETE_POWDER,
+                Blocks.GREEN_CONCRETE_POWDER,
+                Blocks.RED_CONCRETE_POWDER,
+                Blocks.BLACK_CONCRETE_POWDER,
+                Blocks.ANVIL,
+                Blocks.CHIPPED_ANVIL,
+                Blocks.DAMAGED_ANVIL,
+                Blocks.DRAGON_EGG,
+                Blocks.GRAVEL,
+                Blocks.SAND,
+                Blocks.RED_SAND,
+                Blocks.OAK_SIGN,
+                Blocks.SPRUCE_SIGN,
+                Blocks.BIRCH_SIGN,
+                Blocks.ACACIA_SIGN,
+                Blocks.CHERRY_SIGN,
+                Blocks.JUNGLE_SIGN,
+                Blocks.DARK_OAK_SIGN,
+                Blocks.OAK_WALL_SIGN,
+                Blocks.SPRUCE_WALL_SIGN,
+                Blocks.BIRCH_WALL_SIGN,
+                Blocks.ACACIA_WALL_SIGN,
+                Blocks.JUNGLE_WALL_SIGN,
+                Blocks.DARK_OAK_WALL_SIGN,
+                Blocks.OAK_HANGING_SIGN,
+                Blocks.SPRUCE_HANGING_SIGN,
+                Blocks.BIRCH_HANGING_SIGN,
+                Blocks.ACACIA_HANGING_SIGN,
+                Blocks.JUNGLE_HANGING_SIGN,
+                Blocks.DARK_OAK_HANGING_SIGN,
+                Blocks.OAK_WALL_HANGING_SIGN,
+                Blocks.SPRUCE_WALL_HANGING_SIGN,
+                Blocks.BIRCH_WALL_HANGING_SIGN,
+                Blocks.ACACIA_WALL_HANGING_SIGN,
+                Blocks.JUNGLE_WALL_HANGING_SIGN,
+                Blocks.DARK_OAK_WALL_HANGING_SIGN
         ) {
             @Override
             public BlockState updateShape(
-                BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
+                    BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
             ) {
                 return oldState;
             }
@@ -345,7 +333,7 @@ public class UpgradeData {
         DEFAULT {
             @Override
             public BlockState updateShape(
-                BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
+                    BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
             ) {
                 return oldState.updateShape(direction, world.getBlockState(otherPos), world, currentPos, otherPos);
             }
@@ -353,12 +341,12 @@ public class UpgradeData {
         CHEST(Blocks.CHEST, Blocks.TRAPPED_CHEST) {
             @Override
             public BlockState updateShape(
-                BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
+                    BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
             ) {
                 if (otherState.is(oldState.getBlock())
-                    && direction.getAxis().isHorizontal()
-                    && oldState.getValue(ChestBlock.TYPE) == ChestType.SINGLE
-                    && otherState.getValue(ChestBlock.TYPE) == ChestType.SINGLE) {
+                        && direction.getAxis().isHorizontal()
+                        && oldState.getValue(ChestBlock.TYPE) == ChestType.SINGLE
+                        && otherState.getValue(ChestBlock.TYPE) == ChestType.SINGLE) {
                     Direction direction2 = oldState.getValue(ChestBlock.FACING);
                     if (direction.getAxis() != direction2.getAxis() && direction2 == otherState.getValue(ChestBlock.FACING)) {
                         ChestType chestType = direction == direction2.getClockWise() ? ChestType.LEFT : ChestType.RIGHT;
@@ -367,7 +355,7 @@ public class UpgradeData {
                             BlockEntity blockEntity = world.getBlockEntity(currentPos);
                             BlockEntity blockEntity2 = world.getBlockEntity(otherPos);
                             if (blockEntity instanceof ChestBlockEntity && blockEntity2 instanceof ChestBlockEntity) {
-                                ChestBlockEntity.swapContents((ChestBlockEntity)blockEntity, (ChestBlockEntity)blockEntity2);
+                                ChestBlockEntity.swapContents((ChestBlockEntity) blockEntity, (ChestBlockEntity) blockEntity2);
                             }
                         }
 
@@ -379,20 +367,20 @@ public class UpgradeData {
             }
         },
         LEAVES(
-            true,
-            Blocks.ACACIA_LEAVES,
-            Blocks.CHERRY_LEAVES,
-            Blocks.BIRCH_LEAVES,
-            Blocks.DARK_OAK_LEAVES,
-            Blocks.JUNGLE_LEAVES,
-            Blocks.OAK_LEAVES,
-            Blocks.SPRUCE_LEAVES
+                true,
+                Blocks.ACACIA_LEAVES,
+                Blocks.CHERRY_LEAVES,
+                Blocks.BIRCH_LEAVES,
+                Blocks.DARK_OAK_LEAVES,
+                Blocks.JUNGLE_LEAVES,
+                Blocks.OAK_LEAVES,
+                Blocks.SPRUCE_LEAVES
         ) {
             private final ThreadLocal<List<ObjectSet<BlockPos>>> queue = ThreadLocal.withInitial(() -> Lists.newArrayListWithCapacity(7));
 
             @Override
             public BlockState updateShape(
-                BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
+                    BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
             ) {
                 BlockState blockState = oldState.updateShape(direction, world.getBlockState(otherPos), world, currentPos, otherPos);
                 if (oldState != blockState) {
@@ -443,14 +431,14 @@ public class UpgradeData {
         STEM_BLOCK(Blocks.MELON_STEM, Blocks.PUMPKIN_STEM) {
             @Override
             public BlockState updateShape(
-                BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
+                    BlockState oldState, Direction direction, BlockState otherState, LevelAccessor world, BlockPos currentPos, BlockPos otherPos
             ) {
                 if (oldState.getValue(StemBlock.AGE) == 7) {
                     Block block = oldState.is(Blocks.PUMPKIN_STEM) ? Blocks.PUMPKIN : Blocks.MELON;
                     if (otherState.is(block)) {
                         return (oldState.is(Blocks.PUMPKIN_STEM) ? Blocks.ATTACHED_PUMPKIN_STEM : Blocks.ATTACHED_MELON_STEM)
-                            .defaultBlockState()
-                            .setValue(HorizontalDirectionalBlock.FACING, direction);
+                                .defaultBlockState()
+                                .setValue(HorizontalDirectionalBlock.FACING, direction);
                     }
                 }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/status/ChunkPyramid.java b/src/main/java/net/minecraft/world/level/chunk/status/ChunkPyramid.java
index b7bf82f6b6023bd628d3e7ea84d2d6755a0d931a..c9807e9862ababdc4f42a9a5068dd5a11e63b345 100644
--- a/src/main/java/net/minecraft/world/level/chunk/status/ChunkPyramid.java
+++ b/src/main/java/net/minecraft/world/level/chunk/status/ChunkPyramid.java
@@ -64,7 +64,7 @@ public record ChunkPyramid(ImmutableList<ChunkStep> steps) {
     }
 
     public static class Builder {
-        private final List<ChunkStep> steps = new ArrayList<>();
+        private final List<ChunkStep> steps = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         public ChunkPyramid build() {
             return new ChunkPyramid(ImmutableList.copyOf(this.steps));
diff --git a/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java
index 3723c07183e7b894cccf4d01bedf1d0d832c1910..f0cce85cc0faf5a980a2b88a16564677c22f04cd 100644
--- a/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/status/ChunkStatus.java
@@ -1,21 +1,21 @@
 package net.minecraft.world.level.chunk.status;
 
-import com.google.common.collect.Lists;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.Registry;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.level.levelgen.Heightmap;
 import org.jetbrains.annotations.VisibleForTesting;
 
+import javax.annotation.Nullable;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.List;
+
 public class ChunkStatus implements ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkSystemChunkStatus { // Paper - rewrite chunk system
     public static final int MAX_STRUCTURE_DISTANCE = 8;
     private static final EnumSet<Heightmap.Types> WORLDGEN_HEIGHTMAPS = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     public static final EnumSet<Heightmap.Types> FINAL_HEIGHTMAPS = EnumSet.of(
-        Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES
+            Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES
     );
     public static final ChunkStatus EMPTY = register("empty", null, WORLDGEN_HEIGHTMAPS, ChunkType.PROTOCHUNK);
     public static final ChunkStatus STRUCTURE_STARTS = register("structure_starts", EMPTY, WORLDGEN_HEIGHTMAPS, ChunkType.PROTOCHUNK);
@@ -39,7 +39,7 @@ public class ChunkStatus implements ca.spottedleaf.moonrise.patches.chunk_system
     }
 
     public static List<ChunkStatus> getStatusList() {
-        List<ChunkStatus> list = Lists.newArrayList();
+        List<ChunkStatus> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         ChunkStatus chunkStatus;
         for (chunkStatus = FULL; chunkStatus.getParent() != chunkStatus; chunkStatus = chunkStatus.getParent()) {
@@ -95,7 +95,7 @@ public class ChunkStatus implements ca.spottedleaf.moonrise.patches.chunk_system
 
     @Override
     public final boolean moonrise$isEmptyGenStatus() {
-        return (Object)this == ChunkStatus.EMPTY;
+        return (Object) this == ChunkStatus.EMPTY;
     }
 
     @Override
@@ -108,9 +108,9 @@ public class ChunkStatus implements ca.spottedleaf.moonrise.patches.chunk_system
     protected ChunkStatus(@Nullable ChunkStatus previous, EnumSet<Heightmap.Types> heightMapTypes, ChunkType chunkType) {
         this.isParallelCapable = false;
         this.writeRadius = -1;
-        this.nextStatus = (ChunkStatus)(Object)this;
+        this.nextStatus = (ChunkStatus) (Object) this;
         if (previous != null) {
-            previous.nextStatus = (ChunkStatus)(Object)this;
+            previous.nextStatus = (ChunkStatus) (Object) this;
         }
         this.warnedAboutNoImmediateComplete = new java.util.concurrent.atomic.AtomicBoolean();
         this.parent = previous == null ? this : previous;
diff --git a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
index db38112104fe6009b57788b79e0cad4cf180badb..14f465a27d6a9dc42c119a7e1274d60fedb0f01e 100644
--- a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
+++ b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
@@ -599,7 +599,7 @@ public class EndDragonFight {
             }
             // Paper end - Perf: Do crystal-portal proximity check before entity lookup
 
-            List<EndCrystal> list = Lists.newArrayList();
+            List<EndCrystal> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             BlockPos blockposition1 = blockposition.above(1);
             Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
diff --git a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java
index f1f0dbb20d4ee2f3f47e202f2cb3dd4bde9ac0b3..40c9ba4373baebddea82019c90d3175bcb5ad862 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/EuclideanGameEventListenerRegistry.java
@@ -1,21 +1,19 @@
 package net.minecraft.world.level.gameevent;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Optional;
-import java.util.Set;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.phys.Vec3;
 
+import java.util.Iterator;
+import java.util.List;
+import java.util.Optional;
+
 public class EuclideanGameEventListenerRegistry implements GameEventListenerRegistry {
-    private final List<GameEventListener> listeners = Lists.newArrayList();
+    private final List<GameEventListener> listeners = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     //private final Set<GameEventListener> listenersToRemove = Sets.newHashSet(); // Leaf - petal - Not necessary
-    //private final List<GameEventListener> listenersToAdd = Lists.newArrayList(); // Leaf - petal
+    //private final List<GameEventListener> listenersToAdd = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // Leaf - petal
     private boolean processing;
     private final ServerLevel level;
     private final int sectionY;
@@ -104,7 +102,7 @@ public class EuclideanGameEventListenerRegistry implements GameEventListenerRegi
         } else {
             double d = BlockPos.containing(optional.get()).distSqr(BlockPos.containing(listenerPos));
             int i = listener.getListenerRadius() * listener.getListenerRadius();
-            return d > (double)i ? Optional.empty() : optional;
+            return d > (double) i ? Optional.empty() : optional;
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java b/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java
index 75a34d60d6729f3767dc9bef283db6e9e3baf3a7..1d0076b76d4ab9868508f57ccb13df555926d90c 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/GameEventDispatcher.java
@@ -43,7 +43,7 @@ public class GameEventDispatcher {
         int i1 = SectionPos.blockToSectionCoord(blockposition.getX() + i);
         int j1 = SectionPos.blockToSectionCoord(blockposition.getY() + i);
         int k1 = SectionPos.blockToSectionCoord(blockposition.getZ() + i);
-        List<GameEvent.ListenerInfo> list = new ArrayList();
+        List<GameEvent.ListenerInfo> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         GameEventListenerRegistry.ListenerVisitor gameeventlistenerregistry_a = (gameeventlistener, vec3d1) -> {
             if (!gameeventlistener.listensToEvent(event.value(), emitter)) return; // Leaf - petal - If they don't listen, ignore
             if (gameeventlistener.getDeliveryMode() == GameEventListener.DeliveryMode.BY_DISTANCE) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseChunk.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseChunk.java
index 3e8882e4779d6037025e7ee26ebbb46a55a7e52d..1ed2324ee3509767229d901413686d32c48b515e 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseChunk.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseChunk.java
@@ -1,14 +1,9 @@
 package net.minecraft.world.level.levelgen;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import com.google.common.collect.ImmutableList.Builder;
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
 import net.minecraft.core.QuartPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.server.level.ColumnPos;
@@ -21,6 +16,11 @@ import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.levelgen.blending.Blender;
 import net.minecraft.world.level.levelgen.material.MaterialRuleList;
 
+import javax.annotation.Nullable;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
 public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunction.FunctionContext {
     private final NoiseSettings noiseSettings;
     final int cellCountXZ;
@@ -80,31 +80,31 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
     };
 
     public static NoiseChunk forChunk(
-        ChunkAccess chunk,
-        RandomState noiseConfig,
-        DensityFunctions.BeardifierOrMarker beardifying,
-        NoiseGeneratorSettings chunkGeneratorSettings,
-        Aquifer.FluidPicker fluidLevelSampler,
-        Blender blender
+            ChunkAccess chunk,
+            RandomState noiseConfig,
+            DensityFunctions.BeardifierOrMarker beardifying,
+            NoiseGeneratorSettings chunkGeneratorSettings,
+            Aquifer.FluidPicker fluidLevelSampler,
+            Blender blender
     ) {
         NoiseSettings noiseSettings = chunkGeneratorSettings.noiseSettings().clampToHeightAccessor(chunk);
         ChunkPos chunkPos = chunk.getPos();
         int i = 16 / noiseSettings.getCellWidth();
         return new NoiseChunk(
-            i, noiseConfig, chunkPos.getMinBlockX(), chunkPos.getMinBlockZ(), noiseSettings, beardifying, chunkGeneratorSettings, fluidLevelSampler, blender
+                i, noiseConfig, chunkPos.getMinBlockX(), chunkPos.getMinBlockZ(), noiseSettings, beardifying, chunkGeneratorSettings, fluidLevelSampler, blender
         );
     }
 
     public NoiseChunk(
-        int horizontalCellCount,
-        RandomState noiseConfig,
-        int startBlockX,
-        int startBlockZ,
-        NoiseSettings generationShapeConfig,
-        DensityFunctions.BeardifierOrMarker beardifying,
-        NoiseGeneratorSettings chunkGeneratorSettings,
-        Aquifer.FluidPicker fluidLevelSampler,
-        Blender blender
+            int horizontalCellCount,
+            RandomState noiseConfig,
+            int startBlockX,
+            int startBlockZ,
+            NoiseSettings generationShapeConfig,
+            DensityFunctions.BeardifierOrMarker beardifying,
+            NoiseGeneratorSettings chunkGeneratorSettings,
+            Aquifer.FluidPicker fluidLevelSampler,
+            Blender blender
     ) {
         this.noiseSettings = generationShapeConfig;
         this.cellWidth = generationShapeConfig.getCellWidth();
@@ -114,8 +114,8 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
         this.cellNoiseMinY = Mth.floorDiv(generationShapeConfig.minY(), this.cellHeight);
         this.firstCellX = Math.floorDiv(startBlockX, this.cellWidth);
         this.firstCellZ = Math.floorDiv(startBlockZ, this.cellWidth);
-        this.interpolators = Lists.newArrayList();
-        this.cellCaches = Lists.newArrayList();
+        this.interpolators = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        this.cellCaches = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.firstNoiseX = QuartPos.fromBlock(startBlockX);
         this.firstNoiseZ = QuartPos.fromBlock(startBlockZ);
         this.noiseSizeXZ = QuartPos.fromBlock(horizontalCellCount * this.cellWidth);
@@ -145,21 +145,21 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
             int o = SectionPos.blockToSectionCoord(startBlockX);
             int p = SectionPos.blockToSectionCoord(startBlockZ);
             this.aquifer = Aquifer.create(
-                this,
-                new ChunkPos(o, p),
-                noiseRouter2,
-                noiseConfig.aquiferRandom(),
-                generationShapeConfig.minY(),
-                generationShapeConfig.height(),
-                fluidLevelSampler
+                    this,
+                    new ChunkPos(o, p),
+                    noiseRouter2,
+                    noiseConfig.aquiferRandom(),
+                    generationShapeConfig.minY(),
+                    generationShapeConfig.height(),
+                    fluidLevelSampler
             );
         }
 
         Builder<NoiseChunk.BlockStateFiller> builder = ImmutableList.builder();
         DensityFunction densityFunction = DensityFunctions.cacheAllInCell(
-                DensityFunctions.add(noiseRouter2.finalDensity(), DensityFunctions.BeardifierMarker.INSTANCE)
-            )
-            .mapAll(this::wrap);
+                        DensityFunctions.add(noiseRouter2.finalDensity(), DensityFunctions.BeardifierMarker.INSTANCE)
+                )
+                .mapAll(this::wrap);
         builder.add(pos -> this.aquifer.computeSubstance(pos, densityFunction.compute(pos)));
         if (chunkGeneratorSettings.oreVeinsEnabled()) {
             builder.add(OreVeinifier.create(noiseRouter2.veinToggle(), noiseRouter2.veinRidged(), noiseRouter2.veinGap(), noiseConfig.oreRandom()));
@@ -171,13 +171,13 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
 
     protected Climate.Sampler cachedClimateSampler(NoiseRouter noiseRouter, List<Climate.ParameterPoint> spawnTarget) {
         return new Climate.Sampler(
-            noiseRouter.temperature().mapAll(this::wrap),
-            noiseRouter.vegetation().mapAll(this::wrap),
-            noiseRouter.continents().mapAll(this::wrap),
-            noiseRouter.erosion().mapAll(this::wrap),
-            noiseRouter.depth().mapAll(this::wrap),
-            noiseRouter.ridges().mapAll(this::wrap),
-            spawnTarget
+                noiseRouter.temperature().mapAll(this::wrap),
+                noiseRouter.vegetation().mapAll(this::wrap),
+                noiseRouter.continents().mapAll(this::wrap),
+                noiseRouter.erosion().mapAll(this::wrap),
+                noiseRouter.depth().mapAll(this::wrap),
+                noiseRouter.ridges().mapAll(this::wrap),
+                spawnTarget
         );
     }
 
@@ -371,7 +371,7 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
 
     private DensityFunction wrapNew(DensityFunction function) {
         if (function instanceof DensityFunctions.Marker marker) {
-            return (DensityFunction)(switch (marker.type()) {
+            return (DensityFunction) (switch (marker.type()) {
                 case Interpolated -> new NoiseChunk.NoiseInterpolator(marker.wrapped());
                 case FlatCache -> new NoiseChunk.FlatCache(marker.wrapped(), true);
                 case Cache2D -> new NoiseChunk.Cache2D(marker.wrapped());
@@ -538,8 +538,8 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
                 int j = NoiseChunk.this.inCellY;
                 int k = NoiseChunk.this.inCellZ;
                 return i >= 0 && j >= 0 && k >= 0 && i < NoiseChunk.this.cellWidth && j < NoiseChunk.this.cellHeight && k < NoiseChunk.this.cellWidth
-                    ? this.values[((NoiseChunk.this.cellHeight - 1 - j) * NoiseChunk.this.cellWidth + i) * NoiseChunk.this.cellWidth + k]
-                    : this.noiseFiller.compute(pos);
+                        ? this.values[((NoiseChunk.this.cellHeight - 1 - j) * NoiseChunk.this.cellWidth + i) * NoiseChunk.this.cellWidth + k]
+                        : this.noiseFiller.compute(pos);
             }
         }
 
@@ -596,7 +596,7 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
                 if (this.lastArray != null && this.lastArray.length == densities.length) {
                     System.arraycopy(densities, 0, this.lastArray, 0, densities.length);
                 } else {
-                    this.lastArray = (double[])densities.clone();
+                    this.lastArray = (double[]) densities.clone();
                 }
 
                 this.lastArrayCounter = NoiseChunk.this.arrayInterpolationCounter;
@@ -749,10 +749,10 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
                 throw new IllegalStateException("Trying to sample interpolator outside the interpolation loop");
             } else {
                 return NoiseChunk.this.fillingCell
-                    ? Mth.lerp3(
-                        (double)NoiseChunk.this.inCellX / (double)NoiseChunk.this.cellWidth,
-                        (double)NoiseChunk.this.inCellY / (double)NoiseChunk.this.cellHeight,
-                        (double)NoiseChunk.this.inCellZ / (double)NoiseChunk.this.cellWidth,
+                        ? Mth.lerp3(
+                        (double) NoiseChunk.this.inCellX / (double) NoiseChunk.this.cellWidth,
+                        (double) NoiseChunk.this.inCellY / (double) NoiseChunk.this.cellHeight,
+                        (double) NoiseChunk.this.inCellZ / (double) NoiseChunk.this.cellWidth,
                         this.noise000,
                         this.noise100,
                         this.noise010,
@@ -761,8 +761,8 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
                         this.noise101,
                         this.noise011,
                         this.noise111
-                    )
-                    : this.value;
+                )
+                        : this.value;
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java b/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java
index 45f6f74bcae3e3f27809d2ff3973b98edb169f0f..da642aa89b0708483f1492470da970b8225a4060 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java
@@ -340,7 +340,7 @@ public class Blender {
     }
 
     public static Blender.DistanceGetter makeOldChunkDistanceGetter(@Nullable BlendingData data, Map<Direction8, BlendingData> neighborData) {
-        List<Blender.DistanceGetter> list = Lists.newArrayList();
+        List<Blender.DistanceGetter> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         if (data != null) {
             list.add(makeOffsetOldChunkDistanceGetter(null, data));
         }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
index fecbce25736dab20e8459cb3b1c636fa7f7eab6b..c2043874fbd17dcb20154b1290f905713de416c1 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/GeodeFeature.java
@@ -3,8 +3,6 @@ package net.minecraft.world.level.levelgen.feature;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.serialization.Codec;
-import java.util.List;
-import java.util.function.Predicate;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -16,15 +14,14 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.BuddingAmethystBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
-import net.minecraft.world.level.levelgen.GeodeBlockSettings;
-import net.minecraft.world.level.levelgen.GeodeCrackSettings;
-import net.minecraft.world.level.levelgen.GeodeLayerSettings;
-import net.minecraft.world.level.levelgen.LegacyRandomSource;
-import net.minecraft.world.level.levelgen.WorldgenRandom;
+import net.minecraft.world.level.levelgen.*;
 import net.minecraft.world.level.levelgen.feature.configurations.GeodeConfiguration;
 import net.minecraft.world.level.levelgen.synth.NormalNoise;
 import net.minecraft.world.level.material.FluidState;
 
+import java.util.List;
+import java.util.function.Predicate;
+
 public class GeodeFeature extends Feature<GeodeConfiguration> {
     private static final Direction[] DIRECTIONS = Direction.values();
 
@@ -49,7 +46,7 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
         // Leaf end - Matter - Feature Secure Seed
         NormalNoise normalNoise = NormalNoise.create(worldgenRandom, -4, 1.0);
         List<BlockPos> list2 = Lists.newLinkedList();
-        double d = (double)k / (double)geodeConfiguration.outerWallDistance.getMaxValue();
+        double d = (double) k / (double) geodeConfiguration.outerWallDistance.getMaxValue();
         GeodeLayerSettings geodeLayerSettings = geodeConfiguration.geodeLayerSettings;
         GeodeBlockSettings geodeBlockSettings = geodeConfiguration.geodeBlockSettings;
         GeodeCrackSettings geodeCrackSettings = geodeConfiguration.geodeCrackSettings;
@@ -58,7 +55,7 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
         double g = 1.0 / Math.sqrt(geodeLayerSettings.middleLayer + d);
         double h = 1.0 / Math.sqrt(geodeLayerSettings.outerLayer + d);
         double l = 1.0 / Math.sqrt(geodeCrackSettings.baseCrackSize + randomSource.nextDouble() / 2.0 + (k > 3 ? d : 0.0));
-        boolean bl = (double)randomSource.nextFloat() < geodeCrackSettings.generateCrackChance;
+        boolean bl = (double) randomSource.nextFloat() < geodeCrackSettings.generateCrackChance;
         int m = 0;
 
         for (int n = 0; n < k; n++) {
@@ -98,20 +95,20 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
             }
         }
 
-        List<BlockPos> list3 = Lists.newArrayList();
+        List<BlockPos> list3 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Predicate<BlockState> predicate = isReplaceable(geodeConfiguration.geodeBlockSettings.cannotReplace);
 
         for (BlockPos blockPos3 : BlockPos.betweenClosed(blockPos.offset(i, i, i), blockPos.offset(j, j, j))) {
-            double t = normalNoise.getValue((double)blockPos3.getX(), (double)blockPos3.getY(), (double)blockPos3.getZ()) * geodeConfiguration.noiseMultiplier;
+            double t = normalNoise.getValue((double) blockPos3.getX(), (double) blockPos3.getY(), (double) blockPos3.getZ()) * geodeConfiguration.noiseMultiplier;
             double u = 0.0;
             double v = 0.0;
 
             for (Pair<BlockPos, Integer> pair : list) {
-                u += Mth.invSqrt(blockPos3.distSqr(pair.getFirst()) + (double)pair.getSecond().intValue()) + t;
+                u += Mth.invSqrt(blockPos3.distSqr(pair.getFirst()) + (double) pair.getSecond().intValue()) + t;
             }
 
             for (BlockPos blockPos4 : list2) {
-                v += Mth.invSqrt(blockPos3.distSqr(blockPos4) + (double)geodeCrackSettings.crackPointOffset) + t;
+                v += Mth.invSqrt(blockPos3.distSqr(blockPos4) + (double) geodeCrackSettings.crackPointOffset) + t;
             }
 
             if (!(u < h)) {
@@ -128,7 +125,7 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
                 } else if (u >= e) {
                     this.safeSetBlock(worldGenLevel, blockPos3, geodeBlockSettings.fillingProvider.getState(randomSource, blockPos3), predicate);
                 } else if (u >= f) {
-                    boolean bl2 = (double)randomSource.nextFloat() < geodeConfiguration.useAlternateLayer0Chance;
+                    boolean bl2 = (double) randomSource.nextFloat() < geodeConfiguration.useAlternateLayer0Chance;
                     if (bl2) {
                         this.safeSetBlock(worldGenLevel, blockPos3, geodeBlockSettings.alternateInnerLayerProvider.getState(randomSource, blockPos3), predicate);
                     } else {
@@ -136,7 +133,7 @@ public class GeodeFeature extends Feature<GeodeConfiguration> {
                     }
 
                     if ((!geodeConfiguration.placementsRequireLayer0Alternate || bl2)
-                        && (double)randomSource.nextFloat() < geodeConfiguration.usePotentialPlacementsChance) {
+                            && (double) randomSource.nextFloat() < geodeConfiguration.usePotentialPlacementsChance) {
                         list3.add(blockPos3.immutable());
                     }
                 } else if (u >= g) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/SpikeFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/SpikeFeature.java
index 260c3a7dc592fba220ad4a7febb43ee2c9279115..2837ae870cb083e0c6c20da6b2a252cd998b286d 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/SpikeFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/SpikeFeature.java
@@ -190,7 +190,7 @@ public class SpikeFeature extends Feature<SpikeConfiguration> {
         @Override
         public List<SpikeFeature.EndSpike> load(Long long_) {
             IntArrayList intArrayList = Util.toShuffledList(IntStream.range(0, 10), RandomSource.create(long_));
-            List<SpikeFeature.EndSpike> list = Lists.newArrayList();
+            List<SpikeFeature.EndSpike> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             for (int i = 0; i < 10; i++) {
                 int j = Mth.floor(42.0 * Math.cos(2.0 * (-Math.PI + (Math.PI / 10) * (double)i)));
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java b/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java
index ee5b317e87c4d403b6d7f5ab1d493e446f9278f6..1395ddf37fb49309b661baeab2e2c6271a5e851b 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java
@@ -1,11 +1,8 @@
 package net.minecraft.world.level.levelgen.structure;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.DynamicOps;
-import java.util.List;
-import java.util.Locale;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
@@ -26,24 +23,27 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.LiquidSetting
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import org.slf4j.Logger;
 
+import java.util.List;
+import java.util.Locale;
+
 public class PoolElementStructurePiece extends StructurePiece {
     public static final Logger LOGGER = LogUtils.getLogger(); // Gale - EMC - softly log invalid pool element errors - private -> public
     protected final StructurePoolElement element;
     protected BlockPos position;
     private final int groundLevelDelta;
     protected final Rotation rotation;
-    private final List<JigsawJunction> junctions = Lists.newArrayList();
+    private final List<JigsawJunction> junctions = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final StructureTemplateManager structureTemplateManager;
     private final LiquidSettings liquidSettings;
 
     public PoolElementStructurePiece(
-        StructureTemplateManager structureTemplateManager,
-        StructurePoolElement poolElement,
-        BlockPos pos,
-        int groundLevelDelta,
-        Rotation rotation,
-        BoundingBox boundingBox,
-        LiquidSettings liquidSettings
+            StructureTemplateManager structureTemplateManager,
+            StructurePoolElement poolElement,
+            BlockPos pos,
+            int groundLevelDelta,
+            Rotation rotation,
+            BoundingBox boundingBox,
+            LiquidSettings liquidSettings
     ) {
         super(StructurePieceType.JIGSAW, 0, boundingBox);
         this.structureTemplateManager = structureTemplateManager;
@@ -61,8 +61,8 @@ public class PoolElementStructurePiece extends StructurePiece {
         this.groundLevelDelta = nbt.getInt("ground_level_delta");
         DynamicOps<Tag> dynamicOps = context.registryAccess().createSerializationContext(NbtOps.INSTANCE);
         this.element = StructurePoolElement.CODEC
-            .parse(dynamicOps, nbt.getCompound("pool_element"))
-            .getPartialOrThrow(error -> new IllegalStateException("Invalid pool element found: " + error));
+                .parse(dynamicOps, nbt.getCompound("pool_element"))
+                .getPartialOrThrow(error -> new IllegalStateException("Invalid pool element found: " + error));
         this.rotation = Rotation.valueOf(nbt.getString("rotation"));
         this.boundingBox = this.element.getBoundingBox(this.structureTemplateManager, this.position, this.rotation);
         ListTag listTag = nbt.getList("junctions", 10);
@@ -79,9 +79,9 @@ public class PoolElementStructurePiece extends StructurePiece {
         nbt.putInt("ground_level_delta", this.groundLevelDelta);
         DynamicOps<Tag> dynamicOps = context.registryAccess().createSerializationContext(NbtOps.INSTANCE);
         StructurePoolElement.CODEC
-            .encodeStart(dynamicOps, this.element)
-            .resultOrPartial(org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.invalidPoolElementErrorStringConsumer) // Gale - EMC - softly log invalid pool element errors
-            .ifPresent(poolElement -> nbt.put("pool_element", poolElement));
+                .encodeStart(dynamicOps, this.element)
+                .resultOrPartial(org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.invalidPoolElementErrorStringConsumer) // Gale - EMC - softly log invalid pool element errors
+                .ifPresent(poolElement -> nbt.put("pool_element", poolElement));
         nbt.putString("rotation", this.rotation.name());
         ListTag listTag = new ListTag();
 
@@ -97,40 +97,40 @@ public class PoolElementStructurePiece extends StructurePiece {
 
     @Override
     public void postProcess(
-        WorldGenLevel world,
-        StructureManager structureAccessor,
-        ChunkGenerator chunkGenerator,
-        RandomSource random,
-        BoundingBox chunkBox,
-        ChunkPos chunkPos,
-        BlockPos pivot
+            WorldGenLevel world,
+            StructureManager structureAccessor,
+            ChunkGenerator chunkGenerator,
+            RandomSource random,
+            BoundingBox chunkBox,
+            ChunkPos chunkPos,
+            BlockPos pivot
     ) {
         this.place(world, structureAccessor, chunkGenerator, random, chunkBox, pivot, false);
     }
 
     public void place(
-        WorldGenLevel world,
-        StructureManager structureAccessor,
-        ChunkGenerator chunkGenerator,
-        RandomSource random,
-        BoundingBox boundingBox,
-        BlockPos pivot,
-        boolean keepJigsaws
+            WorldGenLevel world,
+            StructureManager structureAccessor,
+            ChunkGenerator chunkGenerator,
+            RandomSource random,
+            BoundingBox boundingBox,
+            BlockPos pivot,
+            boolean keepJigsaws
     ) {
         this.element
-            .place(
-                this.structureTemplateManager,
-                world,
-                structureAccessor,
-                chunkGenerator,
-                this.position,
-                pivot,
-                this.rotation,
-                boundingBox,
-                random,
-                this.liquidSettings,
-                keepJigsaws
-            );
+                .place(
+                        this.structureTemplateManager,
+                        world,
+                        structureAccessor,
+                        chunkGenerator,
+                        this.position,
+                        pivot,
+                        this.rotation,
+                        boundingBox,
+                        random,
+                        this.liquidSettings,
+                        keepJigsaws
+                );
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java b/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
index b9eb60d9b56a1d8e7869fbb5694f7c8a4c1799db..940b2e6e73908a4ffb710f4863fb256a28196cf0 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/pools/JigsawPlacement.java
@@ -1,16 +1,7 @@
 package net.minecraft.world.level.levelgen.structure.pools;
 
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.Holder;
-import net.minecraft.core.Registry;
-import net.minecraft.core.RegistryAccess;
-import net.minecraft.core.Vec3i;
+import net.minecraft.core.*;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.data.worldgen.Pools;
 import net.minecraft.nbt.CompoundTag;
@@ -45,21 +36,25 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 import org.apache.commons.lang3.mutable.MutableObject;
 import org.slf4j.Logger;
 
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+
 public class JigsawPlacement {
     static final Logger LOGGER = LogUtils.getLogger();
 
     public static Optional<Structure.GenerationStub> addPieces(
-        Structure.GenerationContext context,
-        Holder<StructureTemplatePool> structurePool,
-        Optional<ResourceLocation> id,
-        int size,
-        BlockPos pos,
-        boolean useExpansionHack,
-        Optional<Heightmap.Types> projectStartToHeightmap,
-        int maxDistanceFromCenter,
-        PoolAliasLookup aliasLookup,
-        DimensionPadding dimensionPadding,
-        LiquidSettings liquidSettings
+            Structure.GenerationContext context,
+            Holder<StructureTemplatePool> structurePool,
+            Optional<ResourceLocation> id,
+            int size,
+            BlockPos pos,
+            boolean useExpansionHack,
+            Optional<Heightmap.Types> projectStartToHeightmap,
+            int maxDistanceFromCenter,
+            PoolAliasLookup aliasLookup,
+            DimensionPadding dimensionPadding,
+            LiquidSettings liquidSettings
     ) {
         RegistryAccess registryAccess = context.registryAccess();
         ChunkGenerator chunkGenerator = context.chunkGenerator();
@@ -73,8 +68,8 @@ public class JigsawPlacement {
         Registry<StructureTemplatePool> registry = registryAccess.registryOrThrow(Registries.TEMPLATE_POOL);
         Rotation rotation = Rotation.getRandom(worldgenRandom);
         StructureTemplatePool structureTemplatePool = structurePool.unwrapKey()
-            .flatMap(key -> registry.getOptional(aliasLookup.lookup((ResourceKey<StructureTemplatePool>)key)))
-            .orElse(structurePool.value());
+                .flatMap(key -> registry.getOptional(aliasLookup.lookup((ResourceKey<StructureTemplatePool>) key)))
+                .orElse(structurePool.value());
         StructurePoolElement structurePoolElement = structureTemplatePool.getRandomTemplate(worldgenRandom);
         if (structurePoolElement == EmptyPoolElement.INSTANCE) {
             return Optional.empty();
@@ -83,13 +78,13 @@ public class JigsawPlacement {
             if (id.isPresent()) {
                 ResourceLocation resourceLocation = id.get();
                 Optional<BlockPos> optional = getRandomNamedJigsaw(
-                    structurePoolElement, resourceLocation, pos, rotation, structureTemplateManager, worldgenRandom
+                        structurePoolElement, resourceLocation, pos, rotation, structureTemplateManager, worldgenRandom
                 );
                 if (optional.isEmpty()) {
                     LOGGER.error(
-                        "No starting jigsaw {} found in start pool {}",
-                        resourceLocation,
-                        structurePool.unwrapKey().map(key -> key.location().toString()).orElse("<unregistered>")
+                            "No starting jigsaw {} found in start pool {}",
+                            resourceLocation,
+                            structurePool.unwrapKey().map(key -> key.location().toString()).orElse("<unregistered>")
                     );
                     return Optional.empty();
                 }
@@ -102,13 +97,13 @@ public class JigsawPlacement {
             Vec3i vec3i = blockPos.subtract(pos);
             BlockPos blockPos3 = pos.subtract(vec3i);
             PoolElementStructurePiece poolElementStructurePiece = new PoolElementStructurePiece(
-                structureTemplateManager,
-                structurePoolElement,
-                blockPos3,
-                structurePoolElement.getGroundLevelDelta(),
-                rotation,
-                structurePoolElement.getBoundingBox(structureTemplateManager, blockPos3, rotation),
-                liquidSettings
+                    structureTemplateManager,
+                    structurePoolElement,
+                    blockPos3,
+                    structurePoolElement.getGroundLevelDelta(),
+                    rotation,
+                    structurePoolElement.getBoundingBox(structureTemplateManager, blockPos3, rotation),
+                    liquidSettings
             );
             BoundingBox boundingBox = poolElementStructurePiece.getBoundingBox();
             int i = (boundingBox.maxX() + boundingBox.minX()) / 2;
@@ -124,53 +119,53 @@ public class JigsawPlacement {
             poolElementStructurePiece.move(0, k - m, 0);
             int n = k + vec3i.getY();
             return Optional.of(
-                new Structure.GenerationStub(
-                    new BlockPos(i, n, j),
-                    collector -> {
-                        List<PoolElementStructurePiece> list = Lists.newArrayList();
-                        list.add(poolElementStructurePiece);
-                        if (size > 0) {
-                            AABB aABB = new AABB(
-                                (double)(i - maxDistanceFromCenter),
-                                (double)Math.max(n - maxDistanceFromCenter, levelHeightAccessor.getMinBuildHeight() + dimensionPadding.bottom()),
-                                (double)(j - maxDistanceFromCenter),
-                                (double)(i + maxDistanceFromCenter + 1),
-                                (double)Math.min(n + maxDistanceFromCenter + 1, levelHeightAccessor.getMaxBuildHeight() - dimensionPadding.top()),
-                                (double)(j + maxDistanceFromCenter + 1)
-                            );
-                            VoxelShape voxelShape = Shapes.join(Shapes.create(aABB), Shapes.create(AABB.of(boundingBox)), BooleanOp.ONLY_FIRST);
-                            addPieces(
-                                context.randomState(),
-                                size,
-                                useExpansionHack,
-                                chunkGenerator,
-                                structureTemplateManager,
-                                levelHeightAccessor,
-                                worldgenRandom,
-                                registry,
-                                poolElementStructurePiece,
-                                list,
-                                voxelShape,
-                                aliasLookup,
-                                liquidSettings
-                            );
-                            list.forEach(collector::addPiece);
-                        }
-                    }
-                )
+                    new Structure.GenerationStub(
+                            new BlockPos(i, n, j),
+                            collector -> {
+                                List<PoolElementStructurePiece> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+                                list.add(poolElementStructurePiece);
+                                if (size > 0) {
+                                    AABB aABB = new AABB(
+                                            (double) (i - maxDistanceFromCenter),
+                                            (double) Math.max(n - maxDistanceFromCenter, levelHeightAccessor.getMinBuildHeight() + dimensionPadding.bottom()),
+                                            (double) (j - maxDistanceFromCenter),
+                                            (double) (i + maxDistanceFromCenter + 1),
+                                            (double) Math.min(n + maxDistanceFromCenter + 1, levelHeightAccessor.getMaxBuildHeight() - dimensionPadding.top()),
+                                            (double) (j + maxDistanceFromCenter + 1)
+                                    );
+                                    VoxelShape voxelShape = Shapes.join(Shapes.create(aABB), Shapes.create(AABB.of(boundingBox)), BooleanOp.ONLY_FIRST);
+                                    addPieces(
+                                            context.randomState(),
+                                            size,
+                                            useExpansionHack,
+                                            chunkGenerator,
+                                            structureTemplateManager,
+                                            levelHeightAccessor,
+                                            worldgenRandom,
+                                            registry,
+                                            poolElementStructurePiece,
+                                            list,
+                                            voxelShape,
+                                            aliasLookup,
+                                            liquidSettings
+                                    );
+                                    list.forEach(collector::addPiece);
+                                }
+                            }
+                    )
             );
         }
     }
 
     private static Optional<BlockPos> getRandomNamedJigsaw(
-        StructurePoolElement pool, ResourceLocation id, BlockPos pos, Rotation rotation, StructureTemplateManager structureManager, WorldgenRandom random
+            StructurePoolElement pool, ResourceLocation id, BlockPos pos, Rotation rotation, StructureTemplateManager structureManager, WorldgenRandom random
     ) {
         List<StructureTemplate.StructureBlockInfo> list = pool.getShuffledJigsawBlocks(structureManager, pos, rotation, random);
         Optional<BlockPos> optional = Optional.empty();
 
         for (StructureTemplate.StructureBlockInfo structureBlockInfo : list) {
             ResourceLocation resourceLocation = ResourceLocation.tryParse(
-                Objects.requireNonNull(structureBlockInfo.nbt(), () -> structureBlockInfo + " nbt was null").getString("name")
+                    Objects.requireNonNull(structureBlockInfo.nbt(), () -> structureBlockInfo + " nbt was null").getString("name")
             );
             if (id.equals(resourceLocation)) {
                 optional = Optional.of(structureBlockInfo.pos());
@@ -182,19 +177,19 @@ public class JigsawPlacement {
     }
 
     private static void addPieces(
-        RandomState noiseConfig,
-        int maxSize,
-        boolean modifyBoundingBox,
-        ChunkGenerator chunkGenerator,
-        StructureTemplateManager structureTemplateManager,
-        LevelHeightAccessor heightLimitView,
-        RandomSource random,
-        Registry<StructureTemplatePool> structurePoolRegistry,
-        PoolElementStructurePiece firstPiece,
-        List<PoolElementStructurePiece> pieces,
-        VoxelShape pieceShape,
-        PoolAliasLookup aliasLookup,
-        LiquidSettings liquidSettings
+            RandomState noiseConfig,
+            int maxSize,
+            boolean modifyBoundingBox,
+            ChunkGenerator chunkGenerator,
+            StructureTemplateManager structureTemplateManager,
+            LevelHeightAccessor heightLimitView,
+            RandomSource random,
+            Registry<StructureTemplatePool> structurePoolRegistry,
+            PoolElementStructurePiece firstPiece,
+            List<PoolElementStructurePiece> pieces,
+            VoxelShape pieceShape,
+            PoolAliasLookup aliasLookup,
+            LiquidSettings liquidSettings
     ) {
         JigsawPlacement.Placer placer = new JigsawPlacement.Placer(structurePoolRegistry, maxSize, chunkGenerator, structureTemplateManager, pieces, random);
         placer.tryPlacingChildren(firstPiece, new MutableObject<>(pieceShape), 0, modifyBoundingBox, heightLimitView, noiseConfig, aliasLookup, liquidSettings);
@@ -202,41 +197,41 @@ public class JigsawPlacement {
         while (placer.placing.hasNext()) {
             JigsawPlacement.PieceState pieceState = placer.placing.next();
             placer.tryPlacingChildren(
-                pieceState.piece, pieceState.free, pieceState.depth, modifyBoundingBox, heightLimitView, noiseConfig, aliasLookup, liquidSettings
+                    pieceState.piece, pieceState.free, pieceState.depth, modifyBoundingBox, heightLimitView, noiseConfig, aliasLookup, liquidSettings
             );
         }
     }
 
     public static boolean generateJigsaw(
-        ServerLevel world, Holder<StructureTemplatePool> structurePool, ResourceLocation id, int size, BlockPos pos, boolean keepJigsaws
+            ServerLevel world, Holder<StructureTemplatePool> structurePool, ResourceLocation id, int size, BlockPos pos, boolean keepJigsaws
     ) {
         ChunkGenerator chunkGenerator = world.getChunkSource().getGenerator();
         StructureTemplateManager structureTemplateManager = world.getStructureManager();
         StructureManager structureManager = world.structureManager();
         RandomSource randomSource = world.getRandom();
         Structure.GenerationContext generationContext = new Structure.GenerationContext(
-            world.registryAccess(),
-            chunkGenerator,
-            chunkGenerator.getBiomeSource(),
-            world.getChunkSource().randomState(),
-            structureTemplateManager,
-            world.getSeed(),
-            new ChunkPos(pos),
-            world,
-            biome -> true
+                world.registryAccess(),
+                chunkGenerator,
+                chunkGenerator.getBiomeSource(),
+                world.getChunkSource().randomState(),
+                structureTemplateManager,
+                world.getSeed(),
+                new ChunkPos(pos),
+                world,
+                biome -> true
         );
         Optional<Structure.GenerationStub> optional = addPieces(
-            generationContext,
-            structurePool,
-            Optional.of(id),
-            size,
-            pos,
-            false,
-            Optional.empty(),
-            128,
-            PoolAliasLookup.EMPTY,
-            JigsawStructure.DEFAULT_DIMENSION_PADDING,
-            JigsawStructure.DEFAULT_LIQUID_SETTINGS
+                generationContext,
+                structurePool,
+                Optional.of(id),
+                size,
+                pos,
+                false,
+                Optional.empty(),
+                128,
+                PoolAliasLookup.EMPTY,
+                JigsawStructure.DEFAULT_DIMENSION_PADDING,
+                JigsawStructure.DEFAULT_LIQUID_SETTINGS
         );
         if (optional.isPresent()) {
             StructurePiecesBuilder structurePiecesBuilder = optional.get().getPiecesBuilder();
@@ -266,12 +261,12 @@ public class JigsawPlacement {
         final SequencedPriorityIterator<JigsawPlacement.PieceState> placing = new SequencedPriorityIterator<>();
 
         Placer(
-            Registry<StructureTemplatePool> registry,
-            int maxSize,
-            ChunkGenerator chunkGenerator,
-            StructureTemplateManager structureTemplateManager,
-            List<? super PoolElementStructurePiece> children,
-            RandomSource random
+                Registry<StructureTemplatePool> registry,
+                int maxSize,
+                ChunkGenerator chunkGenerator,
+                StructureTemplateManager structureTemplateManager,
+                List<? super PoolElementStructurePiece> children,
+                RandomSource random
         ) {
             this.pools = registry;
             this.maxDepth = maxSize;
@@ -282,14 +277,14 @@ public class JigsawPlacement {
         }
 
         void tryPlacingChildren(
-            PoolElementStructurePiece piece,
-            MutableObject<VoxelShape> pieceShape,
-            int minY,
-            boolean modifyBoundingBox,
-            LevelHeightAccessor world,
-            RandomState noiseConfig,
-            PoolAliasLookup aliasLookup,
-            LiquidSettings liquidSettings
+                PoolElementStructurePiece piece,
+                MutableObject<VoxelShape> pieceShape,
+                int minY,
+                boolean modifyBoundingBox,
+                LevelHeightAccessor world,
+                RandomState noiseConfig,
+                PoolAliasLookup aliasLookup,
+                LiquidSettings liquidSettings
         ) {
             StructurePoolElement structurePoolElement = piece.getElement();
             BlockPos blockPos = piece.getPosition();
@@ -302,7 +297,7 @@ public class JigsawPlacement {
 
             label134:
             for (StructureTemplate.StructureBlockInfo structureBlockInfo : structurePoolElement.getShuffledJigsawBlocks(
-                this.structureTemplateManager, blockPos, rotation, this.random
+                    this.structureTemplateManager, blockPos, rotation, this.random
             )) {
                 Direction direction = JigsawBlock.getFrontFacing(structureBlockInfo.state());
                 BlockPos blockPos2 = structureBlockInfo.pos();
@@ -314,17 +309,17 @@ public class JigsawPlacement {
                 if (optional.isEmpty()) {
                     JigsawPlacement.LOGGER.warn("Empty or non-existent pool: {}", resourceKey.location());
                 } else {
-                    Holder<StructureTemplatePool> holder = (Holder<StructureTemplatePool>)optional.get();
+                    Holder<StructureTemplatePool> holder = (Holder<StructureTemplatePool>) optional.get();
                     if (holder.value().size() == 0 && !holder.is(Pools.EMPTY)) {
                         JigsawPlacement.LOGGER.warn("Empty or non-existent pool: {}", resourceKey.location());
                     } else {
                         Holder<StructureTemplatePool> holder2 = holder.value().getFallback();
                         if (holder2.value().size() == 0 && !holder2.is(Pools.EMPTY)) {
                             JigsawPlacement.LOGGER
-                                .warn(
-                                    "Empty or non-existent fallback pool: {}",
-                                    holder2.unwrapKey().map(key -> key.location().toString()).orElse("<unregistered>")
-                                );
+                                    .warn(
+                                            "Empty or non-existent fallback pool: {}",
+                                            holder2.unwrapKey().map(key -> key.location().toString()).orElse("<unregistered>")
+                                    );
                         } else {
                             boolean bl2 = boundingBox.isInside(blockPos3);
                             MutableObject<VoxelShape> mutableObject2;
@@ -337,7 +332,7 @@ public class JigsawPlacement {
                                 mutableObject2 = pieceShape;
                             }
 
-                            List<StructurePoolElement> list = Lists.newArrayList();
+                            List<StructurePoolElement> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                             if (minY != this.maxDepth) {
                                 list.addAll(holder.value().getShuffledTemplates(this.random));
                             }
@@ -352,32 +347,32 @@ public class JigsawPlacement {
 
                                 for (Rotation rotation2 : Rotation.getShuffled(this.random)) {
                                     List<StructureTemplate.StructureBlockInfo> list2 = structurePoolElement2.getShuffledJigsawBlocks(
-                                        this.structureTemplateManager, BlockPos.ZERO, rotation2, this.random
+                                            this.structureTemplateManager, BlockPos.ZERO, rotation2, this.random
                                     );
                                     BoundingBox boundingBox2 = structurePoolElement2.getBoundingBox(this.structureTemplateManager, BlockPos.ZERO, rotation2);
                                     int n;
                                     if (modifyBoundingBox && boundingBox2.getYSpan() <= 16) {
                                         n = list2.stream()
-                                            .mapToInt(
-                                                structureBlockInfox -> {
-                                                    if (!boundingBox2.isInside(
-                                                        structureBlockInfox.pos().relative(JigsawBlock.getFrontFacing(structureBlockInfox.state()))
-                                                    )) {
-                                                        return 0;
-                                                    } else {
-                                                        ResourceKey<StructureTemplatePool> resourceKeyx = readPoolKey(structureBlockInfox, aliasLookup);
-                                                        Optional<? extends Holder<StructureTemplatePool>> optionalx = this.pools.getHolder(resourceKeyx);
-                                                        Optional<Holder<StructureTemplatePool>> optional2 = optionalx.map(entry -> entry.value().getFallback());
-                                                        int ix = optionalx.<Integer>map(entry -> entry.value().getMaxSize(this.structureTemplateManager))
-                                                            .orElse(0);
-                                                        int jx = optional2.<Integer>map(entry -> entry.value().getMaxSize(this.structureTemplateManager))
-                                                            .orElse(0);
-                                                        return Math.max(ix, jx);
-                                                    }
-                                                }
-                                            )
-                                            .max()
-                                            .orElse(0);
+                                                .mapToInt(
+                                                        structureBlockInfox -> {
+                                                            if (!boundingBox2.isInside(
+                                                                    structureBlockInfox.pos().relative(JigsawBlock.getFrontFacing(structureBlockInfox.state()))
+                                                            )) {
+                                                                return 0;
+                                                            } else {
+                                                                ResourceKey<StructureTemplatePool> resourceKeyx = readPoolKey(structureBlockInfox, aliasLookup);
+                                                                Optional<? extends Holder<StructureTemplatePool>> optionalx = this.pools.getHolder(resourceKeyx);
+                                                                Optional<Holder<StructureTemplatePool>> optional2 = optionalx.map(entry -> entry.value().getFallback());
+                                                                int ix = optionalx.<Integer>map(entry -> entry.value().getMaxSize(this.structureTemplateManager))
+                                                                        .orElse(0);
+                                                                int jx = optional2.<Integer>map(entry -> entry.value().getMaxSize(this.structureTemplateManager))
+                                                                        .orElse(0);
+                                                                return Math.max(ix, jx);
+                                                            }
+                                                        }
+                                                )
+                                                .max()
+                                                .orElse(0);
                                     } else {
                                         n = 0;
                                     }
@@ -398,9 +393,9 @@ public class JigsawPlacement {
                                             } else {
                                                 if (k == -1) {
                                                     k = this.chunkGenerator
-                                                        .getFirstFreeHeight(
-                                                            blockPos2.getX(), blockPos2.getZ(), Heightmap.Types.WORLD_SURFACE_WG, world, noiseConfig
-                                                        );
+                                                            .getFirstFreeHeight(
+                                                                    blockPos2.getX(), blockPos2.getZ(), Heightmap.Types.WORLD_SURFACE_WG, world, noiseConfig
+                                                            );
                                                 }
 
                                                 r = k - p;
@@ -415,12 +410,12 @@ public class JigsawPlacement {
                                             }
 
                                             if (!Shapes.joinIsNotEmpty(
-                                                mutableObject2.getValue(), Shapes.create(AABB.of(boundingBox4).deflate(0.25)), BooleanOp.ONLY_SECOND
+                                                    mutableObject2.getValue(), Shapes.create(AABB.of(boundingBox4).deflate(0.25)), BooleanOp.ONLY_SECOND
                                             )) {
                                                 mutableObject2.setValue(
-                                                    Shapes.joinUnoptimized(
-                                                        mutableObject2.getValue(), Shapes.create(AABB.of(boundingBox4)), BooleanOp.ONLY_FIRST
-                                                    )
+                                                        Shapes.joinUnoptimized(
+                                                                mutableObject2.getValue(), Shapes.create(AABB.of(boundingBox4)), BooleanOp.ONLY_FIRST
+                                                        )
                                                 );
                                                 int v = piece.getGroundLevelDelta();
                                                 int w;
@@ -431,7 +426,7 @@ public class JigsawPlacement {
                                                 }
 
                                                 PoolElementStructurePiece poolElementStructurePiece = new PoolElementStructurePiece(
-                                                    this.structureTemplateManager, structurePoolElement2, blockPos6, w, rotation2, boundingBox4, liquidSettings
+                                                        this.structureTemplateManager, structurePoolElement2, blockPos6, w, rotation2, boundingBox4, liquidSettings
                                                 );
                                                 int y;
                                                 if (bl) {
@@ -441,9 +436,9 @@ public class JigsawPlacement {
                                                 } else {
                                                     if (k == -1) {
                                                         k = this.chunkGenerator
-                                                            .getFirstFreeHeight(
-                                                                blockPos2.getX(), blockPos2.getZ(), Heightmap.Types.WORLD_SURFACE_WG, world, noiseConfig
-                                                            );
+                                                                .getFirstFreeHeight(
+                                                                        blockPos2.getX(), blockPos2.getZ(), Heightmap.Types.WORLD_SURFACE_WG, world, noiseConfig
+                                                                );
                                                     }
 
                                                     y = k + q / 2;
@@ -451,12 +446,12 @@ public class JigsawPlacement {
 
                                                 piece.addJunction(new JigsawJunction(blockPos3.getX(), y - j + v, blockPos3.getZ(), q, projection2));
                                                 poolElementStructurePiece.addJunction(
-                                                    new JigsawJunction(blockPos2.getX(), y - p + w, blockPos2.getZ(), -q, projection)
+                                                        new JigsawJunction(blockPos2.getX(), y - p + w, blockPos2.getZ(), -q, projection)
                                                 );
                                                 this.pieces.add(poolElementStructurePiece);
                                                 if (minY + 1 <= this.maxDepth) {
                                                     JigsawPlacement.PieceState pieceState = new JigsawPlacement.PieceState(
-                                                        poolElementStructurePiece, mutableObject2, minY + 1
+                                                            poolElementStructurePiece, mutableObject2, minY + 1
                                                     );
                                                     this.placing.add(pieceState, l);
                                                 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityPieces.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityPieces.java
index 4f77ccd9b93576a7ac6dd29b8a9e7b0390e43513..49272d792465f404fed28323650ba420766daf3f 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityPieces.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityPieces.java
@@ -1,15 +1,12 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
 import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.Tuple;
-import net.minecraft.world.RandomizableContainer;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.decoration.ItemFrame;
 import net.minecraft.world.entity.monster.Shulker;
@@ -28,12 +25,16 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlac
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.loot.BuiltInLootTables;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class EndCityPieces {
 
     private static final int MAX_GEN_DEPTH = 8;
     static final EndCityPieces.SectionGenerator HOUSE_TOWER_GENERATOR = new EndCityPieces.SectionGenerator() {
         @Override
-        public void init() {}
+        public void init() {
+        }
 
         @Override
         public boolean generate(StructureTemplateManager manager, int depth, EndCityPieces.EndCityPiece root, BlockPos pos, List<StructurePiece> pieces, RandomSource random) {
@@ -64,7 +65,8 @@ public class EndCityPieces {
     static final List<Tuple<Rotation, BlockPos>> TOWER_BRIDGES = Lists.newArrayList(new Tuple[]{new Tuple<>(Rotation.NONE, new BlockPos(1, -1, 0)), new Tuple<>(Rotation.CLOCKWISE_90, new BlockPos(6, -1, 1)), new Tuple<>(Rotation.COUNTERCLOCKWISE_90, new BlockPos(0, -1, 5)), new Tuple<>(Rotation.CLOCKWISE_180, new BlockPos(5, -1, 6))});
     static final EndCityPieces.SectionGenerator TOWER_GENERATOR = new EndCityPieces.SectionGenerator() {
         @Override
-        public void init() {}
+        public void init() {
+        }
 
         @Override
         public boolean generate(StructureTemplateManager manager, int depth, EndCityPieces.EndCityPiece root, BlockPos pos, List<StructurePiece> pieces, RandomSource random) {
@@ -154,7 +156,8 @@ public class EndCityPieces {
     static final List<Tuple<Rotation, BlockPos>> FAT_TOWER_BRIDGES = Lists.newArrayList(new Tuple[]{new Tuple<>(Rotation.NONE, new BlockPos(4, -1, 0)), new Tuple<>(Rotation.CLOCKWISE_90, new BlockPos(12, -1, 4)), new Tuple<>(Rotation.COUNTERCLOCKWISE_90, new BlockPos(0, -1, 8)), new Tuple<>(Rotation.CLOCKWISE_180, new BlockPos(8, -1, 12))});
     static final EndCityPieces.SectionGenerator FAT_TOWER_GENERATOR = new EndCityPieces.SectionGenerator() {
         @Override
-        public void init() {}
+        public void init() {
+        }
 
         @Override
         public boolean generate(StructureTemplateManager manager, int depth, EndCityPieces.EndCityPiece root, BlockPos pos, List<StructurePiece> pieces, RandomSource random) {
@@ -183,7 +186,8 @@ public class EndCityPieces {
         }
     };
 
-    public EndCityPieces() {}
+    public EndCityPieces() {
+    }
 
     static EndCityPieces.EndCityPiece addPiece(StructureTemplateManager structureTemplateManager, EndCityPieces.EndCityPiece lastPiece, BlockPos relativePosition, String template, Rotation rotation, boolean ignoreAir) {
         EndCityPieces.EndCityPiece endcitypieces_a1 = new EndCityPieces.EndCityPiece(structureTemplateManager, template, lastPiece.templatePosition(), rotation, ignoreAir);
@@ -215,7 +219,7 @@ public class EndCityPieces {
         if (depth > 8) {
             return false;
         } else {
-            List<StructurePiece> list1 = Lists.newArrayList();
+            List<StructurePiece> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             if (piece.generate(manager, depth, parent, pos, list1, random)) {
                 boolean flag = false;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityStructure.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityStructure.java
index 35dc49d90aa6d660a60fb76efddb530f9ec59666..763b4ff38e631f0e4b7589cdea10e4f8e41fe7b2 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityStructure.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/EndCityStructure.java
@@ -1,15 +1,15 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
-import com.google.common.collect.Lists;
 import com.mojang.serialization.MapCodec;
-import java.util.List;
-import java.util.Optional;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructurePiece;
 import net.minecraft.world.level.levelgen.structure.StructureType;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+
+import java.util.List;
+import java.util.Optional;
 //import su.plo.matter.WorldgenCryptoRandom; // Leaf - Matter - Feature Secure Seed
 
 public class EndCityStructure extends Structure {
@@ -24,12 +24,12 @@ public class EndCityStructure extends Structure {
         Rotation rotation = Rotation.getRandom(context.random());
         BlockPos blockPos = this.getLowestYIn5by5BoxOffset7Blocks(context, rotation);
         return blockPos.getY() < 60
-            ? Optional.empty()
-            : Optional.of(new Structure.GenerationStub(blockPos, collector -> this.generatePieces(collector, blockPos, rotation, context)));
+                ? Optional.empty()
+                : Optional.of(new Structure.GenerationStub(blockPos, collector -> this.generatePieces(collector, blockPos, rotation, context)));
     }
 
     private void generatePieces(StructurePiecesBuilder collector, BlockPos pos, Rotation rotation, Structure.GenerationContext context) {
-        List<StructurePiece> list = Lists.newArrayList();
+        List<StructurePiece> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         EndCityPieces.startHouseTower(context.structureTemplateManager(), pos, rotation, list, context.random());
         list.forEach(collector::addPiece);
     }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/NetherFortressPieces.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/NetherFortressPieces.java
index 1927565d079ea5febe8149956e8af5330b3b910f..f4b1ef3126d1dcf6912cb2b76525019f3484c2cd 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/NetherFortressPieces.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/NetherFortressPieces.java
@@ -1,9 +1,5 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
-import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
@@ -25,6 +21,10 @@ import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.storage.loot.BuiltInLootTables;
 
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+
 public class NetherFortressPieces {
 
     private static final int MAX_DEPTH = 30;
@@ -33,7 +33,8 @@ public class NetherFortressPieces {
     static final NetherFortressPieces.PieceWeight[] BRIDGE_PIECE_WEIGHTS = new NetherFortressPieces.PieceWeight[]{new NetherFortressPieces.PieceWeight(NetherFortressPieces.BridgeStraight.class, 30, 0, true), new NetherFortressPieces.PieceWeight(NetherFortressPieces.BridgeCrossing.class, 10, 4), new NetherFortressPieces.PieceWeight(NetherFortressPieces.RoomCrossing.class, 10, 4), new NetherFortressPieces.PieceWeight(NetherFortressPieces.StairsRoom.class, 10, 3), new NetherFortressPieces.PieceWeight(NetherFortressPieces.MonsterThrone.class, 5, 2), new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleEntrance.class, 5, 1)};
     static final NetherFortressPieces.PieceWeight[] CASTLE_PIECE_WEIGHTS = new NetherFortressPieces.PieceWeight[]{new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleSmallCorridorPiece.class, 25, 0, true), new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleSmallCorridorCrossingPiece.class, 15, 5), new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleSmallCorridorRightTurnPiece.class, 5, 10), new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleSmallCorridorLeftTurnPiece.class, 5, 10), new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleCorridorStairsPiece.class, 10, 3, true), new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleCorridorTBalconyPiece.class, 7, 2), new NetherFortressPieces.PieceWeight(NetherFortressPieces.CastleStalkRoom.class, 5, 2)};
 
-    public NetherFortressPieces() {}
+    public NetherFortressPieces() {
+    }
 
     static NetherFortressPieces.NetherBridgePiece findAndCreateBridgePieceFactory(NetherFortressPieces.PieceWeight pieceData, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
         Class<? extends NetherFortressPieces.NetherBridgePiece> oclass = pieceData.pieceClass;
@@ -1135,11 +1136,11 @@ public class NetherFortressPieces {
         public NetherFortressPieces.PieceWeight previousPiece;
         public List<NetherFortressPieces.PieceWeight> availableBridgePieces;
         public List<NetherFortressPieces.PieceWeight> availableCastlePieces;
-        public final List<StructurePiece> pendingChildren = Lists.newArrayList();
+        public final List<StructurePiece> pendingChildren = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         public StartPiece(RandomSource random, int x, int z) {
             super(x, z, getRandomHorizontalDirection(random));
-            this.availableBridgePieces = Lists.newArrayList();
+            this.availableBridgePieces = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             NetherFortressPieces.PieceWeight[] anetherfortresspieces_n = NetherFortressPieces.BRIDGE_PIECE_WEIGHTS;
             int k = anetherfortresspieces_n.length;
 
@@ -1152,7 +1153,7 @@ public class NetherFortressPieces {
                 this.availableBridgePieces.add(netherfortresspieces_n);
             }
 
-            this.availableCastlePieces = Lists.newArrayList();
+            this.availableCastlePieces = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             anetherfortresspieces_n = NetherFortressPieces.CASTLE_PIECE_WEIGHTS;
             k = anetherfortresspieces_n.length;
 
@@ -1180,7 +1181,8 @@ public class NetherFortressPieces {
         }
 
         @Override
-        protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag nbt) {}
+        protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag nbt) {
+        }
 
         private int updatePieceWeight(List<NetherFortressPieces.PieceWeight> possiblePieces) {
             boolean flag = false;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/OceanRuinPieces.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/OceanRuinPieces.java
index ddf853819c7770b7aaf9ec052e81fda9aa1667d4..4ee17d2a4f80473ac979fb05a7c307604f18732b 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/OceanRuinPieces.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/OceanRuinPieces.java
@@ -1,8 +1,5 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
-import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
@@ -17,16 +14,8 @@ import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MobSpawnType;
 import net.minecraft.world.entity.SpawnGroupData;
 import net.minecraft.world.entity.monster.Drowned;
-import net.minecraft.world.level.BlockGetter;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.ServerLevelAccessor;
-import net.minecraft.world.level.StructureManager;
-import net.minecraft.world.level.WorldGenLevel;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.ChestBlock;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.*;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
@@ -35,23 +24,15 @@ import net.minecraft.world.level.levelgen.structure.StructurePieceAccessor;
 import net.minecraft.world.level.levelgen.structure.TemplateStructurePiece;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType;
-import net.minecraft.world.level.levelgen.structure.templatesystem.AlwaysTrueTest;
-import net.minecraft.world.level.levelgen.structure.templatesystem.BlockIgnoreProcessor;
-import net.minecraft.world.level.levelgen.structure.templatesystem.BlockMatchTest;
-import net.minecraft.world.level.levelgen.structure.templatesystem.BlockRotProcessor;
-import net.minecraft.world.level.levelgen.structure.templatesystem.CappedProcessor;
-import net.minecraft.world.level.levelgen.structure.templatesystem.PosAlwaysTrueTest;
-import net.minecraft.world.level.levelgen.structure.templatesystem.ProcessorRule;
-import net.minecraft.world.level.levelgen.structure.templatesystem.RuleProcessor;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructurePlaceSettings;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructureProcessor;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplate;
-import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
+import net.minecraft.world.level.levelgen.structure.templatesystem.*;
 import net.minecraft.world.level.levelgen.structure.templatesystem.rule.blockentity.AppendLoot;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.storage.loot.BuiltInLootTables;
 import net.minecraft.world.level.storage.loot.LootTable;
 
+import java.util.Iterator;
+import java.util.List;
+
 public class OceanRuinPieces {
 
     static final StructureProcessor WARM_SUSPICIOUS_BLOCK_PROCESSOR = OceanRuinPieces.archyRuleProcessor(Blocks.SAND, Blocks.SUSPICIOUS_SAND, BuiltInLootTables.OCEAN_RUIN_WARM_ARCHAEOLOGY);
@@ -65,7 +46,8 @@ public class OceanRuinPieces {
     private static final ResourceLocation[] BIG_RUINS_CRACKED = new ResourceLocation[]{ResourceLocation.withDefaultNamespace("underwater_ruin/big_cracked_1"), ResourceLocation.withDefaultNamespace("underwater_ruin/big_cracked_2"), ResourceLocation.withDefaultNamespace("underwater_ruin/big_cracked_3"), ResourceLocation.withDefaultNamespace("underwater_ruin/big_cracked_8")};
     private static final ResourceLocation[] BIG_WARM_RUINS = new ResourceLocation[]{ResourceLocation.withDefaultNamespace("underwater_ruin/big_warm_4"), ResourceLocation.withDefaultNamespace("underwater_ruin/big_warm_5"), ResourceLocation.withDefaultNamespace("underwater_ruin/big_warm_6"), ResourceLocation.withDefaultNamespace("underwater_ruin/big_warm_7")};
 
-    public OceanRuinPieces() {}
+    public OceanRuinPieces() {
+    }
 
     private static StructureProcessor archyRuleProcessor(Block baseBlock, Block suspiciousBlock, ResourceKey<LootTable> lootTable) {
         return new CappedProcessor(new RuleProcessor(List.of(new ProcessorRule(new BlockMatchTest(baseBlock), AlwaysTrueTest.INSTANCE, PosAlwaysTrueTest.INSTANCE, suspiciousBlock.defaultBlockState(), new AppendLoot(lootTable)))), ConstantInt.of(5));
@@ -115,7 +97,7 @@ public class OceanRuinPieces {
     }
 
     private static List<BlockPos> allPositions(RandomSource random, BlockPos pos) {
-        List<BlockPos> list = Lists.newArrayList();
+        List<BlockPos> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         list.add(pos.offset(-16 + Mth.nextInt(random, 1, 8), 0, 16 + Mth.nextInt(random, 1, 7)));
         list.add(pos.offset(-16 + Mth.nextInt(random, 1, 8), 0, Mth.nextInt(random, 1, 7)));
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
index 6984de4f2f86d17f9c2b5b8be1b99bcd1ad8bffb..b4c9f79c211e10b884a45ba5b8559c0d18ecd4ae 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
@@ -1,9 +1,5 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
-import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
@@ -11,16 +7,7 @@ import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.StructureManager;
 import net.minecraft.world.level.WorldGenLevel;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.ButtonBlock;
-import net.minecraft.world.level.block.DoorBlock;
-import net.minecraft.world.level.block.EndPortalFrameBlock;
-import net.minecraft.world.level.block.FenceBlock;
-import net.minecraft.world.level.block.IronBarsBlock;
-import net.minecraft.world.level.block.LadderBlock;
-import net.minecraft.world.level.block.SlabBlock;
-import net.minecraft.world.level.block.StairBlock;
-import net.minecraft.world.level.block.WallTorchBlock;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
 import net.minecraft.world.level.block.state.properties.SlabType;
@@ -32,6 +19,10 @@ import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSeriali
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType;
 import net.minecraft.world.level.storage.loot.BuiltInLootTables;
 
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+
 public class StrongholdPieces {
 
     private static final int SMALL_DOOR_WIDTH = 3;
@@ -41,25 +32,26 @@ public class StrongholdPieces {
     private static final boolean CHECK_AIR = true;
     public static final int MAGIC_START_Y = 64;
     private static final StrongholdPieces.PieceWeight[] STRONGHOLD_PIECE_WEIGHTS = new StrongholdPieces.PieceWeight[]{new StrongholdPieces.PieceWeight(StrongholdPieces.Straight.class, 40, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.PrisonHall.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.LeftTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RightTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RoomCrossing.class, 10, 6), new StrongholdPieces.PieceWeight(StrongholdPieces.StraightStairsDown.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.StairsDown.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.FiveCrossing.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.ChestCorridor.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.Library.class, 10, 2) {
-                @Override
-                public boolean doPlace(int chainLength) {
-                    return super.doPlace(chainLength) && chainLength > 4;
-                }
-            }, new StrongholdPieces.PieceWeight(StrongholdPieces.PortalRoom.class, 20, 1) {
-                @Override
-                public boolean doPlace(int chainLength) {
-                    return super.doPlace(chainLength) && chainLength > 5;
-                }
-            } }; // CraftBukkit - fix decompile styling
+        @Override
+        public boolean doPlace(int chainLength) {
+            return super.doPlace(chainLength) && chainLength > 4;
+        }
+    }, new StrongholdPieces.PieceWeight(StrongholdPieces.PortalRoom.class, 20, 1) {
+        @Override
+        public boolean doPlace(int chainLength) {
+            return super.doPlace(chainLength) && chainLength > 5;
+        }
+    }}; // CraftBukkit - fix decompile styling
     private static List<StrongholdPieces.PieceWeight> currentPieces;
     static Class<? extends StrongholdPieces.StrongholdPiece> imposedPiece;
     private static int totalWeight;
     static final StrongholdPieces.SmoothStoneSelector SMOOTH_STONE_SELECTOR = new StrongholdPieces.SmoothStoneSelector();
 
-    public StrongholdPieces() {}
+    public StrongholdPieces() {
+    }
 
     public static void resetPieces() {
-        StrongholdPieces.currentPieces = Lists.newArrayList();
+        StrongholdPieces.currentPieces = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         StrongholdPieces.PieceWeight[] astrongholdpieces_f = StrongholdPieces.STRONGHOLD_PIECE_WEIGHTS;
         int i = astrongholdpieces_f.length;
 
@@ -1300,7 +1292,8 @@ public class StrongholdPieces {
 
             OPENING, WOOD_DOOR, GRATES, IRON_DOOR;
 
-            private SmallDoorType() {}
+            private SmallDoorType() {
+            }
         }
     }
 
@@ -1309,7 +1302,7 @@ public class StrongholdPieces {
         public StrongholdPieces.PieceWeight previousPiece;
         @Nullable
         public StrongholdPieces.PortalRoom portalRoomPiece;
-        public final List<StructurePiece> pendingChildren = Lists.newArrayList();
+        public final List<StructurePiece> pendingChildren = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         public StartPiece(RandomSource random, int i, int j) {
             super(StructurePieceType.STRONGHOLD_START, 0, i, j, getRandomHorizontalDirection(random));
@@ -1396,7 +1389,8 @@ public class StrongholdPieces {
 
     private static class SmoothStoneSelector extends StructurePiece.BlockSelector {
 
-        SmoothStoneSelector() {}
+        SmoothStoneSelector() {
+        }
 
         @Override
         public void next(RandomSource random, int x, int y, int z, boolean placeBlock) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructurePlaceSettings.java b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructurePlaceSettings.java
index f1e0d3d7b1f458fcce83cf67762a16309123cdcb..b5f33df17ddb23bfbb78917d7c92ae93cea5a300 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructurePlaceSettings.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructurePlaceSettings.java
@@ -1,8 +1,5 @@
 package net.minecraft.world.level.levelgen.structure.templatesystem;
 
-import com.google.common.collect.Lists;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.util.Mth;
@@ -11,6 +8,9 @@ import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 
+import javax.annotation.Nullable;
+import java.util.List;
+
 public class StructurePlaceSettings {
 
     private Mirror mirror;
@@ -32,7 +32,7 @@ public class StructurePlaceSettings {
         this.rotation = Rotation.NONE;
         this.rotationPivot = BlockPos.ZERO;
         this.liquidSettings = LiquidSettings.APPLY_WATERLOGGING;
-        this.processors = Lists.newArrayList();
+        this.processors = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     }
 
     public StructurePlaceSettings copy() {
@@ -149,13 +149,13 @@ public class StructurePlaceSettings {
 
         if (i == 0) {
             throw new IllegalStateException("No palettes");
-        // CraftBukkit start
+            // CraftBukkit start
         } else if (this.palette >= 0) {
             if (this.palette >= i) {
                 throw new IllegalArgumentException("Palette index out of bounds. Got " + this.palette + " where there are only " + i + " palettes available.");
             }
             return infoLists.get(this.palette);
-        // CraftBukkit end
+            // CraftBukkit end
         } else {
             return (StructureTemplate.Palette) infoLists.get(this.getRandom(pos).nextInt(i));
         }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
index 0555abfda468c343af8244a122ebe769e70a0292..b0c42da4c7bcd353de57cc8ab61fce96cdb3346e 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplate.java
@@ -5,45 +5,19 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Optional;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.HolderGetter;
-import net.minecraft.core.IdMapper;
-import net.minecraft.core.Vec3i;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.nbt.DoubleTag;
-import net.minecraft.nbt.IntTag;
-import net.minecraft.nbt.ListTag;
-import net.minecraft.nbt.NbtUtils;
-import net.minecraft.nbt.Tag;
+import net.minecraft.core.*;
+import net.minecraft.nbt.*;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.Clearable;
 import net.minecraft.world.RandomizableContainer;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobSpawnType;
-import net.minecraft.world.entity.SpawnGroupData;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.decoration.Painting;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.EmptyBlockGetter;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.ServerLevelAccessor;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.LiquidBlockContainer;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.*;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
@@ -54,6 +28,10 @@ import net.minecraft.world.phys.shapes.BitSetDiscreteVoxelShape;
 import net.minecraft.world.phys.shapes.DiscreteVoxelShape;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.stream.Collectors;
 // CraftBukkit end
 
 public class StructureTemplate {
@@ -69,8 +47,8 @@ public class StructureTemplate {
     public static final String ENTITY_TAG_BLOCKPOS = "blockPos";
     public static final String ENTITY_TAG_NBT = "nbt";
     public static final String SIZE_TAG = "size";
-    public final List<StructureTemplate.Palette> palettes = Lists.newArrayList();
-    public final List<StructureTemplate.StructureEntityInfo> entityInfoList = Lists.newArrayList();
+    public final List<StructureTemplate.Palette> palettes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    public final List<StructureTemplate.StructureEntityInfo> entityInfoList = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private Vec3i size;
     private String author;
 
@@ -99,9 +77,9 @@ public class StructureTemplate {
     public void fillFromWorld(Level world, BlockPos start, Vec3i dimensions, boolean includeEntities, @Nullable Block ignoredBlock) {
         if (dimensions.getX() >= 1 && dimensions.getY() >= 1 && dimensions.getZ() >= 1) {
             BlockPos blockposition1 = start.offset(dimensions).offset(-1, -1, -1);
-            List<StructureTemplate.StructureBlockInfo> list = Lists.newArrayList();
-            List<StructureTemplate.StructureBlockInfo> list1 = Lists.newArrayList();
-            List<StructureTemplate.StructureBlockInfo> list2 = Lists.newArrayList();
+            List<StructureTemplate.StructureBlockInfo> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+            List<StructureTemplate.StructureBlockInfo> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+            List<StructureTemplate.StructureBlockInfo> list2 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             BlockPos blockposition2 = new BlockPos(Math.min(start.getX(), blockposition1.getX()), Math.min(start.getY(), blockposition1.getY()), Math.min(start.getZ(), blockposition1.getZ()));
             BlockPos blockposition3 = new BlockPos(Math.max(start.getX(), blockposition1.getX()), Math.max(start.getY(), blockposition1.getY()), Math.max(start.getZ(), blockposition1.getZ()));
 
@@ -163,7 +141,7 @@ public class StructureTemplate {
         fullBlocks.sort(comparator);
         otherBlocks.sort(comparator);
         blocksWithNbt.sort(comparator);
-        List<StructureTemplate.StructureBlockInfo> list3 = Lists.newArrayList();
+        List<StructureTemplate.StructureBlockInfo> list3 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         list3.addAll(fullBlocks);
         list3.addAll(otherBlocks);
@@ -460,8 +438,8 @@ public class StructureTemplate {
     }
 
     public static List<StructureTemplate.StructureBlockInfo> processBlockInfos(ServerLevelAccessor world, BlockPos pos, BlockPos pivot, StructurePlaceSettings placementData, List<StructureTemplate.StructureBlockInfo> infos) {
-        List<StructureTemplate.StructureBlockInfo> list1 = new ArrayList();
-        List<StructureTemplate.StructureBlockInfo> list2 = new ArrayList();
+        List<StructureTemplate.StructureBlockInfo> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        List<StructureTemplate.StructureBlockInfo> list2 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Iterator iterator = infos.iterator();
 
         while (iterator.hasNext()) {
@@ -470,7 +448,6 @@ public class StructureTemplate {
             StructureTemplate.StructureBlockInfo definedstructure_blockinfo1 = new StructureTemplate.StructureBlockInfo(blockposition2, definedstructure_blockinfo.state, definedstructure_blockinfo.nbt != null ? definedstructure_blockinfo.nbt.copy() : null);
 
             for (Iterator<StructureProcessor> iterator1 = placementData.getProcessors().iterator(); definedstructure_blockinfo1 != null && iterator1.hasNext(); definedstructure_blockinfo1 = ((StructureProcessor) iterator1.next()).processBlock(world, pos, pivot, definedstructure_blockinfo, definedstructure_blockinfo1, placementData)) {
-                ;
             }
 
             if (definedstructure_blockinfo1 != null) {
@@ -525,9 +502,9 @@ public class StructureTemplate {
     private static Optional<Entity> createEntityIgnoreException(ServerLevelAccessor world, CompoundTag nbt) {
         // CraftBukkit start
         // try {
-            return EntityType.create(nbt, world.getLevel(), true); // Paper - Don't fire sync event during generation
+        return EntityType.create(nbt, world.getLevel(), true); // Paper - Don't fire sync event during generation
         // } catch (Exception exception) {
-            // return Optional.empty();
+        // return Optional.empty();
         // }
         // CraftBukkit end
     }
@@ -656,7 +633,7 @@ public class StructureTemplate {
             nbt.put("blocks", new ListTag());
             nbt.put("palette", new ListTag());
         } else {
-            List<StructureTemplate.SimplePalette> list = Lists.newArrayList();
+            List<StructureTemplate.SimplePalette> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             StructureTemplate.SimplePalette definedstructure_b = new StructureTemplate.SimplePalette();
 
             list.add(definedstructure_b);
@@ -802,9 +779,9 @@ public class StructureTemplate {
             definedstructure_b.addMapping(NbtUtils.readBlockState(blockLookup, palette.getCompound(i)), i);
         }
 
-        List<StructureTemplate.StructureBlockInfo> list = Lists.newArrayList();
-        List<StructureTemplate.StructureBlockInfo> list1 = Lists.newArrayList();
-        List<StructureTemplate.StructureBlockInfo> list2 = Lists.newArrayList();
+        List<StructureTemplate.StructureBlockInfo> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        List<StructureTemplate.StructureBlockInfo> list1 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        List<StructureTemplate.StructureBlockInfo> list2 = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (int j = 0; j < blocks.size(); ++j) {
             CompoundTag nbttagcompound = blocks.getCompound(j);
@@ -859,6 +836,7 @@ public class StructureTemplate {
 
     public static record StructureBlockInfo(BlockPos pos, BlockState state, @Nullable CompoundTag nbt) {
 
+        @Override
         public String toString() {
             return String.format(Locale.ROOT, "<StructureBlockInfo | %s | %s | %s>", this.pos, this.state, this.nbt);
         }
@@ -905,7 +883,8 @@ public class StructureTemplate {
         private final IdMapper<BlockState> ids = new IdMapper<>(16);
         private int lastId;
 
-        SimplePalette() {}
+        SimplePalette() {
+        }
 
         public int idFor(BlockState state) {
             int i = this.ids.getId(state);
@@ -925,6 +904,7 @@ public class StructureTemplate {
             return iblockdata == null ? SimplePalette.DEFAULT_BLOCK_STATE : iblockdata; // CraftBukkit - decompile error
         }
 
+        @Override
         public Iterator<BlockState> iterator() {
             return this.ids.iterator();
         }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplateManager.java b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplateManager.java
index 3ab22c384bb8a7772d389977a61d0e28975fdb79..ea1722de5970ace2941163d59a637b19fe9a1f27 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplateManager.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/templatesystem/StructureTemplateManager.java
@@ -1,33 +1,11 @@
 package net.minecraft.world.level.levelgen.structure.templatesystem;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Maps;
 import com.google.common.collect.ImmutableList.Builder;
+import com.google.common.collect.Maps;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.file.DirectoryStream;
-import java.nio.file.Files;
-import java.nio.file.InvalidPathException;
-import java.nio.file.NoSuchFileException;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.Supplier;
-import java.util.stream.Stream;
 import net.minecraft.FileUtil;
 import net.minecraft.ResourceLocationException;
 import net.minecraft.SharedConstants;
@@ -41,13 +19,22 @@ import net.minecraft.resources.FileToIdConverter;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.util.FastBufferedInputStream;
-import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.storage.LevelResource;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import org.apache.commons.io.IOUtils;
 import org.slf4j.Logger;
 
+import java.io.*;
+import java.nio.file.*;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
 public class StructureTemplateManager {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final String STRUCTURE_RESOURCE_DIRECTORY_NAME = "structure";
@@ -63,7 +50,7 @@ public class StructureTemplateManager {
     private static final FileToIdConverter RESOURCE_LISTER = new FileToIdConverter("structure", ".nbt");
 
     public StructureTemplateManager(
-        ResourceManager resourceManager, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, HolderGetter<Block> blockLookup
+            ResourceManager resourceManager, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, HolderGetter<Block> blockLookup
     ) {
         this.resourceManager = resourceManager;
         this.fixerUpper = dataFixer;
@@ -135,7 +122,7 @@ public class StructureTemplateManager {
         if (!Files.isDirectory(path)) {
             return Stream.empty();
         } else {
-            List<ResourceLocation> list = new ArrayList<>();
+            List<ResourceLocation> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             this.listFolderContents(path, "minecraft", ".snbt", list::add);
             return list.stream();
         }
@@ -155,7 +142,7 @@ public class StructureTemplateManager {
             return Stream.empty();
         } else {
             try {
-                List<ResourceLocation> list = new ArrayList<>();
+                List<ResourceLocation> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
                 try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(this.generatedDir, pathx -> Files.isDirectory(pathx))) {
                     for (Path path : directoryStream) {
@@ -178,7 +165,7 @@ public class StructureTemplateManager {
 
         try (Stream<Path> stream = Files.find(
                 directory, Integer.MAX_VALUE, (path, attributes) -> attributes.isRegularFile() && path.toString().endsWith(fileExtension)
-            )) {
+        )) {
             stream.forEach(path -> {
                 try {
                     idConsumer.accept(ResourceLocation.fromNamespaceAndPath(namespace, function.apply(this.relativize(directory, path))));
@@ -222,8 +209,8 @@ public class StructureTemplateManager {
         try {
             Optional var5;
             try (
-                InputStream inputStream = opener.open();
-                InputStream inputStream2 = new FastBufferedInputStream(inputStream);
+                    InputStream inputStream = opener.open();
+                    InputStream inputStream2 = new FastBufferedInputStream(inputStream)
             ) {
                 var5 = Optional.of(this.readStructure(inputStream2));
             }
@@ -310,6 +297,7 @@ public class StructureTemplateManager {
         InputStream open() throws IOException;
     }
 
-    static record Source(Function<ResourceLocation, Optional<StructureTemplate>> loader, Supplier<Stream<ResourceLocation>> lister) {
+    static record Source(Function<ResourceLocation, Optional<StructureTemplate>> loader,
+                         Supplier<Stream<ResourceLocation>> lister) {
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
index 89b74ee7bd2b75c4eaee7c7bca6cbadad2d9165b..8134434a852e0405ffaf798d6a0ea496874a9ec9 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
@@ -1,20 +1,15 @@
 package net.minecraft.world.level.pathfinder;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.level.PathNavigationRegion;
+
+import javax.annotation.Nullable;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Set;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
-import net.minecraft.core.BlockPos;
-import net.minecraft.util.profiling.metrics.MetricCategory;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.level.PathNavigationRegion;
 
 public class PathFinder {
     private static final float FUDGING = 1.5F;
@@ -53,7 +48,7 @@ public class PathFinder {
             return null;
         } else {
             // Paper start - Perf: remove streams and optimize collection
-            List<Map.Entry<Target, BlockPos>> map = Lists.newArrayList();
+            List<Map.Entry<Target, BlockPos>> map = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (final BlockPos pos : positions) {
                 map.add(new java.util.AbstractMap.SimpleEntry<>(nodeEvaluator.getTarget(pos.getX(), pos.getY(), pos.getZ()), pos)); // Kaiiju - petal - handle nodeEvaluatorGenerator
             }
@@ -65,7 +60,7 @@ public class PathFinder {
                 return this.findPath(node, map, followRange, distance, rangeMultiplier); // Gale - Purpur - remove vanilla profiler
             }
 
-            return new org.dreeam.leaf.async.path.AsyncPath(Lists.newArrayList(), positions, () -> {
+            return new org.dreeam.leaf.async.path.AsyncPath(new net.vansen.norspaper.collections.DynamicObjectArrayList<>(), positions, () -> {
                 try {
                     return this.processPath(nodeEvaluator, node, map, followRange, distance, rangeMultiplier);
                 } catch (Exception e) {
@@ -106,7 +101,7 @@ public class PathFinder {
         // Set<Node> set2 = ImmutableSet.of(); // Paper - unused - diff on change
         int i = 0;
         List<Map.Entry<Target, BlockPos>> entryList = Lists.newArrayListWithExpectedSize(positions.size()); // Paper - optimize collection
-        int j = (int)((float)this.maxVisitedNodes * rangeMultiplier);
+        int j = (int) ((float) this.maxVisitedNodes * rangeMultiplier);
 
         while (!this.openSet.isEmpty()) {
             if (++i >= j) {
@@ -120,7 +115,7 @@ public class PathFinder {
             for (int i1 = 0; i1 < positions.size(); i1++) {
                 final Map.Entry<Target, BlockPos> entry = positions.get(i1);
                 Target target = entry.getKey();
-                if (node.distanceManhattan(target) <= (float)distance) {
+                if (node.distanceManhattan(target) <= (float) distance) {
                     target.setReached();
                     entryList.add(entry);
                     // Paper end - Perf: remove streams and optimize collection
@@ -158,7 +153,7 @@ public class PathFinder {
         Path best = null;
         boolean entryListIsEmpty = entryList.isEmpty();
         Comparator<Path> comparator = entryListIsEmpty ? Comparator.comparingInt(Path::getNodeCount)
-            : Comparator.comparingDouble(Path::getDistToTarget).thenComparingInt(Path::getNodeCount);
+                : Comparator.comparingDouble(Path::getDistToTarget).thenComparingInt(Path::getNodeCount);
         for (Map.Entry<Target, BlockPos> entry : entryListIsEmpty ? positions : entryList) {
             Path path = this.reconstructPath(entry.getKey().getBestNode(), entry.getValue(), !entryListIsEmpty);
             if (best == null || comparator.compare(path, best) < 0)
@@ -189,7 +184,7 @@ public class PathFinder {
     }
 
     private Path reconstructPath(Node endNode, BlockPos target, boolean reachesTarget) {
-        List<Node> list = Lists.newArrayList();
+        List<Node> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Node node = endNode;
         list.add(0, endNode);
 
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index 106af2b2c7ff72c7549975aef75cdcff8d9a7d97..c034baf9c54f80d9c9dbd69eca1462f645ccff04 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -1,10 +1,6 @@
 package net.minecraft.world.level.redstone;
 
 import com.mojang.logging.LogUtils;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.world.level.Level;
@@ -12,12 +8,16 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import org.slf4j.Logger;
 
+import javax.annotation.Nullable;
+import java.util.ArrayDeque;
+import java.util.List;
+
 public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
     private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
-    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
+    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private int count = 0;
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
@@ -28,7 +28,7 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     @Override
     public void shapeUpdate(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
         this.addAndRun(
-            pos, new CollectingNeighborUpdater.ShapeUpdate(direction, neighborState, pos.immutable(), neighborPos.immutable(), flags, maxUpdateDepth)
+                pos, new CollectingNeighborUpdater.ShapeUpdate(direction, neighborState, pos.immutable(), neighborPos.immutable(), flags, maxUpdateDepth)
         );
     }
 
@@ -90,8 +90,9 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         }
     }
 
-    static record FullNeighborUpdate(BlockState state, BlockPos pos, Block block, BlockPos neighborPos, boolean movedByPiston)
-        implements CollectingNeighborUpdater.NeighborUpdates {
+    static record FullNeighborUpdate(BlockState state, BlockPos pos, Block block, BlockPos neighborPos,
+                                     boolean movedByPiston)
+            implements CollectingNeighborUpdater.NeighborUpdates {
         @Override
         public boolean runNext(Level world) {
             NeighborUpdater.executeUpdate(world, this.state, this.pos, this.block, this.neighborPos, this.movedByPiston);
@@ -122,9 +123,9 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
             // Paper start - Call BlockPhysicsEvent
             try {
                 org.bukkit.event.block.BlockPhysicsEvent event = new org.bukkit.event.block.BlockPhysicsEvent(
-                    org.bukkit.craftbukkit.block.CraftBlock.at(world, blockPos),
-                    org.bukkit.craftbukkit.block.data.CraftBlockData.fromData(blockState),
-                    org.bukkit.craftbukkit.block.CraftBlock.at(world, this.sourcePos));
+                        org.bukkit.craftbukkit.block.CraftBlock.at(world, blockPos),
+                        org.bukkit.craftbukkit.block.data.CraftBlockData.fromData(blockState),
+                        org.bukkit.craftbukkit.block.CraftBlock.at(world, this.sourcePos));
 
                 if (event.callEvent()) { // continue to check for adjacent block (increase idx)
                     NeighborUpdater.executeUpdate(world, blockState, blockPos, this.sourceBlock, this.sourcePos, false);
@@ -145,8 +146,9 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         boolean runNext(Level world);
     }
 
-    static record ShapeUpdate(Direction direction, BlockState state, BlockPos pos, BlockPos neighborPos, int updateFlags, int updateLimit)
-        implements CollectingNeighborUpdater.NeighborUpdates {
+    static record ShapeUpdate(Direction direction, BlockState state, BlockPos pos, BlockPos neighborPos,
+                              int updateFlags, int updateLimit)
+            implements CollectingNeighborUpdater.NeighborUpdates {
         @Override
         public boolean runNext(Level world) {
             NeighborUpdater.executeShapeUpdate(world, this.direction, this.state, this.pos, this.neighborPos, this.updateFlags, this.updateLimit);
@@ -154,7 +156,8 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         }
     }
 
-    static record SimpleNeighborUpdate(BlockPos pos, Block block, BlockPos neighborPos) implements CollectingNeighborUpdater.NeighborUpdates {
+    static record SimpleNeighborUpdate(BlockPos pos, Block block,
+                                       BlockPos neighborPos) implements CollectingNeighborUpdater.NeighborUpdates {
         @Override
         public boolean runNext(Level world) {
             BlockState blockState = world.getBlockState(this.pos);
diff --git a/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java b/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
index dacfac988b94a86f214dd530e08064cd6685afc8..9adf2f3ad3ffba97a692beb4cad88be55dd0499e 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -1,29 +1,16 @@
 package net.minecraft.world.level.saveddata.maps;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import io.netty.buffer.ByteBuf;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.function.Predicate;
-import javax.annotation.Nullable;
+import io.papermc.paper.adventure.PaperAdventure;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderLookup;
 import net.minecraft.core.component.DataComponents;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.nbt.ListTag;
-import net.minecraft.nbt.NbtOps;
-import net.minecraft.nbt.NumericTag;
-import net.minecraft.nbt.StringTag;
-import net.minecraft.nbt.Tag;
+import net.minecraft.nbt.*;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.codec.StreamCodec;
@@ -44,17 +31,17 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.dimension.DimensionType;
 import net.minecraft.world.level.saveddata.SavedData;
-import org.slf4j.Logger;
-
-// CraftBukkit start
-import io.papermc.paper.adventure.PaperAdventure; // Paper
-import java.util.UUID;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.map.CraftMapCursor;
 import org.bukkit.craftbukkit.map.CraftMapView;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.util.*;
+import java.util.function.Predicate;
 // CraftBukkit end
 
 public class MapItemSavedData extends SavedData {
@@ -73,7 +60,7 @@ public class MapItemSavedData extends SavedData {
     public byte scale;
     public byte[] colors = new byte[16384];
     public boolean locked;
-    public final List<MapItemSavedData.HoldingPlayer> carriedBy = Lists.newArrayList();
+    public final List<MapItemSavedData.HoldingPlayer> carriedBy = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     public final Map<Player, MapItemSavedData.HoldingPlayer> carriedByPlayers = Maps.newHashMap();
     private final Map<String, MapBanner> bannerMarkers = Maps.newHashMap();
     public final Map<String, MapDecoration> decorations = Maps.newLinkedHashMap();
@@ -337,8 +324,8 @@ public class MapItemSavedData extends SavedData {
             MapFrame worldmapframe1 = new MapFrame(blockposition, entityitemframe.getDirection().get2DDataValue() * 90, entityitemframe.getId());
 
             if (this.decorations.size() < player.level().paperConfig().maps.itemFrameCursorLimit) { // Paper - Limit item frame cursors on maps
-            this.addDecoration(MapDecorationTypes.FRAME, player.level(), MapItemSavedData.getFrameKey(entityitemframe.getId()), (double) blockposition.getX(), (double) blockposition.getZ(), (double) (entityitemframe.getDirection().get2DDataValue() * 90), (Component) null);
-            this.frameMarkers.put(worldmapframe1.getId(), worldmapframe1);
+                this.addDecoration(MapDecorationTypes.FRAME, player.level(), MapItemSavedData.getFrameKey(entityitemframe.getId()), (double) blockposition.getX(), (double) blockposition.getZ(), (double) (entityitemframe.getDirection().get2DDataValue() * 90), (Component) null);
+                this.frameMarkers.put(worldmapframe1.getId(), worldmapframe1);
             } // Paper - Limit item frame cursors on maps
         }
 
@@ -444,7 +431,8 @@ public class MapItemSavedData extends SavedData {
             }
 
             this.setDecorationsDirty();
-            if (type.value().showOnItemFrame() || (mapicon1 != null && mapicon.type().value().showOnItemFrame())) this.dirtyFrameDecorations = true; // Paper
+            if (type.value().showOnItemFrame() || (mapicon1 != null && mapicon.type().value().showOnItemFrame()))
+                this.dirtyFrameDecorations = true; // Paper
         }
 
     }
@@ -716,9 +704,11 @@ public class MapItemSavedData extends SavedData {
                 }
             });
         }
+
         private boolean shouldUseVanillaMap() {
             return mapView.getRenderers().size() == 1 && mapView.getRenderers().get(0).getClass() == org.bukkit.craftbukkit.map.CraftMapRenderer.class;
         }
+
         // Paper end
         public final Player player;
         private boolean dirtyData = true;
@@ -753,7 +743,10 @@ public class MapItemSavedData extends SavedData {
         @Nullable
         Packet<?> nextUpdatePacket(MapId mapId) {
             MapItemSavedData.MapPatch worldmap_b;
-            if (!this.dirtyData && this.tick % 5 != 0) { this.tick++; return null; } // Paper - this won't end up sending, so don't render it!
+            if (!this.dirtyData && this.tick % 5 != 0) {
+                this.tick++;
+                return null;
+            } // Paper - this won't end up sending, so don't render it!
             boolean vanillaMaps = shouldUseVanillaMap(); // Paper
             org.bukkit.craftbukkit.map.RenderData render = !vanillaMaps ? MapItemSavedData.this.mapView.render((org.bukkit.craftbukkit.entity.CraftPlayer) this.player.getBukkitEntity()) : MapItemSavedData.this.vanillaRender; // CraftBukkit // Paper
 
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/LootPool.java b/src/main/java/net/minecraft/world/level/storage/loot/LootPool.java
index 13dbadfb50278b79b33d9dce10413c93c9e4ff31..bd57fdd36de48d7369694de78340ddf7d20d9208 100644
--- a/src/main/java/net/minecraft/world/level/storage/loot/LootPool.java
+++ b/src/main/java/net/minecraft/world/level/storage/loot/LootPool.java
@@ -1,13 +1,8 @@
 package net.minecraft.world.level.storage.loot;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
-import java.util.List;
-import java.util.function.BiFunction;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
 import net.minecraft.Util;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
@@ -25,16 +20,21 @@ import net.minecraft.world.level.storage.loot.providers.number.NumberProvider;
 import net.minecraft.world.level.storage.loot.providers.number.NumberProviders;
 import org.apache.commons.lang3.mutable.MutableInt;
 
+import java.util.List;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
 public class LootPool {
     public static final Codec<LootPool> CODEC = RecordCodecBuilder.create(
-        instance -> instance.group(
-                    LootPoolEntries.CODEC.listOf().fieldOf("entries").forGetter(pool -> pool.entries),
-                    LootItemCondition.DIRECT_CODEC.listOf().optionalFieldOf("conditions", List.of()).forGetter(pool -> pool.conditions),
-                    LootItemFunctions.ROOT_CODEC.listOf().optionalFieldOf("functions", List.of()).forGetter(pool -> pool.functions),
-                    NumberProviders.CODEC.fieldOf("rolls").forGetter(pool -> pool.rolls),
-                    NumberProviders.CODEC.fieldOf("bonus_rolls").orElse(ConstantValue.exactly(0.0F)).forGetter(pool -> pool.bonusRolls)
-                )
-                .apply(instance, LootPool::new)
+            instance -> instance.group(
+                            LootPoolEntries.CODEC.listOf().fieldOf("entries").forGetter(pool -> pool.entries),
+                            LootItemCondition.DIRECT_CODEC.listOf().optionalFieldOf("conditions", List.of()).forGetter(pool -> pool.conditions),
+                            LootItemFunctions.ROOT_CODEC.listOf().optionalFieldOf("functions", List.of()).forGetter(pool -> pool.functions),
+                            NumberProviders.CODEC.fieldOf("rolls").forGetter(pool -> pool.rolls),
+                            NumberProviders.CODEC.fieldOf("bonus_rolls").orElse(ConstantValue.exactly(0.0F)).forGetter(pool -> pool.bonusRolls)
+                    )
+                    .apply(instance, LootPool::new)
     );
     public final List<LootPoolEntryContainer> entries; // Leaves - private -> public
     private final List<LootItemCondition> conditions;
@@ -45,11 +45,11 @@ public class LootPool {
     private final NumberProvider bonusRolls;
 
     LootPool(
-        List<LootPoolEntryContainer> entries,
-        List<LootItemCondition> conditions,
-        List<LootItemFunction> functions,
-        NumberProvider rolls,
-        NumberProvider bonusRolls
+            List<LootPoolEntryContainer> entries,
+            List<LootItemCondition> conditions,
+            List<LootItemFunction> functions,
+            NumberProvider rolls,
+            NumberProvider bonusRolls
     ) {
         this.entries = entries;
         this.conditions = conditions;
@@ -62,7 +62,7 @@ public class LootPool {
 
     private void addRandomItem(Consumer<ItemStack> lootConsumer, LootContext context) {
         RandomSource randomSource = context.getRandom();
-        List<LootPoolEntry> list = Lists.newArrayList();
+        List<LootPoolEntry> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         MutableInt mutableInt = new MutableInt();
 
         for (LootPoolEntryContainer lootPoolEntryContainer : this.entries) {
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java b/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java
index f09cfc472d4dbdc8cb0b6a45ef240b25a865ffba..1eaa6d23e04bf9a0e24a2d201103f63d8c0b1e20 100644
--- a/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java
+++ b/src/main/java/net/minecraft/world/level/storage/loot/LootTable.java
@@ -1,19 +1,11 @@
 package net.minecraft.world.level.storage.loot;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableList.Builder;
-import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectListIterator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.function.BiFunction;
-import java.util.function.Consumer;
 import net.minecraft.Util;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.Registries;
@@ -29,13 +21,18 @@ import net.minecraft.world.level.storage.loot.functions.LootItemFunction;
 import net.minecraft.world.level.storage.loot.functions.LootItemFunctions;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSet;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
-import org.slf4j.Logger;
-
-// CraftBukkit start
 import org.bukkit.craftbukkit.CraftLootTable;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.world.LootGenerateEvent;
+import org.slf4j.Logger;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
 // CraftBukkit end
 
 public class LootTable {
@@ -205,7 +202,7 @@ public class LootTable {
     }
 
     private void shuffleAndSplitItems(ObjectArrayList<ItemStack> drops, int freeSlots, RandomSource random) {
-        List<ItemStack> list = Lists.newArrayList();
+        List<ItemStack> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Iterator<ItemStack> iterator = drops.iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index 6e24b2c1b9ac9f1be02a6cc88085cbbcbfee1a02..2465709ba374871bdca68372b0ce4f8239dc7213 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -1,25 +1,9 @@
 package net.minecraft.world.ticks;
 
-import it.unimi.dsi.fastutil.longs.Long2LongMap;
-import it.unimi.dsi.fastutil.longs.Long2LongMaps;
-import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2LongMap.Entry;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.List;
-import java.util.LongSummaryStatistics;
-import java.util.PriorityQueue;
-import java.util.Queue;
-import java.util.Set;
-import java.util.function.BiConsumer;
-import java.util.function.LongPredicate;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -27,6 +11,11 @@ import net.minecraft.core.Vec3i;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
 
+import java.util.*;
+import java.util.function.BiConsumer;
+import java.util.function.LongPredicate;
+import java.util.function.Predicate;
+
 public class LevelTicks<T> implements LevelTickAccess<T> {
     private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
     private final LongPredicate tickCheck;
@@ -34,7 +23,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     private final Long2LongMap nextTickForContainer = Util.make(new Long2LongOpenHashMap(), map -> map.defaultReturnValue(Long.MAX_VALUE));
     private final Queue<LevelChunkTicks<T>> containersToTick = new PriorityQueue<>(CONTAINER_DRAIN_ORDER);
     private final Queue<ScheduledTick<T>> toRunThisTick = new ArrayDeque<>();
-    private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
+    private final List<ScheduledTick<T>> alreadyRunThisTick = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final Set<ScheduledTick<?>> toRunThisTickSet = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
     private final BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> chunkScheduleUpdater = (chunkTickScheduler, tick) -> {
         if (tick.equals(chunkTickScheduler.peek())) {
@@ -143,7 +132,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void drainFromCurrentContainer(
-        Queue<LevelChunkTicks<T>> tickableChunkTickSchedulers, LevelChunkTicks<T> chunkTickScheduler, long tick, int maxTicks
+            Queue<LevelChunkTicks<T>> tickableChunkTickSchedulers, LevelChunkTicks<T> chunkTickScheduler, long tick, int maxTicks
     ) {
         if (this.canScheduleMoreTicks(maxTicks)) {
             LevelChunkTicks<T> levelChunkTicks = tickableChunkTickSchedulers.peek();
@@ -152,8 +141,8 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
             while (this.canScheduleMoreTicks(maxTicks)) {
                 ScheduledTick<T> scheduledTick2 = chunkTickScheduler.peek();
                 if (scheduledTick2 == null
-                    || scheduledTick2.triggerTick() > tick
-                    || scheduledTick != null && ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(scheduledTick2, scheduledTick) > 0) {
+                        || scheduledTick2.triggerTick() > tick
+                        || scheduledTick != null && ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(scheduledTick2, scheduledTick) > 0) {
                     break;
                 }
 
@@ -209,10 +198,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void forContainersInArea(BoundingBox box, LevelTicks.PosAndContainerConsumer<T> visitor) {
-        int i = SectionPos.posToSectionCoord((double)box.minX());
-        int j = SectionPos.posToSectionCoord((double)box.minZ());
-        int k = SectionPos.posToSectionCoord((double)box.maxX());
-        int l = SectionPos.posToSectionCoord((double)box.maxZ());
+        int i = SectionPos.posToSectionCoord((double) box.minX());
+        int j = SectionPos.posToSectionCoord((double) box.minZ());
+        int k = SectionPos.posToSectionCoord((double) box.maxX());
+        int l = SectionPos.posToSectionCoord((double) box.maxZ());
 
         for (int m = i; m <= k; m++) {
             for (int n = j; n <= l; n++) {
@@ -248,7 +237,7 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     public void copyAreaFrom(LevelTicks<T> scheduler, BoundingBox box, Vec3i offset) {
-        List<ScheduledTick<T>> list = new ArrayList<>();
+        List<ScheduledTick<T>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         Predicate<ScheduledTick<T>> predicate = tick -> box.isInside(tick.pos());
         scheduler.alreadyRunThisTick.stream().filter(predicate).forEach(list::add);
         scheduler.toRunThisTick.stream().filter(predicate).forEach(list::add);
@@ -257,8 +246,8 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         long l = longSummaryStatistics.getMin();
         long m = longSummaryStatistics.getMax();
         list.forEach(
-            tick -> this.schedule(
-                    new ScheduledTick<>(tick.type(), tick.pos().offset(offset), tick.triggerTick(), tick.priority(), tick.subTickOrder() - l + m + 1L)
+                tick -> this.schedule(
+                        new ScheduledTick<>(tick.type(), tick.pos().offset(offset), tick.triggerTick(), tick.priority(), tick.subTickOrder() - l + m + 1L)
                 )
         );
     }
diff --git a/src/main/java/net/neoforged/art/internal/RenamerImpl.java b/src/main/java/net/neoforged/art/internal/RenamerImpl.java
index 73b20a92f330311e3fef8f03b51a098513afafc1..6912dbcdf2252371f410e690320467b35180ceb2 100644
--- a/src/main/java/net/neoforged/art/internal/RenamerImpl.java
+++ b/src/main/java/net/neoforged/art/internal/RenamerImpl.java
@@ -19,30 +19,6 @@
 
 package net.neoforged.art.internal;
 
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.file.Files;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-import java.util.function.Consumer;
-import java.util.stream.Collectors;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-import java.util.zip.ZipOutputStream;
-
-import net.neoforged.cliutils.JarUtils;
-import net.neoforged.cliutils.progress.ProgressReporter;
-import org.objectweb.asm.Opcodes;
-
 import net.neoforged.art.api.ClassProvider;
 import net.neoforged.art.api.Renamer;
 import net.neoforged.art.api.Transformer;
@@ -50,6 +26,18 @@ import net.neoforged.art.api.Transformer.ClassEntry;
 import net.neoforged.art.api.Transformer.Entry;
 import net.neoforged.art.api.Transformer.ManifestEntry;
 import net.neoforged.art.api.Transformer.ResourceEntry;
+import net.neoforged.cliutils.JarUtils;
+import net.neoforged.cliutils.progress.ProgressReporter;
+import org.objectweb.asm.Opcodes;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
 
 public class RenamerImpl implements Renamer { // Paper - public
     private static final ProgressReporter PROGRESS = ProgressReporter.getDefault();
@@ -94,6 +82,7 @@ public class RenamerImpl implements Renamer { // Paper - public
         // Paper start - Add remappingSelf
         this.run(input, output, false);
     }
+
     public void run(File input, File output, boolean remappingSelf) {
         // Paper end
         if (!this.setup)
@@ -116,10 +105,10 @@ public class RenamerImpl implements Renamer { // Paper - public
         logger.accept("Reading Input: " + input.getAbsolutePath());
         PROGRESS.setStep("Reading input jar");
         // Read everything from the input jar!
-        List<Entry> oldEntries = new ArrayList<>();
+        List<Entry> oldEntries = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         try (ZipFile in = new ZipFile(input)) {
             int amount = 0;
-            for (Enumeration<? extends ZipEntry> entries = in.entries(); entries.hasMoreElements();) {
+            for (Enumeration<? extends ZipEntry> entries = in.entries(); entries.hasMoreElements(); ) {
                 final ZipEntry e = entries.nextElement();
                 if (e.isDirectory())
                     continue;
@@ -167,15 +156,15 @@ public class RenamerImpl implements Renamer { // Paper - public
             PROGRESS.setStep("Processing entries");
 
             List<ClassEntry> ourClasses = oldEntries.stream()
-                .filter(e -> e instanceof ClassEntry && !e.getName().startsWith("META-INF/"))
-                .map(ClassEntry.class::cast)
-                .collect(Collectors.toList());
+                    .filter(e -> e instanceof ClassEntry && !e.getName().startsWith("META-INF/"))
+                    .map(ClassEntry.class::cast)
+                    .collect(Collectors.toList());
 
             // Add the original classes to the inheritance map, TODO: Multi-Release somehow?
             logger.accept("Adding input to inheritance map");
             ClassProvider.Builder inputClassesBuilder = ClassProvider.builder();
             async.consumeAll(ourClasses, ClassEntry::getClassName, c ->
-                inputClassesBuilder.addClass(c.getName().substring(0, c.getName().length() - 6), c.getData())
+                    inputClassesBuilder.addClass(c.getName().substring(0, c.getName().length() - 6), c.getData())
             );
             classProviders.add(0, inputClassesBuilder.build());
 
@@ -191,7 +180,7 @@ public class RenamerImpl implements Renamer { // Paper - public
             Set<String> seen = new HashSet<>();
             if (remappingSelf) {
                 // deduplicate
-                List<Entry> n = new ArrayList<>();
+                List<Entry> n = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 for (final Entry e : newEntries) {
                     if (seen.add(e.getName())) {
                         n.add(e);
@@ -199,12 +188,12 @@ public class RenamerImpl implements Renamer { // Paper - public
                 }
                 newEntries = n;
             } else {
-            String dupes = newEntries.stream().map(Entry::getName)
-                .filter(n -> !seen.add(n))
-                .sorted()
-                .collect(Collectors.joining(", "));
-            if (!dupes.isEmpty())
-                throw new IllegalStateException("Duplicate entries detected: " + dupes);
+                String dupes = newEntries.stream().map(Entry::getName)
+                        .filter(n -> !seen.add(n))
+                        .sorted()
+                        .collect(Collectors.joining(", "));
+                if (!dupes.isEmpty())
+                    throw new IllegalStateException("Duplicate entries detected: " + dupes);
             }
             // Paper end
 
@@ -297,7 +286,7 @@ public class RenamerImpl implements Renamer { // Paper - public
         if (MANIFEST_NAME.equals(o1.getName()))
             return MANIFEST_NAME.equals(o2.getName()) ? 0 : -1;
         if (MANIFEST_NAME.equals(o2.getName()))
-            return MANIFEST_NAME.equals(o1.getName()) ? 0 :  1;
+            return MANIFEST_NAME.equals(o1.getName()) ? 0 : 1;
         return o1.getName().compareTo(o2.getName());
     }
 
diff --git a/src/main/java/net/vansen/norspaper/collections/DynamicObjectArrayList.java b/src/main/java/net/vansen/norspaper/collections/DynamicObjectArrayList.java
new file mode 100644
index 0000000000000000000000000000000000000000..a83b900855f8c555f6c994c77d44fc9a41300e27
--- /dev/null
+++ b/src/main/java/net/vansen/norspaper/collections/DynamicObjectArrayList.java
@@ -0,0 +1,455 @@
+package net.vansen.norspaper.collections;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.function.UnaryOperator;
+
+@SuppressWarnings({"unchecked", "unused"})
+public class DynamicObjectArrayList<T> extends ArrayList<T> implements Cloneable {
+
+    private Object[] elements;
+    private int size;
+
+    public DynamicObjectArrayList() {
+        elements = new Object[10];
+        size = 0;
+    }
+
+    public DynamicObjectArrayList(int capacity) {
+        elements = new Object[capacity];
+        size = 0;
+    }
+
+    private void ensureCapacityInternal(int minCapacity) {
+        if (minCapacity > elements.length) {
+            int newCapacity = Math.max(minCapacity, elements.length * 2);
+            elements = Arrays.copyOf(elements, newCapacity);
+        }
+    }
+
+    @Override
+    public void trimToSize() {
+        if (size < elements.length) {
+            elements = Arrays.copyOf(elements, size);
+        }
+    }
+
+    @Override
+    public T getFirst() {
+        if (isEmpty()) {
+            throw new NoSuchElementException("List is empty");
+        }
+        return (T) elements[0];
+    }
+
+    @Override
+    public T getLast() {
+        if (isEmpty()) {
+            throw new NoSuchElementException("List is empty");
+        }
+        return (T) elements[size - 1];
+    }
+
+    @Override
+    public void addFirst(T value) {
+        add(0, value);
+    }
+
+    @Override
+    public void addLast(T value) {
+        add(value);
+    }
+
+    @Override
+    public T removeFirst() {
+        if (isEmpty()) {
+            throw new NoSuchElementException("List is empty");
+        }
+        return remove(0);
+    }
+
+    @Override
+    public T removeLast() {
+        if (isEmpty()) {
+            throw new NoSuchElementException("List is empty");
+        }
+        return remove(size - 1);
+    }
+
+    @Override
+    public T get(int index) {
+        if (index >= size || index < 0) {
+            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
+        }
+        return (T) elements[index];
+    }
+
+    @Override
+    public boolean add(T value) {
+        ensureCapacityInternal(size + 1);
+        elements[size++] = value;
+        return true;
+    }
+
+    @Override
+    public T set(int index, T value) {
+        if (index >= size || index < 0) {
+            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
+        }
+        T oldValue = (T) elements[index];
+        elements[index] = value;
+        return oldValue;
+    }
+
+    @Override
+    public void add(int index, T value) {
+        if (index > size || index < 0) {
+            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
+        }
+        ensureCapacityInternal(size + 1);
+        System.arraycopy(elements, index, elements, index + 1, size - index);
+        elements[index] = value;
+        size++;
+    }
+
+    @Override
+    public T remove(int index) {
+        if (index >= size || index < 0) {
+            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
+        }
+        T oldValue = (T) elements[index];
+        System.arraycopy(elements, index + 1, elements, index, size - index - 1);
+        elements[--size] = null;
+        return oldValue;
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        int index = indexOf(o);
+        if (index >= 0) {
+            remove(index);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void clear() {
+        Arrays.fill(elements, 0, size, null);
+        size = 0;
+    }
+
+    @Override
+    public int size() {
+        return size;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return size == 0;
+    }
+
+    @Override
+    public Object[] toArray() {
+        return Arrays.copyOf(elements, size);
+    }
+
+    @Override
+    public <T1> T1[] toArray(T1[] a) {
+        if (a.length < size) {
+            return (T1[]) Arrays.copyOf(elements, size, a.getClass());
+        }
+        System.arraycopy(elements, 0, a, 0, size);
+        if (a.length > size) {
+            a[size] = null;
+        }
+        return a;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+        Object[] array = c.toArray();
+        int newElements = array.length;
+        ensureCapacityInternal(size + newElements);
+        System.arraycopy(array, 0, elements, size, newElements);
+        size += newElements;
+        return newElements > 0;
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+        Object[] array = c.toArray();
+        int newElements = array.length;
+        ensureCapacityInternal(size + newElements);
+        System.arraycopy(elements, index, elements, index + newElements, size - index);
+        System.arraycopy(array, 0, elements, index, newElements);
+        size += newElements;
+        return newElements > 0;
+    }
+
+    @Override
+    public void removeRange(int fromIndex, int toIndex) {
+        if (fromIndex < 0 || toIndex > size || fromIndex > toIndex) {
+            throw new IndexOutOfBoundsException();
+        }
+        System.arraycopy(elements, toIndex, elements, fromIndex, size - toIndex);
+        int newSize = size - (toIndex - fromIndex);
+        Arrays.fill(elements, newSize, size, null);
+        size = newSize;
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        boolean modified = false;
+        for (Object item : c) {
+            while (remove(item)) {
+                modified = true;
+            }
+        }
+        return modified;
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        boolean modified = false;
+        for (int i = size - 1; i >= 0; i--) {
+            if (!c.contains(elements[i])) {
+                remove(i);
+                modified = true;
+            }
+        }
+        return modified;
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return new Iterator<>() {
+            private int cursor = 0;
+
+            @Override
+            public boolean hasNext() {
+                return cursor < size;
+            }
+
+            @Override
+            public T next() {
+                if (cursor >= size) {
+                    throw new NoSuchElementException();
+                }
+                return (T) elements[cursor++];
+            }
+        };
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return listIterator(0);
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+        if (index < 0 || index > size) {
+            throw new IndexOutOfBoundsException("Index: " + index);
+        }
+        return new ListIterator<>() {
+            private int cursor;
+            private int lastReturned = -1; // track
+
+            @Override
+            public boolean hasNext() {
+                return cursor < size;
+            }
+
+            @Override
+            public T next() {
+                if (cursor >= size) {
+                    throw new NoSuchElementException();
+                }
+                lastReturned = cursor;
+                return (T) elements[cursor++];
+            }
+
+            @Override
+            public boolean hasPrevious() {
+                return cursor > 0;
+            }
+
+            @Override
+            public T previous() {
+                if (cursor <= 0) {
+                    throw new NoSuchElementException();
+                }
+                lastReturned = --cursor;
+                return (T) elements[cursor];
+            }
+
+            @Override
+            public int nextIndex() {
+                return cursor;
+            }
+
+            @Override
+            public int previousIndex() {
+                return cursor - 1;
+            }
+
+            @Override
+            public void remove() {
+                if (lastReturned == -1) {
+                    throw new IllegalStateException("remove() called before next() or previous()");
+                }
+                DynamicObjectArrayList.this.remove(lastReturned);
+                if (lastReturned < cursor) {
+                    cursor--;
+                }
+                lastReturned = -1;
+            }
+
+            @Override
+            public void set(T t) {
+                if (lastReturned == -1) {
+                    throw new IllegalStateException("set() called before next() or previous()");
+                }
+                DynamicObjectArrayList.this.set(lastReturned, t);
+            }
+
+            @Override
+            public void add(T t) {
+                DynamicObjectArrayList.this.add(cursor, t);
+                cursor++;
+                lastReturned = -1;
+            }
+        };
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+        if (fromIndex < 0 || toIndex > size || fromIndex > toIndex) {
+            throw new IndexOutOfBoundsException();
+        }
+        DynamicObjectArrayList<T> subList = new DynamicObjectArrayList<>(toIndex - fromIndex);
+        for (int i = fromIndex; i < toIndex; i++) {
+            subList.add((T) elements[i]);
+        }
+        return subList;
+    }
+
+    @Override
+    public void forEach(Consumer<? super T> action) {
+        Objects.requireNonNull(action);
+        for (int i = 0; i < size; i++) {
+            action.accept((T) elements[i]);
+        }
+    }
+
+    @Override
+    public Spliterator<T> spliterator() {
+        return Arrays.spliterator((T[]) elements, 0, size);
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super T> filter) {
+        Objects.requireNonNull(filter);
+        boolean removed = false;
+        for (int i = size - 1; i >= 0; i--) {
+            if (filter.test((T) elements[i])) {
+                remove(i);
+                removed = true;
+            }
+        }
+        return removed;
+    }
+
+    @Override
+    public void replaceAll(UnaryOperator<T> operator) {
+        Objects.requireNonNull(operator);
+        for (int i = 0; i < size; i++) {
+            elements[i] = operator.apply((T) elements[i]);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof List)) {
+            return false;
+        }
+        List<?> other = (List<?>) o;
+        if (size != other.size()) {
+            return false;
+        }
+        Iterator<?> it = other.iterator();
+        for (int i = 0; i < size; i++) {
+            if (!Objects.equals(elements[i], it.next())) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public void sort(Comparator<? super T> c) {
+        if (c == null) {
+            throw new NullPointerException("Comparator must not be null");
+        }
+        Arrays.sort((T[]) elements, 0, size, c);
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return indexOf(o) >= 0;
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        if (o == null) {
+            for (int i = 0; i < size; i++) {
+                if (elements[i] == null) {
+                    return i;
+                }
+            }
+        } else {
+            for (int i = 0; i < size; i++) {
+                if (o.equals(elements[i])) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        if (o == null) {
+            for (int i = size - 1; i >= 0; i--) {
+                if (elements[i] == null) {
+                    return i;
+                }
+            }
+        } else {
+            for (int i = size - 1; i >= 0; i--) {
+                if (o.equals(elements[i])) {
+                    return i;
+                }
+            }
+        }
+        return -1;
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> c) {
+        return c.stream().allMatch(this::contains);
+    }
+
+    @Override
+    public DynamicObjectArrayList<T> clone() {
+        DynamicObjectArrayList<T> clone = (DynamicObjectArrayList<T>) super.clone();
+        clone.elements = Arrays.copyOf(elements, elements.length);
+        return clone;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/vansen/norspaper/plugin/PluginDownloader.java b/src/main/java/net/vansen/norspaper/plugin/PluginDownloader.java
index 56d1efd052c2b02aa2bbc177d992c99b81b0cb73..63efb7ad21b8053bdd3432d53c35223d2850d9ed 100644
--- a/src/main/java/net/vansen/norspaper/plugin/PluginDownloader.java
+++ b/src/main/java/net/vansen/norspaper/plugin/PluginDownloader.java
@@ -115,7 +115,7 @@ public class PluginDownloader {
      * Installs required plugins based on configuration.
      */
     public static void installRequiredPlugins() {
-        List<CompletableFuture<Void>> futures = new ArrayList<>();
+        List<CompletableFuture<Void>> futures = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         if (ConfigVariables.INSTALL_PLUGINMANX_ON_SERVER_START) {
             futures.add(downloadPlugin("PluginManX", getPluginDownloadURL("88135")));
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index c7d806f7e2ddef2226be1efbe794f0da4c331615..2f9fef239efca3da69b016b15ce02f590dfe851b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -14,33 +14,7 @@ import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
-import java.awt.image.BufferedImage;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.net.InetAddress;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.function.Consumer;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import java.util.stream.Collectors;
-import javax.imageio.ImageIO;
-// import jline.console.ConsoleReader;
+import net.md_5.bungee.api.chat.BaseComponent;
 import net.minecraft.advancements.AdvancementHolder;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
@@ -67,11 +41,7 @@ import net.minecraft.server.dedicated.DedicatedServerSettings;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.TicketType;
-import net.minecraft.server.players.IpBanListEntry;
-import net.minecraft.server.players.PlayerList;
-import net.minecraft.server.players.ServerOpListEntry;
-import net.minecraft.server.players.UserBanListEntry;
-import net.minecraft.server.players.UserWhiteListEntry;
+import net.minecraft.server.players.*;
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.GsonHelper;
 import net.minecraft.util.datafix.DataFixers;
@@ -80,11 +50,7 @@ import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.ai.village.VillageSiege;
 import net.minecraft.world.entity.npc.CatSpawner;
 import net.minecraft.world.entity.npc.WanderingTraderSpawner;
-import net.minecraft.world.inventory.AbstractContainerMenu;
-import net.minecraft.world.inventory.CraftingContainer;
-import net.minecraft.world.inventory.CraftingMenu;
-import net.minecraft.world.inventory.ResultContainer;
-import net.minecraft.world.inventory.TransientCraftingContainer;
+import net.minecraft.world.inventory.*;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.MapItem;
 import net.minecraft.world.item.crafting.CraftingRecipe;
@@ -111,38 +77,12 @@ import net.minecraft.world.level.storage.PlayerDataStorage;
 import net.minecraft.world.level.storage.PrimaryLevelData;
 import net.minecraft.world.level.validation.ContentValidationException;
 import net.minecraft.world.phys.Vec3;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.GameMode;
-import org.bukkit.Keyed;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.NamespacedKey;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Registry;
-import org.bukkit.Server;
-import org.bukkit.ServerLinks;
-import org.bukkit.ServerTickManager;
-import org.bukkit.StructureType;
-import org.bukkit.UnsafeValues;
+import org.bukkit.*;
 import org.bukkit.Warning.WarningState;
-import org.bukkit.World;
 import org.bukkit.World.Environment;
-import org.bukkit.WorldBorder;
-import org.bukkit.WorldCreator;
 import org.bukkit.block.data.BlockData;
-import org.bukkit.boss.BarColor;
-import org.bukkit.boss.BarFlag;
-import org.bukkit.boss.BarStyle;
-import org.bukkit.boss.BossBar;
-import org.bukkit.boss.KeyedBossBar;
-import org.bukkit.command.Command;
-import org.bukkit.command.CommandException;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.command.PluginCommand;
-import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.boss.*;
+import org.bukkit.command.*;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
@@ -160,21 +100,7 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.generator.CraftWorldInfo;
 import org.bukkit.craftbukkit.generator.OldCraftChunkData;
 import org.bukkit.craftbukkit.help.SimpleHelpMap;
-import org.bukkit.craftbukkit.inventory.CraftBlastingRecipe;
-import org.bukkit.craftbukkit.inventory.CraftCampfireRecipe;
-import org.bukkit.craftbukkit.inventory.CraftFurnaceRecipe;
-import org.bukkit.craftbukkit.inventory.CraftItemCraftResult;
-import org.bukkit.craftbukkit.inventory.CraftItemFactory;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.inventory.CraftMerchantCustom;
-import org.bukkit.craftbukkit.inventory.CraftRecipe;
-import org.bukkit.craftbukkit.inventory.CraftShapedRecipe;
-import org.bukkit.craftbukkit.inventory.CraftShapelessRecipe;
-import org.bukkit.craftbukkit.inventory.CraftSmithingTransformRecipe;
-import org.bukkit.craftbukkit.inventory.CraftSmithingTrimRecipe;
-import org.bukkit.craftbukkit.inventory.CraftSmokingRecipe;
-import org.bukkit.craftbukkit.inventory.CraftStonecuttingRecipe;
-import org.bukkit.craftbukkit.inventory.RecipeIterator;
+import org.bukkit.craftbukkit.inventory.*;
 import org.bukkit.craftbukkit.inventory.util.CraftInventoryCreator;
 import org.bukkit.craftbukkit.map.CraftMapColorCache;
 import org.bukkit.craftbukkit.map.CraftMapCursor;
@@ -193,15 +119,7 @@ import org.bukkit.craftbukkit.tag.CraftBlockTag;
 import org.bukkit.craftbukkit.tag.CraftEntityTag;
 import org.bukkit.craftbukkit.tag.CraftFluidTag;
 import org.bukkit.craftbukkit.tag.CraftItemTag;
-import org.bukkit.craftbukkit.util.ApiVersion;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-import org.bukkit.craftbukkit.util.CraftIconCache;
-import org.bukkit.craftbukkit.util.CraftLocation;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
-import org.bukkit.craftbukkit.util.CraftSpawnCategory;
-import org.bukkit.craftbukkit.util.DatFileFilter;
-import org.bukkit.craftbukkit.util.Versioning;
+import org.bukkit.craftbukkit.util.*;
 import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
@@ -217,23 +135,7 @@ import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.generator.WorldInfo;
 import org.bukkit.help.HelpMap;
-import org.bukkit.inventory.BlastingRecipe;
-import org.bukkit.inventory.CampfireRecipe;
-import org.bukkit.inventory.ComplexRecipe;
-import org.bukkit.inventory.FurnaceRecipe;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryHolder;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemCraftResult;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.Merchant;
-import org.bukkit.inventory.Recipe;
-import org.bukkit.inventory.ShapedRecipe;
-import org.bukkit.inventory.ShapelessRecipe;
-import org.bukkit.inventory.SmithingTransformRecipe;
-import org.bukkit.inventory.SmithingTrimRecipe;
-import org.bukkit.inventory.SmokingRecipe;
-import org.bukkit.inventory.StonecuttingRecipe;
+import org.bukkit.inventory.*;
 import org.bukkit.loot.LootTable;
 import org.bukkit.map.MapPalette;
 import org.bukkit.map.MapView;
@@ -241,12 +143,7 @@ import org.bukkit.packs.DataPackManager;
 import org.bukkit.packs.ResourcePack;
 import org.bukkit.permissions.Permissible;
 import org.bukkit.permissions.Permission;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.PluginLoadOrder;
-import org.bukkit.plugin.PluginManager;
-import org.bukkit.plugin.ServicesManager;
-import org.bukkit.plugin.SimplePluginManager;
-import org.bukkit.plugin.SimpleServicesManager;
+import org.bukkit.plugin.*;
 import org.bukkit.plugin.messaging.Messenger;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.profile.PlayerProfile;
@@ -260,10 +157,17 @@ import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
-import net.md_5.bungee.api.chat.BaseComponent; // Spigot
-
-import javax.annotation.Nullable; // Paper
-import javax.annotation.Nonnull; // Paper
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.*;
+import java.net.InetAddress;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.stream.Collectors;
 
 public final class CraftServer implements Server {
     private final String serverName = io.papermc.paper.ServerBuildInfo.buildInfo().brandName(); // Paper
@@ -337,14 +241,14 @@ public final class CraftServer implements Server {
     @Override
     public final boolean isOwnedByCurrentRegion(World world, io.papermc.paper.math.Position position) {
         return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(
-            ((CraftWorld) world).getHandle(), position.blockX() >> 4, position.blockZ() >> 4
+                ((CraftWorld) world).getHandle(), position.blockX() >> 4, position.blockZ() >> 4
         );
     }
 
     @Override
     public final boolean isOwnedByCurrentRegion(World world, io.papermc.paper.math.Position position, int squareRadiusChunks) {
         return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(
-            ((CraftWorld) world).getHandle(), position.blockX() >> 4, position.blockZ() >> 4, squareRadiusChunks
+                ((CraftWorld) world).getHandle(), position.blockX() >> 4, position.blockZ() >> 4, squareRadiusChunks
         );
     }
 
@@ -352,7 +256,7 @@ public final class CraftServer implements Server {
     public final boolean isOwnedByCurrentRegion(Location location) {
         World world = location.getWorld();
         return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(
-            ((CraftWorld) world).getHandle(), location.getBlockX() >> 4, location.getBlockZ() >> 4
+                ((CraftWorld) world).getHandle(), location.getBlockX() >> 4, location.getBlockZ() >> 4
         );
     }
 
@@ -360,21 +264,21 @@ public final class CraftServer implements Server {
     public final boolean isOwnedByCurrentRegion(Location location, int squareRadiusChunks) {
         World world = location.getWorld();
         return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(
-            ((CraftWorld) world).getHandle(), location.getBlockX() >> 4, location.getBlockZ() >> 4, squareRadiusChunks
+                ((CraftWorld) world).getHandle(), location.getBlockX() >> 4, location.getBlockZ() >> 4, squareRadiusChunks
         );
     }
 
     @Override
     public final boolean isOwnedByCurrentRegion(World world, int chunkX, int chunkZ) {
         return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(
-            ((CraftWorld) world).getHandle(), chunkX, chunkZ
+                ((CraftWorld) world).getHandle(), chunkX, chunkZ
         );
     }
 
     @Override
     public final boolean isOwnedByCurrentRegion(World world, int chunkX, int chunkZ, int squareRadiusChunks) {
         return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(
-            ((CraftWorld) world).getHandle(), chunkX, chunkZ, squareRadiusChunks
+                ((CraftWorld) world).getHandle(), chunkX, chunkZ, squareRadiusChunks
         );
     }
 
@@ -413,10 +317,11 @@ public final class CraftServer implements Server {
         this.pluginManager = new SimplePluginManager(this, commandMap);
         this.paperPluginManager = new io.papermc.paper.plugin.manager.PaperPluginManagerImpl(this, this.commandMap, pluginManager);
         this.pluginManager.paperPluginManager = this.paperPluginManager;
-         // Paper end
+        // Paper end
         // Purpur start
         org.purpurmc.purpur.language.Language.setLanguage(new org.purpurmc.purpur.language.Language() {
             private net.minecraft.locale.Language language = net.minecraft.locale.Language.getInstance();
+
             @Override
             public boolean has(@org.jetbrains.annotations.NotNull String key) {
                 return language.has(key);
@@ -571,9 +476,8 @@ public final class CraftServer implements Server {
     }
 
     private List<File> extraPluginJars() {
-        @SuppressWarnings("unchecked")
-        final List<File> jars = (List<File>) this.console.options.valuesOf("add-plugin");
-        final List<File> list = new ArrayList<>();
+        @SuppressWarnings("unchecked") final List<File> jars = (List<File>) this.console.options.valuesOf("add-plugin");
+        final List<File> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final File file : jars) {
             if (!file.exists()) {
                 net.minecraft.server.MinecraftServer.LOGGER.warn("File '{}' specified through 'add-plugin' argument does not exist, cannot load a plugin from it!", file.getAbsolutePath());
@@ -597,7 +501,8 @@ public final class CraftServer implements Server {
         if (type == PluginLoadOrder.STARTUP) {
             this.helpMap.clear();
             this.helpMap.initializeGeneralTopics();
-            if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins) loadCustomPermissions(); // Paper
+            if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins)
+                loadCustomPermissions(); // Paper
         }
 
         Plugin[] plugins = this.pluginManager.getPlugins();
@@ -617,7 +522,8 @@ public final class CraftServer implements Server {
             this.commandMap.registerServerAliases();
             DefaultPermissions.registerCorePermissions();
             CraftDefaultPermissions.registerCorePermissions();
-            if (!io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins) this.loadCustomPermissions(); // Paper
+            if (!io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins)
+                this.loadCustomPermissions(); // Paper
             this.helpMap.initializeCommands();
             this.syncCommands();
         }
@@ -643,14 +549,14 @@ public final class CraftServer implements Server {
     private void enablePlugin(Plugin plugin) {
         try {
             List<Permission> perms = plugin.getDescription().getPermissions();
-            List<Permission> permsToLoad = new ArrayList<>(); // Paper
+            List<Permission> permsToLoad = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // Paper
             for (Permission perm : perms) {
                 // Paper start
                 if (this.paperPluginManager.getPermission(perm.getName()) == null) {
                     permsToLoad.add(perm);
                 } else {
                     this.getLogger().log(Level.WARNING, "Plugin " + plugin.getDescription().getFullName() + " tried to register permission '" + perm.getName() + "' but it's already registered");
-                // Paper end
+                    // Paper end
                 }
             }
             this.paperPluginManager.addPermissions(permsToLoad); // Paper
@@ -747,7 +653,7 @@ public final class CraftServer implements Server {
     public List<Player> matchPlayer(String partialName) {
         Preconditions.checkArgument(partialName != null, "partialName cannot be null");
 
-        List<Player> matchedPlayers = new ArrayList<>();
+        List<Player> matchedPlayers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Player iterPlayer : this.getOnlinePlayers()) {
             String iterPlayerName = iterPlayer.getName();
@@ -1133,7 +1039,8 @@ public final class CraftServer implements Server {
         while (pollCount < 50 && this.getScheduler().getActiveWorkers().size() > 0) {
             try {
                 Thread.sleep(50);
-            } catch (InterruptedException e) {}
+            } catch (InterruptedException e) {
+            }
             pollCount++;
         }
 
@@ -1141,19 +1048,21 @@ public final class CraftServer implements Server {
         for (BukkitWorker worker : overdueWorkers) {
             Plugin plugin = worker.getOwner();
             this.getLogger().log(Level.SEVERE, String.format(
-                "Nag author(s): '%s' of '%s' about the following: %s",
-                plugin.getDescription().getAuthors(),
-                plugin.getDescription().getFullName(),
-                "This plugin is not properly shutting down its async tasks when it is being reloaded.  This may cause conflicts with the newly loaded version of the plugin"
+                    "Nag author(s): '%s' of '%s' about the following: %s",
+                    plugin.getDescription().getAuthors(),
+                    plugin.getDescription().getFullName(),
+                    "This plugin is not properly shutting down its async tasks when it is being reloaded.  This may cause conflicts with the newly loaded version of the plugin"
             ));
-            if (console.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper - Debugging
+            if (console.isDebugging())
+                io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper - Debugging
         }
         io.papermc.paper.plugin.PluginInitializerManager.reload(this.console); // Paper
         this.loadPlugins();
         this.enablePlugins(PluginLoadOrder.STARTUP);
         this.enablePlugins(PluginLoadOrder.POSTWORLD);
         this.spark.registerCommandAfterPlugins(this); // Paper - spark
-        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null) io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.pluginsEnabled(); // Paper - Remap plugins
+        if (io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper != null)
+            io.papermc.paper.plugin.PluginInitializerManager.instance().pluginRemapper.pluginsEnabled(); // Paper - Remap plugins
         // Paper start - brigadier command API
         io.papermc.paper.command.brigadier.PaperCommands.INSTANCE.setValid(); // to clear invalid state for event fire below
         io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.INSTANCE.callReloadableRegistrarEvent(io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents.COMMANDS, io.papermc.paper.command.brigadier.PaperCommands.INSTANCE, org.bukkit.plugin.Plugin.class, io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEvent.Cause.RELOAD); // call commands event for regular plugins
@@ -1169,10 +1078,11 @@ public final class CraftServer implements Server {
         int pollCount = 0;
 
         // Wait for at most 5 seconds for plugins to close their threads
-        while (pollCount < 10*5 && getScheduler().getActiveWorkers().size() > 0) {
+        while (pollCount < 10 * 5 && getScheduler().getActiveWorkers().size() > 0) {
             try {
                 Thread.sleep(100);
-            } catch (InterruptedException e) {}
+            } catch (InterruptedException e) {
+            }
             pollCount++;
         }
 
@@ -1180,10 +1090,10 @@ public final class CraftServer implements Server {
         for (BukkitWorker worker : overdueWorkers) {
             Plugin plugin = worker.getOwner();
             getLogger().log(Level.SEVERE, String.format(
-                "Nag author(s): '%s' of '%s' about the following: %s",
-                plugin.getPluginMeta().getAuthors(),
-                plugin.getPluginMeta().getDisplayName(),
-                "This plugin is not properly shutting down its async tasks when it is being shut down. This task may throw errors during the final shutdown logs and might not complete before process dies."
+                    "Nag author(s): '%s' of '%s' about the following: %s",
+                    plugin.getPluginMeta().getAuthors(),
+                    plugin.getPluginMeta().getDisplayName(),
+                    "This plugin is not properly shutting down its async tasks when it is being shut down. This task may throw errors during the final shutdown logs and might not complete before process dies."
             ));
             // Gale start - Airplane - print stack trace for plugins not shutting down tasks
             getLogger().log(Level.SEVERE, String.format("%s Stacktrace", worker.getThread().getName()));
@@ -1192,7 +1102,8 @@ public final class CraftServer implements Server {
                 getLogger().log(Level.SEVERE, "  " + element.toString());
             }
             // Gale end - Airplane - print stack trace for plugins not shutting down tasks
-            if (console.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper - Debugging
+            if (console.isDebugging())
+                io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper - Debugging
         }
     }
     // Paper end - Wait for Async Tasks during shutdown
@@ -1226,7 +1137,7 @@ public final class CraftServer implements Server {
         }
     }
 
-    @SuppressWarnings({ "unchecked", "finally" })
+    @SuppressWarnings({"unchecked", "finally"})
     private void loadCustomPermissions() {
         File file = new File(this.configuration.getString("settings.permissions-file"));
         FileInputStream stream;
@@ -1254,7 +1165,8 @@ public final class CraftServer implements Server {
         } finally {
             try {
                 stream.close();
-            } catch (IOException ex) {}
+            } catch (IOException ex) {
+            }
         }
 
         if (perms == null) {
@@ -1677,7 +1589,8 @@ public final class CraftServer implements Server {
 
     @Override
     public void sendBlockHighlight(Location location, int duration, String text, org.bukkit.Color color, int transparency) {
-        if (transparency < 0 || transparency > 255) throw new IllegalArgumentException("transparency is outside of 0-255 range");
+        if (transparency < 0 || transparency > 255)
+            throw new IllegalArgumentException("transparency is outside of 0-255 range");
         sendBlockHighlight(location, duration, text, transparency << 24 | color.asRGB());
     }
 
@@ -1920,6 +1833,7 @@ public final class CraftServer implements Server {
         String msg = getShutdownMessage();
         return msg != null ? net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(msg) : null;
     }
+
     // Paper end
     @Override
     @Deprecated // Paper
@@ -2094,6 +2008,7 @@ public final class CraftServer implements Server {
 
         return CraftItemStack.asBukkitCopy(stack);
     }
+
     // Paper start - copied from above (uses un-deprecated StructureType type)
     @Override
     public ItemStack createExplorerMap(World world, Location location, org.bukkit.generator.structure.StructureType structureType, org.bukkit.map.MapCursor.Type mapIcon, int radius, boolean findUnexplored) {
@@ -2164,6 +2079,7 @@ public final class CraftServer implements Server {
     }
 
     // Paper start
+    @Override
     @Nullable
     public UUID getPlayerUniqueId(String name) {
         Player player = Bukkit.getPlayerExact(name);
@@ -2332,13 +2248,13 @@ public final class CraftServer implements Server {
     @Override
     public <B extends BanList<E>, E> B getBanList(final io.papermc.paper.ban.BanListType<B> type) {
         Preconditions.checkArgument(type != null, "BanList.BanType cannot be null");
-       if (type == io.papermc.paper.ban.BanListType.IP) {
-           return (B) new CraftIpBanList(this.playerList.getIpBans());
-       } else if (type == io.papermc.paper.ban.BanListType.PROFILE) {
-          return (B) new CraftProfileBanList(this.playerList.getBans());
-       } else {
-           throw new IllegalArgumentException("Unknown BanListType: " + type);
-       }
+        if (type == io.papermc.paper.ban.BanListType.IP) {
+            return (B) new CraftIpBanList(this.playerList.getIpBans());
+        } else if (type == io.papermc.paper.ban.BanListType.PROFILE) {
+            return (B) new CraftProfileBanList(this.playerList.getBans());
+        } else {
+            throw new IllegalArgumentException("Unknown BanListType: " + type);
+        }
     }
     // Paper end - add BanListType (which has a generic)
 
@@ -2520,6 +2436,7 @@ public final class CraftServer implements Server {
     public Merchant createMerchant(net.kyori.adventure.text.Component title) {
         return new org.bukkit.craftbukkit.inventory.CraftMerchantCustom(title == null ? InventoryType.MERCHANT.defaultTitle() : title);
     }
+
     // Paper end
     @Override
     @Deprecated // Paper
@@ -2585,6 +2502,7 @@ public final class CraftServer implements Server {
         Preconditions.checkArgument(CraftSpawnCategory.isValidForLimits(spawnCategory), "SpawnCategory." + spawnCategory + " does not have a spawn limit.");
         return this.getSpawnLimitUnsafe(spawnCategory);
     }
+
     public int getSpawnLimitUnsafe(final SpawnCategory spawnCategory) {
         // Paper end - Add mobcaps commands
         return this.spawnCategoryLimit.getOrDefault(spawnCategory, -1);
@@ -2600,6 +2518,7 @@ public final class CraftServer implements Server {
     public net.kyori.adventure.text.Component motd() {
         return this.console.motd();
     }
+
     @Override
     public void motd(final net.kyori.adventure.text.Component motd) {
         this.console.motd(motd);
@@ -2647,8 +2566,7 @@ public final class CraftServer implements Server {
 
     public List<String> tabCompleteCommand(Player player, String message, ServerLevel world, Vec3 pos) {
         // Spigot Start
-        if ( (org.spigotmc.SpigotConfig.tabComplete < 0 || message.length() <= org.spigotmc.SpigotConfig.tabComplete) && !message.contains( " " ) )
-        {
+        if ((org.spigotmc.SpigotConfig.tabComplete < 0 || message.length() <= org.spigotmc.SpigotConfig.tabComplete) && !message.contains(" ")) {
             return ImmutableList.of();
         }
         // Spigot End
@@ -3039,38 +2957,32 @@ public final class CraftServer implements Server {
     }
 
     // Spigot start
-    private final org.bukkit.Server.Spigot spigot = new org.bukkit.Server.Spigot()
-    {
+    private final org.bukkit.Server.Spigot spigot = new org.bukkit.Server.Spigot() {
 
         @Deprecated
         @Override
-        public YamlConfiguration getConfig()
-        {
+        public YamlConfiguration getConfig() {
             return org.spigotmc.SpigotConfig.config;
         }
 
         @Override
-        public YamlConfiguration getBukkitConfig()
-        {
+        public YamlConfiguration getBukkitConfig() {
             return configuration;
         }
 
         @Override
-        public YamlConfiguration getSpigotConfig()
-        {
+        public YamlConfiguration getSpigotConfig() {
             return org.spigotmc.SpigotConfig.config;
         }
 
         @Override
-        public YamlConfiguration getPaperConfig()
-        {
+        public YamlConfiguration getPaperConfig() {
             return CraftServer.this.console.paperConfigurations.createLegacyObject(CraftServer.this.console);
         }
 
         // Gale start - Gale configuration - API
         @Override
-        public YamlConfiguration getGaleConfig()
-        {
+        public YamlConfiguration getGaleConfig() {
             return CraftServer.this.console.galeConfigurations.createLegacyObject(CraftServer.this.console);
         }
         // Gale end - Gale configuration - API
@@ -3107,31 +3019,32 @@ public final class CraftServer implements Server {
         }
     };
 
-    public org.bukkit.Server.Spigot spigot()
-    {
+    @Override
+    public org.bukkit.Server.Spigot spigot() {
         return this.spigot;
     }
     // Spigot end
 
     @Override
     public double[] getTPS() {
-        if (org.dreeam.leaf.config.modules.misc.Including5sIngetTPS.enabled) return getTPSIncluding5SecondAverage(); // Leaf - Including 5s in getTPS()
+        if (org.dreeam.leaf.config.modules.misc.Including5sIngetTPS.enabled)
+            return getTPSIncluding5SecondAverage(); // Leaf - Including 5s in getTPS()
 
-        return new double[] {
-            net.minecraft.server.MinecraftServer.getServer().tps1.getAverage(),
-            net.minecraft.server.MinecraftServer.getServer().tps5.getAverage(),
-            net.minecraft.server.MinecraftServer.getServer().tps15.getAverage()
+        return new double[]{
+                net.minecraft.server.MinecraftServer.getServer().tps1.getAverage(),
+                net.minecraft.server.MinecraftServer.getServer().tps5.getAverage(),
+                net.minecraft.server.MinecraftServer.getServer().tps15.getAverage()
         };
     }
 
     // Gale start - Purpur - 5 second TPS average
     @Override
     public double[] getTPSIncluding5SecondAverage() {
-        return new double[] {
-            net.minecraft.server.MinecraftServer.getServer().tps5s.getAverage(),
-            net.minecraft.server.MinecraftServer.getServer().tps1.getAverage(),
-            net.minecraft.server.MinecraftServer.getServer().tps5.getAverage(),
-            net.minecraft.server.MinecraftServer.getServer().tps15.getAverage()
+        return new double[]{
+                net.minecraft.server.MinecraftServer.getServer().tps5s.getAverage(),
+                net.minecraft.server.MinecraftServer.getServer().tps1.getAverage(),
+                net.minecraft.server.MinecraftServer.getServer().tps5.getAverage(),
+                net.minecraft.server.MinecraftServer.getServer().tps15.getAverage()
         };
     }
     // Gale end - Purpur - 5 second TPS average
@@ -3164,7 +3077,8 @@ public final class CraftServer implements Server {
     // Paper start - adventure sounds
     @Override
     public void playSound(final net.kyori.adventure.sound.Sound sound) {
-        if (sound.seed().isEmpty()) org.spigotmc.AsyncCatcher.catchOp("play sound; cannot generate seed with world random"); // Paper
+        if (sound.seed().isEmpty())
+            org.spigotmc.AsyncCatcher.catchOp("play sound; cannot generate seed with world random"); // Paper
         final long seed = sound.seed().orElseGet(this.console.overworld().getRandom()::nextLong);
         for (ServerPlayer player : this.playerList.getPlayers()) {
             player.connection.send(io.papermc.paper.adventure.PaperAdventure.asSoundPacket(sound, player.getX(), player.getY(), player.getZ(), seed, null));
@@ -3179,7 +3093,8 @@ public final class CraftServer implements Server {
 
     @Override
     public void playSound(final net.kyori.adventure.sound.Sound sound, final net.kyori.adventure.sound.Sound.Emitter emitter) {
-        if (sound.seed().isEmpty()) org.spigotmc.AsyncCatcher.catchOp("play sound; cannot generate seed with world random"); // Paper
+        if (sound.seed().isEmpty())
+            org.spigotmc.AsyncCatcher.catchOp("play sound; cannot generate seed with world random"); // Paper
         final long seed = sound.seed().orElseGet(this.console.overworld().getRandom()::nextLong);
         if (emitter == net.kyori.adventure.sound.Sound.Emitter.self()) {
             for (ServerPlayer player : this.playerList.getPlayers()) {
@@ -3232,7 +3147,9 @@ public final class CraftServer implements Server {
             return null;
         }
     }
+
     private Iterable<? extends net.kyori.adventure.audience.Audience> adventure$audiences;
+
     @Override
     public Iterable<? extends net.kyori.adventure.audience.Audience> audiences() {
         if (this.adventure$audiences == null) {
@@ -3244,7 +3161,8 @@ public final class CraftServer implements Server {
     @Override
     public void reloadPermissions() {
         pluginManager.clearPermissions();
-        if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins) loadCustomPermissions();
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins)
+            loadCustomPermissions();
         for (Plugin plugin : pluginManager.getPlugins()) {
             for (Permission perm : plugin.getDescription().getPermissions()) {
                 try {
@@ -3254,7 +3172,8 @@ public final class CraftServer implements Server {
                 }
             }
         }
-        if (!io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins) loadCustomPermissions();
+        if (!io.papermc.paper.configuration.GlobalConfiguration.get().misc.loadPermissionsYmlBeforePlugins)
+            loadCustomPermissions();
         DefaultPermissions.registerCorePermissions();
         CraftDefaultPermissions.registerCorePermissions();
     }
@@ -3338,6 +3257,7 @@ public final class CraftServer implements Server {
     }
 
     private com.destroystokyo.paper.entity.ai.MobGoals mobGoals = new com.destroystokyo.paper.entity.ai.PaperMobGoals();
+
     @Override
     public com.destroystokyo.paper.entity.ai.MobGoals getMobGoals() {
         return mobGoals;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 617c386290e525e2e81fe0e7b6d1f0b16ef8d109..d47954c0ac8bdb968460d3b3aa2338e4d31d8a09 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -5,44 +5,17 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.ExecutionException;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
-import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.HolderSet;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
-import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
-import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
-import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundSoundPacket;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.resources.ResourceLocation;
-import net.minecraft.server.level.ChunkHolder;
-import net.minecraft.server.level.ChunkMap;
-import net.minecraft.server.level.DistanceManager;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.level.Ticket;
-import net.minecraft.server.level.TicketType;
+import net.minecraft.server.level.*;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.util.SortedArraySet;
@@ -65,26 +38,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.CollisionContext;
-import org.bukkit.BlockChangeDelegate;
-import org.bukkit.Bukkit;
-import org.bukkit.Chunk;
-import org.bukkit.ChunkSnapshot;
-import org.bukkit.Difficulty;
-import org.bukkit.Effect;
-import org.bukkit.FeatureFlag;
-import org.bukkit.FluidCollisionMode;
-import org.bukkit.GameRule;
-import org.bukkit.Instrument;
-import org.bukkit.Location;
-import org.bukkit.NamespacedKey;
-import org.bukkit.Note;
-import org.bukkit.Particle;
-import org.bukkit.Raid;
-import org.bukkit.Registry;
-import org.bukkit.Sound;
-import org.bukkit.TreeType;
-import org.bukkit.World;
-import org.bukkit.WorldBorder;
+import org.bukkit.*;
 import org.bukkit.block.Biome;
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockState;
@@ -104,27 +58,10 @@ import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
-import org.bukkit.craftbukkit.util.CraftBiomeSearchResult;
-import org.bukkit.craftbukkit.util.CraftLocation;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
-import org.bukkit.craftbukkit.util.CraftRayTraceResult;
-import org.bukkit.craftbukkit.util.CraftSpawnCategory;
-import org.bukkit.craftbukkit.util.CraftStructureSearchResult;
-import org.bukkit.entity.AbstractArrow;
-import org.bukkit.entity.Arrow;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.FallingBlock;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.entity.LightningStrike;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Player;
-import org.bukkit.entity.SpawnCategory;
-import org.bukkit.entity.SpectralArrow;
-import org.bukkit.entity.TippedArrow;
-import org.bukkit.entity.Trident;
+import org.bukkit.craftbukkit.util.*;
+import org.bukkit.entity.*;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.BlockPopulator;
@@ -139,15 +76,17 @@ import org.bukkit.persistence.PersistentDataContainer;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.potion.PotionType;
-import org.bukkit.util.BiomeSearchResult;
-import org.bukkit.util.BoundingBox;
-import org.bukkit.util.NumberConversions;
-import org.bukkit.util.RayTraceResult;
-import org.bukkit.util.StructureSearchResult;
 import org.bukkit.util.Vector;
+import org.bukkit.util.*;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.io.File;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
 public class CraftWorld extends CraftRegionAccessor implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
@@ -266,8 +205,8 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         final net.minecraft.world.level.biome.Climate.Sampler sampler = serverCache.randomState().sampler();
 
         final List<Biome> possibleBiomes = finalBiomeSource.possibleBiomes().stream()
-            .map(CraftBiome::minecraftHolderToBukkit)
-            .toList();
+                .map(CraftBiome::minecraftHolderToBukkit)
+                .toList();
         return new BiomeProvider() {
             @Override
             public Biome getBiome(final org.bukkit.generator.WorldInfo worldInfo, final int x, final int y, final int z) {
@@ -280,13 +219,14 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             }
         };
     }
+
     // Paper end
     // Paper start - structure check API
     @Override
     public boolean hasStructureAt(final io.papermc.paper.math.Position position, final Structure structure) {
         return this.world.structureManager().getStructureWithPieceAt(
-            io.papermc.paper.util.MCUtil.toBlockPos(position),
-            CraftStructure.bukkitToMinecraft(structure)
+                io.papermc.paper.util.MCUtil.toBlockPos(position),
+                CraftStructure.bukkitToMinecraft(structure)
         ).isValid();
     }
     // Paper end
@@ -355,6 +295,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public boolean setSpawnLocation(int x, int y, int z) {
         return this.setSpawnLocation(x, y, z, 0.0F);
     }
+
     // Paper start
     private static void warnUnsafeChunk(String reason, int x, int z) {
         // if any chunk coord is outside of 30 million blocks
@@ -425,7 +366,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         }
         final java.util.concurrent.CompletableFuture<ChunkAccess> future = new java.util.concurrent.CompletableFuture<>();
         ca.spottedleaf.moonrise.common.util.ChunkSystem.scheduleChunkLoad(
-            this.world, x, z, false, ChunkStatus.EMPTY, true, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL, future::complete
+                this.world, x, z, false, ChunkStatus.EMPTY, true, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL, future::complete
         );
         world.getChunkSource().mainThreadProcessor.managedBlock(future::isDone);
         return future.thenApply(c -> {
@@ -525,20 +466,20 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             return false;
         }
         // Paper end - chunk system
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
-                if (playersInRange.isEmpty()) return true; // Paper - chunk system
-
-                // Paper start - Anti-Xray bypass
-                final Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
-                for (ServerPlayer player : playersInRange) {
-                    if (player.connection == null) continue;
-
-                    Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-                    player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, (Boolean) s);
-                    }));
-                    // Paper end - Anti-Xray bypass
-                }
+        List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
+        if (playersInRange.isEmpty()) return true; // Paper - chunk system
+
+        // Paper start - Anti-Xray bypass
+        final Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
+        for (ServerPlayer player : playersInRange) {
+            if (player.connection == null) continue;
+
+            Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
+            player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
+                return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, (Boolean) s);
+            }));
+            // Paper end - Anti-Xray bypass
+        }
         // Paper - chunk system
 
         return true;
@@ -676,7 +617,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @NotNull
     @Override
     public Collection<Chunk> getIntersectingChunks(@NotNull BoundingBox boundingBox) {
-        List<Chunk> chunks = new ArrayList<>();
+        List<Chunk> chunks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         int minX = NumberConversions.floor(boundingBox.getMinX()) >> 4;
         int maxX = NumberConversions.floor(boundingBox.getMaxX()) >> 4;
@@ -714,6 +655,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         return Collections.unmodifiableCollection(chunks);
     }
 
+    @Override
     public ServerLevel getHandle() {
         return this.world;
     }
@@ -808,10 +750,10 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public Location findLightningRod(Location location) {
         return this.world.findLightningRod(io.papermc.paper.util.MCUtil.toBlockPosition(location))
-            .map(blockPos -> io.papermc.paper.util.MCUtil.toLocation(this.world, blockPos)
-                // get the actual rod pos
-                .subtract(0, 1, 0))
-            .orElse(null);
+                .map(blockPos -> io.papermc.paper.util.MCUtil.toLocation(this.world, blockPos)
+                        // get the actual rod pos
+                        .subtract(0, 1, 0))
+                .orElse(null);
     }
 
     @Override
@@ -949,6 +891,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
         return !this.world.explode(source == null ? null : ((CraftEntity) source).getHandle(), x, y, z, power, setFire, explosionType).wasCanceled;
     }
+
     // Paper start
     @Override
     public boolean createExplosion(Entity source, Location loc, float power, boolean setFire, boolean breakBlocks, boolean excludeSourceFromDamage) {
@@ -1173,6 +1116,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         return rayTraceEntities((io.papermc.paper.math.Position) start, direction, maxDistance, raySize, filter);
     }
 
+    @Override
     public RayTraceResult rayTraceEntities(io.papermc.paper.math.Position start, Vector direction, double maxDistance, double raySize, Predicate<? super Entity> filter) {
         Preconditions.checkArgument(start != null, "Location start cannot be null");
         Preconditions.checkArgument(!(start instanceof Location location) || this.equals(location.getWorld()), "Location start cannot be in a different world");
@@ -1867,6 +1811,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         // Paper start - Add mobcaps commands
         return this.getSpawnLimitUnsafe(spawnCategory);
     }
+
     public final int getSpawnLimitUnsafe(final SpawnCategory spawnCategory) {
         int limit = this.spawnCategoryLimit.getOrDefault(spawnCategory, -1);
         if (limit < 0) {
@@ -1901,7 +1846,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void playSound(Location loc, Sound sound, org.bukkit.SoundCategory category, float volume, float pitch) {
-        this.playSound(loc, sound, category, volume, pitch, this.getHandle().random.nextLong());;
+        this.playSound(loc, sound, category, volume, pitch, this.getHandle().random.nextLong());
     }
 
     @Override
@@ -1957,7 +1902,8 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public void playSound(Entity entity, Sound sound, org.bukkit.SoundCategory category, float volume, float pitch, long seed) {
         org.spigotmc.AsyncCatcher.catchOp("play sound"); // Paper
-        if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
+        if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null)
+            return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(CraftSound.bukkitToMinecraftHolder(sound), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
         ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
@@ -1969,7 +1915,8 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public void playSound(Entity entity, String sound, org.bukkit.SoundCategory category, float volume, float pitch, long seed) {
         org.spigotmc.AsyncCatcher.catchOp("play sound"); // Paper
-        if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
+        if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null)
+            return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(Holder.direct(SoundEvent.createVariableRangeEvent(ResourceLocation.parse(sound))), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
         ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
@@ -1977,6 +1924,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             entityTracker.broadcastAndSend(packet);
         }
     }
+
     // Paper start - Adventure
     @Override
     public void playSound(final net.kyori.adventure.sound.Sound sound) {
@@ -2015,6 +1963,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Paper end
 
     private static Map<String, GameRules.Key<?>> gamerules;
+
     public static synchronized Map<String, GameRules.Key<?>> getGameRulesNMS() {
         if (CraftWorld.gamerules != null) {
             return CraftWorld.gamerules;
@@ -2032,6 +1981,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
 
     private static Map<String, GameRules.Type<?>> gameruleDefinitions;
+
     public static synchronized Map<String, GameRules.Type<?>> getGameRuleDefinitions() {
         if (CraftWorld.gameruleDefinitions != null) {
             return CraftWorld.gameruleDefinitions;
@@ -2211,6 +2161,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         // Paper start - Particle API
         this.spawnParticle(particle, null, null, x, y, z, count, offsetX, offsetY, offsetZ, extra, data, force);
     }
+
     @Override
     public <T> void spawnParticle(Particle particle, List<Player> receivers, Player sender, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
         // Paper end - Particle API
@@ -2280,7 +2231,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
-        List<Structure> structures = new ArrayList<>();
+        List<Structure> structures = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (Structure structure : Registry.STRUCTURE) {
             if (structure.getStructureType() == structureType) {
                 structures.add(structure);
@@ -2297,7 +2248,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     public StructureSearchResult locateNearestStructure(Location origin, List<Structure> structures, int radius, boolean findUnexplored) {
         BlockPos originPos = BlockPos.containing(origin.getX(), origin.getY(), origin.getZ());
-        List<Holder<net.minecraft.world.level.levelgen.structure.Structure>> holders = new ArrayList<>();
+        List<Holder<net.minecraft.world.level.levelgen.structure.Structure>> holders = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Structure structure : structures) {
             holders.add(Holder.direct(CraftStructure.bukkitToMinecraft(structure)));
@@ -2329,7 +2280,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void sendGameEvent(Entity sourceEntity, org.bukkit.GameEvent gameEvent, Vector position) {
-        getHandle().gameEvent(sourceEntity != null ? ((CraftEntity) sourceEntity).getHandle(): null, net.minecraft.core.registries.BuiltInRegistries.GAME_EVENT.getHolder(org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(gameEvent.getKey())).orElseThrow(), org.bukkit.craftbukkit.util.CraftVector.toBlockPos(position));
+        getHandle().gameEvent(sourceEntity != null ? ((CraftEntity) sourceEntity).getHandle() : null, net.minecraft.core.registries.BuiltInRegistries.GAME_EVENT.getHolder(org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(gameEvent.getKey())).orElseThrow(), org.bukkit.craftbukkit.util.CraftVector.toBlockPos(position));
     }
     // Paper end
 
@@ -2387,6 +2338,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
 
     // Purpur start
+    @Override
     public float getLocalDifficultyAt(Location location) {
         return getHandle().getCurrentDifficultyAt(io.papermc.paper.util.MCUtil.toBlockPosition(location)).getEffectiveDifficulty();
     }
@@ -2418,7 +2370,8 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void sendBlockHighlight(Location location, int duration, String text, org.bukkit.Color color, int transparency) {
-        if (transparency < 0 || transparency > 255) throw new IllegalArgumentException("transparency is outside of 0-255 range");
+        if (transparency < 0 || transparency > 255)
+            throw new IllegalArgumentException("transparency is outside of 0-255 range");
         sendBlockHighlight(location, duration, text, transparency << 24 | color.asRGB());
     }
 
@@ -2444,7 +2397,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
 
     private List<GeneratedStructure> getStructures(int x, int z, Predicate<net.minecraft.world.level.levelgen.structure.Structure> predicate) {
-        List<GeneratedStructure> structures = new ArrayList<>();
+        List<GeneratedStructure> structures = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (StructureStart start : this.getHandle().structureManager().startsForStructure(new ChunkPos(x, z), predicate)) {
             structures.add(new CraftGeneratedStructure(start));
         }
@@ -2472,28 +2425,27 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
 
     // Spigot start
-    private final org.bukkit.World.Spigot spigot = new org.bukkit.World.Spigot()
-    {
+    private final org.bukkit.World.Spigot spigot = new org.bukkit.World.Spigot() {
 
         @Override
-        public LightningStrike strikeLightning(Location loc, boolean isSilent)
-        {
+        public LightningStrike strikeLightning(Location loc, boolean isSilent) {
             return CraftWorld.this.strikeLightning(loc);
         }
 
         @Override
-        public LightningStrike strikeLightningEffect(Location loc, boolean isSilent)
-        {
+        public LightningStrike strikeLightningEffect(Location loc, boolean isSilent) {
             return CraftWorld.this.strikeLightningEffect(loc);
         }
     };
 
-    public org.bukkit.World.Spigot spigot()
-    {
+    @Override
+    public org.bukkit.World.Spigot spigot() {
         return this.spigot;
     }
+
     // Spigot end
     // Paper start
+    @Override
     public java.util.concurrent.CompletableFuture<Chunk> getChunkAtAsync(int x, int z, boolean gen, boolean urgent) {
         warnUnsafeChunk("getting a faraway chunk async", x, z); // Paper
         if (Bukkit.isPrimaryThread()) {
@@ -2514,7 +2466,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
         ca.spottedleaf.moonrise.common.util.ChunkSystem.scheduleChunkLoad(this.getHandle(), x, z, gen, ChunkStatus.FULL, true, priority, (c) -> {
             net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(() -> {
-                net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk)c;
+                net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk) c;
                 if (chunk != null) this.addTicket(x, z); // Paper
                 ret.complete(chunk == null ? null : new CraftChunk(chunk));
             });
@@ -2554,9 +2506,9 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public net.kyori.adventure.pointer.Pointers pointers() {
         if (this.adventure$pointers == null) {
             this.adventure$pointers = net.kyori.adventure.pointer.Pointers.builder()
-                .withDynamic(net.kyori.adventure.identity.Identity.NAME, this::getName)
-                .withDynamic(net.kyori.adventure.identity.Identity.UUID, this::getUID)
-                .build();
+                    .withDynamic(net.kyori.adventure.identity.Identity.NAME, this::getName)
+                    .withDynamic(net.kyori.adventure.identity.Identity.UUID, this::getUID)
+                    .build();
         }
 
         return this.adventure$pointers;
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java
index bb2d1dddca6bfe719b28df136e80a7c5a339a5ce..20048fe9baf6c1262176ec95c94734ab55130d8d 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBanner.java
@@ -1,8 +1,6 @@
 package org.bukkit.craftbukkit.block;
 
 import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.List;
 import net.minecraft.world.level.block.AbstractBannerBlock;
 import net.minecraft.world.level.block.entity.BannerBlockEntity;
 import net.minecraft.world.level.block.entity.BannerPatternLayers;
@@ -13,6 +11,9 @@ import org.bukkit.block.Banner;
 import org.bukkit.block.banner.Pattern;
 import org.bukkit.craftbukkit.block.banner.CraftPatternType;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class CraftBanner extends CraftBlockEntityState<BannerBlockEntity> implements Banner {
 
     private DyeColor base;
@@ -99,7 +100,7 @@ public class CraftBanner extends CraftBlockEntityState<BannerBlockEntity> implem
 
         banner.baseColor = net.minecraft.world.item.DyeColor.byId(this.base.getWoolData());
 
-        List<BannerPatternLayers.Layer> newPatterns = new ArrayList<>();
+        List<BannerPatternLayers.Layer> newPatterns = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Pattern p : this.patterns) {
             newPatterns.add(new net.minecraft.world.level.block.entity.BannerPatternLayers.Layer(CraftPatternType.bukkitToMinecraftHolder(p.getPattern()), net.minecraft.world.item.DyeColor.byId(p.getColor().getWoolData())));
@@ -135,7 +136,7 @@ public class CraftBanner extends CraftBlockEntityState<BannerBlockEntity> implem
 
     @Override
     public void setCustomName(String name) {
-       this.customName(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserializeOrNull(name));
+        this.customName(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserializeOrNull(name));
     }
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBeehive.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBeehive.java
index 3beb26ad2ef0fded49a8da8c5dec64f9508c1995..b56fdedaddf50d40bb9320c32f21a44fcd1f43a6 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBeehive.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBeehive.java
@@ -16,7 +16,7 @@ import org.bukkit.entity.Bee;
 
 public class CraftBeehive extends CraftBlockEntityState<BeehiveBlockEntity> implements Beehive {
 
-    private final List<org.purpurmc.purpur.entity.StoredEntity<Bee>> storage = new ArrayList<>(); // Purpur
+    private final List<org.purpurmc.purpur.entity.StoredEntity<Bee>> storage = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // Purpur
 
     public CraftBeehive(World world, BeehiveBlockEntity tileEntity) {
         super(world, tileEntity);
@@ -74,7 +74,7 @@ public class CraftBeehive extends CraftBlockEntityState<BeehiveBlockEntity> impl
     public List<Bee> releaseEntities() {
         this.ensureNoWorldGeneration();
 
-        List<Bee> bees = new ArrayList<>();
+        List<Bee> bees = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         if (this.isPlaced()) {
             BeehiveBlockEntity beehive = ((BeehiveBlockEntity) this.getTileEntityFromWorld());
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftConduit.java b/src/main/java/org/bukkit/craftbukkit/block/CraftConduit.java
index 1a91bc2e422db0eba65694ac046f1b362c6b0cd6..4155b878950d74d8ea542521c21f9ef99d8a20b0 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftConduit.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftConduit.java
@@ -50,7 +50,7 @@ public class CraftConduit extends CraftBlockEntityState<ConduitBlockEntity> impl
     @Override
     public Collection<Block> getFrameBlocks() {
         this.ensureNoWorldGeneration();
-        Collection<Block> blocks = new ArrayList<>();
+        Collection<Block> blocks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         ConduitBlockEntity conduit = (ConduitBlockEntity) this.getTileEntityFromWorld();
         if (conduit != null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftCreatureSpawner.java b/src/main/java/org/bukkit/craftbukkit/block/CraftCreatureSpawner.java
index 881ce7c18efab9ef6f678be1a64afeaa3731b387..78d61772b844f3d8b8db7ea1b8966662993abbe2 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftCreatureSpawner.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftCreatureSpawner.java
@@ -142,7 +142,7 @@ public class CraftCreatureSpawner extends CraftBlockEntityState<SpawnerBlockEnti
     }
 
     public static List<SpawnerEntry> getPotentialSpawns(BaseSpawner spawner) {
-        List<SpawnerEntry> entries = new ArrayList<>();
+        List<SpawnerEntry> entries = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Wrapper<SpawnData> entry : spawner.spawnPotentials.unwrap()) { // PAIL rename Wrapper
             CraftEntitySnapshot snapshot = CraftEntitySnapshot.create(entry.data().getEntityToSpawn());
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftTrialSpawnerConfiguration.java b/src/main/java/org/bukkit/craftbukkit/block/CraftTrialSpawnerConfiguration.java
index 72dfd388bb784009ac77ff0c93db56eb641c7ffc..f7ecba144a31ff61908870685df1db3cd9e3f0bd 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftTrialSpawnerConfiguration.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftTrialSpawnerConfiguration.java
@@ -1,12 +1,6 @@
 package org.bukkit.craftbukkit.block;
 
 import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.resources.ResourceKey;
@@ -26,6 +20,8 @@ import org.bukkit.entity.EntityType;
 import org.bukkit.loot.LootTable;
 import org.bukkit.spawner.TrialSpawnerConfiguration;
 
+import java.util.*;
+
 public class CraftTrialSpawnerConfiguration implements TrialSpawnerConfiguration {
     private final TrialSpawnerBlockEntity snapshot;
 
@@ -55,12 +51,12 @@ public class CraftTrialSpawnerConfiguration implements TrialSpawnerConfiguration
 
     @Override
     public EntityType getSpawnedType() {
-       if (this.spawnPotentialsDefinition.isEmpty()) {
-           return null;
-       }
+        if (this.spawnPotentialsDefinition.isEmpty()) {
+            return null;
+        }
 
-       Optional<net.minecraft.world.entity.EntityType<?>> type = net.minecraft.world.entity.EntityType.by(this.spawnPotentialsDefinition.unwrap().get(0).data().getEntityToSpawn());
-       return type.map(CraftEntityType::minecraftToBukkitCached).orElse(null); // Leaf - Cache CraftEntityType#minecraftToBukkit convert
+        Optional<net.minecraft.world.entity.EntityType<?>> type = net.minecraft.world.entity.EntityType.by(this.spawnPotentialsDefinition.unwrap().get(0).data().getEntityToSpawn());
+        return type.map(CraftEntityType::minecraftToBukkitCached).orElse(null); // Leaf - Cache CraftEntityType#minecraftToBukkit convert
     }
 
     @Override
@@ -120,7 +116,7 @@ public class CraftTrialSpawnerConfiguration implements TrialSpawnerConfiguration
 
     @Override
     public int getDelay() {
-      return this.ticksBetweenSpawn;
+        return this.ticksBetweenSpawn;
     }
 
     @Override
@@ -213,7 +209,7 @@ public class CraftTrialSpawnerConfiguration implements TrialSpawnerConfiguration
 
     @Override
     public List<SpawnerEntry> getPotentialSpawns() {
-        List<SpawnerEntry> entries = new ArrayList<>();
+        List<SpawnerEntry> entries = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Wrapper<SpawnData> entry : this.spawnPotentialsDefinition.unwrap()) { // PAIL rename Wrapper
             CraftEntitySnapshot snapshot = CraftEntitySnapshot.create(entry.data().getEntityToSpawn());
@@ -286,7 +282,7 @@ public class CraftTrialSpawnerConfiguration implements TrialSpawnerConfiguration
 
     @Override
     public int getRequiredPlayerRange() {
-      return this.snapshot.trialSpawner.getRequiredPlayerRange();
+        return this.snapshot.trialSpawner.getRequiredPlayerRange();
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/bootstrap/Main.java b/src/main/java/org/bukkit/craftbukkit/bootstrap/Main.java
index 8a4f95049c63afb28bef6719c77b7a7092e75aae..62df3fa89c6b3ecbee8da2b85438648b02e423f3 100644
--- a/src/main/java/org/bukkit/craftbukkit/bootstrap/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/bootstrap/Main.java
@@ -41,7 +41,7 @@ public class Main {
             System.out.println("Unbundling libraries to " + outputDir);
 
             boolean readOnly = Boolean.getBoolean("bundlerReadOnly");
-            List<URL> extractedUrls = new ArrayList<>();
+            List<URL> extractedUrls = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             this.readAndExtractDir("versions", outputDir, extractedUrls, readOnly);
             this.readAndExtractDir("libraries", outputDir, extractedUrls, readOnly);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java b/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java
index d7a41421784cf9066518310e00031e26d9817171..fcf9292c7c5a6ad7e8e99a33321f13905b5e918c 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/VanillaCommandWrapper.java
@@ -4,18 +4,11 @@ import com.google.common.base.Joiner;
 import com.google.common.base.Preconditions;
 import com.mojang.brigadier.ParseResults;
 import com.mojang.brigadier.tree.CommandNode;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
 import net.minecraft.world.entity.vehicle.MinecartCommandBlock;
 import org.bukkit.Location;
-import org.bukkit.command.BlockCommandSender;
-import org.bukkit.command.CommandSender;
-import org.bukkit.command.ConsoleCommandSender;
-import org.bukkit.command.ProxiedCommandSender;
-import org.bukkit.command.RemoteConsoleCommandSender;
+import org.bukkit.command.*;
 import org.bukkit.command.defaults.BukkitCommand;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.entity.CraftEntity;
@@ -23,6 +16,9 @@ import org.bukkit.craftbukkit.entity.CraftMinecartCommand;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.minecart.CommandMinecart;
 
+import java.util.Collections;
+import java.util.List;
+
 public class VanillaCommandWrapper extends BukkitCommand { // Paper
 
     //private final Commands dispatcher; // Paper
@@ -65,7 +61,7 @@ public class VanillaCommandWrapper extends BukkitCommand { // Paper
         CommandSourceStack icommandlistener = VanillaCommandWrapper.getListener(sender);
         ParseResults<CommandSourceStack> parsed = this.commands().getDispatcher().parse(this.toDispatcher(args, this.getName()), icommandlistener); // Paper
 
-        List<String> results = new ArrayList<>();
+        List<String> results = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.commands().getDispatcher().getCompletionSuggestions(parsed).thenAccept((suggestions) -> { // Paper
             suggestions.getList().forEach((s) -> results.add(s.getText()));
         });
@@ -123,6 +119,7 @@ public class VanillaCommandWrapper extends BukkitCommand { // Paper
     private String toDispatcher(String[] args, String name) {
         return name + ((args.length > 0) ? " " + Joiner.on(' ').join(args) : "");
     }
+
     // Paper start
     @Override
     public boolean canBeOverriden() {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 46856d2b7e24c5d223b7b1627ccb451749b183e7..b6e29e611e00ab3e5731751ad2210f45bc7f1216 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -2,11 +2,6 @@ package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Optional;
-import java.util.Set;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.chat.Component;
@@ -37,36 +32,25 @@ import org.bukkit.block.Block;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.entity.memory.CraftMemoryMapper;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
-import org.bukkit.craftbukkit.inventory.CraftContainer;
-import org.bukkit.craftbukkit.inventory.CraftInventory;
-import org.bukkit.craftbukkit.inventory.CraftInventoryAbstractHorse;
-import org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest;
-import org.bukkit.craftbukkit.inventory.CraftInventoryLectern;
-import org.bukkit.craftbukkit.inventory.CraftInventoryPlayer;
-import org.bukkit.craftbukkit.inventory.CraftInventoryView;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.inventory.CraftItemType;
-import org.bukkit.craftbukkit.inventory.CraftMerchantCustom;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.craftbukkit.inventory.*;
 import org.bukkit.craftbukkit.util.CraftLocation;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.Firework;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.entity.Villager;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.inventory.EntityEquipment;
-import org.bukkit.inventory.Inventory;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.MainHand;
-import org.bukkit.inventory.Merchant;
-import org.bukkit.inventory.PlayerInventory;
+import org.bukkit.inventory.*;
 import org.bukkit.permissions.PermissibleBase;
 import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
 
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Optional;
+import java.util.Set;
+
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
     private final CraftInventory enderChest;
@@ -159,6 +143,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
         }
         return new Location(worldServer.getWorld(), bed.getX(), bed.getY(), bed.getZ());
     }
+
     // Paper end
     // Paper start
     @Override
@@ -168,6 +153,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
         }
         return (org.bukkit.entity.FishHook) getHandle().fishing.getBukkitEntity();
     }
+
     // Paper end
     @Override
     public boolean sleep(Location location, boolean force) {
@@ -375,11 +361,14 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
 
         //String title = container.getBukkitView().getTitle(); // Paper - comment
         net.kyori.adventure.text.Component adventure$title = container.getBukkitView().title(); // Paper
-        if (adventure$title == null) adventure$title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(container.getBukkitView().getTitle()); // Paper
-        if (result.getFirst() != null) adventure$title = result.getFirst(); // Paper - Add titleOverride to InventoryOpenEvent
+        if (adventure$title == null)
+            adventure$title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(container.getBukkitView().getTitle()); // Paper
+        if (result.getFirst() != null)
+            adventure$title = result.getFirst(); // Paper - Add titleOverride to InventoryOpenEvent
 
         //player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, CraftChatMessage.fromString(title)[0])); // Paper - comment
-        if (!player.isImmobile()) player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, io.papermc.paper.adventure.PaperAdventure.asVanilla(adventure$title))); // Paper - Prevent opening inventories when frozen
+        if (!player.isImmobile())
+            player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, io.papermc.paper.adventure.PaperAdventure.asVanilla(adventure$title))); // Paper - Prevent opening inventories when frozen
         player.containerMenu = container;
         player.initMenu(container);
     }
@@ -466,10 +455,13 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
 
         //String title = inventory.getTitle(); // Paper - comment
         net.kyori.adventure.text.Component adventure$title = inventory.title(); // Paper
-        if (adventure$title == null) adventure$title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(inventory.getTitle()); // Paper
-        if (result.getFirst() != null) adventure$title = result.getFirst(); // Paper - Add titleOverride to InventoryOpenEvent
+        if (adventure$title == null)
+            adventure$title = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(inventory.getTitle()); // Paper
+        if (result.getFirst() != null)
+            adventure$title = result.getFirst(); // Paper - Add titleOverride to InventoryOpenEvent
         //player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, CraftChatMessage.fromString(title)[0])); // Paper - comment
-        if (!player.isImmobile()) player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, io.papermc.paper.adventure.PaperAdventure.asVanilla(adventure$title))); // Paper - Prevent opening inventories when frozen
+        if (!player.isImmobile())
+            player.connection.send(new ClientboundOpenScreenPacket(container.containerId, windowType, io.papermc.paper.adventure.PaperAdventure.asVanilla(adventure$title))); // Paper - Prevent opening inventories when frozen
         player.containerMenu = container;
         player.initMenu(container);
     }
@@ -583,6 +575,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
         // Paper start - Inventory close reason
         this.getHandle().closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.PLUGIN);
     }
+
     @Override
     public void closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
         getHandle().closeContainer(reason);
@@ -707,7 +700,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     }
 
     private Collection<RecipeHolder<?>> bukkitKeysToMinecraftRecipes(Collection<NamespacedKey> recipeKeys) {
-        Collection<RecipeHolder<?>> recipes = new ArrayList<>();
+        Collection<RecipeHolder<?>> recipes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         RecipeManager manager = this.getHandle().level().getServer().getRecipeManager();
 
         for (NamespacedKey recipeKey : recipeKeys) {
@@ -765,6 +758,7 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     public void openSign(final org.bukkit.block.Sign sign, final org.bukkit.block.sign.Side side) {
         org.bukkit.craftbukkit.block.CraftSign.openSign(sign, (CraftPlayer) this, side);
     }
+
     // Paper end
     @Override
     public boolean dropItem(boolean dropAll) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 801a237b666fe8f26e477d848b1f9e31a4025fd0..6426879a5eeeb6af45d42364e2012dfafd4cf8a6 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -8,33 +8,7 @@ import com.mojang.datafixers.util.Pair;
 import io.netty.buffer.Unpooled;
 import it.unimi.dsi.fastutil.shorts.ShortArraySet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.lang.ref.WeakReference;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.nio.charset.StandardCharsets;
-import java.time.Duration;
-import java.time.Instant;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
-import java.util.UUID;
-import java.util.WeakHashMap;
-import java.util.concurrent.CompletableFuture;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.annotation.Nullable;
+import net.md_5.bungee.api.chat.BaseComponent;
 import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -44,47 +18,11 @@ import net.minecraft.network.ConnectionProtocol;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.PlayerChatMessage;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket;
-import net.minecraft.network.protocol.common.ClientboundResourcePackPopPacket;
-import net.minecraft.network.protocol.common.ClientboundResourcePackPushPacket;
-import net.minecraft.network.protocol.common.ClientboundServerLinksPacket;
-import net.minecraft.network.protocol.common.ClientboundStoreCookiePacket;
-import net.minecraft.network.protocol.common.ClientboundTransferPacket;
+import net.minecraft.network.protocol.common.*;
 import net.minecraft.network.protocol.common.custom.DiscardedPayload;
 import net.minecraft.network.protocol.cookie.ClientboundCookieRequestPacket;
 import net.minecraft.network.protocol.cookie.ServerboundCookieResponsePacket;
-import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundClearTitlesPacket;
-import net.minecraft.network.protocol.game.ClientboundCustomChatCompletionsPacket;
-import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
-import net.minecraft.network.protocol.game.ClientboundHurtAnimationPacket;
-import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
-import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
-import net.minecraft.network.protocol.game.ClientboundMapItemDataPacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerInfoRemovePacket;
-import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundRemoveMobEffectPacket;
-import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderCenterPacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
-import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
-import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
-import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
-import net.minecraft.network.protocol.game.ClientboundSetHealthPacket;
-import net.minecraft.network.protocol.game.ClientboundSetSubtitleTextPacket;
-import net.minecraft.network.protocol.game.ClientboundSetTitleTextPacket;
-import net.minecraft.network.protocol.game.ClientboundSetTitlesAnimationPacket;
-import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundSoundPacket;
-import net.minecraft.network.protocol.game.ClientboundStopSoundPacket;
-import net.minecraft.network.protocol.game.ClientboundTabListPacket;
-import net.minecraft.network.protocol.game.ClientboundUpdateAttributesPacket;
-import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.PlayerAdvancements;
 import net.minecraft.server.level.ChunkMap;
@@ -107,24 +45,7 @@ import net.minecraft.world.level.border.BorderChangeListener;
 import net.minecraft.world.level.saveddata.maps.MapDecoration;
 import net.minecraft.world.level.saveddata.maps.MapId;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
-import org.bukkit.BanEntry;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.DyeColor;
-import org.bukkit.Effect;
-import org.bukkit.GameMode;
-import org.bukkit.Instrument;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.NamespacedKey;
-import org.bukkit.Note;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Particle;
-import org.bukkit.ServerLinks;
-import org.bukkit.Sound;
-import org.bukkit.Statistic;
-import org.bukkit.WeatherType;
-import org.bukkit.WorldBorder;
+import org.bukkit.*;
 import org.bukkit.ban.IpBanList;
 import org.bukkit.ban.ProfileBanList;
 import org.bukkit.block.Block;
@@ -137,16 +58,7 @@ import org.bukkit.configuration.serialization.DelegateDeserialization;
 import org.bukkit.conversations.Conversation;
 import org.bukkit.conversations.ConversationAbandonedEvent;
 import org.bukkit.conversations.ManuallyAbandonedConversationCanceller;
-import org.bukkit.craftbukkit.CraftEffect;
-import org.bukkit.craftbukkit.CraftEquipmentSlot;
-import org.bukkit.craftbukkit.CraftOfflinePlayer;
-import org.bukkit.craftbukkit.CraftParticle;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.CraftServerLinks;
-import org.bukkit.craftbukkit.CraftSound;
-import org.bukkit.craftbukkit.CraftStatistic;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.CraftWorldBorder;
+import org.bukkit.craftbukkit.*;
 import org.bukkit.craftbukkit.advancement.CraftAdvancement;
 import org.bukkit.craftbukkit.advancement.CraftAdvancementProgress;
 import org.bukkit.craftbukkit.block.CraftBlockEntityState;
@@ -161,7 +73,6 @@ import org.bukkit.craftbukkit.map.CraftMapView;
 import org.bukkit.craftbukkit.map.RenderData;
 import org.bukkit.craftbukkit.potion.CraftPotionEffectType;
 import org.bukkit.craftbukkit.potion.CraftPotionUtil;
-import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
 import org.bukkit.craftbukkit.scoreboard.CraftScoreboard;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftLocation;
@@ -170,13 +81,7 @@ import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerExpCooldownChangeEvent;
-import org.bukkit.event.player.PlayerHideEntityEvent;
-import org.bukkit.event.player.PlayerRegisterChannelEvent;
-import org.bukkit.event.player.PlayerShowEntityEvent;
-import org.bukkit.event.player.PlayerSpawnChangeEvent;
-import org.bukkit.event.player.PlayerTeleportEvent;
-import org.bukkit.event.player.PlayerUnregisterChannelEvent;
+import org.bukkit.event.player.*;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView.Property;
 import org.bukkit.inventory.ItemStack;
@@ -187,11 +92,23 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.potion.PotionEffect;
 import org.bukkit.potion.PotionEffectType;
-import org.bukkit.profile.PlayerProfile;
 import org.bukkit.scoreboard.Scoreboard;
 import org.jetbrains.annotations.NotNull;
 
-import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import javax.annotation.Nullable;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.nio.charset.StandardCharsets;
+import java.time.Duration;
+import java.time.Instant;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -226,8 +143,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     @Override
     public void remove() {
         if (this.getHandle().getClass().equals(ServerPlayer.class)) { // special case for NMS plugins inheriting
-        // Will lead to an inconsistent player state if we remove the player as any other entity.
-        throw new UnsupportedOperationException(String.format("Cannot remove player %s, use Player#kickPlayer(String) instead.", this.getName()));
+            // Will lead to an inconsistent player state if we remove the player as any other entity.
+            throw new UnsupportedOperationException(String.format("Cannot remove player %s, use Player#kickPlayer(String) instead.", this.getName()));
         } else {
             super.remove();
         }
@@ -298,6 +215,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public record CookieFuture(ResourceLocation key, CompletableFuture<byte[]> future) {
 
     }
+
     private final Queue<CookieFuture> requestedCookies = new LinkedList<>();
 
     public boolean isAwaitingCookies() {
@@ -446,21 +364,21 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void setPlayerListHeaderFooter(BaseComponent[] header, BaseComponent[] footer) {
-         if (header != null) {
-             String headerJson = net.md_5.bungee.chat.ComponentSerializer.toString(header);
-             playerListHeader = net.kyori.adventure.text.serializer.gson.GsonComponentSerializer.gson().deserialize(headerJson);
-         } else {
-             playerListHeader = null;
-         }
+        if (header != null) {
+            String headerJson = net.md_5.bungee.chat.ComponentSerializer.toString(header);
+            playerListHeader = net.kyori.adventure.text.serializer.gson.GsonComponentSerializer.gson().deserialize(headerJson);
+        } else {
+            playerListHeader = null;
+        }
 
         if (footer != null) {
-             String footerJson = net.md_5.bungee.chat.ComponentSerializer.toString(footer);
-             playerListFooter = net.kyori.adventure.text.serializer.gson.GsonComponentSerializer.gson().deserialize(footerJson);
+            String footerJson = net.md_5.bungee.chat.ComponentSerializer.toString(footer);
+            playerListFooter = net.kyori.adventure.text.serializer.gson.GsonComponentSerializer.gson().deserialize(footerJson);
         } else {
-             playerListFooter = null;
-         }
+            playerListFooter = null;
+        }
 
-         updatePlayerListHeaderFooter();
+        updatePlayerListHeaderFooter();
     }
 
     @Override
@@ -537,7 +455,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public String getDisplayName() {
-        if(true) return io.papermc.paper.adventure.DisplayNames.getLegacy(this); // Paper
+        if (true) return io.papermc.paper.adventure.DisplayNames.getLegacy(this); // Paper
         return this.getHandle().displayName;
     }
 
@@ -558,18 +476,22 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             }
         }
     }
+
     @Override
     public net.kyori.adventure.text.Component playerListName() {
         return getHandle().listName == null ? net.kyori.adventure.text.Component.text(getName()) : io.papermc.paper.adventure.PaperAdventure.asAdventure(getHandle().listName);
     }
+
     @Override
     public net.kyori.adventure.text.Component playerListHeader() {
         return playerListHeader;
     }
+
     @Override
     public net.kyori.adventure.text.Component playerListFooter() {
         return playerListFooter;
     }
+
     // Paper end
     @Override
     public String getPlayerListName() {
@@ -581,13 +503,15 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         // Purpur start
         setPlayerListName(name, false);
     }
+
     public void setPlayerListName(String name, boolean useMM) {
         // Purpur end
         if (name == null) {
             name = this.getName();
         }
         this.getHandle().listName = name.equals(this.getName()) ? null : useMM ? io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(name)) : CraftChatMessage.fromStringOrNull(name); // Purpur
-        if (this.getHandle().connection == null) return; // Paper - Updates are possible before the player has fully joined
+        if (this.getHandle().connection == null)
+            return; // Paper - Updates are possible before the player has fully joined
         for (ServerPlayer player : (List<ServerPlayer>) this.server.getHandle().players) {
             if (player.getBukkitEntity().canSee(this)) {
                 player.connection.send(new ClientboundPlayerInfoUpdatePacket(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_DISPLAY_NAME, this.getHandle()));
@@ -663,6 +587,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     // Paper start
     private static final net.kyori.adventure.text.Component DEFAULT_KICK_COMPONENT = net.kyori.adventure.text.Component.translatable("multiplayer.disconnect.kicked");
+
     @Override
     public void kick() {
         this.kick(DEFAULT_KICK_COMPONENT);
@@ -718,16 +643,16 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     @Override
     public void addAdditionalChatCompletions(@NotNull Collection<String> completions) {
         this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundCustomChatCompletionsPacket(
-            net.minecraft.network.protocol.game.ClientboundCustomChatCompletionsPacket.Action.ADD,
-            new ArrayList<>(completions)
+                net.minecraft.network.protocol.game.ClientboundCustomChatCompletionsPacket.Action.ADD,
+                new ArrayList<>(completions)
         ));
     }
 
     @Override
     public void removeAdditionalChatCompletions(@NotNull Collection<String> completions) {
         this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundCustomChatCompletionsPacket(
-            net.minecraft.network.protocol.game.ClientboundCustomChatCompletionsPacket.Action.REMOVE,
-            new ArrayList<>(completions)
+                net.minecraft.network.protocol.game.ClientboundCustomChatCompletionsPacket.Action.REMOVE,
+                new ArrayList<>(completions)
         ));
     }
     // Paper end - custom chat completions API
@@ -863,14 +788,16 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void playSound(org.bukkit.entity.Entity entity, Sound sound, org.bukkit.SoundCategory category, float volume, float pitch, long seed) {
-        if (!(entity instanceof CraftEntity craftEntity) || sound == null || category == null || this.getHandle().connection == null) return;
+        if (!(entity instanceof CraftEntity craftEntity) || sound == null || category == null || this.getHandle().connection == null)
+            return;
 
         this.playSound0(entity, CraftSound.bukkitToMinecraftHolder(sound), net.minecraft.sounds.SoundSource.valueOf(category.name()), volume, pitch, seed);
     }
 
     @Override
     public void playSound(org.bukkit.entity.Entity entity, String sound, org.bukkit.SoundCategory category, float volume, float pitch, long seed) {
-        if (!(entity instanceof CraftEntity craftEntity) || sound == null || category == null || this.getHandle().connection == null) return;
+        if (!(entity instanceof CraftEntity craftEntity) || sound == null || category == null || this.getHandle().connection == null)
+            return;
 
         this.playSound0(entity, Holder.direct(SoundEvent.createVariableRangeEvent(ResourceLocation.parse(sound))), net.minecraft.sounds.SoundSource.valueOf(category.name()), volume, pitch, seed);
     }
@@ -1036,10 +963,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.sendBlockChanges(blocks);
     }
 
-    private record ChunkSectionChanges(ShortSet positions, List<net.minecraft.world.level.block.state.BlockState> blockData) {
+    private record ChunkSectionChanges(ShortSet positions,
+                                       List<net.minecraft.world.level.block.state.BlockState> blockData) {
 
         public ChunkSectionChanges() {
-            this(new ShortArraySet(), new ArrayList<>());
+            this(new ShortArraySet(), new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
         }
     }
 
@@ -1087,6 +1015,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         Component[] components = CraftSign.sanitizeLines(lines);
         this.sendSignChange0(components, loc, dyeColor, hasGlowingText);
     }
+
     // Paper end
     @Override
     public void sendSignChange(Location loc, String[] lines) {
@@ -1254,10 +1183,12 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             }
 
             @Override
-            public void onBorderSetDamagePerBlock(net.minecraft.world.level.border.WorldBorder border, double damagePerBlock) {} // NO OP
+            public void onBorderSetDamagePerBlock(net.minecraft.world.level.border.WorldBorder border, double damagePerBlock) {
+            } // NO OP
 
             @Override
-            public void onBorderSetDamageSafeZOne(net.minecraft.world.level.border.WorldBorder border, double safeZoneRadius) {} // NO OP
+            public void onBorderSetDamageSafeZOne(net.minecraft.world.level.border.WorldBorder border, double safeZoneRadius) {
+            } // NO OP
         };
     }
 
@@ -1286,6 +1217,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         // Paper start - Add target entity to sendHurtAnimation
         this.sendHurtAnimation(yaw, this);
     }
+
     public void sendHurtAnimation(float yaw, org.bukkit.entity.Entity target) {
         // Paper end - Add target entity to sendHurtAnimation
         if (this.getHandle().connection == null) {
@@ -1367,6 +1299,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     // Slice start
+    @Override
     public void teleportWithoutRespawn(Location location) {
         ServerPlayer serverPlayer = getHandle();
         serverPlayer.smoothWorldTeleport = true;
@@ -1451,7 +1384,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         // Don't allow teleporting between worlds while keeping passengers
         if (ignorePassengers && entity.isVehicle() && location.getWorld() != this.getWorld()) {
             if (!new org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent(entity.getBukkitEntity(), org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_VEHICLE, cause).callEvent()) // Purpur start
-            return false;
+                return false;
         }
 
         // Don't allow to teleport between worlds if remaining on vehicle
@@ -1473,7 +1406,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         if (entity.isVehicle() && !ignorePassengers) { // Paper - Teleport API
             if (!new org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent(entity.getBukkitEntity(), org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_VEHICLE, cause).callEvent()) // Purpur start
-            return false;
+                return false;
         }
 
         // From = Players current Location
@@ -1880,7 +1813,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         // Logic copied from EntityExperienceOrb and remapped to unobfuscated methods/properties
 
         final Optional<net.minecraft.world.item.enchantment.EnchantedItemInUse> stackEntry = net.minecraft.world.item.enchantment.EnchantmentHelper
-            .getRandomItemWith(net.minecraft.world.item.enchantment.EnchantmentEffectComponents.REPAIR_WITH_XP, handle, net.minecraft.world.item.ItemStack::isDamaged);
+                .getRandomItemWith(net.minecraft.world.item.enchantment.EnchantmentEffectComponents.REPAIR_WITH_XP, handle, net.minecraft.world.item.ItemStack::isDamaged);
         final net.minecraft.world.item.ItemStack itemstack = stackEntry.map(net.minecraft.world.item.enchantment.EnchantedItemInUse::itemStack).orElse(net.minecraft.world.item.ItemStack.EMPTY);
         if (!itemstack.isEmpty() && itemstack.getItem().components().has(net.minecraft.core.component.DataComponents.MAX_DAMAGE)) {
             net.minecraft.world.entity.ExperienceOrb orb = net.minecraft.world.entity.EntityType.EXPERIENCE_ORB.create(handle.level());
@@ -1889,7 +1822,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             orb.setPosRaw(handle.getX(), handle.getY(), handle.getZ());
 
             final int possibleDurabilityFromXp = net.minecraft.world.item.enchantment.EnchantmentHelper.modifyDurabilityToRepairFromXp(
-                handle.serverLevel(), itemstack, amount
+                    handle.serverLevel(), itemstack, amount
             );
             int i = Math.min(possibleDurabilityFromXp, itemstack.getDamageValue());
             final int consumedExperience = i * amount / possibleDurabilityFromXp; // Paper - taken from ExperienceOrb#repairPlayerItems
@@ -1952,6 +1885,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         Preconditions.checkArgument(exp >= 0, "Total experience points must not be negative (%s)", exp);
         this.getHandle().totalExperience = exp;
     }
+
     // Paper start
     @Override
     public int calculateTotalExperiencePoints() {
@@ -2078,6 +2012,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         server.getPluginManager().callEvent(new PlayerHideEntityEvent(this, entity));
     }
+
     private void unregisterEntity(Entity other) {
         // Paper end
         ChunkMap tracker = ((ServerLevel) this.getHandle().level()).getChunkSource().chunkMap;
@@ -2160,6 +2095,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         // Paper start - uuid override
         this.trackAndShowEntity(entity, null);
     }
+
     private void trackAndShowEntity(org.bukkit.entity.Entity entity, final @Nullable UUID uuidOverride) {
         // Paper end
         ChunkMap tracker = ((ServerLevel) this.getHandle().level()).getChunkSource().chunkMap;
@@ -2185,6 +2121,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         this.server.getPluginManager().callEvent(new PlayerShowEntityEvent(this, entity));
     }
+
     // Paper start
     @Override
     public void setPlayerProfile(com.destroystokyo.paper.profile.PlayerProfile profile) {
@@ -2229,7 +2166,9 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             this.trackAndShowEntity(entity);
         }
     }
+
     // Paper start
+    @Override
     public com.destroystokyo.paper.profile.PlayerProfile getPlayerProfile() {
         return new com.destroystokyo.paper.profile.CraftPlayerProfile(this).clone();
     }
@@ -2279,6 +2218,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
     // SparklyPaper end
 
+    @Override
     public boolean canSeePlayer(UUID uuid) {
         org.bukkit.entity.Entity entity = this.getServer().getPlayer(uuid);
 
@@ -2566,7 +2506,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             this.clearResourcePacks();
         }
         final Component prompt = io.papermc.paper.adventure.PaperAdventure.asVanilla(request.prompt());
-        for (final java.util.Iterator<net.kyori.adventure.resource.ResourcePackInfo> iter = request.packs().iterator(); iter.hasNext();) {
+        for (final java.util.Iterator<net.kyori.adventure.resource.ResourcePackInfo> iter = request.packs().iterator(); iter.hasNext(); ) {
             final net.kyori.adventure.resource.ResourcePackInfo pack = iter.next();
             packs.add(new ClientboundResourcePackPushPacket(pack.id(), pack.uri().toASCIIString(), pack.hash(), request.required(), iter.hasNext() ? Optional.empty() : Optional.ofNullable(prompt)));
             if (request.callback() != net.kyori.adventure.resource.ResourcePackCallback.noOp()) {
@@ -2578,7 +2518,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     @Override
-    public void removeResourcePacks(final UUID id, final UUID ... others) {
+    public void removeResourcePacks(final UUID id, final UUID... others) {
         if (this.getHandle().connection == null) return;
         this.sendBundle(net.kyori.adventure.util.MonkeyBars.nonEmptyArrayToList(pack -> new ClientboundResourcePackPopPacket(Optional.of(pack)), id, others));
     }
@@ -2868,7 +2808,9 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     public void setRealHealth(double health) {
-        if (Double.isNaN(health)) {return;} // Paper - Check for NaN
+        if (Double.isNaN(health)) {
+            return;
+        } // Paper - Check for NaN
         this.health = health;
     }
 
@@ -2922,13 +2864,13 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
                 break;
             }
         }
-        AttributeInstance dummy = new AttributeInstance(Attributes.MAX_HEALTH, (attribute) -> { });
+        AttributeInstance dummy = new AttributeInstance(Attributes.MAX_HEALTH, (attribute) -> {
+        });
         // Spigot start
         double healthMod = this.scaledHealth ? this.healthScale : this.getMaxHealth();
-        if ( healthMod >= Float.MAX_VALUE || healthMod <= 0 )
-        {
+        if (healthMod >= Float.MAX_VALUE || healthMod <= 0) {
             healthMod = 20; // Reset health
-            this.getServer().getLogger().warning( this.getName() + " tried to crash the server with a large health attribute" );
+            this.getServer().getLogger().warning(this.getName() + " tried to crash the server with a large health attribute");
         }
         dummy.setBaseValue(healthMod);
         // Spigot end
@@ -3066,6 +3008,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public java.util.Locale locale() {
         return getHandle().adventure$locale;
     }
+
     // Paper end
     @Override
     public int getPing() {
@@ -3081,6 +3024,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     // Paper start
+    @Override
     public void setAffectsSpawning(boolean affects) {
         this.getHandle().affectsSpawning = affects;
     }
@@ -3155,9 +3099,9 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         net.minecraft.core.Registry<net.minecraft.network.chat.ChatType> chatTypeRegistry = this.getHandle().level().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.CHAT_TYPE);
 
         return new net.minecraft.network.chat.ChatType.Bound(
-            chatTypeRegistry.getHolderOrThrow(net.minecraft.resources.ResourceKey.create(net.minecraft.core.registries.Registries.CHAT_TYPE, io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.type().key()))),
-            io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.name()),
-            Optional.ofNullable(io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.target()))
+                chatTypeRegistry.getHolderOrThrow(net.minecraft.resources.ResourceKey.create(net.minecraft.core.registries.Registries.CHAT_TYPE, io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.type().key()))),
+                io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.name()),
+                Optional.ofNullable(io.papermc.paper.adventure.PaperAdventure.asVanilla(boundChatType.target()))
         );
     }
 
@@ -3231,8 +3175,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         final ServerGamePacketListenerImpl connection = this.getHandle().connection;
         if (connection == null) return;
         final ClientboundTabListPacket packet = new ClientboundTabListPacket(
-            io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListHeader),
-            io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListFooter)
+                io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListHeader),
+                io.papermc.paper.adventure.PaperAdventure.asVanillaNullToEmpty(this.playerListFooter)
         );
         connection.send(packet);
     }
@@ -3255,10 +3199,10 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         java.util.Objects.requireNonNull(part, "part");
         java.util.Objects.requireNonNull(value, "value");
         if (part == net.kyori.adventure.title.TitlePart.TITLE) {
-            final ClientboundSetTitleTextPacket tp = new ClientboundSetTitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla((net.kyori.adventure.text.Component)value));
+            final ClientboundSetTitleTextPacket tp = new ClientboundSetTitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla((net.kyori.adventure.text.Component) value));
             this.getHandle().connection.send(tp);
         } else if (part == net.kyori.adventure.title.TitlePart.SUBTITLE) {
-            final ClientboundSetSubtitleTextPacket sp = new ClientboundSetSubtitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla((net.kyori.adventure.text.Component)value));
+            final ClientboundSetSubtitleTextPacket sp = new ClientboundSetSubtitleTextPacket(io.papermc.paper.adventure.PaperAdventure.asVanilla((net.kyori.adventure.text.Component) value));
             this.getHandle().connection.send(sp);
         } else if (part == net.kyori.adventure.title.TitlePart.TIMES) {
             final net.kyori.adventure.title.Title.Times times = (net.kyori.adventure.title.Title.Times) value;
@@ -3339,8 +3283,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     @Override
     public void stopSound(final net.kyori.adventure.sound.SoundStop stop) {
         this.getHandle().connection.send(new ClientboundStopSoundPacket(
-            io.papermc.paper.adventure.PaperAdventure.asVanillaNullable(stop.sound()),
-            io.papermc.paper.adventure.PaperAdventure.asVanillaNullable(stop.source())
+                io.papermc.paper.adventure.PaperAdventure.asVanillaNullable(stop.sound()),
+                io.papermc.paper.adventure.PaperAdventure.asVanillaNullable(stop.source())
         ));
     }
 
@@ -3362,12 +3306,12 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public net.kyori.adventure.pointer.Pointers pointers() {
         if (this.adventure$pointers == null) {
             this.adventure$pointers = net.kyori.adventure.pointer.Pointers.builder()
-                .withDynamic(net.kyori.adventure.identity.Identity.DISPLAY_NAME, this::displayName)
-                .withDynamic(net.kyori.adventure.identity.Identity.NAME, this::getName)
-                .withDynamic(net.kyori.adventure.identity.Identity.UUID, this::getUniqueId)
-                .withStatic(net.kyori.adventure.permission.PermissionChecker.POINTER, this::permissionValue)
-                .withDynamic(net.kyori.adventure.identity.Identity.LOCALE, this::locale)
-                .build();
+                    .withDynamic(net.kyori.adventure.identity.Identity.DISPLAY_NAME, this::displayName)
+                    .withDynamic(net.kyori.adventure.identity.Identity.NAME, this::getName)
+                    .withDynamic(net.kyori.adventure.identity.Identity.UUID, this::getUniqueId)
+                    .withStatic(net.kyori.adventure.permission.PermissionChecker.POINTER, this::permissionValue)
+                    .withDynamic(net.kyori.adventure.identity.Identity.LOCALE, this::locale)
+                    .build();
         }
 
         return this.adventure$pointers;
@@ -3387,49 +3331,43 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void resetCooldown() {
         getHandle().resetAttackStrengthTicker();
     }
+
     // Paper end
     // Spigot start
-    private final Player.Spigot spigot = new Player.Spigot()
-    {
+    private final Player.Spigot spigot = new Player.Spigot() {
 
         @Override
-        public InetSocketAddress getRawAddress()
-        {
+        public InetSocketAddress getRawAddress() {
             return (InetSocketAddress) CraftPlayer.this.getHandle().connection.getRawAddress();
         }
 
         @Override
-        public void respawn()
-        {
-            if ( CraftPlayer.this.getHealth() <= 0 && CraftPlayer.this.isOnline() )
-            {
-                CraftPlayer.this.server.getServer().getPlayerList().respawn( CraftPlayer.this.getHandle(), false, Entity.RemovalReason.KILLED, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.PLUGIN );
+        public void respawn() {
+            if (CraftPlayer.this.getHealth() <= 0 && CraftPlayer.this.isOnline()) {
+                CraftPlayer.this.server.getServer().getPlayerList().respawn(CraftPlayer.this.getHandle(), false, Entity.RemovalReason.KILLED, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.PLUGIN);
             }
         }
 
         @Override
-        public Set<Player> getHiddenPlayers()
-        {
+        public Set<Player> getHiddenPlayers() {
             Set<Player> ret = new HashSet<>();
-            for ( Player p : CraftPlayer.this.getServer().getOnlinePlayers() )
-            {
-                if ( !CraftPlayer.this.canSee(p) )
-                {
-                    ret.add( p );
+            for (Player p : CraftPlayer.this.getServer().getOnlinePlayers()) {
+                if (!CraftPlayer.this.canSee(p)) {
+                    ret.add(p);
                 }
             }
 
-            return java.util.Collections.unmodifiableSet( ret );
+            return java.util.Collections.unmodifiableSet(ret);
         }
 
         @Override
         public void sendMessage(BaseComponent component) {
-          this.sendMessage( new BaseComponent[] { component } );
+            this.sendMessage(new BaseComponent[]{component});
         }
 
         @Override
         public void sendMessage(BaseComponent... components) {
-           this.sendMessage(net.md_5.bungee.api.ChatMessageType.SYSTEM, components);
+            this.sendMessage(net.md_5.bungee.api.ChatMessageType.SYSTEM, components);
         }
 
         @Override
@@ -3444,7 +3382,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         @Override
         public void sendMessage(net.md_5.bungee.api.ChatMessageType position, BaseComponent component) {
-            this.sendMessage( position, new BaseComponent[] { component } );
+            this.sendMessage(position, new BaseComponent[]{component});
         }
 
         @Override
@@ -3454,20 +3392,19 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
         @Override
         public void sendMessage(net.md_5.bungee.api.ChatMessageType position, UUID sender, BaseComponent component) {
-            this.sendMessage( position, sender, new BaseComponent[] { component } );
+            this.sendMessage(position, sender, new BaseComponent[]{component});
         }
 
         @Override
         public void sendMessage(net.md_5.bungee.api.ChatMessageType position, UUID sender, BaseComponent... components) {
-            if ( CraftPlayer.this.getHandle().connection == null ) return;
+            if (CraftPlayer.this.getHandle().connection == null) return;
 
             CraftPlayer.this.getHandle().connection.send(new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(components, position == net.md_5.bungee.api.ChatMessageType.ACTION_BAR));
         }
 
         // Paper start
         @Override
-        public int getPing()
-        {
+        public int getPing() {
             return CraftPlayer.this.getPing();
         }
         // Paper end
@@ -3483,7 +3420,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start
     @Override
     public void showElderGuardian(boolean silent) {
-        if (getHandle().connection != null) getHandle().connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.GUARDIAN_ELDER_EFFECT, silent ? 0F : 1F));
+        if (getHandle().connection != null)
+            getHandle().connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.GUARDIAN_ELDER_EFFECT, silent ? 0F : 1F));
     }
 
     @Override
@@ -3539,7 +3477,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public Set<java.lang.Long> getSentChunkKeys() {
         org.spigotmc.AsyncCatcher.catchOp("accessing sent chunks");
         return it.unimi.dsi.fastutil.longs.LongSets.unmodifiable(
-            this.getHandle().moonrise$getChunkLoader().getSentChunksRaw().clone()
+                this.getHandle().moonrise$getChunkLoader().getSentChunksRaw().clone()
         );
     }
 
@@ -3563,8 +3501,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
     // Paper end
 
-    public Player.Spigot spigot()
-    {
+    @Override
+    public Player.Spigot spigot() {
         return this.spigot;
     }
     // Spigot end
@@ -3577,8 +3515,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     @Override
     public void setViewDistance(final int viewDistance) {
         // Paper - rewrite chunk system - TODO do this better
-        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer)this.getHandle())
-            .moonrise$getViewDistanceHolder().setLoadViewDistance(viewDistance + 1);
+        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer) this.getHandle())
+                .moonrise$getViewDistanceHolder().setLoadViewDistance(viewDistance + 1);
     }
 
     @Override
@@ -3589,8 +3527,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     @Override
     public void setSimulationDistance(final int simulationDistance) {
         // Paper - rewrite chunk system - TODO do this better
-        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer)this.getHandle())
-            .moonrise$getViewDistanceHolder().setTickViewDistance(simulationDistance);
+        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer) this.getHandle())
+                .moonrise$getViewDistanceHolder().setTickViewDistance(simulationDistance);
     }
 
     @Override
@@ -3601,8 +3539,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     @Override
     public void setSendViewDistance(final int viewDistance) {
         // Paper - rewrite chunk system - TODO do this better
-        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer)this.getHandle())
-            .moonrise$getViewDistanceHolder().setSendViewDistance(viewDistance);
+        ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer) this.getHandle())
+                .moonrise$getViewDistanceHolder().setSendViewDistance(viewDistance);
     }
 
     // Paper start - entity effect API
@@ -3664,7 +3602,8 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void sendBlockHighlight(Location location, int duration, String text, org.bukkit.Color color, int transparency) {
-        if (transparency < 0 || transparency > 255) throw new IllegalArgumentException("transparency is outside of 0-255 range");
+        if (transparency < 0 || transparency > 255)
+            throw new IllegalArgumentException("transparency is outside of 0-255 range");
         sendBlockHighlight(location, duration, text, transparency << 24 | color.asRGB());
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 858c6c860d9b8aaa1d3f9f77a9e410726239d7cc..9dbe60ce8ccd27b223d69292e9a2b4dc24851120 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -5,16 +5,6 @@ import com.google.common.base.Functions;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Either;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.network.protocol.game.ServerboundContainerClosePacket;
@@ -72,171 +62,33 @@ import org.bukkit.block.BlockFace;
 import org.bukkit.block.BlockState;
 import org.bukkit.block.Sign;
 import org.bukkit.block.sign.Side;
-import org.bukkit.craftbukkit.CraftChunk;
-import org.bukkit.craftbukkit.CraftEquipmentSlot;
-import org.bukkit.craftbukkit.CraftExplosionResult;
-import org.bukkit.craftbukkit.CraftLootTable;
-import org.bukkit.craftbukkit.CraftRaid;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.CraftStatistic;
-import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.*;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockStates;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.damage.CraftDamageSource;
-import org.bukkit.craftbukkit.entity.CraftEntity;
-import org.bukkit.craftbukkit.entity.CraftLivingEntity;
-import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.entity.CraftRaider;
-import org.bukkit.craftbukkit.entity.CraftSpellcaster;
+import org.bukkit.craftbukkit.entity.*;
 import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.inventory.CraftItemType;
 import org.bukkit.craftbukkit.potion.CraftPotionUtil;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.craftbukkit.util.CraftVector;
-import org.bukkit.entity.AbstractHorse;
-import org.bukkit.entity.Animals;
-import org.bukkit.entity.AreaEffectCloud;
-import org.bukkit.entity.Bat;
-import org.bukkit.entity.Creeper;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.ExperienceOrb;
-import org.bukkit.entity.Explosive;
-import org.bukkit.entity.Firework;
-import org.bukkit.entity.Fish;
-import org.bukkit.entity.HumanEntity;
-import org.bukkit.entity.Item;
-import org.bukkit.entity.LightningStrike;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Pig;
-import org.bukkit.entity.PigZombie;
-import org.bukkit.entity.Piglin;
-import org.bukkit.entity.Player;
-import org.bukkit.entity.Projectile;
-import org.bukkit.entity.Raider;
-import org.bukkit.entity.Spellcaster;
-import org.bukkit.entity.Strider;
-import org.bukkit.entity.ThrownExpBottle;
-import org.bukkit.entity.ThrownPotion;
-import org.bukkit.entity.Vehicle;
-import org.bukkit.entity.Villager;
+import org.bukkit.entity.*;
 import org.bukkit.entity.Villager.Profession;
 import org.bukkit.event.Cancellable;
 import org.bukkit.event.Event;
 import org.bukkit.event.Event.Result;
-import org.bukkit.event.block.Action;
-import org.bukkit.event.block.BellResonateEvent;
-import org.bukkit.event.block.BellRingEvent;
-import org.bukkit.event.block.BlockDamageAbortEvent;
-import org.bukkit.event.block.BlockDamageEvent;
-import org.bukkit.event.block.BlockDispenseLootEvent;
-import org.bukkit.event.block.BlockDropItemEvent;
-import org.bukkit.event.block.BlockExplodeEvent;
-import org.bukkit.event.block.BlockFadeEvent;
-import org.bukkit.event.block.BlockFormEvent;
-import org.bukkit.event.block.BlockGrowEvent;
-import org.bukkit.event.block.BlockIgniteEvent;
+import org.bukkit.event.block.*;
 import org.bukkit.event.block.BlockIgniteEvent.IgniteCause;
-import org.bukkit.event.block.BlockMultiPlaceEvent;
-import org.bukkit.event.block.BlockPhysicsEvent;
-import org.bukkit.event.block.BlockPlaceEvent;
-import org.bukkit.event.block.BlockRedstoneEvent;
-import org.bukkit.event.block.BlockShearEntityEvent;
-import org.bukkit.event.block.BlockSpreadEvent;
-import org.bukkit.event.block.CrafterCraftEvent;
-import org.bukkit.event.block.EntityBlockFormEvent;
-import org.bukkit.event.block.FluidLevelChangeEvent;
-import org.bukkit.event.block.MoistureChangeEvent;
-import org.bukkit.event.block.NotePlayEvent;
-import org.bukkit.event.block.TNTPrimeEvent;
-import org.bukkit.event.block.VaultDisplayItemEvent;
-import org.bukkit.event.entity.AreaEffectCloudApplyEvent;
-import org.bukkit.event.entity.ArrowBodyCountChangeEvent;
-import org.bukkit.event.entity.BatToggleSleepEvent;
-import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.*;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.entity.CreeperPowerEvent;
-import org.bukkit.event.entity.EntityBreakDoorEvent;
-import org.bukkit.event.entity.EntityBreedEvent;
-import org.bukkit.event.entity.EntityChangeBlockEvent;
-import org.bukkit.event.entity.EntityDamageByBlockEvent;
-import org.bukkit.event.entity.EntityDamageByEntityEvent;
-import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.entity.EntityDamageEvent.DamageCause;
 import org.bukkit.event.entity.EntityDamageEvent.DamageModifier;
-import org.bukkit.event.entity.EntityDeathEvent;
-import org.bukkit.event.entity.EntityEnterLoveModeEvent;
-import org.bukkit.event.entity.EntityExhaustionEvent;
-import org.bukkit.event.entity.EntityExplodeEvent;
-import org.bukkit.event.entity.EntityInteractEvent;
-import org.bukkit.event.entity.EntityKnockbackByEntityEvent;
-import org.bukkit.event.entity.EntityKnockbackEvent;
-import org.bukkit.event.entity.EntityPickupItemEvent;
-import org.bukkit.event.entity.EntityPlaceEvent;
-import org.bukkit.event.entity.EntityPotionEffectEvent;
-import org.bukkit.event.entity.EntityRemoveEvent;
-import org.bukkit.event.entity.EntityShootBowEvent;
-import org.bukkit.event.entity.EntitySpawnEvent;
-import org.bukkit.event.entity.EntitySpellCastEvent;
-import org.bukkit.event.entity.EntityTameEvent;
-import org.bukkit.event.entity.EntityTargetEvent;
-import org.bukkit.event.entity.EntityTargetLivingEntityEvent;
-import org.bukkit.event.entity.EntityTeleportEvent;
-import org.bukkit.event.entity.EntityToggleGlideEvent;
-import org.bukkit.event.entity.EntityToggleSwimEvent;
-import org.bukkit.event.entity.EntityTransformEvent;
-import org.bukkit.event.entity.ExpBottleEvent;
-import org.bukkit.event.entity.ExplosionPrimeEvent;
-import org.bukkit.event.entity.FireworkExplodeEvent;
-import org.bukkit.event.entity.FoodLevelChangeEvent;
-import org.bukkit.event.entity.HorseJumpEvent;
-import org.bukkit.event.entity.ItemDespawnEvent;
-import org.bukkit.event.entity.ItemMergeEvent;
-import org.bukkit.event.entity.ItemSpawnEvent;
-import org.bukkit.event.entity.LingeringPotionSplashEvent;
-import org.bukkit.event.entity.PigZapEvent;
-import org.bukkit.event.entity.PiglinBarterEvent;
-import org.bukkit.event.entity.PlayerDeathEvent;
-import org.bukkit.event.entity.PlayerLeashEntityEvent;
-import org.bukkit.event.entity.PotionSplashEvent;
-import org.bukkit.event.entity.ProjectileHitEvent;
-import org.bukkit.event.entity.ProjectileLaunchEvent;
-import org.bukkit.event.entity.SpawnerSpawnEvent;
-import org.bukkit.event.entity.StriderTemperatureChangeEvent;
-import org.bukkit.event.entity.TrialSpawnerSpawnEvent;
-import org.bukkit.event.entity.VillagerCareerChangeEvent;
-import org.bukkit.event.inventory.InventoryCloseEvent;
-import org.bukkit.event.inventory.InventoryOpenEvent;
-import org.bukkit.event.inventory.PrepareAnvilEvent;
-import org.bukkit.event.inventory.PrepareGrindstoneEvent;
-import org.bukkit.event.inventory.PrepareItemCraftEvent;
-import org.bukkit.event.inventory.PrepareSmithingEvent;
-import org.bukkit.event.inventory.TradeSelectEvent;
-import org.bukkit.event.player.PlayerBedEnterEvent;
+import org.bukkit.event.inventory.*;
+import org.bukkit.event.player.*;
 import org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;
-import org.bukkit.event.player.PlayerBucketEmptyEvent;
-import org.bukkit.event.player.PlayerBucketEntityEvent;
-import org.bukkit.event.player.PlayerBucketFillEvent;
-import org.bukkit.event.player.PlayerBucketFishEvent;
-import org.bukkit.event.player.PlayerEditBookEvent;
-import org.bukkit.event.player.PlayerEvent;
-import org.bukkit.event.player.PlayerExpChangeEvent;
-import org.bukkit.event.player.PlayerExpCooldownChangeEvent;
-import org.bukkit.event.player.PlayerHarvestBlockEvent;
-import org.bukkit.event.player.PlayerInteractEvent;
-import org.bukkit.event.player.PlayerItemBreakEvent;
-import org.bukkit.event.player.PlayerItemMendEvent;
-import org.bukkit.event.player.PlayerLevelChangeEvent;
-import org.bukkit.event.player.PlayerRecipeBookClickEvent;
-import org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent;
-import org.bukkit.event.player.PlayerRecipeDiscoverEvent;
-import org.bukkit.event.player.PlayerRiptideEvent;
-import org.bukkit.event.player.PlayerShearEntityEvent;
-import org.bukkit.event.player.PlayerSignOpenEvent;
-import org.bukkit.event.player.PlayerStatisticIncrementEvent;
-import org.bukkit.event.player.PlayerUnleashEntityEvent;
 import org.bukkit.event.raid.RaidFinishEvent;
 import org.bukkit.event.raid.RaidSpawnWaveEvent;
 import org.bukkit.event.raid.RaidStopEvent;
@@ -256,6 +108,13 @@ import org.bukkit.inventory.view.AnvilView;
 import org.bukkit.potion.PotionEffect;
 import org.bukkit.util.Vector;
 
+import javax.annotation.Nullable;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
 public class CraftEventFactory {
 
     // helper methods
@@ -313,10 +172,10 @@ public class CraftEventFactory {
                         return BedEnterResult.TOO_FAR_AWAY;
                     case NOT_SAFE:
                         return BedEnterResult.NOT_SAFE;
-                        // Paper start
+                    // Paper start
                     case OBSTRUCTED:
                         return BedEnterResult.OBSTRUCTED;
-                        // Paper end
+                    // Paper end
                     default:
                         return BedEnterResult.OTHER_PROBLEM;
                 }
@@ -463,7 +322,7 @@ public class CraftEventFactory {
 
     public static void handleBlockDropItemEvent(Block block, BlockState state, ServerPlayer player, List<ItemEntity> items) {
         // Paper start - Allow adding items to BlockDropItemEvent
-        List<Item> list = new ArrayList<>();
+        List<Item> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (ItemEntity item : items) {
             list.add((Item) item.getBukkitEntity());
         }
@@ -626,7 +485,7 @@ public class CraftEventFactory {
      * EntityTransformEvent
      */
     public static EntityTransformEvent callEntityTransformEvent(net.minecraft.world.entity.LivingEntity original, List<net.minecraft.world.entity.LivingEntity> convertedList, EntityTransformEvent.TransformReason convertType) {
-        List<org.bukkit.entity.Entity> list = new ArrayList<>();
+        List<org.bukkit.entity.Entity> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (net.minecraft.world.entity.LivingEntity entityLiving : convertedList) {
             list.add(entityLiving.getBukkitEntity());
         }
@@ -762,23 +621,23 @@ public class CraftEventFactory {
                 final boolean mergeUnconditionally = maxValue <= 0;
                 if (mergeUnconditionally || xp.value < maxValue) { // Paper - Skip iteration if unnecessary
 
-                List<Entity> entities = world.getEntities(entity, entity.getBoundingBox().inflate(radius, radius, radius));
-                for (Entity e : entities) {
-                    if (e instanceof net.minecraft.world.entity.ExperienceOrb loopItem) {
-                        // Paper start
-                        if (!loopItem.isRemoved() && xp.count == loopItem.count && (mergeUnconditionally || loopItem.value < maxValue) && new com.destroystokyo.paper.event.entity.ExperienceOrbMergeEvent((org.bukkit.entity.ExperienceOrb) entity.getBukkitEntity(), (org.bukkit.entity.ExperienceOrb) loopItem.getBukkitEntity()).callEvent()) { // Paper - ExperienceOrbMergeEvent
-                            long newTotal = (long)xp.value + (long)loopItem.value;
-                            if ((int) newTotal < 0) continue; // Overflow
-                            if (!mergeUnconditionally && newTotal > maxValue) {
-                                loopItem.value = (int) (newTotal - maxValue);
-                                xp.value = (int) maxValue;
-                            } else {
-                            xp.value += loopItem.value;
-                            loopItem.discard(null); // Add Bukkit remove cause
-                            } // Paper end - Maximum exp value when merging
+                    List<Entity> entities = world.getEntities(entity, entity.getBoundingBox().inflate(radius, radius, radius));
+                    for (Entity e : entities) {
+                        if (e instanceof net.minecraft.world.entity.ExperienceOrb loopItem) {
+                            // Paper start
+                            if (!loopItem.isRemoved() && xp.count == loopItem.count && (mergeUnconditionally || loopItem.value < maxValue) && new com.destroystokyo.paper.event.entity.ExperienceOrbMergeEvent((org.bukkit.entity.ExperienceOrb) entity.getBukkitEntity(), (org.bukkit.entity.ExperienceOrb) loopItem.getBukkitEntity()).callEvent()) { // Paper - ExperienceOrbMergeEvent
+                                long newTotal = (long) xp.value + (long) loopItem.value;
+                                if ((int) newTotal < 0) continue; // Overflow
+                                if (!mergeUnconditionally && newTotal > maxValue) {
+                                    loopItem.value = (int) (newTotal - maxValue);
+                                    xp.value = (int) maxValue;
+                                } else {
+                                    xp.value += loopItem.value;
+                                    loopItem.discard(null); // Add Bukkit remove cause
+                                } // Paper end - Maximum exp value when merging
+                            }
                         }
                     }
-                }
                 } // Paper end - End iteration skip check - All tweaking ends here
             }
         }
@@ -926,7 +785,7 @@ public class CraftEventFactory {
         }
 
         io.papermc.paper.event.entity.WaterBottleSplashEvent event = new io.papermc.paper.event.entity.WaterBottleSplashEvent(
-            thrownPotion, hitEntity, hitBlock, hitFace, affectedEntities, rehydrate, extinguish
+                thrownPotion, hitEntity, hitBlock, hitFace, affectedEntities, rehydrate, extinguish
         );
         event.callEvent();
         return event;
@@ -1023,7 +882,8 @@ public class CraftEventFactory {
             if (stack == null || stack.getType() == Material.AIR || stack.getAmount() == 0) continue;
 
             drop.runConsumer(s -> world.dropItem(entity.getLocation(), s)); // Paper - Restore vanilla drops behavior
-            if (stack instanceof CraftItemStack) stack.setAmount(0); // Paper - destroy this item - if this ever leaks due to game bugs, ensure it doesn't dupe, but don't nuke bukkit stacks of manually added items
+            if (stack instanceof CraftItemStack)
+                stack.setAmount(0); // Paper - destroy this item - if this ever leaks due to game bugs, ensure it doesn't dupe, but don't nuke bukkit stacks of manually added items
         }
 
         return event;
@@ -1088,6 +948,7 @@ public class CraftEventFactory {
         }
     }
     // Paper end
+
     /**
      * Server methods
      */
@@ -1424,16 +1285,19 @@ public class CraftEventFactory {
         // Paper start - Add titleOverride to InventoryOpenEvent
         return callInventoryOpenEventWithTitle(player, container).getSecond();
     }
+
     public static com.mojang.datafixers.util.Pair<net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component, @org.jetbrains.annotations.Nullable AbstractContainerMenu> callInventoryOpenEventWithTitle(ServerPlayer player, AbstractContainerMenu container) {
         return CraftEventFactory.callInventoryOpenEventWithTitle(player, container, false);
         // Paper end - Add titleOverride to InventoryOpenEvent
     }
 
-    @Deprecated @io.papermc.paper.annotation.DoNotUse // Paper - use method that acknowledges title overrides
+    @Deprecated
+    @io.papermc.paper.annotation.DoNotUse // Paper - use method that acknowledges title overrides
     public static AbstractContainerMenu callInventoryOpenEvent(ServerPlayer player, AbstractContainerMenu container, boolean cancelled) {
         // Paper start - Add titleOverride to InventoryOpenEvent
         return callInventoryOpenEventWithTitle(player, container, cancelled).getSecond();
     }
+
     public static com.mojang.datafixers.util.Pair<net.kyori.adventure.text.@org.jetbrains.annotations.Nullable Component, @org.jetbrains.annotations.Nullable AbstractContainerMenu> callInventoryOpenEventWithTitle(ServerPlayer player, AbstractContainerMenu container, boolean cancelled) {
         // Paper end - Add titleOverride to InventoryOpenEvent
         if (player.containerMenu != player.inventoryMenu) { // fire INVENTORY_CLOSE if one already open
@@ -1477,6 +1341,7 @@ public class CraftEventFactory {
         Bukkit.getPluginManager().callEvent(crafterCraftEvent);
         return crafterCraftEvent;
     }
+
     // Paper start
     @Deprecated
     public static com.destroystokyo.paper.event.entity.ProjectileCollideEvent callProjectileCollideEvent(Entity entity, EntityHitResult position) {
@@ -1642,14 +1507,17 @@ public class CraftEventFactory {
     }
 
     // Paper start
+
     /**
      * Incase plugins hooked into this or Spigot adds a new inventory close event. Prefer to pass a reason
+     *
      * @param human
      */
     @Deprecated
     public static void handleInventoryCloseEvent(net.minecraft.world.entity.player.Player human) {
         handleInventoryCloseEvent(human, org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNKNOWN);
     }
+
     public static void handleInventoryCloseEvent(net.minecraft.world.entity.player.Player human, org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
         // Paper end
         InventoryCloseEvent event = new InventoryCloseEvent(human.containerMenu.getBukkitView(), reason); // Paper
@@ -1827,7 +1695,7 @@ public class CraftEventFactory {
         }
         event.callEvent();
         event.getInventory().setItem(resultSlot, event.getResult());
-        container.broadcastChanges();;
+        container.broadcastChanges();
     }
     // Paper end - Add PrepareResultEvent
 
@@ -2022,7 +1890,7 @@ public class CraftEventFactory {
 
     public static void callRaidSpawnWaveEvent(Raid raid, net.minecraft.world.entity.raid.Raider leader, List<net.minecraft.world.entity.raid.Raider> raiders) {
         Raider craftLeader = (CraftRaider) leader.getBukkitEntity();
-        List<Raider> craftRaiders = new ArrayList<>();
+        List<Raider> craftRaiders = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (net.minecraft.world.entity.raid.Raider entityRaider : raiders) {
             craftRaiders.add((Raider) entityRaider.getBukkitEntity());
         }
@@ -2194,12 +2062,13 @@ public class CraftEventFactory {
 
         Bukkit.getPluginManager().callEvent(new EntityRemoveEvent(entity.getBukkitEntity(), cause));
     }
+
     // Paper start - PlayerUseUnknownEntityEvent
     public static void callPlayerUseUnknownEntityEvent(net.minecraft.world.entity.player.Player player, net.minecraft.network.protocol.game.ServerboundInteractPacket packet, InteractionHand hand, @Nullable net.minecraft.world.phys.Vec3 vector) {
         new com.destroystokyo.paper.event.player.PlayerUseUnknownEntityEvent(
-            (Player) player.getBukkitEntity(), packet.getEntityId(), packet.isAttack(),
-            CraftEquipmentSlot.getHand(hand),
-            vector != null ? CraftVector.toBukkit(vector) : null
+                (Player) player.getBukkitEntity(), packet.getEntityId(), packet.isAttack(),
+                CraftEquipmentSlot.getHand(hand),
+                vector != null ? CraftVector.toBukkit(vector) : null
         ).callEvent();
     }
     // Paper end - PlayerUseUnknownEntityEvent
@@ -2255,6 +2124,7 @@ public class CraftEventFactory {
     // Paper end - Call missing BlockDispenseEvent
 
     // Paper start - add EntityFertilizeEggEvent
+
     /**
      * Calls the {@link io.papermc.paper.event.entity.EntityFertilizeEggEvent}.
      * If the event is cancelled, this method also resets the love on both the {@code breeding} and {@code other} entity.
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CraftLimitedRegion.java b/src/main/java/org/bukkit/craftbukkit/generator/CraftLimitedRegion.java
index 25598df0bb0d4347b2c17b6ec0afbfe4ecf808b9..6110aecda00d1aff4e140ee487d389b364999249 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CraftLimitedRegion.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CraftLimitedRegion.java
@@ -1,12 +1,6 @@
 package org.bukkit.craftbukkit.generator;
 
 import com.google.common.base.Preconditions;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Random;
-import java.util.function.Consumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.nbt.CompoundTag;
@@ -16,11 +10,7 @@ import net.minecraft.world.level.WorldGenLevel;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ProtoChunk;
 import net.minecraft.world.level.chunk.status.ChunkStatus;
-import org.bukkit.HeightMap;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.TreeType;
-import org.bukkit.World;
+import org.bukkit.*;
 import org.bukkit.block.Biome;
 import org.bukkit.block.BlockState;
 import org.bukkit.block.data.BlockData;
@@ -30,6 +20,13 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.generator.LimitedRegion;
 import org.bukkit.util.BoundingBox;
 
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Random;
+import java.util.function.Consumer;
+
 public class CraftLimitedRegion extends CraftRegionAccessor implements LimitedRegion {
 
     private final WeakReference<WorldGenLevel> weakAccess;
@@ -43,10 +40,10 @@ public class CraftLimitedRegion extends CraftRegionAccessor implements LimitedRe
     // Minecraft saves the entities as NBTTagCompound during chunk generation. This causes that
     // changes made to the returned bukkit entity are not saved. To combat this we keep them and
     // save them when the population is finished.
-    private final List<net.minecraft.world.entity.Entity> entities = new ArrayList<>();
+    private final List<net.minecraft.world.entity.Entity> entities = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     // SPIGOT-6891: Save outside Entities extra, since they are not part of the region.
     // Prevents crash for chunks which are converting from 1.17 to 1.18
-    private final List<net.minecraft.world.entity.Entity> outsideEntities = new ArrayList<>();
+    private final List<net.minecraft.world.entity.Entity> outsideEntities = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     public CraftLimitedRegion(WorldGenLevel access, ChunkPos center) {
         this.weakAccess = new WeakReference<>(access);
@@ -64,6 +61,7 @@ public class CraftLimitedRegion extends CraftRegionAccessor implements LimitedRe
         this.region = new BoundingBox(xMin, world.getMinHeight(), zMin, xMax, world.getMaxHeight(), zMax);
     }
 
+    @Override
     public WorldGenLevel getHandle() {
         WorldGenLevel handle = this.weakAccess.get();
 
@@ -145,7 +143,7 @@ public class CraftLimitedRegion extends CraftRegionAccessor implements LimitedRe
 
     @Override
     public List<BlockState> getTileEntities() {
-        List<BlockState> blockStates = new ArrayList<>();
+        List<BlockState> blockStates = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (int x = -(this.buffer >> 4); x <= (this.buffer >> 4); x++) {
             for (int z = -(this.buffer >> 4); z <= (this.buffer >> 4); z++) {
@@ -302,6 +300,7 @@ public class CraftLimitedRegion extends CraftRegionAccessor implements LimitedRe
     public int getCenterChunkZ() {
         return centerChunkZ;
     }
+
     // Paper end - Add more LimitedRegion API
     // Paper start - Fluid API
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomWorldChunkManager.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomWorldChunkManager.java
index 0bac128d6faff0063b03f595b82deea78d1ae161..8bf3618e574a377ea1638e0424ccec491a23b62a 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomWorldChunkManager.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomWorldChunkManager.java
@@ -2,9 +2,6 @@ package org.bukkit.craftbukkit.generator;
 
 import com.google.common.base.Preconditions;
 import com.mojang.serialization.MapCodec;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.stream.Stream;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.world.level.biome.BiomeSource;
@@ -14,6 +11,9 @@ import org.bukkit.craftbukkit.block.CraftBiome;
 import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.WorldInfo;
 
+import java.util.List;
+import java.util.stream.Stream;
+
 public class CustomWorldChunkManager extends BiomeSource {
 
     private final WorldInfo worldInfo;
@@ -21,7 +21,7 @@ public class CustomWorldChunkManager extends BiomeSource {
     private final Registry<net.minecraft.world.level.biome.Biome> registry;
 
     private static List<Holder<net.minecraft.world.level.biome.Biome>> biomeListToBiomeBaseList(List<Biome> biomes, Registry<net.minecraft.world.level.biome.Biome> registry) {
-        List<Holder<net.minecraft.world.level.biome.Biome>> biomeBases = new ArrayList<>();
+        List<Holder<net.minecraft.world.level.biome.Biome>> biomeBases = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Biome biome : biomes) {
             Preconditions.checkArgument(biome != Biome.CUSTOM, "Cannot use the biome %s", biome);
@@ -33,6 +33,7 @@ public class CustomWorldChunkManager extends BiomeSource {
 
     // Paper start - add vanillaBiomeProvider
     public final BiomeSource vanillaBiomeSource;
+
     public CustomWorldChunkManager(WorldInfo worldInfo, BiomeProvider biomeProvider, Registry<net.minecraft.world.level.biome.Biome> registry, BiomeSource vanillaBiomeSource) {
         this.vanillaBiomeSource = vanillaBiomeSource;
         // Paper end - add vanillaBiomeProvider
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemCraftResult.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemCraftResult.java
index 79a807e354552eedf7328b07374c9e133b413534..c527c10e35498b7fe2cc2275b1a1e0950e1f59d1 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemCraftResult.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemCraftResult.java
@@ -16,7 +16,7 @@ public final class CraftItemCraftResult implements ItemCraftResult {
     public CraftItemCraftResult(ItemStack result) {
         this.result = Objects.requireNonNullElseGet(result, () -> new ItemStack(Material.AIR));
         this.resultMatrix = new ItemStack[9];
-        this.overflowItems = new ArrayList<>();
+        this.overflowItems = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (int i = 0; i < this.resultMatrix.length; i++) {
             this.resultMatrix[i] = new ItemStack(Material.AIR);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
index fdc0c1d73bb523f003e4169589f1002375b9c88c..d88bbb4b1a31a468bb49fc339ed55defaff2c8a8 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBanner.java
@@ -3,9 +3,6 @@ package org.bukkit.craftbukkit.inventory;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
 import net.minecraft.core.component.DataComponentPatch;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.world.level.block.entity.BannerPatternLayers;
@@ -16,6 +13,10 @@ import org.bukkit.configuration.serialization.DelegateDeserialization;
 import org.bukkit.craftbukkit.block.banner.CraftPatternType;
 import org.bukkit.inventory.meta.BannerMeta;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
 @DelegateDeserialization(SerializableMeta.class)
 public class CraftMetaBanner extends CraftMetaItem implements BannerMeta {
 
@@ -70,7 +71,7 @@ public class CraftMetaBanner extends CraftMetaItem implements BannerMeta {
         super.applyToItem(tag);
 
         if (this.patterns.isEmpty()) return; // Paper - don't write empty patterns
-        List<BannerPatternLayers.Layer> newPatterns = new ArrayList<>();
+        List<BannerPatternLayers.Layer> newPatterns = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Pattern p : this.patterns) {
             newPatterns.add(new BannerPatternLayers.Layer(CraftPatternType.bukkitToMinecraftHolder(p.getPattern()), net.minecraft.world.item.DyeColor.byId(p.getColor().getWoolData())));
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
index 70f20de37c1f8d57a8d9fe00dcd864fdd9948ec2..40b9acf5a70fea4aa8b5f446a1e2748759e45f4d 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBook.java
@@ -2,14 +2,10 @@ package org.bukkit.craftbukkit.inventory;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
-
-import com.google.common.collect.ImmutableMap; // Paper
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
 import net.minecraft.core.component.DataComponentPatch;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.network.chat.Component;
@@ -22,11 +18,7 @@ import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.inventory.meta.BookMeta;
 import org.bukkit.inventory.meta.WritableBookMeta;
 
-// Spigot start
-import java.util.AbstractList;
-import net.md_5.bungee.api.chat.BaseComponent;
-import net.md_5.bungee.chat.ComponentSerializer;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
+import java.util.*;
 // Spigot end
 
 @DelegateDeserialization(SerializableMeta.class)
@@ -101,7 +93,7 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
         super.applyToItem(itemData);
 
         if (this.pages != null) {
-            List<Filterable<String>> list = new ArrayList<>();
+            List<Filterable<String>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (String page : this.pages) {
                 list.add(Filterable.from(FilteredText.passThrough(page)));
             }
@@ -231,7 +223,7 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
 
     @Override
     public void addPages(net.kyori.adventure.text.Component... pages) {
-        if (this.pages == null) this.pages = new ArrayList<>();
+        if (this.pages == null) this.pages = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (net.kyori.adventure.text.Component page : pages) {
             if (this.pages.size() >= MAX_PAGES) {
                 return;
@@ -421,6 +413,7 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
 
     // Spigot start
     private BookMeta.Spigot spigot = new SpigotMeta();
+
     private class SpigotMeta extends BookMeta.Spigot {
 
         private String pageToJSON(String page) {
@@ -500,7 +493,7 @@ public class CraftMetaBook extends CraftMetaItem implements BookMeta, WritableBo
                 this.addPage(page);
             }
         }
-    };
+    }
 
     @Override
     public BookMeta.Spigot spigot() {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
index 040dac82e484cb44b3afd444b4bbd1fd994bfe7c..fa05c426fbfa3dfc6f69a38245cc48dc00c2a98d 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
@@ -124,7 +124,7 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
     void applyToItem(CraftMetaItem.Applicator itemData) {
         super.applyToItem(itemData);
 
-        List<Filterable<Component>> list = new ArrayList<>(); // Paper - General ItemMeta Fixes
+        List<Filterable<Component>> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // Paper - General ItemMeta Fixes
         if (this.pages != null) {
             for (Component page : this.pages) {
                 list.add(Filterable.passThrough(page));
@@ -556,7 +556,7 @@ public class CraftMetaBookSigned extends CraftMetaItem implements BookMeta {
 
     @Override
     public void addPages(net.kyori.adventure.text.Component... pages) {
-        if (this.pages == null) this.pages = new ArrayList<>();
+        if (this.pages == null) this.pages = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (net.kyori.adventure.text.Component page : pages) {
             if (this.pages.size() >= MAX_PAGES) {
                 return;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
index 51da0db4da3549efd69f367e28450408968fa8d0..5a82095f486b2ae65d4f5c6c49ffa984123dc7f5 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBundle.java
@@ -3,9 +3,6 @@ package org.bukkit.craftbukkit.inventory;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
 import net.minecraft.core.component.DataComponentPatch;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.world.item.component.BundleContents;
@@ -13,6 +10,10 @@ import org.bukkit.configuration.serialization.DelegateDeserialization;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.meta.BundleMeta;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
 @DelegateDeserialization(SerializableMeta.class)
 public class CraftMetaBundle extends CraftMetaItem implements BundleMeta {
 
@@ -66,7 +67,7 @@ public class CraftMetaBundle extends CraftMetaItem implements BundleMeta {
         super.applyToItem(tag);
 
         if (this.hasItems()) {
-            List<net.minecraft.world.item.ItemStack> list = new ArrayList<>();
+            List<net.minecraft.world.item.ItemStack> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             for (ItemStack item : this.items) {
                 list.add(CraftItemStack.asNMSCopy(item));
@@ -113,7 +114,7 @@ public class CraftMetaBundle extends CraftMetaItem implements BundleMeta {
         Preconditions.checkArgument(item != null && !item.isEmpty(), "item is null or empty"); // Paper
 
         if (this.items == null) {
-            this.items = new ArrayList<>();
+            this.items = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
 
         this.items.add(item);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
index 88ea260fb84a5f8eaab3a23a9a65d0411215a6a1..615ed921b4f9abb41b5dc736eac415553fb7ab29 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaCrossbow.java
@@ -3,18 +3,17 @@ package org.bukkit.craftbukkit.inventory;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
 import net.minecraft.core.component.DataComponentPatch;
 import net.minecraft.core.component.DataComponents;
-import net.minecraft.world.item.ArrowItem;
 import net.minecraft.world.item.component.ChargedProjectiles;
-import org.bukkit.Material;
 import org.bukkit.configuration.serialization.DelegateDeserialization;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.meta.CrossbowMeta;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
 @DelegateDeserialization(SerializableMeta.class)
 public class CraftMetaCrossbow extends CraftMetaItem implements CrossbowMeta {
 
@@ -43,7 +42,7 @@ public class CraftMetaCrossbow extends CraftMetaItem implements CrossbowMeta {
             List<net.minecraft.world.item.ItemStack> list = p.getItems();
 
             if (list != null && !list.isEmpty()) {
-                this.chargedProjectiles = new ArrayList<>();
+                this.chargedProjectiles = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
                 for (int i = 0; i < list.size(); i++) {
                     net.minecraft.world.item.ItemStack nbttagcompound1 = list.get(i);
@@ -72,7 +71,7 @@ public class CraftMetaCrossbow extends CraftMetaItem implements CrossbowMeta {
         super.applyToItem(tag);
 
         if (this.hasChargedProjectiles()) {
-            List<net.minecraft.world.item.ItemStack> list = new ArrayList<>();
+            List<net.minecraft.world.item.ItemStack> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             for (ItemStack item : this.chargedProjectiles) {
                 list.add(CraftItemStack.asNMSCopy(item));
@@ -120,7 +119,7 @@ public class CraftMetaCrossbow extends CraftMetaItem implements CrossbowMeta {
         Preconditions.checkArgument(!item.isEmpty(), "Item cannot be empty"); // Paper
 
         if (this.chargedProjectiles == null) {
-            this.chargedProjectiles = new ArrayList<>();
+            this.chargedProjectiles = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
 
         this.chargedProjectiles.add(item);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
index a944803771d514572f94b4e98a6d4435a009c078..b4af5aba7fbe391dfbc95a454c33195944a4bf87 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaFirework.java
@@ -4,11 +4,6 @@ import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap.Builder;
 import it.unimi.dsi.fastutil.ints.IntList;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
 import net.minecraft.core.component.DataComponentPatch;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.world.item.component.FireworkExplosion;
@@ -21,6 +16,8 @@ import org.bukkit.craftbukkit.inventory.CraftMetaItem.ItemMetaKey.Specific;
 import org.bukkit.craftbukkit.inventory.CraftMetaItem.ItemMetaKey.Specific.To;
 import org.bukkit.inventory.meta.FireworkMeta;
 
+import java.util.*;
+
 public @DelegateDeserialization(SerializableMeta.class)
 class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
     /*
@@ -164,7 +161,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
 
         List<FireworkEffect> effects = this.effects;
         if (effects == null) {
-            effects = this.effects = new ArrayList<>();
+            effects = this.effects = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
 
         for (Object obj : collection) {
@@ -189,7 +186,7 @@ class CraftMetaFirework extends CraftMetaItem implements FireworkMeta {
             return;
         }
 
-        List<FireworkExplosion> effects = new ArrayList<>();
+        List<FireworkExplosion> effects = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         if (this.hasEffects()) {
             for (FireworkEffect effect : this.effects) {
                 effects.add(CraftMetaFirework.getExplosion(effect));
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 60ec9b228518de0521b12f3f4ef26cb30260315a..9e569a87a58e8846ba6b7ae6bd3710669f3a00d9 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -1583,7 +1583,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
             if (componentValue.isPresent()) {
                 Tag componentValueAsNBT = (Tag) ((DataComponentType) componentType).codecOrThrow().encodeStart(ops, componentValue.get()).getOrThrow();
-                String componentValueAsNBTString = new SnbtPrinterTagVisitor("", 0, new ArrayList<>()).visit(componentValueAsNBT);
+                String componentValueAsNBTString = new SnbtPrinterTagVisitor("", 0, new net.vansen.norspaper.collections.DynamicObjectArrayList<>()).visit(componentValueAsNBT);
                 componentString.add(componentKey + "=" + componentValueAsNBTString);
             } else {
                 componentString.add("!" + componentKey);
@@ -1839,7 +1839,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
         if (this.hasLore()) {
             // SPIGOT-7625: Convert lore to json before serializing it
-            List<String> jsonLore = new ArrayList<>();
+            List<String> jsonLore = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             for (Component component : this.lore) {
                 jsonLore.add(CraftChatMessage.toJSON(component));
@@ -1963,7 +1963,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             RegistryAccess registryAccess = CraftRegistry.getMinecraftRegistry();
             Registry<DataComponentType<?>> componentTypeRegistry = registryAccess.registryOrThrow(Registries.DATA_COMPONENT_TYPE);
 
-            List<String> removedTags = new ArrayList<>();
+            List<String> removedTags = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (DataComponentType<?> removed : this.removedTags) {
                 String componentKey = componentTypeRegistry.getResourceKey(removed).orElseThrow().location().toString();
 
@@ -2246,7 +2246,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     }
 
     private static List<net.minecraft.advancements.critereon.BlockPredicate> convertFromLegacyNamespaced(final Collection<com.destroystokyo.paper.Namespaced> namespaceds) {
-        final List<net.minecraft.advancements.critereon.BlockPredicate> predicates = new ArrayList<>();
+        final List<net.minecraft.advancements.critereon.BlockPredicate> predicates = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final com.destroystokyo.paper.Namespaced namespaced : namespaceds) {
             if (namespaced instanceof final org.bukkit.NamespacedKey key) {
                 predicates.add(net.minecraft.advancements.critereon.BlockPredicate.Builder.block().of(CraftBlockType.bukkitToMinecraft(Objects.requireNonNull(org.bukkit.Registry.MATERIAL.get(key)))).build());
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java
index e47c1b9a52c938b145b721d9c088f4a916a01424..bca033535d83e6ca5df2837bed064a8a56c66b81 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaKnowledgeBook.java
@@ -1,10 +1,6 @@
 package org.bukkit.craftbukkit.inventory;
 
 import com.google.common.collect.ImmutableMap.Builder;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
 import net.minecraft.core.component.DataComponentPatch;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.resources.ResourceLocation;
@@ -13,6 +9,11 @@ import org.bukkit.configuration.serialization.DelegateDeserialization;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.inventory.meta.KnowledgeBookMeta;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
 @DelegateDeserialization(SerializableMeta.class)
 public class CraftMetaKnowledgeBook extends CraftMetaItem implements KnowledgeBookMeta {
 
@@ -60,7 +61,7 @@ public class CraftMetaKnowledgeBook extends CraftMetaItem implements KnowledgeBo
         super.applyToItem(itemData);
 
         if (this.hasRecipes()) {
-            List<ResourceLocation> list = new ArrayList<>();
+            List<ResourceLocation> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (NamespacedKey recipe : this.recipes) {
                 list.add(CraftNamespacedKey.toMinecraft(recipe));
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
index c2476232b5472f1a0b1862588de2abf879b82ede..024a75ed6215a7ff007d600509c6f85c6474d780 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaPotion.java
@@ -122,7 +122,7 @@ class CraftMetaPotion extends CraftMetaItem implements PotionMeta {
         Optional<Holder<Potion>> defaultPotion = (this.hasBasePotionType()) ? Optional.of(CraftPotionType.bukkitToMinecraftHolder(this.type)) : Optional.empty();
         Optional<Integer> potionColor = (this.hasColor()) ? Optional.of(this.color) : Optional.empty(); // Paper
 
-        List<MobEffectInstance> effectList = new ArrayList<>();
+        List<MobEffectInstance> effectList = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         if (this.customEffects != null) {
             for (PotionEffect effect : this.customEffects) {
                 effectList.add(new MobEffectInstance(CraftPotionEffectType.bukkitToMinecraftHolder(effect.getType()), effect.getDuration(), effect.getAmplifier(), effect.isAmbient(), effect.hasParticles(), effect.hasIcon()));
@@ -207,7 +207,7 @@ class CraftMetaPotion extends CraftMetaItem implements PotionMeta {
             }
         } else {
             if (this.customEffects == null) {
-                this.customEffects = new ArrayList<>();
+                this.customEffects = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             }
             this.customEffects.add(effect);
             return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaShield.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaShield.java
index e229ca6acb6dbc3185f326f6653b3d66d835a9e5..deca2638cceaa5a24794b752e2c9abd5cfe77955 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaShield.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaShield.java
@@ -103,7 +103,7 @@ public class CraftMetaShield extends CraftMetaItem implements ShieldMeta, BlockS
         if (this.patterns != null && !this.patterns.isEmpty()) {
             {
         // Paper end - general item meta fixes - decoupled base colour and patterns
-                List<BannerPatternLayers.Layer> newPatterns = new ArrayList<>();
+                List<BannerPatternLayers.Layer> newPatterns = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
                 for (Pattern p : this.patterns) { // Paper - general item meta fixes - decoupled base colour and patterns
                     newPatterns.add(new BannerPatternLayers.Layer(CraftPatternType.bukkitToMinecraftHolder(p.getPattern()), net.minecraft.world.item.DyeColor.byId(p.getColor().getWoolData())));
@@ -117,7 +117,7 @@ public class CraftMetaShield extends CraftMetaItem implements ShieldMeta, BlockS
     @Override
     public List<Pattern> getPatterns() {
         if (this.patterns == null) { // Paper - general item meta fixes - decoupled base colour and patterns
-            return new ArrayList<>();
+            return new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
 
         return new ArrayList<>(this.patterns); // Paper - general item meta fixes - decoupled base colour and patterns
@@ -131,7 +131,7 @@ public class CraftMetaShield extends CraftMetaItem implements ShieldMeta, BlockS
     @Override
     public void addPattern(Pattern pattern) {
         // Paper start - general item meta fixes - decoupled base colour and patterns
-        if (this.patterns == null) this.patterns = new ArrayList<>();
+        if (this.patterns == null) this.patterns = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         this.patterns.add(pattern);
         // Paper end - general item meta fixes - decoupled base colour and patterns
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java
index 192cd33f6276ea4928e29ac2cd4e45bf8bf82dcb..8906d5db095324191a78400ea832421ed99380e3 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSuspiciousStew.java
@@ -3,10 +3,6 @@ package org.bukkit.craftbukkit.inventory;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap.Builder;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
 import net.minecraft.core.component.DataComponentPatch;
 import net.minecraft.core.component.DataComponents;
 import net.minecraft.world.item.component.SuspiciousStewEffects;
@@ -16,6 +12,11 @@ import org.bukkit.inventory.meta.SuspiciousStewMeta;
 import org.bukkit.potion.PotionEffect;
 import org.bukkit.potion.PotionEffectType;
 
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
 @DelegateDeserialization(SerializableMeta.class)
 public class CraftMetaSuspiciousStew extends CraftMetaItem implements SuspiciousStewMeta {
 
@@ -71,7 +72,7 @@ public class CraftMetaSuspiciousStew extends CraftMetaItem implements Suspicious
         super.applyToItem(tag);
 
         if (this.customEffects != null) {
-            List<SuspiciousStewEffects.Entry> effectList = new ArrayList<>();
+            List<SuspiciousStewEffects.Entry> effectList = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
             for (io.papermc.paper.potion.SuspiciousEffectEntry effect : this.customEffects) {
                 effectList.add(new net.minecraft.world.item.component.SuspiciousStewEffects.Entry(CraftPotionEffectType.bukkitToMinecraftHolder(effect.effect()), effect.duration())); // Paper - add overloads to use suspicious effect entry to mushroom cow and suspicious stew meta
@@ -123,7 +124,7 @@ public class CraftMetaSuspiciousStew extends CraftMetaItem implements Suspicious
         Preconditions.checkArgument(suspiciousEffectEntry != null, "Suspicious effect entry cannot be null");
         if (this.hasCustomEffects()) {
             final List<io.papermc.paper.potion.SuspiciousEffectEntry> matchingEffects = this.customEffects.stream().filter(
-                entry -> entry.effect() == suspiciousEffectEntry.effect()
+                    entry -> entry.effect() == suspiciousEffectEntry.effect()
             ).toList();
             if (!matchingEffects.isEmpty()) {
                 if (overwrite) {
@@ -143,13 +144,13 @@ public class CraftMetaSuspiciousStew extends CraftMetaItem implements Suspicious
                         this.customEffects.add(suspiciousEffectEntry);
                     }
                     return true;
-                } else  {
+                } else {
                     return false;
                 }
             }
         }
         if (this.customEffects == null) {
-            this.customEffects = new ArrayList<>();
+            this.customEffects = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         }
         this.customEffects.add(suspiciousEffectEntry);
         return true;
@@ -170,7 +171,7 @@ public class CraftMetaSuspiciousStew extends CraftMetaItem implements Suspicious
         while (iterator.hasNext()) {
             io.papermc.paper.potion.SuspiciousEffectEntry effect = iterator.next();
             if (type.equals(effect.effect())) {
-        // Paper end - add overloads to use suspicious effect entry to mushroom cow and suspicious stew meta
+                // Paper end - add overloads to use suspicious effect entry to mushroom cow and suspicious stew meta
                 iterator.remove();
                 changed = true;
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftStonecutterView.java b/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftStonecutterView.java
index fc5da1e31e25bc08d9e478fc10214a02219d2400..0b290051cb20a006f69c84af60fffa48c4c84e28 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftStonecutterView.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/view/CraftStonecutterView.java
@@ -1,7 +1,5 @@
 package org.bukkit.craftbukkit.inventory.view;
 
-import java.util.ArrayList;
-import java.util.List;
 import net.minecraft.world.inventory.StonecutterMenu;
 import net.minecraft.world.item.crafting.RecipeHolder;
 import net.minecraft.world.item.crafting.StonecutterRecipe;
@@ -12,6 +10,8 @@ import org.bukkit.inventory.StonecuttingRecipe;
 import org.bukkit.inventory.view.StonecutterView;
 import org.jetbrains.annotations.NotNull;
 
+import java.util.List;
+
 public class CraftStonecutterView extends CraftInventoryView<StonecutterMenu, StonecutterInventory> implements StonecutterView {
 
     public CraftStonecutterView(final HumanEntity player, final StonecutterInventory viewing, final StonecutterMenu container) {
@@ -26,7 +26,7 @@ public class CraftStonecutterView extends CraftInventoryView<StonecutterMenu, St
     @NotNull
     @Override
     public List<StonecuttingRecipe> getRecipes() {
-        final List<StonecuttingRecipe> recipes = new ArrayList<>();
+        final List<StonecuttingRecipe> recipes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (final RecipeHolder<StonecutterRecipe> recipe : this.container.getRecipes()) {
             recipes.add((StonecuttingRecipe) recipe.toBukkitRecipe());
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/legacy/reroute/RerouteBuilder.java b/src/main/java/org/bukkit/craftbukkit/legacy/reroute/RerouteBuilder.java
index ca02b6b937a4b95778e6318714f8d8af7af8fb39..e3ac20d6a10623134094253b0e06df3f662b1cb9 100644
--- a/src/main/java/org/bukkit/craftbukkit/legacy/reroute/RerouteBuilder.java
+++ b/src/main/java/org/bukkit/craftbukkit/legacy/reroute/RerouteBuilder.java
@@ -15,7 +15,7 @@ import org.objectweb.asm.Type;
 
 public class RerouteBuilder {
 
-    private final List<Class<?>> classes = new ArrayList<>();
+    private final List<Class<?>> classes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final Predicate<String> compatibilityPresent;
 
     private RerouteBuilder(Predicate<String> compatibilityPresent) {
@@ -45,7 +45,7 @@ public class RerouteBuilder {
     private static List<RerouteMethodData> buildFromClass(Class<?> clazz, Predicate<String> compatibilityPresent) {
         Preconditions.checkArgument(!clazz.isInterface(), "Interface Classes are currently not supported");
 
-        List<RerouteMethodData> result = new ArrayList<>();
+        List<RerouteMethodData> result = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         boolean shouldInclude = RerouteBuilder.shouldInclude(RerouteBuilder.getRequireCompatibility(clazz), true, compatibilityPresent);
 
         for (Method method : clazz.getDeclaredMethods()) {
@@ -65,8 +65,8 @@ public class RerouteBuilder {
 
     private static RerouteMethodData buildFromMethod(Method method) {
         RerouteReturn rerouteReturn = new RerouteReturn(Type.getReturnType(method));
-        List<RerouteArgument> arguments = new ArrayList<>();
-        List<RerouteArgument> sourceArguments = new ArrayList<>();
+        List<RerouteArgument> arguments = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+        List<RerouteArgument> sourceArguments = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
         for (Parameter parameter : method.getParameters()) {
             Type type = Type.getType(parameter.getType());
diff --git a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
index 66eff9ddee09f44935df6d8ed3eb24943b603581..25d6157014a3447412029b752610d4caa3af34b3 100644
--- a/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
+++ b/src/main/java/org/bukkit/craftbukkit/profile/CraftPlayerProfile.java
@@ -295,7 +295,7 @@ public final class CraftPlayerProfile implements PlayerProfile, com.destroystoky
         }
         this.rebuildDirtyProperties();
         if (!this.properties.isEmpty()) {
-            List<Object> propertiesData = new ArrayList<>();
+            List<Object> propertiesData = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             this.properties.forEach((propertyName, property) -> propertiesData.add(CraftProfileProperty.serialize(property)));
             map.put("properties", propertiesData);
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
index 4975fde71785a86dc812829f640ec2742d7d6fba..d772e67d3ef056fc80ba52d08bb8ed46db67d94d 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftAsyncScheduler.java
@@ -27,14 +27,9 @@ import com.destroystokyo.paper.ServerSchedulerReportingWrapper;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import org.bukkit.plugin.Plugin;
 
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.*;
 
 public class CraftAsyncScheduler extends CraftScheduler {
 
@@ -42,7 +37,7 @@ public class CraftAsyncScheduler extends CraftScheduler {
     private final Executor executor; // Leaf - use super class
     private final Executor management = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()
             .setNameFormat("Craft Async Scheduler Management Thread").build());
-    private final List<CraftTask> temp = new ArrayList<>();
+    private final List<CraftTask> temp = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     CraftAsyncScheduler() {
         super(true);
@@ -136,6 +131,7 @@ public class CraftAsyncScheduler extends CraftScheduler {
 
     /**
      * Task is not cancelled
+     *
      * @param runningTask
      * @return
      */
diff --git a/src/main/java/org/bukkit/craftbukkit/structure/CraftPalette.java b/src/main/java/org/bukkit/craftbukkit/structure/CraftPalette.java
index 26c7d0d39e5517945cc99c89e9abba653e4333de..f84b87cf266192b453293ec9a14153bf241c9f6f 100644
--- a/src/main/java/org/bukkit/craftbukkit/structure/CraftPalette.java
+++ b/src/main/java/org/bukkit/craftbukkit/structure/CraftPalette.java
@@ -20,7 +20,7 @@ public class CraftPalette implements Palette {
 
     @Override
     public List<BlockState> getBlocks() {
-        List<BlockState> blocks = new ArrayList<>();
+        List<BlockState> blocks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (StructureTemplate.StructureBlockInfo blockInfo : this.palette.blocks()) {
             blocks.add(CraftBlockStates.getBlockState(this.registry, blockInfo.pos(), blockInfo.state(), blockInfo.nbt()));
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/structure/CraftStructure.java b/src/main/java/org/bukkit/craftbukkit/structure/CraftStructure.java
index d317bdb4a0e161f03d85b3164b91794e3a42d5a9..92f72f15f497bdb24578694f897d8aed4b7e1179 100644
--- a/src/main/java/org/bukkit/craftbukkit/structure/CraftStructure.java
+++ b/src/main/java/org/bukkit/craftbukkit/structure/CraftStructure.java
@@ -1,12 +1,6 @@
 package org.bukkit.craftbukkit.structure;
 
 import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.RegistryAccess;
 import net.minecraft.util.RandomSource;
@@ -26,11 +20,7 @@ import org.bukkit.block.structure.Mirror;
 import org.bukkit.block.structure.StructureRotation;
 import org.bukkit.craftbukkit.CraftRegionAccessor;
 import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.util.CraftBlockVector;
-import org.bukkit.craftbukkit.util.CraftLocation;
-import org.bukkit.craftbukkit.util.CraftStructureTransformer;
-import org.bukkit.craftbukkit.util.RandomSourceWrapper;
-import org.bukkit.craftbukkit.util.TransformerGeneratorAccess;
+import org.bukkit.craftbukkit.util.*;
 import org.bukkit.entity.Entity;
 import org.bukkit.persistence.PersistentDataContainer;
 import org.bukkit.structure.Palette;
@@ -39,6 +29,12 @@ import org.bukkit.util.BlockTransformer;
 import org.bukkit.util.BlockVector;
 import org.bukkit.util.EntityTransformer;
 
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import java.util.stream.Collectors;
+
 public class CraftStructure implements Structure {
 
     private final StructureTemplate structure;
@@ -67,7 +63,7 @@ public class CraftStructure implements Structure {
 
     @Override
     public void place(RegionAccessor regionAccessor, BlockVector location, boolean includeEntities, StructureRotation structureRotation, Mirror mirror, int palette, float integrity, Random random) {
-       this.place(regionAccessor, location, includeEntities, structureRotation, mirror, palette, integrity, random, Collections.emptyList(), Collections.emptyList());
+        this.place(regionAccessor, location, includeEntities, structureRotation, mirror, palette, integrity, random, Collections.emptyList(), Collections.emptyList());
     }
 
     @Override
@@ -130,7 +126,7 @@ public class CraftStructure implements Structure {
 
     @Override
     public List<Entity> getEntities() {
-        List<Entity> entities = new ArrayList<>();
+        List<Entity> entities = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (StructureTemplate.StructureEntityInfo entity : this.structure.entityInfoList) {
             EntityType.create(entity.nbt, ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle()).ifPresent(dummyEntity -> {
                 dummyEntity.setPos(entity.pos.x, entity.pos.y, entity.pos.z);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Commodore.java b/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
index 419b899f0e65b9656432513b69f60150c75bd13f..c9a7e4acb324e95519c2e30f6cf18a12f685b25a 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
@@ -92,7 +92,7 @@ public class Commodore {
             "org/bukkit/block/banner/PatternType", "NOP"
     );
 
-    private final List<Reroute> reroutes = new ArrayList<>(); // only for testing
+    private final List<Reroute> reroutes = new net.vansen.norspaper.collections.DynamicObjectArrayList<>(); // only for testing
     private Reroute materialReroute;
     private Reroute reroute;
 
@@ -607,7 +607,7 @@ public class Commodore {
                                     newOpcode = Opcodes.H_INVOKESTATIC;
                                 }
 
-                                List<Object> methodArgs = new ArrayList<>();
+                                List<Object> methodArgs = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                                 methodArgs.add(newSam);
                                 methodArgs.add(new Handle(newOpcode, newOwner, newName, newDescription, newItf));
                                 methodArgs.add(newInstantiated);
@@ -725,7 +725,7 @@ public class Commodore {
     }
 
     private static List<String> getMethodSignatures(byte[] clazz) {
-        List<String> methods = new ArrayList<>();
+        List<String> methods = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         ClassReader cr = new ClassReader(clazz);
         cr.accept(new ClassVisitor(Opcodes.ASM9) {
             @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
index 59ff2801592c98e7471404c70dbbdf3db1b7716b..c7aec5af1636e1b818e8f985128c5008706017a6 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/WeakCollection.java
@@ -12,7 +12,7 @@ public final class WeakCollection<T> implements Collection<T> {
     private final Collection<WeakReference<T>> collection;
 
     public WeakCollection() {
-        this.collection = new ArrayList<>();
+        this.collection = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     }
 
     @Override
diff --git a/src/main/java/org/dreeam/leaf/config/modules/misc/HiddenItemComponents.java b/src/main/java/org/dreeam/leaf/config/modules/misc/HiddenItemComponents.java
index f89b21cbe62d66afd61c7a61d3a126a5dfda373e..5892d250c4fd205ec6b890665571addb8adec4d1 100644
--- a/src/main/java/org/dreeam/leaf/config/modules/misc/HiddenItemComponents.java
+++ b/src/main/java/org/dreeam/leaf/config/modules/misc/HiddenItemComponents.java
@@ -20,20 +20,20 @@ public class HiddenItemComponents extends ConfigModules {
 
     @Override
     public void onLoaded() {
-        List<String> list = config.getList(getBasePath() + ".hidden-item-components", new ArrayList<>(), config.pickStringRegionBased("""
-                Controls whether specified component information is sent to clients.
-                This may break resource packs and mods that rely on this information.
-                It needs a component type list, incorrect things will not work.
-                You can fill it with ["custom_data"] to hide components of CUSTOM_DATA.
-                Also, it can avoid some frequent client animations.
-                NOTICE: You must know what you're filling in and how it works! It will handle all itemStacks!""",
+        List<String> list = config.getList(getBasePath() + ".hidden-item-components", new net.vansen.norspaper.collections.DynamicObjectArrayList<>(), config.pickStringRegionBased("""
+                        Controls whether specified component information is sent to clients.
+                        This may break resource packs and mods that rely on this information.
+                        It needs a component type list, incorrect things will not work.
+                        You can fill it with ["custom_data"] to hide components of CUSTOM_DATA.
+                        Also, it can avoid some frequent client animations.
+                        NOTICE: You must know what you're filling in and how it works! It will handle all itemStacks!""",
                 """
-                控制哪些物品组件信息会被发送至客户端.
-                可能会导致依赖物品组件的资源包/模组无法正常工作.
-                该配置项接受一个物品组件列表, 格式不正确将不会启用.
-                可以填入 ["custom_data"] 来隐藏自定义数据物品组件 CUSTOM_DATA.
-                也可以避免一些客户端动画效果.
-                注意: 你必须知道你填进去的是什么, 有什么用, 该项配置会处理所有的ItemStack!"""));
+                        控制哪些物品组件信息会被发送至客户端.
+                        可能会导致依赖物品组件的资源包/模组无法正常工作.
+                        该配置项接受一个物品组件列表, 格式不正确将不会启用.
+                        可以填入 ["custom_data"] 来隐藏自定义数据物品组件 CUSTOM_DATA.
+                        也可以避免一些客户端动画效果.
+                        注意: 你必须知道你填进去的是什么, 有什么用, 该项配置会处理所有的ItemStack!"""));
 
         List<DataComponentType<?>> types = new ArrayList<>(list.size());
 
diff --git a/src/main/java/org/dreeam/leaf/config/modules/opt/DynamicActivationofBrain.java b/src/main/java/org/dreeam/leaf/config/modules/opt/DynamicActivationofBrain.java
index 7e1e06ff65d1e186e6ec41917945d3d90fe72008..943d2631527223ec1de5046beef04bb2378f4798 100644
--- a/src/main/java/org/dreeam/leaf/config/modules/opt/DynamicActivationofBrain.java
+++ b/src/main/java/org/dreeam/leaf/config/modules/opt/DynamicActivationofBrain.java
@@ -22,7 +22,7 @@ public class DynamicActivationofBrain extends ConfigModules {
     public static int maximumActivationPrio = 20;
     public static int activationDistanceMod = 8;
     public static boolean dontEnableIfInWater = false;
-    public static List<String> blackedEntities = new ArrayList<>();
+    public static List<String> blackedEntities = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     @Override
     public void onLoaded() {
diff --git a/src/main/java/org/leavesmc/leaves/protocol/ChatImageProtocol.java b/src/main/java/org/leavesmc/leaves/protocol/ChatImageProtocol.java
index 1ddafae8b8c3d5c0f12bb12dc01d09ecaa5d68cf..8b66edf498a78bab38fcd8af1da6d582f033e6aa 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/ChatImageProtocol.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/ChatImageProtocol.java
@@ -1,13 +1,11 @@
 package org.leavesmc.leaves.protocol;
 
-import com.google.common.collect.Lists;
 import com.google.gson.Gson;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ServerPlayer;
-import org.dreeam.leaf.config.modules.network.ProtocolSupport;
 import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.leavesmc.leaves.protocol.chatimage.ChatImageIndex;
@@ -54,7 +52,8 @@ public class ChatImageProtocol {
         }
     }
 
-    public record DownloadFileChannelPacket(String message) implements LeavesCustomPayload<LeavesProtocolManager.LeavesPayload> {
+    public record DownloadFileChannelPacket(
+            String message) implements LeavesCustomPayload<LeavesProtocolManager.LeavesPayload> {
         private static final ResourceLocation DOWNLOAD_FILE_CHANNEL = ChatImageProtocol.id("download_file_channel");
 
         @New
@@ -74,7 +73,8 @@ public class ChatImageProtocol {
 
     }
 
-    public record FileChannelPacket(String message) implements LeavesCustomPayload<LeavesProtocolManager.LeavesPayload> {
+    public record FileChannelPacket(
+            String message) implements LeavesCustomPayload<LeavesProtocolManager.LeavesPayload> {
         private static final ResourceLocation FILE_CHANNEL = ChatImageProtocol.id("file_channel");
 
         @New
@@ -110,7 +110,7 @@ public class ChatImageProtocol {
                         sendToPlayer(new FileInfoChannelPacket("true->" + title.url), serverPlayer);
                     }
                 }
-                USER_CACHE_MAP.put(title.url, Lists.newArrayList());
+                USER_CACHE_MAP.put(title.url, new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
             }
         }
     }
@@ -128,7 +128,7 @@ public class ChatImageProtocol {
             }
         }
         sendToPlayer(new FileInfoChannelPacket("null->" + url), player);
-        List<String> names = USER_CACHE_MAP.containsKey(url) ? USER_CACHE_MAP.get(url) : Lists.newArrayList();
+        List<String> names = USER_CACHE_MAP.containsKey(url) ? USER_CACHE_MAP.get(url) : new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         names.add(player.getStringUUID());
         USER_CACHE_MAP.put(url, names);
     }
diff --git a/src/main/java/org/leavesmc/leaves/protocol/core/LeavesProtocolManager.java b/src/main/java/org/leavesmc/leaves/protocol/core/LeavesProtocolManager.java
index ec901ea7103ce5a3e1d6fa1efd8135ce020e18ce..b6b8c691ed7c656e5d53b314278f8100b5cbe78b 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/core/LeavesProtocolManager.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/core/LeavesProtocolManager.java
@@ -10,21 +10,9 @@ import org.bukkit.event.player.PlayerKickEvent;
 import org.jetbrains.annotations.NotNull;
 import org.leavesmc.leaves.LeavesLogger;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Executable;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
+import java.lang.reflect.*;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 
 public class LeavesProtocolManager {
 
@@ -36,10 +24,10 @@ public class LeavesProtocolManager {
     private static final Map<LeavesProtocol, Map<ProtocolHandler.PayloadReceiver, Method>> KNOW_RECEIVERS = new HashMap<>();
     private static Set<ResourceLocation> ALL_KNOWN_ID = new HashSet<>();
 
-    private static final List<Method> TICKERS = new ArrayList<>();
-    private static final List<Method> PLAYER_JOIN = new ArrayList<>();
-    private static final List<Method> PLAYER_LEAVE = new ArrayList<>();
-    private static final List<Method> RELOAD_SERVER = new ArrayList<>();
+    private static final List<Method> TICKERS = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private static final List<Method> PLAYER_JOIN = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private static final List<Method> PLAYER_LEAVE = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    private static final List<Method> RELOAD_SERVER = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private static final Map<LeavesProtocol, Map<ProtocolHandler.MinecraftRegister, Method>> MINECRAFT_REGISTER = new HashMap<>();
 
     public static void reload() {
@@ -305,7 +293,7 @@ public class LeavesProtocolManager {
             Map<ProtocolHandler.MinecraftRegister, Method> map = MINECRAFT_REGISTER.get(protocol);
             for (ProtocolHandler.MinecraftRegister register : map.keySet()) {
                 if (register.ignoreId() || register.channelId().equals(channel[1]) ||
-                    ArrayUtils.contains(register.channelIds(), channel[1])) {
+                        ArrayUtils.contains(register.channelIds(), channel[1])) {
                     try {
                         map.get(register).invoke(null, player);
                     } catch (InvocationTargetException | IllegalAccessException exception) {
@@ -316,7 +304,8 @@ public class LeavesProtocolManager {
         }
     }
 
-    public record ErrorPayload(ResourceLocation id, String[] protocolID, String[] packetID) implements LeavesCustomPayload<ErrorPayload> {
+    public record ErrorPayload(ResourceLocation id, String[] protocolID,
+                               String[] packetID) implements LeavesCustomPayload<ErrorPayload> {
         @Override
         public void write(@NotNull FriendlyByteBuf buf) {
         }
@@ -334,7 +323,8 @@ public class LeavesProtocolManager {
         }
     }
 
-    public record LeavesPayload(FriendlyByteBuf data, ResourceLocation id) implements LeavesCustomPayload<LeavesPayload> {
+    public record LeavesPayload(FriendlyByteBuf data,
+                                ResourceLocation id) implements LeavesCustomPayload<LeavesPayload> {
 
         @New
         public LeavesPayload(ResourceLocation location, FriendlyByteBuf buf) {
diff --git a/src/main/java/org/leavesmc/leaves/protocol/jade/provider/block/CampfireProvider.java b/src/main/java/org/leavesmc/leaves/protocol/jade/provider/block/CampfireProvider.java
index a1a479987f2c0b6ff4cfd511cbcac1ea7b1c247b..e884d0f57728581c2ac916d6f2693ebe09dfa775 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/jade/provider/block/CampfireProvider.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/jade/provider/block/CampfireProvider.java
@@ -1,6 +1,5 @@
 package org.leavesmc.leaves.protocol.jade.provider.block;
 
-import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import net.minecraft.core.component.DataComponents;
@@ -25,7 +24,7 @@ public enum CampfireProvider implements IServerExtensionProvider<ItemStack> {
     @Override
     public List<ViewGroup<ItemStack>> getGroups(RequestAccessor<?> request) {
         if (request.target() instanceof CampfireBlockEntity campfire) {
-            List<ItemStack> list = Lists.newArrayList();
+            List<ItemStack> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (int i = 0; i < campfire.cookingTime.length; i++) {
                 ItemStack stack = campfire.getItems().get(i);
                 if (stack.isEmpty()) {
@@ -34,8 +33,8 @@ public enum CampfireProvider implements IServerExtensionProvider<ItemStack> {
                 stack = stack.copy();
 
                 CustomData customData = stack.getOrDefault(DataComponents.CUSTOM_DATA, CustomData.EMPTY)
-                    .update(NbtOps.INSTANCE, COOKING_TIME_CODEC, campfire.cookingTime[i] - campfire.cookingProgress[i])
-                    .getOrThrow();
+                        .update(NbtOps.INSTANCE, COOKING_TIME_CODEC, campfire.cookingTime[i] - campfire.cookingProgress[i])
+                        .getOrThrow();
                 stack.set(DataComponents.CUSTOM_DATA, customData);
 
                 list.add(stack);
diff --git a/src/main/java/org/leavesmc/leaves/protocol/jade/tool/SimpleToolHandler.java b/src/main/java/org/leavesmc/leaves/protocol/jade/tool/SimpleToolHandler.java
index 22fee6ecc49bbda94a7d32ee9dcf2a9ee661904b..fd377ffd5e011c8013974ce8f23ab62733eadae8 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/jade/tool/SimpleToolHandler.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/jade/tool/SimpleToolHandler.java
@@ -15,7 +15,7 @@ import java.util.List;
 
 public class SimpleToolHandler implements ToolHandler {
 
-    protected final List<ItemStack> tools = Lists.newArrayList();
+    protected final List<ItemStack> tools = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final ResourceLocation uid;
     private final boolean skipInstaBreakingBlock;
 
diff --git a/src/main/java/org/leavesmc/leaves/protocol/jade/util/HierarchyLookup.java b/src/main/java/org/leavesmc/leaves/protocol/jade/util/HierarchyLookup.java
index 9e88dc87bd4a86c15b2b0d11ac4b095174b1c3d3..12fdc7ca12953960c9270d1c041f2fa78a56bd8f 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/jade/util/HierarchyLookup.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/jade/util/HierarchyLookup.java
@@ -3,23 +3,13 @@ package org.leavesmc.leaves.protocol.jade.util;
 import com.google.common.base.Preconditions;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
-import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
+import com.google.common.collect.*;
 import net.minecraft.resources.ResourceLocation;
 import org.leavesmc.leaves.LeavesLogger;
 import org.leavesmc.leaves.protocol.jade.JadeProtocol;
 import org.leavesmc.leaves.protocol.jade.provider.IJadeProvider;
 
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.ExecutionException;
 import java.util.stream.Stream;
 
@@ -57,7 +47,7 @@ public class HierarchyLookup<T extends IJadeProvider> implements IHierarchyLooku
     public List<T> get(Class<?> clazz) {
         try {
             return resultCache.get(clazz, () -> {
-                List<T> list = Lists.newArrayList();
+                List<T> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
                 getInternal(clazz, list);
                 list = ImmutableList.sortedCopyOf(Comparator.comparingInt(JadeProtocol.priorities::byValue), list);
                 if (singleton && !list.isEmpty()) {
@@ -103,9 +93,9 @@ public class HierarchyLookup<T extends IJadeProvider> implements IHierarchyLooku
             for (T provider : list) {
                 if (set.contains(provider.getUid())) {
                     throw new IllegalStateException("Duplicate UID: %s for %s".formatted(provider.getUid(), list.stream()
-                        .filter(p -> p.getUid().equals(provider.getUid()))
-                        .map(p -> p.getClass().getName())
-                        .toList()
+                            .filter(p -> p.getUid().equals(provider.getUid()))
+                            .map(p -> p.getClass().getName())
+                            .toList()
                     ));
                 }
                 set.add(provider.getUid());
@@ -113,8 +103,8 @@ public class HierarchyLookup<T extends IJadeProvider> implements IHierarchyLooku
         });
 
         objects = ImmutableListMultimap.<Class<?>, T>builder()
-            .orderValuesBy(Comparator.comparingInt(priorityStore::byValue))
-            .putAll(objects)
-            .build();
+                .orderValuesBy(Comparator.comparingInt(priorityStore::byValue))
+                .putAll(objects)
+                .build();
     }
 }
diff --git a/src/main/java/org/leavesmc/leaves/protocol/jade/util/LootTableMineableCollector.java b/src/main/java/org/leavesmc/leaves/protocol/jade/util/LootTableMineableCollector.java
index c811f89295964b1cb86c3eea39cd20f979ebceb9..e3a43fed0b53381e0d03f99e5ad264d4b1cfd5ea 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/jade/util/LootTableMineableCollector.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/jade/util/LootTableMineableCollector.java
@@ -1,6 +1,5 @@
 package org.leavesmc.leaves.protocol.jade.util;
 
-import com.google.common.collect.Lists;
 import net.minecraft.advancements.critereon.ItemPredicate;
 import net.minecraft.core.Registry;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -31,7 +30,7 @@ public class LootTableMineableCollector {
 
     public static List<Block> execute(Registry<LootTable> lootRegistry, ItemStack toolItem) {
         LootTableMineableCollector collector = new LootTableMineableCollector(lootRegistry, toolItem);
-        List<Block> list = Lists.newArrayList();
+        List<Block> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (Block block : BuiltInRegistries.BLOCK) {
             if (!ShearsToolHandler.getInstance().test(block.defaultBlockState()).isEmpty()) {
                 continue;
diff --git a/src/main/java/org/leavesmc/leaves/protocol/jade/util/WrappedHierarchyLookup.java b/src/main/java/org/leavesmc/leaves/protocol/jade/util/WrappedHierarchyLookup.java
index eec302b45bedb026e1d3a4595ed99b89b2a64655..511103ebb4fb291e81784c20cafcb7ade7547fae 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/jade/util/WrappedHierarchyLookup.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/jade/util/WrappedHierarchyLookup.java
@@ -1,6 +1,5 @@
 package org.leavesmc.leaves.protocol.jade.util;
 
-import com.google.common.collect.Lists;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.level.block.Block;
 import org.apache.commons.lang3.tuple.Pair;
@@ -17,7 +16,7 @@ import java.util.stream.Stream;
 
 public class WrappedHierarchyLookup<T extends IJadeProvider> extends HierarchyLookup<T> {
 
-    public final List<Pair<IHierarchyLookup<T>, Function<RequestAccessor<?>, @Nullable Object>>> overrides = Lists.newArrayList();
+    public final List<Pair<IHierarchyLookup<T>, Function<RequestAccessor<?>, @Nullable Object>>> overrides = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private boolean empty = true;
 
     public WrappedHierarchyLookup() {
@@ -31,7 +30,7 @@ public class WrappedHierarchyLookup<T extends IJadeProvider> extends HierarchyLo
     }
 
     public List<T> get(RequestAccessor<?> accessor) {
-        List<T> list = Lists.newArrayList();
+        List<T> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         for (var override : overrides) {
             Object o = override.getRight().apply(accessor);
             if (o != null) {
diff --git a/src/main/java/org/leavesmc/leaves/protocol/syncmatica/CommunicationManager.java b/src/main/java/org/leavesmc/leaves/protocol/syncmatica/CommunicationManager.java
index c039765237d56def91a1e630a0510062305fd585..712401c7204f7986c2b8cd1e8b67513bf16781db 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/syncmatica/CommunicationManager.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/syncmatica/CommunicationManager.java
@@ -11,25 +11,14 @@ import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.Rotation;
 import org.jetbrains.annotations.NotNull;
 import org.leavesmc.leaves.protocol.core.LeavesProtocol;
-import org.leavesmc.leaves.protocol.core.LeavesProtocolManager;
 import org.leavesmc.leaves.protocol.core.ProtocolHandler;
-import org.leavesmc.leaves.protocol.syncmatica.exchange.DownloadExchange;
-import org.leavesmc.leaves.protocol.syncmatica.exchange.Exchange;
-import org.leavesmc.leaves.protocol.syncmatica.exchange.ExchangeTarget;
-import org.leavesmc.leaves.protocol.syncmatica.exchange.ModifyExchangeServer;
-import org.leavesmc.leaves.protocol.syncmatica.exchange.UploadExchange;
-import org.leavesmc.leaves.protocol.syncmatica.exchange.VersionHandshakeServer;
+import org.leavesmc.leaves.protocol.syncmatica.exchange.*;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
+import java.util.*;
 
 @LeavesProtocol(namespace = "syncmatica")
 public class CommunicationManager {
@@ -37,7 +26,7 @@ public class CommunicationManager {
     private static final Map<UUID, List<ServerPlacement>> downloadingFile = new HashMap<>();
     private static final Map<ExchangeTarget, ServerPlayer> playerMap = new HashMap<>();
 
-    protected static final Collection<ExchangeTarget> broadcastTargets = new ArrayList<>();
+    protected static final Collection<ExchangeTarget> broadcastTargets = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
 
     protected static final Map<UUID, Boolean> downloadState = new HashMap<>();
     protected static final Map<UUID, Exchange> modifyState = new HashMap<>();
@@ -150,7 +139,7 @@ public class CommunicationManager {
 
             if (!SyncmaticaProtocol.getFileStorage().getLocalState(placement).isLocalFileReady()) {
                 if (SyncmaticaProtocol.getFileStorage().getLocalState(placement) == LocalLitematicState.DOWNLOADING_LITEMATIC) {
-                    downloadingFile.computeIfAbsent(placement.getHash(), key -> new ArrayList<>()).add(placement);
+                    downloadingFile.computeIfAbsent(placement.getHash(), key -> new net.vansen.norspaper.collections.DynamicObjectArrayList<>()).add(placement);
                     return;
                 }
                 try {
diff --git a/src/main/java/org/leavesmc/leaves/protocol/syncmatica/FeatureSet.java b/src/main/java/org/leavesmc/leaves/protocol/syncmatica/FeatureSet.java
index ddd0f498feb2ad62134ae15a3ddb21527f2f24bf..6ba3e2b292fab0e991e125188adc2f1c4dfbfae1 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/syncmatica/FeatureSet.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/syncmatica/FeatureSet.java
@@ -31,7 +31,7 @@ public class FeatureSet {
 
     @NotNull
     public static FeatureSet fromString(final @NotNull String features) {
-        final FeatureSet featureSet = new FeatureSet(new ArrayList<>());
+        final FeatureSet featureSet = new FeatureSet(new net.vansen.norspaper.collections.DynamicObjectArrayList<>());
         for (final String feature : features.split("\n")) {
             final Feature f = Feature.fromString(feature);
             if (f != null) {
diff --git a/src/main/java/org/leavesmc/leaves/protocol/syncmatica/exchange/ExchangeTarget.java b/src/main/java/org/leavesmc/leaves/protocol/syncmatica/exchange/ExchangeTarget.java
index b0da7abf0748d4bdb3141c28f201906157a0eaad..c372c8b831ef9abc05fcf26d4958f950c507851c 100644
--- a/src/main/java/org/leavesmc/leaves/protocol/syncmatica/exchange/ExchangeTarget.java
+++ b/src/main/java/org/leavesmc/leaves/protocol/syncmatica/exchange/ExchangeTarget.java
@@ -7,13 +7,12 @@ import org.leavesmc.leaves.protocol.core.ProtocolUtils;
 import org.leavesmc.leaves.protocol.syncmatica.FeatureSet;
 import org.leavesmc.leaves.protocol.syncmatica.SyncmaticaPayload;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
 public class ExchangeTarget {
 
-    private final List<Exchange> ongoingExchanges = new ArrayList<>();
+    private final List<Exchange> ongoingExchanges = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private final ServerGamePacketListenerImpl client;
     private FeatureSet features;
 
diff --git a/src/main/java/org/purpurmc/purpur/PurpurConfig.java b/src/main/java/org/purpurmc/purpur/PurpurConfig.java
index 5b9b9830eadf133e5ee822d6d6a0d649e08a53ed..d80a720818aa3e3762f3411a88f22b743a8d0d8b 100644
--- a/src/main/java/org/purpurmc/purpur/PurpurConfig.java
+++ b/src/main/java/org/purpurmc/purpur/PurpurConfig.java
@@ -2,7 +2,6 @@ package org.purpurmc.purpur;
 
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
-import com.mojang.datafixers.util.Pair;
 import net.kyori.adventure.bossbar.BossBar;
 import net.kyori.adventure.text.minimessage.MiniMessage;
 import net.minecraft.core.Registry;
@@ -10,12 +9,8 @@ import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
-import net.minecraft.world.effect.MobEffect;
-import net.minecraft.world.effect.MobEffectInstance;
 import net.minecraft.world.entity.EntityDimensions;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.food.FoodProperties;
-import net.minecraft.world.food.Foods;
 import net.minecraft.world.item.enchantment.Enchantment;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
@@ -32,13 +27,7 @@ import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 import java.util.logging.Level;
 
 @SuppressWarnings("unused")
@@ -198,6 +187,7 @@ public class PurpurConfig {
     public static String sleepSkippingNight = "default";
     public static String sleepingPlayersPercent = "default";
     public static String sleepNotPossible = "default";
+
     private static void messages() {
         cannotRideMob = getString("settings.messages.cannot-ride-mob", cannotRideMob);
         afkBroadcastAway = getString("settings.messages.afk-broadcast-away", afkBroadcastAway);
@@ -226,6 +216,7 @@ public class PurpurConfig {
 
     public static String deathMsgRunWithScissors = "<player> slipped and fell on their shears";
     public static String deathMsgStonecutter = "<player> has sawed themself in half";
+
     private static void deathMessages() {
         deathMsgRunWithScissors = getString("settings.messages.death-message.run-with-scissors", deathMsgRunWithScissors);
         deathMsgStonecutter = getString("settings.messages.death-message.stonecutter", deathMsgStonecutter);
@@ -233,22 +224,25 @@ public class PurpurConfig {
 
     public static boolean advancementOnlyBroadcastToAffectedPlayer = false;
     public static boolean deathMessageOnlyBroadcastToAffectedPlayer = false;
+
     private static void broadcastSettings() {
         if (version < 13) {
             boolean oldValue = getBoolean("settings.advancement.only-broadcast-to-affected-player", false);
             set("settings.broadcasts.advancement.only-broadcast-to-affected-player", oldValue);
             set("settings.advancement.only-broadcast-to-affected-player", null);
         }
-        advancementOnlyBroadcastToAffectedPlayer  = getBoolean("settings.broadcasts.advancement.only-broadcast-to-affected-player", advancementOnlyBroadcastToAffectedPlayer);
+        advancementOnlyBroadcastToAffectedPlayer = getBoolean("settings.broadcasts.advancement.only-broadcast-to-affected-player", advancementOnlyBroadcastToAffectedPlayer);
         deathMessageOnlyBroadcastToAffectedPlayer = getBoolean("settings.broadcasts.death.only-broadcast-to-affected-player", deathMessageOnlyBroadcastToAffectedPlayer);
     }
 
     public static double laggingThreshold = 19.0D;
+
     private static void tickLoopSettings() {
         laggingThreshold = getDouble("settings.lagging-threshold", laggingThreshold);
     }
 
     public static boolean disableGiveCommandDrops = false;
+
     private static void disableGiveCommandDrops() {
         disableGiveCommandDrops = getBoolean("settings.disable-give-dropping", disableGiveCommandDrops);
     }
@@ -288,6 +282,7 @@ public class PurpurConfig {
     public static String uptimeMinutes = "%02d minutes, and ";
     public static String uptimeSecond = "%02d second";
     public static String uptimeSeconds = "%02d seconds";
+
     private static void commandSettings() {
         commandRamBarTitle = getString("settings.command.rambar.title", commandRamBarTitle);
         commandRamBarProgressOverlay = BossBar.Overlay.valueOf(getString("settings.command.rambar.overlay", commandRamBarProgressOverlay.name()));
@@ -346,6 +341,7 @@ public class PurpurConfig {
     public static int weepingVinesMaxGrowthAge = 25;
     public static boolean magmaBlockReverseBubbleColumnFlow = false;
     public static boolean soulSandBlockReverseBubbleColumnFlow = false;
+
     private static void blockSettings() {
         if (version < 3) {
             boolean oldValue = getBoolean("settings.barrel.packed-barrels", true);
@@ -381,7 +377,7 @@ public class PurpurConfig {
         beeInsideBeeHive = getInt("settings.blocks.beehive.max-bees-inside", beeInsideBeeHive);
         anvilCumulativeCost = getBoolean("settings.blocks.anvil.cumulative-cost", anvilCumulativeCost);
         lightningRodRange = getInt("settings.blocks.lightning_rod.range", lightningRodRange);
-        ArrayList<String> defaultCurses = new ArrayList<>(){{
+        ArrayList<String> defaultCurses = new net.vansen.norspaper.collections.DynamicObjectArrayList<>() {{
             add("minecraft:binding_curse");
             add("minecraft:vanishing_curse");
         }};
@@ -431,6 +427,7 @@ public class PurpurConfig {
     public static boolean allowUnsafeEnchantCommand = false;
     public static boolean replaceIncompatibleEnchants = false;
     public static boolean clampEnchantLevels = true;
+
     private static void enchantmentSettings() {
         if (version < 30) {
             boolean oldValue = getBoolean("settings.enchantment.allow-unsafe-enchants", false);
@@ -459,34 +456,40 @@ public class PurpurConfig {
     }
 
     public static boolean endermanShortHeight = false;
+
     private static void entitySettings() {
         endermanShortHeight = getBoolean("settings.entity.enderman.short-height", endermanShortHeight);
         if (endermanShortHeight) EntityType.ENDERMAN.setDimensions(EntityDimensions.scalable(0.6F, 1.9F));
     }
 
     public static boolean allowWaterPlacementInTheEnd = true;
+
     private static void allowWaterPlacementInEnd() {
         allowWaterPlacementInTheEnd = getBoolean("settings.allow-water-placement-in-the-end", allowWaterPlacementInTheEnd);
     }
 
     public static boolean beeCountPayload = false;
+
     private static void beeCountPayload() {
         beeCountPayload = getBoolean("settings.bee-count-payload", beeCountPayload);
     }
 
     public static boolean tpsCatchup = true;
+
     private static void tpsCatchup() {
         tpsCatchup = getBoolean("settings.tps-catchup", tpsCatchup);
     }
 
     public static boolean useUPnP = false;
     public static boolean maxJoinsPerSecond = false;
+
     private static void networkSettings() {
         useUPnP = getBoolean("settings.network.upnp-port-forwarding", useUPnP);
         maxJoinsPerSecond = getBoolean("settings.network.max-joins-per-second", maxJoinsPerSecond);
     }
 
     public static java.util.regex.Pattern usernameValidCharactersPattern;
+
     private static void usernameValidationSettings() {
         String defaultPattern = "^[a-zA-Z0-9_.]*$";
         String setPattern = getString("settings.username-valid-characters", defaultPattern);
@@ -494,16 +497,19 @@ public class PurpurConfig {
     }
 
     public static boolean fixProjectileLootingTransfer = false;
+
     private static void fixProjectileLootingTransfer() {
         fixProjectileLootingTransfer = getBoolean("settings.fix-projectile-looting-transfer", fixProjectileLootingTransfer);
     }
 
     public static boolean clampAttributes = true;
+
     private static void clampAttributes() {
         clampAttributes = getBoolean("settings.clamp-attributes", clampAttributes);
     }
 
     public static boolean limitArmor = true;
+
     private static void limitArmor() {
         limitArmor = getBoolean("settings.limit-armor", limitArmor);
     }
@@ -522,6 +528,7 @@ public class PurpurConfig {
             block.explosionResistance = blastResistance.floatValue();
         });
     }
+
     private static void blockFallMultiplierSettings() {
         getMap("settings.block-fall-multipliers", Map.ofEntries(
                 Map.entry("minecraft:hay_block", Map.of("damage", 0.2F)),
@@ -570,16 +577,19 @@ public class PurpurConfig {
     }
 
     public static boolean playerDeathsAlwaysShowItem = false;
+
     private static void playerDeathsAlwaysShowItem() {
         playerDeathsAlwaysShowItem = getBoolean("settings.player-deaths-always-show-item", playerDeathsAlwaysShowItem);
     }
 
     public static boolean registerMinecraftDebugCommands = false;
+
     private static void registerMinecraftDebugCommands() {
         registerMinecraftDebugCommands = getBoolean("settings.register-minecraft-debug-commands", registerMinecraftDebugCommands);
     }
 
-    public static List<String> startupCommands = new ArrayList<>();
+    public static List<String> startupCommands = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+
     private static void startupCommands() {
         startupCommands.clear();
         getList("settings.startup-commands", new ArrayList<String>()).forEach(line -> {
diff --git a/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java b/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java
index c3612a5d62bdd6f84319b58f99cdb82d24c9132a..23aee44718471935a4f235b5db60bc68a2bfa87b 100644
--- a/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java
+++ b/src/main/java/org/purpurmc/purpur/PurpurWorldConfig.java
@@ -227,10 +227,10 @@ public class PurpurWorldConfig {
         explosionClampRadius = getBoolean("gameplay-mechanics.clamp-explosion-radius", explosionClampRadius);
     }
 
-    public List<Item> itemImmuneToCactus = new ArrayList<>();
-    public List<Item> itemImmuneToExplosion = new ArrayList<>();
-    public List<Item> itemImmuneToFire = new ArrayList<>();
-    public List<Item> itemImmuneToLightning = new ArrayList<>();
+    public List<Item> itemImmuneToCactus = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    public List<Item> itemImmuneToExplosion = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    public List<Item> itemImmuneToFire = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    public List<Item> itemImmuneToLightning = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     public boolean dontRunWithScissors = false;
     public boolean ignoreScissorsInWater = false;
     public boolean ignoreScissorsInLava = false;
@@ -247,7 +247,7 @@ public class PurpurWorldConfig {
     public boolean snowballExtinguishesCampfires = false;
     private void itemSettings() {
         itemImmuneToCactus.clear();
-        getList("gameplay-mechanics.item.immune.cactus", new ArrayList<>()).forEach(key -> {
+        getList("gameplay-mechanics.item.immune.cactus", new net.vansen.norspaper.collections.DynamicObjectArrayList<>()).forEach(key -> {
             if (key.toString().equals("*")) {
                 BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToCactus.add(item));
                 return;
@@ -256,7 +256,7 @@ public class PurpurWorldConfig {
             if (item != Items.AIR) itemImmuneToCactus.add(item);
         });
         itemImmuneToExplosion.clear();
-        getList("gameplay-mechanics.item.immune.explosion", new ArrayList<>()).forEach(key -> {
+        getList("gameplay-mechanics.item.immune.explosion", new net.vansen.norspaper.collections.DynamicObjectArrayList<>()).forEach(key -> {
             if (key.toString().equals("*")) {
                 BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToExplosion.add(item));
                 return;
@@ -265,7 +265,7 @@ public class PurpurWorldConfig {
             if (item != Items.AIR) itemImmuneToExplosion.add(item);
         });
         itemImmuneToFire.clear();
-        getList("gameplay-mechanics.item.immune.fire", new ArrayList<>()).forEach(key -> {
+        getList("gameplay-mechanics.item.immune.fire", new net.vansen.norspaper.collections.DynamicObjectArrayList<>()).forEach(key -> {
             if (key.toString().equals("*")) {
                 BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToFire.add(item));
                 return;
@@ -274,7 +274,7 @@ public class PurpurWorldConfig {
             if (item != Items.AIR) itemImmuneToFire.add(item);
         });
         itemImmuneToLightning.clear();
-        getList("gameplay-mechanics.item.immune.lightning", new ArrayList<>()).forEach(key -> {
+        getList("gameplay-mechanics.item.immune.lightning", new net.vansen.norspaper.collections.DynamicObjectArrayList<>()).forEach(key -> {
             if (key.toString().equals("*")) {
                 BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToLightning.add(item));
                 return;
@@ -466,14 +466,14 @@ public class PurpurWorldConfig {
 
     public boolean silkTouchEnabled = false;
     public String silkTouchSpawnerName = "<reset><white>Monster Spawner";
-    public List<String> silkTouchSpawnerLore = new ArrayList<>();
-    public List<Item> silkTouchTools = new ArrayList<>();
+    public List<String> silkTouchSpawnerLore = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
+    public List<Item> silkTouchTools = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     public int minimumSilkTouchSpawnerRequire = 1;
     private void silkTouchSettings() {
         if (PurpurConfig.version < 21) {
             String oldName = getString("gameplay-mechanics.silk-touch.spawner-name", silkTouchSpawnerName);
             set("gameplay-mechanics.silk-touch.spawner-name", "<reset>" + ChatColor.toMM(oldName.replace("{mob}", "<mob>")));
-            List<String> list = new ArrayList<>();
+            List<String> list = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             getList("gameplay-mechanics.silk-touch.spawner-lore", List.of("Spawns a <mob>"))
                     .forEach(line -> list.add("<reset>" + ChatColor.toMM(line.toString().replace("{mob}", "<mob>"))));
             set("gameplay-mechanics.silk-touch.spawner-lore", list);
@@ -908,7 +908,7 @@ public class PurpurWorldConfig {
         dispenserPlaceAnvils = getBoolean("blocks.dispenser.place-anvils", dispenserPlaceAnvils);
     }
 
-    public List<Block> doorRequiresRedstone = new ArrayList<>();
+    public List<Block> doorRequiresRedstone = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     private void doorSettings() {
         getList("blocks.door.requires-redstone", new ArrayList<String>()).forEach(key -> {
             Block block = BuiltInRegistries.BLOCK.get(ResourceLocation.parse(key.toString()));
@@ -2495,7 +2495,7 @@ public class PurpurWorldConfig {
     public double ravagerScale = 1.0D;
     public boolean ravagerBypassMobGriefing = false;
     public boolean ravagerTakeDamageFromWater = false;
-    public List<Block> ravagerGriefableBlocks = new ArrayList<>();
+    public List<Block> ravagerGriefableBlocks = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
     public boolean ravagerAlwaysDropExp = false;
     public boolean ravagerAvoidRabbits = false;
     private void ravagerSettings() {
@@ -3445,7 +3445,7 @@ public class PurpurWorldConfig {
         conduitDistance = getInt("blocks.conduit.effect-distance", conduitDistance);
         conduitDamageDistance = getDouble("blocks.conduit.mob-damage.distance", conduitDamageDistance);
         conduitDamageAmount = (float) getDouble("blocks.conduit.mob-damage.damage-amount", conduitDamageAmount);
-        List<Block> conduitBlockList = new ArrayList<>();
+        List<Block> conduitBlockList = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
         getList("blocks.conduit.valid-ring-blocks", new ArrayList<String>(){{
             add("minecraft:prismarine");
             add("minecraft:prismarine_bricks");
diff --git a/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFile.java b/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFile.java
index d2cbdd75f02d377a7680288bb1154d51dbc6bc51..df0f8c6cd672197334453f78c7323d07ef5e6080 100644
--- a/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFile.java
+++ b/src/main/java/org/stupidcraft/linearpaper/region/LinearRegionFile.java
@@ -158,7 +158,7 @@ public class LinearRegionFile implements IRegionFile, AutoCloseable {
             dataStream.writeLong(timestamp);
             dataStream.writeByte(this.compressionLevel);
 
-            ArrayList<byte[]> byteBuffers = new ArrayList<>();
+            ArrayList<byte[]> byteBuffers = new net.vansen.norspaper.collections.DynamicObjectArrayList<>();
             for (int i = 0; i < 1024; i++) {
                 if (this.bufferUncompressedSize[i] != 0) {
                     chunkCount += 1;

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: vansencool <vansencool@gmail.com>
Date: Fri, 24 Jan 2025 21:24:31 +0530
Subject: [PATCH] Add CommandUtils to NorsPaper


diff --git a/src/main/java/dev/vansen/commandutils/AbstractCommandUtils.java b/src/main/java/dev/vansen/commandutils/AbstractCommandUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..0675183f3a9b50e076f55d6257983e2fdacaf439
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/AbstractCommandUtils.java
@@ -0,0 +1,208 @@
+package dev.vansen.commandutils;
+
+import dev.vansen.commandutils.argument.AbstractCommandArgument;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.command.CommandExecutor;
+import dev.vansen.commandutils.command.CommandWrapper;
+import dev.vansen.commandutils.command.ExecutableSender;
+import dev.vansen.commandutils.command.Position;
+import dev.vansen.commandutils.info.Aliases;
+import dev.vansen.commandutils.info.CommandInfo;
+import dev.vansen.commandutils.sender.SenderTypes;
+import dev.vansen.commandutils.subcommand.AbstractSubCommand;
+import dev.vansen.commandutils.subcommand.SubCommand;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+/**
+ * This is generally not recommended to use, since it limits the ability to nest arguments, and it is generally recommended to use {@link SimpleCommandUtils} since it allows easier command management, and saves alot of time in coding.
+ */
+@SuppressWarnings("unused")
+public abstract class AbstractCommandUtils {
+    private final String name;
+    private Aliases aliases;
+    private CommandExecutor defaultExecutor;
+    private CommandExecutor playerExecutor;
+    private CommandExecutor consoleExecutor;
+    private CommandExecutor entityExecutor;
+    private CommandExecutor blockExecutor;
+    private CommandExecutor proxiedExecutor;
+
+    public AbstractCommandUtils(@NotNull String commandName) {
+        this.name = commandName;
+    }
+
+    public AbstractCommandUtils(@NotNull String commandName, @NotNull Aliases aliases) {
+        this.name = commandName;
+        this.aliases = aliases;
+    }
+
+    public AbstractCommandUtils(@NotNull String commandName, @NotNull List<String> aliases) {
+        this.name = commandName;
+        this.aliases = Aliases.of(aliases);
+    }
+
+    public AbstractCommandUtils(@NotNull String commandName, @NotNull String... aliases) {
+        this.name = commandName;
+        this.aliases = Aliases.of(aliases);
+    }
+
+    public void execute(@NotNull CommandWrapper context) {
+    }
+
+    public SenderTypes[] senderTypes() {
+        return null;
+    }
+
+    public void playerExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void consoleExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void remoteConsoleExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void entityExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void blockExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void proxiedExecute(@NotNull CommandWrapper context) {
+    }
+
+    public CommandInfo info() {
+        return null;
+    }
+
+    public List<CommandArgument> arguments() {
+        return List.of();
+    }
+
+    public List<AbstractCommandArgument> abstractArguments() {
+        return List.of();
+    }
+
+    public List<SubCommand> subCommands() {
+        return List.of();
+    }
+
+    public List<AbstractSubCommand> abstractSubCommands() {
+        return List.of();
+    }
+
+    @NotNull
+    public Position argumentPosition() {
+        return Position.LAST; // Adds argument at the last.
+    }
+
+    @NotNull
+    public Position abstractArgumentPosition() {
+        return Position.LAST; // Adds abstract arguments at the last.
+    }
+
+    @NotNull
+    public Position abstractSubCommandPosition() {
+        return Position.LAST; // Adds abstract subcommands at the last.
+    }
+
+    @ApiStatus.NonExtendable
+    public CommandUtils build() {
+        CommandUtils commandUtils = CommandUtils.command(name);
+
+        try {
+            Method executeMethod = this.getClass().getDeclaredMethod("execute", CommandWrapper.class);
+            Method superExecuteMethod = AbstractCommandUtils.class.getDeclaredMethod("execute", CommandWrapper.class);
+            if (!executeMethod.equals(superExecuteMethod)) {
+                if (senderTypes() != null) {
+                    commandUtils.defaultExecute(this::execute, ExecutableSender.types(senderTypes()));
+                } else {
+                    commandUtils.defaultExecute(this::execute);
+                }
+            }
+
+            Method playerExecuteMethod = this.getClass().getDeclaredMethod("playerExecute", CommandWrapper.class);
+            Method superPlayerExecuteMethod = AbstractCommandUtils.class.getDeclaredMethod("playerExecute", CommandWrapper.class);
+            if (!playerExecuteMethod.equals(superPlayerExecuteMethod)) {
+                commandUtils.playerExecute(this::playerExecute);
+            }
+
+            Method consoleExecuteMethod = this.getClass().getDeclaredMethod("consoleExecute", CommandWrapper.class);
+            Method superConsoleExecuteMethod = AbstractCommandUtils.class.getDeclaredMethod("consoleExecute", CommandWrapper.class);
+            if (!consoleExecuteMethod.equals(superConsoleExecuteMethod)) {
+                commandUtils.consoleExecute(this::consoleExecute);
+            }
+
+            Method remoteConsoleExecuteMethod = this.getClass().getDeclaredMethod("remoteConsoleExecute", CommandWrapper.class);
+            Method superRemoteConsoleExecuteMethod = AbstractCommandUtils.class.getDeclaredMethod("remoteConsoleExecute", CommandWrapper.class);
+            if (!remoteConsoleExecuteMethod.equals(superRemoteConsoleExecuteMethod)) {
+                commandUtils.remoteConsoleExecute(this::remoteConsoleExecute);
+            }
+
+            Method entityExecuteMethod = this.getClass().getDeclaredMethod("entityExecute", CommandWrapper.class);
+            Method superEntityExecuteMethod = AbstractCommandUtils.class.getDeclaredMethod("entityExecute", CommandWrapper.class);
+            if (!entityExecuteMethod.equals(superEntityExecuteMethod)) {
+                commandUtils.entityExecute(this::entityExecute);
+            }
+
+            Method blockExecuteMethod = this.getClass().getDeclaredMethod("blockExecute", CommandWrapper.class);
+            Method superBlockExecuteMethod = AbstractCommandUtils.class.getDeclaredMethod("blockExecute", CommandWrapper.class);
+            if (!blockExecuteMethod.equals(superBlockExecuteMethod)) {
+                commandUtils.blockExecute(this::blockExecute);
+            }
+
+            Method proxiedExecuteMethod = this.getClass().getDeclaredMethod("proxiedExecute", CommandWrapper.class);
+            Method superProxiedExecuteMethod = AbstractCommandUtils.class.getDeclaredMethod("proxiedExecute", CommandWrapper.class);
+            if (!proxiedExecuteMethod.equals(superProxiedExecuteMethod)) {
+                commandUtils.proxiedExecute(this::proxiedExecute);
+            }
+        } catch (NoSuchMethodException ignored) {
+        }
+
+        if (info() != null) commandUtils.info(info());
+        if (aliases != null) commandUtils.aliases(aliases);
+
+        if (argumentPosition() == Position.LAST) {
+            if (abstractSubCommandPosition() == Position.LAST) {
+                subCommands().forEach(commandUtils::subCommand);
+                abstractSubCommands().forEach(commandUtils::subCommand);
+            } else {
+                abstractSubCommands().forEach(commandUtils::subCommand);
+                subCommands().forEach(commandUtils::subCommand);
+            }
+            if (abstractArgumentPosition() == Position.LAST) {
+                arguments().forEach(commandUtils::argument);
+                abstractArguments().forEach(commandUtils::argument);
+            } else {
+                abstractArguments().forEach(commandUtils::argument);
+                arguments().forEach(commandUtils::argument);
+            }
+        } else {
+            if (abstractArgumentPosition() == Position.LAST) {
+                arguments().forEach(commandUtils::argument);
+                abstractArguments().forEach(commandUtils::argument);
+            } else {
+                abstractArguments().forEach(commandUtils::argument);
+                arguments().forEach(commandUtils::argument);
+            }
+            if (abstractSubCommandPosition() == Position.LAST) {
+                subCommands().forEach(commandUtils::subCommand);
+                abstractSubCommands().forEach(commandUtils::subCommand);
+            } else {
+                abstractSubCommands().forEach(commandUtils::subCommand);
+                subCommands().forEach(commandUtils::subCommand);
+            }
+        }
+
+        return commandUtils;
+    }
+
+    @ApiStatus.NonExtendable
+    public void register() {
+        build().register(); // easier
+    }
+}
diff --git a/src/main/java/dev/vansen/commandutils/CommandUtils.java b/src/main/java/dev/vansen/commandutils/CommandUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..2afe267dfd5c1aba99ce69772aed2b55a4fecd9f
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/CommandUtils.java
@@ -0,0 +1,978 @@
+package dev.vansen.commandutils;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import dev.vansen.commandutils.api.CommandAPI;
+import dev.vansen.commandutils.argument.AbstractCommandArgument;
+import dev.vansen.commandutils.argument.Argument;
+import dev.vansen.commandutils.argument.ArgumentNester;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.argument.finder.ArgumentString;
+import dev.vansen.commandutils.command.CommandExecutor;
+import dev.vansen.commandutils.command.*;
+import dev.vansen.commandutils.completer.CompletionHandler;
+import dev.vansen.commandutils.completer.SuggestionsBuilderWrapper;
+import dev.vansen.commandutils.exceptions.CmdException;
+import dev.vansen.commandutils.info.Aliases;
+import dev.vansen.commandutils.info.CommandInfo;
+import dev.vansen.commandutils.messages.MessageTypes;
+import dev.vansen.commandutils.permission.CommandPermission;
+import dev.vansen.commandutils.sender.SenderTypes;
+import dev.vansen.commandutils.subcommand.AbstractSubCommand;
+import dev.vansen.commandutils.subcommand.SubCommand;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import io.papermc.paper.command.brigadier.Commands;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents;
+import org.bukkit.command.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+
+/**
+ * Utility class for building and registering Minecraft commands using Brigadier.
+ * This class allows for defining permissions, arguments, completions, subcommands,
+ * and more in a fluent and customizable way.
+ */
+@SuppressWarnings({"unused"})
+public final class CommandUtils {
+
+    private final LiteralArgumentBuilder<CommandSourceStack> builder;
+    private final List<RequiredArgumentBuilder<CommandSourceStack, ?>> argumentStack = new ArrayList<>();
+    private boolean nest = true;
+    private CommandExecutor defaultExecutor;
+    private CommandExecutor playerExecutor;
+    private CommandExecutor consoleExecutor;
+    private CommandExecutor remoteConsoleExecutor;
+    private CommandExecutor entityExecutor;
+    private CommandExecutor blockExecutor;
+    private CommandExecutor proxiedExecutor;
+    private SenderTypes[] senderTypes = null;
+    @Nullable
+    private String description = null;
+    @Nullable
+    private List<String> aliases = null;
+
+    /**
+     * Constructs a new command builder with the specified name.
+     *
+     * @param commandName the name of the command.
+     */
+    public CommandUtils(@NotNull String commandName) {
+        builder = LiteralArgumentBuilder.literal(commandName);
+    }
+
+    /**
+     * Factory method to create a new command builder.
+     *
+     * @param commandName the name of the command.
+     * @return a new instance of {@link CommandUtils}.
+     */
+    @NotNull
+    public static CommandUtils newCommand(@NotNull String commandName) {
+        return new CommandUtils(commandName);
+    }
+
+    /**
+     * Factory method to create a new command builder.
+     *
+     * @param commandName the name of the command.
+     * @return a new instance of {@link CommandUtils}.
+     */
+    @NotNull
+    public static CommandUtils command(@NotNull String commandName) {
+        return new CommandUtils(commandName);
+    }
+
+    private void execute() {
+        builder.executes(context -> {
+            CommandSender sender = context.getSource().getSender();
+            CommandWrapper wrapped = new CommandWrapper(context);
+            boolean done = false;
+
+            try {
+                switch (sender) {
+                    case Player player when playerExecutor != null -> {
+                        done = true;
+                        playerExecutor.execute(wrapped);
+                    }
+                    case ConsoleCommandSender consoleCommandSender when consoleExecutor != null -> {
+                        done = true;
+                        consoleExecutor.execute(wrapped);
+                    }
+                    case RemoteConsoleCommandSender remoteConsoleCommandSender when remoteConsoleExecutor != null -> {
+                        done = true;
+                        remoteConsoleExecutor.execute(wrapped);
+                    }
+                    case BlockCommandSender blockCommandSender when blockExecutor != null -> {
+                        done = true;
+                        blockExecutor.execute(wrapped);
+                    }
+                    default -> {
+                        switch (context.getSource().getExecutor()) {
+                            case Entity entity when entityExecutor != null -> {
+                                done = true;
+                                entityExecutor.execute(wrapped);
+                            }
+                            case ProxiedCommandSender proxiedCommandSender when proxiedExecutor != null -> {
+                                done = true;
+                                proxiedExecutor.execute(wrapped);
+                            }
+                            case null, default -> {
+                            }
+                        }
+                    }
+                }
+                if (!done) {
+                    Optional.ofNullable(defaultExecutor)
+                            .ifPresent(executor -> {
+                                if (senderTypes == null) executor.execute(wrapped);
+                                else if (Arrays.stream(senderTypes)
+                                        .anyMatch(type -> type == wrapped.senderType()))
+                                    executor.execute(wrapped);
+                                else {
+                                    switch (wrapped.senderType()) {
+                                        case PLAYER -> wrapped.response(MessageTypes.NOT_ALLOWED_PLAYER);
+                                        case CONSOLE -> wrapped.response(MessageTypes.NOT_ALLOWED_CONSOLE);
+                                        case REMOTE_CONSOLE ->
+                                                wrapped.response(MessageTypes.NOT_ALLOWED_REMOTE_CONSOLE);
+                                        case ENTITY -> wrapped.response(MessageTypes.NOT_ALLOWED_ENTITY);
+                                        case COMMAND_BLOCK -> wrapped.response(MessageTypes.NOT_ALLOWED_COMMAND_BLOCK);
+                                        case PROXIED -> wrapped.response(MessageTypes.NOT_ALLOWED_PROXIED_SENDER);
+                                    }
+                                }
+                            });
+                }
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+    }
+
+    private void executeIf() {
+        if (defaultExecutor != null || playerExecutor != null || consoleExecutor != null || remoteConsoleExecutor != null || entityExecutor != null || blockExecutor != null || proxiedExecutor != null) {
+            execute();
+        }
+    }
+
+    private void nest() {
+        if (nest) ArgumentNester.nest(argumentStack, builder);
+    }
+
+    /**
+     * Sets the default executor for the command, which is called when the command
+     * is executed without any arguments/subcommands or when no other execution path is matched.
+     *
+     * @param executor the {@link CommandExecutor} to be executed by default.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils defaultExecute(@NotNull CommandExecutor executor) {
+        defaultExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the default executor for the command, which is called when the command
+     * is executed without any arguments/subcommands or when no other execution path is matched.
+     * If the command sender is not in the sender types, the executor is not called either.
+     *
+     * @param executor    the {@link CommandExecutor} to be executed by default.
+     * @param senderTypes the {@link SenderTypes} of the sender.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils defaultExecute(@NotNull CommandExecutor executor, @NotNull ExecutableSender senderTypes) {
+        defaultExecutor = executor;
+        this.senderTypes = senderTypes.types();
+        return this;
+    }
+
+    /**
+     * Sets the sender types for the command.
+     *
+     * @param senderTypes the {@link SenderTypes} of the sender.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils senderTypes(@NotNull ExecutableSender senderTypes) {
+        this.senderTypes = senderTypes.types();
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link Player}.
+     * If the sender is not a player, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a player.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils playerExecute(@NotNull CommandExecutor executor) {
+        playerExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link ConsoleCommandSender}.
+     * If the sender is not a console, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a console.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils consoleExecute(@NotNull CommandExecutor executor) {
+        consoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link RemoteConsoleCommandSender}.
+     * If the sender is not a remote console, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a remote console.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils remoteConsoleExecute(@NotNull CommandExecutor executor) {
+        remoteConsoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is an {@link Entity}.
+     * If the sender is not an entity, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is an entity.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils entityExecute(@NotNull CommandExecutor executor) {
+        entityExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link BlockCommandSender}.
+     * If the sender is not a command block, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a block.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils blockExecute(@NotNull CommandExecutor executor) {
+        blockExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link ProxiedCommandSender}.
+     * If the sender is not a proxied sender, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a proxied player.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils proxiedExecute(@NotNull CommandExecutor executor) {
+        proxiedExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param argument the {@link CommandArgument}
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull CommandArgument argument) {
+        argumentStack.add(argument.get());
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param argument the {@link AbstractCommandArgument}
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull AbstractCommandArgument argument) {
+        argumentStack.add(argument.build().get());
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param argument the {@link Argument}
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull Argument argument) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param argument the {@link Argument}
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull Argument argument, @NotNull CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param argument the {@link Argument}
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull Argument argument, @NotNull CommandExecutor executor) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param argument the {@link Argument}
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull Argument argument, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        }).suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull ArgumentType<?> type, @NotNull String name) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CommandExecutor executor) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        }).suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull ArgumentType<?> type) {
+        return argument(type, name);
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull ArgumentType<?> type, CompletionHandler handler) {
+        return argument(type, name, handler);
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CommandExecutor executor) {
+        return argument(type, name, executor);
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        return argument(type, name, executor, handler);
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull String type) {
+        return argument(ArgumentString.fromString(type), name);
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull String type, CompletionHandler handler) {
+        return argument(ArgumentString.fromString(type), name, handler);
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull String type, @NotNull CommandExecutor executor) {
+        return argument(ArgumentString.fromString(type), name, executor);
+    }
+
+    /**
+     * Adds an argument to the command.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils argument(@NotNull String name, @NotNull String type, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        return argument(ArgumentString.fromString(type), name, executor, handler);
+    }
+
+    /**
+     * Adds a completion handler to the last argument added to the command.
+     *
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils completion(@NotNull CompletionHandler handler) {
+        argumentStack.getLast()
+                .suggests((context, builder) -> {
+                    CommandWrapper wrapped = new CommandWrapper(context);
+                    SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                    return handler.complete(wrapped, wrapper);
+                });
+        return this;
+    }
+
+    /**
+     * Adds a completion handler to the first or last argument added to the command.
+     *
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils completion(@NotNull Position position, @NotNull CompletionHandler handler) {
+        switch (position) {
+            case Position.FIRST -> argumentStack.getFirst()
+                    .suggests((context, builder) -> {
+                        CommandWrapper wrapped = new CommandWrapper(context);
+                        SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                        return handler.complete(wrapped, wrapper);
+                    });
+            case Position.LAST -> argumentStack.getLast()
+                    .suggests((context, builder) -> {
+                        CommandWrapper wrapped = new CommandWrapper(context);
+                        SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                        return handler.complete(wrapped, wrapper);
+                    });
+        }
+        return this;
+    }
+
+    /**
+     * Adds a completion handler to the argument at the specified index.
+     *
+     * @param index   the index of the argument to add the completion handler to.
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils completion(int index, @NotNull CompletionHandler handler) {
+        argumentStack.get(index)
+                .suggests((context, builder) -> {
+                    CommandWrapper wrapped = new CommandWrapper(context);
+                    SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                    return handler.complete(wrapped, wrapper);
+                });
+        return this;
+    }
+
+    /**
+     * Adds a subcommand to the main command.
+     * Subcommands are separate execution paths that have their own logic.
+     *
+     * @param subCommand the {@link SubCommand} to be added.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils subCommand(@NotNull SubCommand subCommand) {
+        builder.then(subCommand.get());
+        return this;
+    }
+
+    /**
+     * Adds a subcommand to the main command.
+     * Subcommands are separate execution paths that have their own logic.
+     *
+     * @param subCommand the {@link AbstractSubCommand} to be added.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils subCommand(@NotNull AbstractSubCommand subCommand) {
+        builder.then(subCommand.build().get());
+        return this;
+    }
+
+    /**
+     * Adds additional metadata to the command, such as aliases, description, and permissions.
+     *
+     * @param info a {@link CommandInfo} for setting metadata.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils info(@NotNull CommandInfo info) {
+        this.aliases = info.getAliases();
+        this.description = info.getDescription();
+        CommandPermission permission = info.getPermission();
+        if (permission == null) return this;
+        if (permission.isOpPermission()) {
+            builder.requires(consumer -> consumer.getSender().isOp());
+        } else if (permission.getPermission() != null) {
+            builder.requires(consumer -> consumer.getSender().hasPermission(permission.getPermission()));
+        }
+        return this;
+    }
+
+    /**
+     * The requirement of the command, if the requirement is not met the command will not execute, and not show in tab complete either.
+     *
+     * @param requirement the {@link Predicate} for the requirement
+     * @return this {@link CommandUtils} instance for chaining
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils requirement(@NotNull Predicate<CommandRequirement> requirement) {
+        builder.requires(consumer -> requirement.test(new CommandRequirement(consumer)));
+        return this;
+    }
+
+    /**
+     * The requirement of the command, if the requirement is not met the command will not execute, and not show in tab complete either.
+     *
+     * @param checker the {@link BooleanChecker} for the requirement
+     * @return this {@link CommandUtils} instance for chaining
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils requirement(@NotNull BooleanChecker checker) {
+        builder.requires(consumer -> checker.check());
+        return this;
+    }
+
+    /**
+     * Disables argument nesting for the command.
+     * <p>
+     * Note, disabling this (may) have 2 or even more arguments in a single argument, which is not recommended.
+     * So it would be "/command [arg1 | arg2 | arg3]" instead of "/command arg1 arg2 arg3", there are other unexpected results as well, for example arguments not working.
+     * <p>
+     * Some cases where this would work would be using {@link CommandArgument} and {@link CommandArgument#argument(CommandArgument)}, but if disabled nesting in command arguments will lead to it not working.
+     *
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils noNest() {
+        nest = false;
+        return this;
+    }
+
+    /**
+     * Sets the aliases of the command using an {@link Aliases} instance.
+     *
+     * @param aliases a {@link Aliases} for setting metadata.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils aliases(@NotNull Aliases aliases) {
+        this.aliases = aliases.getAliases();
+        return this;
+    }
+
+    /**
+     * Sets the aliases of the command using an array of strings.
+     *
+     * @param aliases an array of strings for setting metadata.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils aliases(@NotNull String... aliases) {
+        this.aliases = Arrays.asList(aliases);
+        return this;
+    }
+
+    /**
+     * Sets the aliases of the command using a list of strings.
+     *
+     * @param aliases a list of strings for setting metadata.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils aliases(@NotNull List<String> aliases) {
+        this.aliases = aliases;
+        return this;
+    }
+
+    /**
+     * Sets the permission of the command using a {@link CommandPermission} instance.
+     *
+     * @param permission a {@link CommandPermission} for setting metadata.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils permission(@NotNull CommandPermission permission) {
+        if (permission.isOpPermission()) {
+            builder.requires(consumer -> consumer.getSender().isOp());
+        } else if (permission.getPermission() != null) {
+            builder.requires(consumer -> consumer.getSender().hasPermission(permission.getPermission()));
+        }
+        return this;
+    }
+
+    /**
+     * Sets the permission of the command using a string permission.
+     *
+     * @param permission a string permission for setting metadata.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandUtils permission(@NotNull String permission) {
+        builder.requires(consumer -> consumer.getSender().hasPermission(permission));
+        return this;
+    }
+
+    /**
+     * Registers the command with the provided description and aliases.
+     */
+    public void build() {
+        CommandAPI.get().registerEventHandler(LifecycleEvents.COMMANDS, event -> {
+            final Commands commands = event.registrar();
+            executeIf();
+            nest();
+            commands.register(builder.build(), description, aliases == null ? List.of() : aliases);
+        });
+    }
+
+    /**
+     * Registers the command under that plugin's name with the provided description and aliases.
+     */
+    public void build(@NotNull LifecycleEventManager<@NotNull Plugin> plugin) {
+        plugin.registerEventHandler(LifecycleEvents.COMMANDS, event -> {
+            final Commands commands = event.registrar();
+            executeIf();
+            nest();
+            commands.register(builder.build(), description, aliases == null ? List.of() : aliases);
+        });
+    }
+
+    /**
+     * Registers the command under that plugin's name with the provided description and aliases.
+     */
+    public void build(@NotNull JavaPlugin plugin) {
+        plugin.getLifecycleManager().registerEventHandler(LifecycleEvents.COMMANDS, event -> {
+            final Commands commands = event.registrar();
+            executeIf();
+            nest();
+            commands.register(builder.build(), description, aliases == null ? List.of() : aliases);
+        });
+    }
+
+    /**
+     * Registers the command under that plugin meta's name with the provided description and aliases.
+     */
+    public void build(@NotNull PluginMeta meta) {
+        CommandAPI.get().registerEventHandler(LifecycleEvents.COMMANDS, event -> {
+            final Commands commands = event.registrar();
+            executeIf();
+            nest();
+            commands.register(meta, builder.build(), description, aliases == null ? List.of() : aliases);
+        });
+    }
+
+    /**
+     * Registers the command under that the namespace with the provided description and aliases.
+     *
+     * @param namespace the namespace of the command.
+     * @see #build()
+     * @see #build(JavaPlugin)
+     * @see #build(LifecycleEventManager)
+     */
+    // @Deprecated // NorsPaper
+    public void build(@NotNull String namespace) {
+        // NorsPaper start - Add CommandUtils to NorsPaper
+        CommandAPI.get().registerEventHandler(LifecycleEvents.COMMANDS, event -> {
+            final Commands commands = event.registrar();
+            executeIf();
+            nest();
+            commands.register(builder.build(), description, aliases == null ? List.of() : aliases, namespace);
+        });
+        /*
+        CommandAPI.get().registerEventHandler(LifecycleEvents.COMMANDS, event -> {
+            final Commands commands = event.registrar();
+            executeIf();
+            nest();
+            commands.getDispatcher().register(builder);
+            commands.getDispatcher().register(LiteralArgumentBuilder
+                    .<CommandSourceStack>literal(namespace + ":" + builder.getLiteral())
+                    .redirect(builder.build()));
+            if (aliases != null && !aliases.isEmpty()) {
+                aliases.forEach(alias -> {
+                    commands.getDispatcher().register(LiteralArgumentBuilder
+                            .<CommandSourceStack>literal(alias)
+                            .redirect(builder.build()));
+                    commands.getDispatcher().register(LiteralArgumentBuilder
+                            .<CommandSourceStack>literal(namespace + ":" + alias)
+                            .redirect(builder.build()));
+                });
+            }
+        });
+         */
+        // NorsPaper end - Add CommandUtils to NorsPaper
+    }
+
+    /**
+     * Registers the command with the provided description and aliases.
+     */
+    public void register() {
+        build();
+    }
+
+    /**
+     * Registers the command under that plugin's name with the provided description and aliases.
+     */
+    public void register(@NotNull LifecycleEventManager<@NotNull Plugin> plugin) {
+        build(plugin);
+    }
+
+    /**
+     * Registers the command under that plugin's name with the provided description and aliases.
+     */
+    public void register(@NotNull JavaPlugin plugin) {
+        build(plugin);
+    }
+
+    /**
+     * Registers the command under that plugin meta's name with the provided description and aliases.
+     */
+    public void register(@NotNull PluginMeta meta) {
+        build(meta);
+    }
+
+    /**
+     * Registers the command under that the namespace with the provided description and aliases.
+     *
+     * @param namespace the namespace of the command.
+     * @see #build()
+     * @see #build(PluginMeta)
+     * @see #build(JavaPlugin)
+     * @see #build(LifecycleEventManager)
+     */
+    // @Deprecated // NorsPaper
+    public void register(@NotNull String namespace) {
+        build(namespace);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/SimpleCommandUtils.java b/src/main/java/dev/vansen/commandutils/SimpleCommandUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a1051f54f97886349808eda02ec09148f163569
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/SimpleCommandUtils.java
@@ -0,0 +1,352 @@
+package dev.vansen.commandutils;
+
+import dev.vansen.commandutils.argument.AbstractCommandArgument;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.command.CommandExecutor;
+import dev.vansen.commandutils.command.ExecutableSender;
+import dev.vansen.commandutils.command.Position;
+import dev.vansen.commandutils.info.Aliases;
+import dev.vansen.commandutils.info.CommandInfo;
+import dev.vansen.commandutils.sender.SenderTypes;
+import dev.vansen.commandutils.subcommand.AbstractSubCommand;
+import dev.vansen.commandutils.subcommand.SubCommand;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * A utility class for simplifying the creation, customization, and registration of commands.
+ * Supports specifying executors for various sender types, defining arguments, aliases, subcommands, and more.
+ */
+@SuppressWarnings("unused")
+public class SimpleCommandUtils {
+
+    private final String name;
+    private CommandExecutor defaultExecutor;
+    private CommandExecutor playerExecutor;
+    private CommandExecutor consoleExecutor;
+    private CommandExecutor remoteConsoleExecutor;
+    private CommandExecutor entityExecutor;
+    private CommandExecutor blockExecutor;
+    private CommandExecutor proxiedExecutor;
+    private Aliases aliases;
+    private CommandInfo info;
+    private SenderTypes[] sender;
+    private List<CommandArgument> arguments;
+    private List<AbstractCommandArgument> abstractArguments;
+    private List<SubCommand> subCommands;
+    private List<AbstractSubCommand> abstractSubCommands;
+    private Position argumentPosition;
+    private Position abstractArgumentPosition;
+    private Position abstractSubCommandPosition;
+
+    /**
+     * Constructs a SimpleCommandUtils instance with a command name.
+     *
+     * @param name the name of the command.
+     */
+    public SimpleCommandUtils(@NotNull String name) {
+        this.name = name;
+    }
+
+    /**
+     * Constructs a SimpleCommandUtils instance with a command name and aliases.
+     *
+     * @param commandName the name of the command.
+     * @param aliases     the aliases for the command.
+     */
+    public SimpleCommandUtils(@NotNull String commandName, @NotNull Aliases aliases) {
+        this.name = commandName;
+        this.aliases = aliases;
+    }
+
+    /**
+     * Constructs a SimpleCommandUtils instance with a command name and aliases list.
+     *
+     * @param commandName the name of the command.
+     * @param aliases     a list of aliases for the command.
+     */
+    public SimpleCommandUtils(@NotNull String commandName, @NotNull List<String> aliases) {
+        this.name = commandName;
+        this.aliases = Aliases.of(aliases);
+    }
+
+    /**
+     * Constructs a SimpleCommandUtils instance with a command name and aliases array.
+     *
+     * @param commandName the name of the command.
+     * @param aliases     an array of aliases for the command.
+     */
+    public SimpleCommandUtils(@NotNull String commandName, @NotNull String... aliases) {
+        this.name = commandName;
+        this.aliases = Aliases.of(aliases);
+    }
+
+    /**
+     * Sets the default executor for the command.
+     *
+     * @param executor the default executor.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils execute(@NotNull CommandExecutor executor) {
+        this.defaultExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for player senders.
+     *
+     * @param executor the executor for players.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils playerExecute(@NotNull CommandExecutor executor) {
+        this.playerExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for console senders.
+     *
+     * @param executor the executor for the console.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils consoleExecute(@NotNull CommandExecutor executor) {
+        this.consoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for remote console senders.
+     *
+     * @param executor the executor for remote consoles.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils remoteConsoleExecute(@NotNull CommandExecutor executor) {
+        this.remoteConsoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for entity senders.
+     *
+     * @param executor the executor for entities.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils entityExecute(@NotNull CommandExecutor executor) {
+        this.entityExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for block senders.
+     *
+     * @param executor the executor for blocks.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils blockExecute(@NotNull CommandExecutor executor) {
+        this.blockExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for proxied senders.
+     *
+     * @param executor the executor for proxied senders.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils proxiedExecute(@NotNull CommandExecutor executor) {
+        this.proxiedExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the aliases for the command.
+     *
+     * @param aliases the command aliases.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils aliases(@NotNull Aliases aliases) {
+        this.aliases = aliases;
+        return this;
+    }
+
+    /**
+     * Sets the information for the command.
+     *
+     * @param info the command info.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils info(@NotNull CommandInfo info) {
+        this.info = info;
+        return this;
+    }
+
+    /**
+     * Specifies the allowed sender types for the command.
+     *
+     * @param senderTypes the sender types.
+     * @return the current instance for chaining.
+     */
+    public SimpleCommandUtils senderTypes(@NotNull SenderTypes... senderTypes) {
+        this.sender = senderTypes;
+        return this;
+    }
+
+    /**
+     * Adds arguments to the command.
+     *
+     * @param arguments a list of command arguments.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils arguments(@NotNull List<CommandArgument> arguments) {
+        this.arguments = arguments;
+        return this;
+    }
+
+    /**
+     * Adds abstract arguments to the command.
+     *
+     * @param abstractArguments a list of abstract command arguments.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils abstractArguments(@NotNull List<AbstractCommandArgument> abstractArguments) {
+        this.abstractArguments = abstractArguments;
+        return this;
+    }
+
+    /**
+     * Adds subcommands to the command.
+     *
+     * @param subCommands a list of subcommands.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils subCommands(@NotNull List<SubCommand> subCommands) {
+        this.subCommands = subCommands;
+        return this;
+    }
+
+    /**
+     * Adds abstract subcommands to the command.
+     *
+     * @param abstractSubCommands a list of abstract subcommands.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils abstractSubCommands(@NotNull List<AbstractSubCommand> abstractSubCommands) {
+        this.abstractSubCommands = abstractSubCommands;
+        return this;
+    }
+
+    /**
+     * Sets the position of command arguments.
+     *
+     * @param position the argument position.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils argumentPosition(@NotNull Position position) {
+        this.argumentPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the position of abstract command arguments.
+     *
+     * @param position the abstract argument position.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils abstractArgumentPosition(@NotNull Position position) {
+        this.abstractArgumentPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the position of abstract subcommands.
+     *
+     * @param position the abstract subcommand position.
+     * @return the current instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandUtils abstractSubCommandPosition(@NotNull Position position) {
+        this.abstractSubCommandPosition = position;
+        return this;
+    }
+
+    /**
+     * Builds a {@link CommandUtils} instance based on the current configuration.
+     *
+     * @return a fully constructed CommandUtils object.
+     */
+    @ApiStatus.NonExtendable
+    public CommandUtils build() {
+        CommandUtils commandUtils = CommandUtils.command(name);
+
+        if (sender != null) commandUtils.senderTypes(ExecutableSender.types(sender));
+        if (defaultExecutor != null) commandUtils.defaultExecute(defaultExecutor);
+        if (playerExecutor != null) commandUtils.playerExecute(playerExecutor);
+        if (consoleExecutor != null) commandUtils.consoleExecute(consoleExecutor);
+        if (remoteConsoleExecutor != null) commandUtils.remoteConsoleExecute(remoteConsoleExecutor);
+        if (entityExecutor != null) commandUtils.entityExecute(entityExecutor);
+        if (blockExecutor != null) commandUtils.blockExecute(blockExecutor);
+        if (proxiedExecutor != null) commandUtils.proxiedExecute(proxiedExecutor);
+
+        if (aliases != null) commandUtils.aliases(aliases);
+        if (info != null) commandUtils.info(info);
+
+        if (argumentPosition == Position.LAST) {
+            if (abstractSubCommandPosition == Position.LAST) {
+                if (subCommands != null) subCommands.forEach(commandUtils::subCommand);
+                if (abstractSubCommands != null) abstractSubCommands.forEach(commandUtils::subCommand);
+            } else {
+                if (abstractSubCommands != null) abstractSubCommands.forEach(commandUtils::subCommand);
+                if (subCommands != null) subCommands.forEach(commandUtils::subCommand);
+            }
+            if (abstractArgumentPosition == Position.LAST) {
+                if (arguments != null) arguments.forEach(commandUtils::argument);
+                if (abstractArguments != null) abstractArguments.forEach(commandUtils::argument);
+            } else {
+                if (abstractArguments != null) abstractArguments.forEach(commandUtils::argument);
+                if (arguments != null) arguments.forEach(commandUtils::argument);
+            }
+        } else {
+            if (abstractArgumentPosition == Position.LAST) {
+                if (arguments != null) arguments.forEach(commandUtils::argument);
+                if (abstractArguments != null) abstractArguments.forEach(commandUtils::argument);
+            } else {
+                if (abstractArguments != null) abstractArguments.forEach(commandUtils::argument);
+                if (arguments != null) arguments.forEach(commandUtils::argument);
+            }
+            if (abstractSubCommandPosition == Position.LAST) {
+                if (subCommands != null) subCommands.forEach(commandUtils::subCommand);
+                if (abstractSubCommands != null) abstractSubCommands.forEach(commandUtils::subCommand);
+            } else {
+                if (abstractSubCommands != null) abstractSubCommands.forEach(commandUtils::subCommand);
+                if (subCommands != null) subCommands.forEach(commandUtils::subCommand);
+            }
+        }
+
+        return commandUtils;
+    }
+
+    /**
+     * Registers the built command with the server.
+     */
+    @ApiStatus.NonExtendable
+    public void register() {
+        build().register();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/api/CommandAPI.java b/src/main/java/dev/vansen/commandutils/api/CommandAPI.java
new file mode 100644
index 0000000000000000000000000000000000000000..241455666952ea2da59935c4fdca1a195e470813
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/api/CommandAPI.java
@@ -0,0 +1,77 @@
+package dev.vansen.commandutils.api;
+
+import com.mojang.brigadier.CommandDispatcher;
+import dev.vansen.commandutils.argument.arguments.ColorArgumentType;
+import dev.vansen.commandutils.argument.arguments.color.ArgumentColors;
+import dev.vansen.commandutils.exceptions.APINotFoundException;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.types.LifecycleEvents;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class for managing and accessing the lifecycle event manager for command registration.
+ * <p>
+ * This class provides static methods to get and set the {@link LifecycleEventManager} instance,
+ * which is essential for registering commands.
+ * </p>
+ * This class also provides access to the {@link CommandDispatcher} once the event manager is set.
+ */
+@SuppressWarnings({"unused"})
+public final class CommandAPI {
+    private static LifecycleEventManager<@NotNull Plugin> event;
+    private static CommandDispatcher<CommandSourceStack> dispatcher;
+
+    /**
+     * Retrieves the current {@link LifecycleEventManager} instance.
+     *
+     * @return the {@link LifecycleEventManager} used for handling lifecycle events.
+     * @throws APINotFoundException if the event manager has not been set.
+     */
+    @NotNull
+    public static LifecycleEventManager<@NotNull Plugin> get() {
+        if (event == null) throw new APINotFoundException();
+        return event;
+    }
+
+    /**
+     * Sets the {@link LifecycleEventManager} instance to be used for handling lifecycle events, as well as the dispatcher.
+     *
+     * @param event the {@link LifecycleEventManager} instance to set.
+     */
+    public static void set(@NotNull LifecycleEventManager<@NotNull Plugin> event) {
+        CommandAPI.event = event;
+        event.registerEventHandler(LifecycleEvents.COMMANDS, registrar -> dispatcher = registrar.registrar().getDispatcher());
+    }
+
+    /**
+     * Sets the {@link LifecycleEventManager} instance to be used for handling lifecycle events, as well as the dispatcher.
+     *
+     * @param plugin the {@link JavaPlugin} instance to set (uses the plugin's lifecycle event manager).
+     */
+    public static void set(@NotNull JavaPlugin plugin) {
+        set(plugin.getLifecycleManager());
+    }
+
+    /**
+     * Retrieves the {@link CommandDispatcher} instance.
+     *
+     * @return the {@link CommandDispatcher} used for handling commands.
+     * @throws APINotFoundException if the dispatcher has not been set.
+     */
+    public static CommandDispatcher<CommandSourceStack> dispatcher() {
+        if (dispatcher == null) throw new APINotFoundException();
+        return dispatcher;
+    }
+
+    /**
+     * Initializes the default colors for {@link ColorArgumentType}
+     * <p>
+     * This isn't required, just optional "0ms" of performance boost when using ArgumentColors for the first time (usually when somebody executes a command, and you are using {@link ColorArgumentType})
+     */
+    public static void initializeColors() {
+        ArgumentColors.defaultColors();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/AbstractCommandArgument.java b/src/main/java/dev/vansen/commandutils/argument/AbstractCommandArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b4bb058161f758437811e8da91415883d0eff5d
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/AbstractCommandArgument.java
@@ -0,0 +1,192 @@
+package dev.vansen.commandutils.argument;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import dev.vansen.commandutils.command.CommandWrapper;
+import dev.vansen.commandutils.command.ExecutableSender;
+import dev.vansen.commandutils.command.Position;
+import dev.vansen.commandutils.completer.CompletionHandler;
+import dev.vansen.commandutils.permission.CommandPermission;
+import dev.vansen.commandutils.sender.SenderTypes;
+import dev.vansen.commandutils.subcommand.AbstractSubCommand;
+import dev.vansen.commandutils.subcommand.SubCommand;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+/**
+ * This is generally not recommended to use, since it limits the ability to nest arguments, and it is generally recommended to use {@link SimpleCommandArgument} since it allows easier command argument management, and saves alot of time in coding.
+ */
+@SuppressWarnings("unused")
+public abstract class AbstractCommandArgument {
+
+    private final Argument argument;
+    private CompletionHandler handler;
+
+    public AbstractCommandArgument(@NotNull Argument argument) {
+        this.argument = argument;
+    }
+
+    public AbstractCommandArgument(@NotNull String name, @NotNull ArgumentType<?> type) {
+        this(new Argument(name, type));
+    }
+
+    public AbstractCommandArgument(@NotNull Argument argument, @NotNull CompletionHandler handler) {
+        this.argument = argument;
+        this.handler = handler;
+    }
+
+    public AbstractCommandArgument(@NotNull String name, @NotNull ArgumentType<?> type, CompletionHandler handler) {
+        this(new Argument(name, type), handler);
+    }
+
+    public SenderTypes[] senderTypes() {
+        return null;
+    }
+
+    public void execute(@NotNull CommandWrapper context) {
+    }
+
+    public void playerExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void consoleExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void remoteConsoleExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void entityExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void blockExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void proxiedExecute(@NotNull CommandWrapper context) {
+    }
+
+    public CommandPermission permission() {
+        return null;
+    }
+
+    public List<CommandArgument> arguments() {
+        return List.of();
+    }
+
+    public List<AbstractCommandArgument> abstractArguments() {
+        return List.of();
+    }
+
+    public List<SubCommand> subCommands() {
+        return List.of();
+    }
+
+    public List<AbstractSubCommand> abstractSubCommands() {
+        return List.of();
+    }
+
+    @NotNull
+    public Position argumentPosition() {
+        return Position.LAST; // adds argument at the last.
+    }
+
+    @NotNull
+    public Position abstractArgumentPosition() {
+        return Position.LAST; // adds abstract arguments at the last.
+    }
+
+    @NotNull
+    public Position abstractSubCommandPosition() {
+        return Position.LAST; // adds abstract subcommands at the last.
+    }
+
+    public CommandArgument build() {
+        CommandArgument arg = CommandArgument.of(argument);
+
+        try {
+            Method executeMethod = this.getClass().getDeclaredMethod("execute", CommandWrapper.class);
+            Method superExecuteMethod = AbstractCommandArgument.class.getDeclaredMethod("execute", CommandWrapper.class);
+            if (!executeMethod.equals(superExecuteMethod)) {
+                if (senderTypes() != null) {
+                    arg.defaultExecute(this::execute, ExecutableSender.types(senderTypes()));
+                } else {
+                    arg.defaultExecute(this::execute);
+                }
+            }
+
+            Method playerExecuteMethod = this.getClass().getDeclaredMethod("playerExecute", CommandWrapper.class);
+            Method superPlayerExecuteMethod = AbstractCommandArgument.class.getDeclaredMethod("playerExecute", CommandWrapper.class);
+            if (!playerExecuteMethod.equals(superPlayerExecuteMethod)) {
+                arg.playerExecute(this::playerExecute);
+            }
+
+            Method consoleExecuteMethod = this.getClass().getDeclaredMethod("consoleExecute", CommandWrapper.class);
+            Method superConsoleExecuteMethod = AbstractCommandArgument.class.getDeclaredMethod("consoleExecute", CommandWrapper.class);
+            if (!consoleExecuteMethod.equals(superConsoleExecuteMethod)) {
+                arg.consoleExecute(this::consoleExecute);
+            }
+
+            Method remoteConsoleExecuteMethod = this.getClass().getDeclaredMethod("remoteConsoleExecute", CommandWrapper.class);
+            Method superRemoteConsoleExecuteMethod = AbstractCommandArgument.class.getDeclaredMethod("remoteConsoleExecute", CommandWrapper.class);
+            if (!remoteConsoleExecuteMethod.equals(superRemoteConsoleExecuteMethod)) {
+                arg.remoteConsoleExecute(this::remoteConsoleExecute);
+            }
+
+            Method entityExecuteMethod = this.getClass().getDeclaredMethod("entityExecute", CommandWrapper.class);
+            Method superEntityExecuteMethod = AbstractCommandArgument.class.getDeclaredMethod("entityExecute", CommandWrapper.class);
+            if (!entityExecuteMethod.equals(superEntityExecuteMethod)) {
+                arg.entityExecute(this::entityExecute);
+            }
+
+            Method blockExecuteMethod = this.getClass().getDeclaredMethod("blockExecute", CommandWrapper.class);
+            Method superBlockExecuteMethod = AbstractCommandArgument.class.getDeclaredMethod("blockExecute", CommandWrapper.class);
+            if (!blockExecuteMethod.equals(superBlockExecuteMethod)) {
+                arg.blockExecute(this::blockExecute);
+            }
+
+            Method proxiedExecuteMethod = this.getClass().getDeclaredMethod("proxiedExecute", CommandWrapper.class);
+            Method superProxiedExecuteMethod = AbstractCommandArgument.class.getDeclaredMethod("proxiedExecute", CommandWrapper.class);
+            if (!proxiedExecuteMethod.equals(superProxiedExecuteMethod)) {
+                arg.proxiedExecute(this::proxiedExecute);
+            }
+        } catch (NoSuchMethodException ignored) {
+        }
+
+        if (permission() != null) arg.permission(permission());
+
+        if (handler != null) arg.completion(handler);
+
+        if (argumentPosition() == Position.LAST) {
+            if (abstractSubCommandPosition() == Position.LAST) {
+                subCommands().forEach(arg::subCommand);
+                abstractSubCommands().forEach(arg::subCommand);
+            } else {
+                abstractSubCommands().forEach(arg::subCommand);
+                subCommands().forEach(arg::subCommand);
+            }
+            if (abstractArgumentPosition() == Position.LAST) {
+                arguments().forEach(arg::argument);
+                abstractArguments().forEach(arg::argument);
+            } else {
+                abstractArguments().forEach(arg::argument);
+                arguments().forEach(arg::argument);
+            }
+        } else {
+            if (abstractArgumentPosition() == Position.LAST) {
+                arguments().forEach(arg::argument);
+                abstractArguments().forEach(arg::argument);
+            } else {
+                abstractArguments().forEach(arg::argument);
+                arguments().forEach(arg::argument);
+            }
+            if (abstractSubCommandPosition() == Position.LAST) {
+                subCommands().forEach(arg::subCommand);
+                abstractSubCommands().forEach(arg::subCommand);
+            } else {
+                abstractSubCommands().forEach(arg::subCommand);
+                subCommands().forEach(arg::subCommand);
+            }
+        }
+        return arg;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/Argument.java b/src/main/java/dev/vansen/commandutils/argument/Argument.java
new file mode 100644
index 0000000000000000000000000000000000000000..744f5dc2e2a9ec5ab31ff0fb84f614edfa310984
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/Argument.java
@@ -0,0 +1,13 @@
+package dev.vansen.commandutils.argument;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents an argument in a command.
+ *
+ * @param name The name of the argument.
+ * @param type The type of the argument.
+ */
+public record Argument(@NotNull String name, @NotNull ArgumentType<?> type) {
+}
diff --git a/src/main/java/dev/vansen/commandutils/argument/ArgumentNester.java b/src/main/java/dev/vansen/commandutils/argument/ArgumentNester.java
new file mode 100644
index 0000000000000000000000000000000000000000..7876e572f5b21d12d53b1ba619b428f5ef0e101d
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/ArgumentNester.java
@@ -0,0 +1,47 @@
+package dev.vansen.commandutils.argument;
+
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * Utility class for nesting arguments into a command.
+ */
+@SuppressWarnings({"unused"})
+public final class ArgumentNester {
+
+    /**
+     * Backend method for nesting arguments into a command, you generally don't need to use this.
+     */
+    public static void nest(@NotNull List<RequiredArgumentBuilder<CommandSourceStack, ?>> argumentStack, @NotNull LiteralArgumentBuilder<CommandSourceStack> builder) {
+        if (argumentStack.isEmpty()) return;
+
+        RequiredArgumentBuilder<CommandSourceStack, ?> lastArg = argumentStack.getLast();
+        for (int i = argumentStack.size() - 2; i >= 0; i--) {
+            RequiredArgumentBuilder<CommandSourceStack, ?> previousArg = argumentStack.get(i);
+            previousArg.then(lastArg);
+            lastArg = previousArg;
+        }
+
+        builder.then(lastArg);
+    }
+
+    /**
+     * Backend method for nesting arguments into a command, you generally don't need to use this.
+     */
+    public static void nest(@NotNull RequiredArgumentBuilder<CommandSourceStack, ?> argument, @NotNull List<RequiredArgumentBuilder<CommandSourceStack, ?>> argumentStack) {
+        if (argumentStack.isEmpty()) return;
+
+        RequiredArgumentBuilder<CommandSourceStack, ?> lastArg = argumentStack.getLast();
+        for (int i = argumentStack.size() - 2; i >= 0; i--) {
+            RequiredArgumentBuilder<CommandSourceStack, ?> previousArg = argumentStack.get(i);
+            previousArg.then(lastArg);
+            lastArg = previousArg;
+        }
+
+        argument.then(lastArg);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/CommandArgument.java b/src/main/java/dev/vansen/commandutils/argument/CommandArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..82a02144f88622117c01dd5c0508c60ff970da57
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/CommandArgument.java
@@ -0,0 +1,1026 @@
+package dev.vansen.commandutils.argument;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.mojang.brigadier.arguments.*;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import dev.vansen.commandutils.argument.arguments.ColorArgumentType;
+import dev.vansen.commandutils.argument.arguments.CommandBlockModeArgumentType;
+import dev.vansen.commandutils.argument.arguments.PlayerArgumentType;
+import dev.vansen.commandutils.argument.finder.ArgumentString;
+import dev.vansen.commandutils.command.CommandExecutor;
+import dev.vansen.commandutils.command.*;
+import dev.vansen.commandutils.completer.CompletionHandler;
+import dev.vansen.commandutils.completer.SuggestionsBuilderWrapper;
+import dev.vansen.commandutils.exceptions.CmdException;
+import dev.vansen.commandutils.messages.MessageTypes;
+import dev.vansen.commandutils.permission.CommandPermission;
+import dev.vansen.commandutils.sender.SenderTypes;
+import dev.vansen.commandutils.subcommand.AbstractSubCommand;
+import dev.vansen.commandutils.subcommand.SubCommand;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import io.papermc.paper.command.brigadier.argument.ArgumentTypes;
+import org.bukkit.command.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+
+/**
+ * Represents a command argument in the command system.
+ * Arguments are individual command branches with their own execution logic and other things.
+ */
+@SuppressWarnings({"unused"})
+public final class CommandArgument {
+    private final RequiredArgumentBuilder<CommandSourceStack, ?> argument;
+    private final List<RequiredArgumentBuilder<CommandSourceStack, ?>> argumentStack = new ArrayList<>();
+    private boolean nest = true;
+    private CommandExecutor defaultExecutor;
+    private CommandExecutor playerExecutor;
+    private CommandExecutor consoleExecutor;
+    private CommandExecutor remoteConsoleExecutor;
+    private CommandExecutor entityExecutor;
+    private CommandExecutor blockExecutor;
+    private CommandExecutor proxiedExecutor;
+    private SenderTypes[] senderTypes = null;
+
+    /**
+     * Constructs a new command argument with the specified Argument.
+     *
+     * @param argument the argument.
+     */
+    public CommandArgument(@NotNull Argument argument) {
+        this.argument = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+    }
+
+    /**
+     * Constructs a new command argument with the specified Argument and CompletionHandler.
+     *
+     * @param argument the argument.
+     * @param handler  the completion handler.
+     */
+    public CommandArgument(@NotNull Argument argument, @NotNull CompletionHandler handler) {
+        this.argument = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        completion(handler);
+    }
+
+    /**
+     * Constructs a new command argument with the specified name and ArgumentType.
+     *
+     * @param name the name of the argument.
+     * @param type the type of the argument.
+     */
+    public CommandArgument(@NotNull String name, @NotNull ArgumentType<?> type) {
+        this.argument = RequiredArgumentBuilder.argument(name, type);
+    }
+
+    /**
+     * Constructs a new command argument with the specified name, ArgumentType, and CompletionHandler.
+     *
+     * @param name    the name of the argument.
+     * @param type    the type of the argument.
+     * @param handler the completion handler.
+     */
+    public CommandArgument(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CompletionHandler handler) {
+        this.argument = RequiredArgumentBuilder.argument(name, type);
+        completion(handler);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link CommandArgument}.
+     *
+     * @param argument the argument.
+     * @return a new {@link CommandArgument} instance.
+     */
+    @NotNull
+    public static CommandArgument of(@NotNull Argument argument) {
+        return new CommandArgument(argument);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link CommandArgument} with a CompletionHandler.
+     *
+     * @param argument the argument.
+     * @param handler  the completion handler.
+     * @return a new {@link CommandArgument} instance.
+     */
+    @NotNull
+    public static CommandArgument of(@NotNull Argument argument, @NotNull CompletionHandler handler) {
+        return new CommandArgument(argument, handler);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link CommandArgument} with a name and ArgumentType.
+     *
+     * @param name the name of the argument.
+     * @param type the type of the argument.
+     * @return a new {@link CommandArgument} instance.
+     */
+    @NotNull
+    public static CommandArgument of(@NotNull String name, @NotNull ArgumentType<?> type) {
+        return new CommandArgument(name, type);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link CommandArgument} with a name, ArgumentType, and CompletionHandler.
+     *
+     * @param name    the name of the argument.
+     * @param type    the type of the argument.
+     * @param handler the completion handler.
+     * @return a new {@link CommandArgument} instance.
+     */
+    @NotNull
+    public static CommandArgument of(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CompletionHandler handler) {
+        return new CommandArgument(name, type, handler);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link CommandArgument} with a name and ArgumentType.
+     *
+     * @param name the name of the argument.
+     * @param type the type of the argument.
+     * @return a new {@link CommandArgument} instance.
+     */
+    @NotNull
+    public static CommandArgument of(@NotNull String name, @NotNull String type) {
+        return new CommandArgument(name, ArgumentString.fromString(type));
+    }
+
+    /**
+     * Factory method to create a new instance of {@link CommandArgument} with a name, ArgumentType, and CompletionHandler.
+     *
+     * @param name    the name of the argument.
+     * @param type    the type of the argument.
+     * @param handler the completion handler.
+     * @return a new {@link CommandArgument} instance.
+     */
+    @NotNull
+    public static CommandArgument of(@NotNull String name, @NotNull String type, @NotNull CompletionHandler handler) {
+        return new CommandArgument(name, ArgumentString.fromString(type), handler);
+    }
+
+    /**
+     * Creates a new string argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a string argument.
+     */
+    @NotNull
+    public static CommandArgument string(@NotNull String name) {
+        return new CommandArgument(name, StringArgumentType.string());
+    }
+
+    /**
+     * Creates a new word argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a word argument.
+     */
+    @NotNull
+    public static CommandArgument word(@NotNull String name) {
+        return new CommandArgument(name, StringArgumentType.word());
+    }
+
+    /**
+     * Creates a new greedy string argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a greedy string argument.
+     */
+    @NotNull
+    public static CommandArgument greedy(@NotNull String name) {
+        return new CommandArgument(name, StringArgumentType.greedyString());
+    }
+
+    /**
+     * Creates a new boolean argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a boolean argument.
+     */
+    @NotNull
+    public static CommandArgument bool(@NotNull String name) {
+        return new CommandArgument(name, BoolArgumentType.bool());
+    }
+
+    /**
+     * Creates a new integer argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing an integer argument.
+     */
+    @NotNull
+    public static CommandArgument integer(@NotNull String name) {
+        return new CommandArgument(name, IntegerArgumentType.integer());
+    }
+
+    /**
+     * Creates a new integer argument with the specified name and minimum value.
+     *
+     * @param name the name of the argument.
+     * @param min  the minimum value for the integer argument.
+     * @return a new {@link CommandArgument} instance representing an integer argument.
+     */
+    @NotNull
+    public static CommandArgument integer(@NotNull String name, int min) {
+        return new CommandArgument(name, IntegerArgumentType.integer(min));
+    }
+
+    /**
+     * Creates a new integer argument with the specified name and a minimum and maximum value.
+     *
+     * @param name the name of the argument.
+     * @param max  the maximum value for the integer argument.
+     * @return a new {@link CommandArgument} instance representing an integer argument.
+     */
+    @NotNull
+    public static CommandArgument integer(@NotNull String name, int min, int max) {
+        return new CommandArgument(name, IntegerArgumentType.integer(min, max));
+    }
+
+    /**
+     * Creates a new double argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a double argument.
+     */
+    @NotNull
+    public static CommandArgument doubleArg(@NotNull String name) {
+        return new CommandArgument(name, DoubleArgumentType.doubleArg());
+    }
+
+    /**
+     * Creates a new float argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a float argument.
+     */
+    @NotNull
+    public static CommandArgument floatArg(@NotNull String name) {
+        return new CommandArgument(name, FloatArgumentType.floatArg());
+    }
+
+    /**
+     * Creates a new long argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a long argument.
+     */
+    @NotNull
+    public static CommandArgument longArg(@NotNull String name) {
+        return new CommandArgument(name, LongArgumentType.longArg());
+    }
+
+    /**
+     * Creates a new player argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a player argument.
+     */
+    @NotNull
+    public static CommandArgument player(@NotNull String name) {
+        return new CommandArgument(name, PlayerArgumentType.player());
+    }
+
+    /**
+     * Creates a new color argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a color argument.
+     */
+    @NotNull
+    public static CommandArgument color(@NotNull String name) {
+        return new CommandArgument(name, ColorArgumentType.color());
+    }
+
+    /**
+     * Creates a new named color argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a named color argument.
+     */
+    @NotNull
+    public static CommandArgument namedColor(@NotNull String name) {
+        return new CommandArgument(name, ArgumentTypes.namedColor());
+    }
+
+    /**
+     * Creates a new block mode argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a block mode argument.
+     */
+    @NotNull
+    public static CommandArgument blockMode(@NotNull String name) {
+        return new CommandArgument(name, CommandBlockModeArgumentType.mode());
+    }
+
+    /**
+     * Creates a new item stack argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing an item stack argument.
+     */
+    @NotNull
+    public static CommandArgument itemStack(@NotNull String name) {
+        return new CommandArgument(name, ArgumentTypes.itemStack());
+    }
+
+    /**
+     * Creates a new world argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a world argument.
+     */
+    @NotNull
+    public static CommandArgument world(@NotNull String name) {
+        return new CommandArgument(name, ArgumentTypes.world());
+    }
+
+    /**
+     * Creates a new game mode argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a game mode argument.
+     */
+    @NotNull
+    public static CommandArgument gameMode(@NotNull String name) {
+        return new CommandArgument(name, ArgumentTypes.gameMode());
+    }
+
+    /**
+     * Creates a new uuid argument with the specified name.
+     *
+     * @param name the name of the argument.
+     * @return a new {@link CommandArgument} instance representing a uuid argument.
+     */
+    @NotNull
+    public static CommandArgument uuid(@NotNull String name) {
+        return new CommandArgument(name, ArgumentTypes.uuid());
+    }
+
+    private void execute() {
+        argument.executes(context -> {
+            CommandSender sender = context.getSource().getSender();
+            CommandWrapper wrapped = new CommandWrapper(context);
+            boolean done = false;
+
+            try {
+                switch (sender) {
+                    case Player player when playerExecutor != null -> {
+                        done = true;
+                        playerExecutor.execute(wrapped);
+                    }
+                    case ConsoleCommandSender consoleCommandSender when consoleExecutor != null -> {
+                        done = true;
+                        consoleExecutor.execute(wrapped);
+                    }
+                    case RemoteConsoleCommandSender remoteConsoleCommandSender when remoteConsoleExecutor != null -> {
+                        done = true;
+                        remoteConsoleExecutor.execute(wrapped);
+                    }
+                    case BlockCommandSender blockCommandSender when blockExecutor != null -> {
+                        done = true;
+                        blockExecutor.execute(wrapped);
+                    }
+                    default -> {
+                        switch (context.getSource().getExecutor()) {
+                            case Entity entity when entityExecutor != null -> {
+                                done = true;
+                                entityExecutor.execute(wrapped);
+                            }
+                            case ProxiedCommandSender proxiedCommandSender when proxiedExecutor != null -> {
+                                done = true;
+                                proxiedExecutor.execute(wrapped);
+                            }
+                            case null, default -> {
+                            }
+                        }
+                    }
+                }
+                if (!done) {
+                    Optional.ofNullable(defaultExecutor)
+                            .ifPresent(executor -> {
+                                if (senderTypes == null) executor.execute(wrapped);
+                                else if (Arrays.stream(senderTypes)
+                                        .anyMatch(type -> type == wrapped.senderType()))
+                                    executor.execute(wrapped);
+                                else {
+                                    switch (wrapped.senderType()) {
+                                        case PLAYER -> wrapped.response(MessageTypes.NOT_ALLOWED_PLAYER);
+                                        case CONSOLE -> wrapped.response(MessageTypes.NOT_ALLOWED_CONSOLE);
+                                        case REMOTE_CONSOLE ->
+                                                wrapped.response(MessageTypes.NOT_ALLOWED_REMOTE_CONSOLE);
+                                        case ENTITY -> wrapped.response(MessageTypes.NOT_ALLOWED_ENTITY);
+                                        case COMMAND_BLOCK -> wrapped.response(MessageTypes.NOT_ALLOWED_COMMAND_BLOCK);
+                                        case PROXIED -> wrapped.response(MessageTypes.NOT_ALLOWED_PROXIED_SENDER);
+                                    }
+                                }
+                            });
+                }
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+    }
+
+    private void executeIf() {
+        if (defaultExecutor != null || playerExecutor != null || consoleExecutor != null || remoteConsoleExecutor != null || entityExecutor != null || blockExecutor != null || proxiedExecutor != null) {
+            execute();
+        }
+    }
+
+    /**
+     * Sets the default executor for the argument, which is called when the argument
+     * is executed without any other arguments/subcommands or when no other execution path is matched.
+     *
+     * @param executor the {@link CommandExecutor} to be executed by default.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument defaultExecute(@NotNull CommandExecutor executor) {
+        defaultExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the default executor for the argument, which is called when the argument
+     * is executed without any other arguments/subcommands or when no other execution path is matched.
+     * If the command sender is not in the sender types, the executor is not called either.
+     *
+     * @param executor    the {@link CommandExecutor} to be executed by default.
+     * @param senderTypes the {@link SenderTypes} of the sender.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument defaultExecute(@NotNull CommandExecutor executor, @NotNull ExecutableSender senderTypes) {
+        defaultExecutor = executor;
+        this.senderTypes = senderTypes.types();
+        return this;
+    }
+
+    /**
+     * Sets the sender types for the argument.
+     *
+     * @param senderTypes the {@link SenderTypes} of the sender.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument senderTypes(@NotNull ExecutableSender senderTypes) {
+        this.senderTypes = senderTypes.types();
+        return this;
+    }
+
+    /**
+     * Sets the executor for the argument, but only if the {@link CommandSender} is a {@link Player}.
+     * If the sender is not a player, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a player.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument playerExecute(@NotNull CommandExecutor executor) {
+        playerExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the argument, but only if the {@link CommandSender} is a {@link ConsoleCommandSender}.
+     * If the sender is not a console, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a console.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument consoleExecute(@NotNull CommandExecutor executor) {
+        consoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the argument, but only if the {@link CommandSender} is a {@link RemoteConsoleCommandSender}.
+     * If the sender is not a remote console, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a remote console.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument remoteConsoleExecute(@NotNull CommandExecutor executor) {
+        remoteConsoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the argument, but only if the {@link CommandSender} is an {@link Entity}.
+     * If the sender is not an entity, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is an entity.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument entityExecute(@NotNull CommandExecutor executor) {
+        entityExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the argument, but only if the {@link CommandSender} is a {@link BlockCommandSender}.
+     * If the sender is not a command block, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a block.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument blockExecute(@NotNull CommandExecutor executor) {
+        blockExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the argument, but only if the {@link CommandSender} is a {@link ProxiedCommandSender}.
+     * If the sender is not a proxied sender, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a proxied player.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument proxiedExecute(@NotNull CommandExecutor executor) {
+        proxiedExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param argument the {@link CommandArgument}
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull CommandArgument argument) {
+        argumentStack.add(argument.get());
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param argument the {@link AbstractCommandArgument}
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull AbstractCommandArgument argument) {
+        argumentStack.add(argument.build().get());
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param argument the {@link Argument}
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull Argument argument, @NotNull CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param argument the {@link Argument}
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull Argument argument, @NotNull CommandExecutor executor) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param argument the {@link Argument}
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull Argument argument, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        }).suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull ArgumentType<?> type, @NotNull String name) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CommandExecutor executor) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        }).suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull ArgumentType<?> type) {
+        return argument(type, name);
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull ArgumentType<?> type, CompletionHandler handler) {
+        return argument(type, name, handler);
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CommandExecutor executor) {
+        return argument(type, name, executor);
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        return argument(type, name, executor, handler);
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull String type) {
+        return argument(type, ArgumentString.fromString(name));
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull String type, CompletionHandler handler) {
+        return argument(type, ArgumentString.fromString(name), handler);
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull String type, @NotNull CommandExecutor executor) {
+        return argument(type, ArgumentString.fromString(name), executor);
+    }
+
+    /**
+     * Adds an argument to the argument.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument argument(@NotNull String name, @NotNull String type, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        return argument(type, ArgumentString.fromString(name), executor, handler);
+    }
+
+    /**
+     * Adds a completion handler to the main argument.
+     *
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument completion(@NotNull CompletionHandler handler) {
+        argument.suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        return this;
+    }
+
+    /**
+     * Adds a completion handler to the first or last argument added to the argument.
+     *
+     * @param position the position of the argument to add the completion handler to.
+     * @param handler  the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument completion(@NotNull Position position, @NotNull CompletionHandler handler) {
+        switch (position) {
+            case Position.FIRST -> argumentStack.getFirst()
+                    .suggests((context, builder) -> {
+                        CommandWrapper wrapped = new CommandWrapper(context);
+                        SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                        return handler.complete(wrapped, wrapper);
+                    });
+            case Position.LAST -> argumentStack.getLast()
+                    .suggests((context, builder) -> {
+                        CommandWrapper wrapped = new CommandWrapper(context);
+                        SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                        return handler.complete(wrapped, wrapper);
+                    });
+        }
+        return this;
+    }
+
+    /**
+     * Adds a completion handler to the argument at the specified index.
+     *
+     * @param index   the index of the argument to add the completion handler to.
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument completion(int index, @NotNull CompletionHandler handler) {
+        argumentStack.get(index)
+                .suggests((context, builder) -> {
+                    CommandWrapper wrapped = new CommandWrapper(context);
+                    SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                    return handler.complete(wrapped, wrapper);
+                });
+        return this;
+    }
+
+    /**
+     * Adds a subcommand to the argument.
+     *
+     * @param subCommand the {@link SubCommand} to be added.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument subCommand(@NotNull SubCommand subCommand) {
+        argument.then(subCommand.get());
+        return this;
+    }
+
+    /**
+     * Adds a subcommand to the argument.
+     *
+     * @param subCommand the {@link AbstractSubCommand} to be added.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument subCommand(@NotNull AbstractSubCommand subCommand) {
+        argument.then(subCommand.build().get());
+        return this;
+    }
+
+    /**
+     * Disables argument nesting for the argument.
+     * <p>
+     * Note, disabling this (may) have 2 or even more arguments in a single argument, which is not recommended.
+     * So it would be "/command [arg1 | arg2 | arg3]" instead of "/command arg1 arg2 arg3", there are other unexpected results as well, for example arguments not working.
+     * <p>
+     * Some cases where this would work would be using {@link CommandArgument} and {@link CommandArgument#argument(CommandArgument)}, but if disabled nesting in command arguments will lead to it not working.
+     *
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    public CommandArgument noNest() {
+        nest = false;
+        return this;
+    }
+
+    /**
+     * Adds a permission to the argument.
+     *
+     * @param permission the {@link CommandPermission} to be added.
+     * @return this {@link CommandArgument} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument permission(@NotNull CommandPermission permission) {
+        if (permission.isOpPermission()) {
+            argument.requires(consumer -> consumer.getSender().isOp());
+        } else if (permission.getPermission() != null) {
+            argument.requires(consumer -> consumer.getSender().hasPermission(permission.getPermission()));
+        }
+        return this;
+    }
+
+    /**
+     * The requirement of the subcommand, if the requirement is not met the argument will not execute.
+     *
+     * @param requirement the {@link Predicate} for the requirement
+     * @return this {@link CommandArgument} instance for chaining
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument requirement(@NotNull Predicate<CommandRequirement> requirement) {
+        argument.requires(consumer -> requirement.test(new CommandRequirement(consumer)));
+        return this;
+    }
+
+    /**
+     * The requirement of the argument, if the requirement is not met the argument will not execute.
+     *
+     * @param checker the {@link BooleanChecker} for the requirement
+     * @return this {@link CommandArgument} instance for chaining
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandArgument requirement(@NotNull BooleanChecker checker) {
+        argument.requires(consumer -> checker.check());
+        return this;
+    }
+
+    @NotNull
+    public RequiredArgumentBuilder<CommandSourceStack, ?> get() {
+        executeIf();
+        if (nest) ArgumentNester.nest(argument, argumentStack);
+        return argument;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/SimpleCommandArgument.java b/src/main/java/dev/vansen/commandutils/argument/SimpleCommandArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..4355139cce3290df11c367dc6a4022269f64140b
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/SimpleCommandArgument.java
@@ -0,0 +1,359 @@
+package dev.vansen.commandutils.argument;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import dev.vansen.commandutils.command.CommandExecutor;
+import dev.vansen.commandutils.command.ExecutableSender;
+import dev.vansen.commandutils.command.Position;
+import dev.vansen.commandutils.completer.CompletionHandler;
+import dev.vansen.commandutils.permission.CommandPermission;
+import dev.vansen.commandutils.sender.SenderTypes;
+import dev.vansen.commandutils.subcommand.AbstractSubCommand;
+import dev.vansen.commandutils.subcommand.SubCommand;
+import org.bukkit.command.BlockCommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * Represents a command argument in the command system.
+ * Arguments are individual command branches with their own execution logic and other things.
+ */
+@SuppressWarnings("unused")
+public class SimpleCommandArgument {
+    private final Argument argument;
+    private CommandExecutor defaultExecutor;
+    private CommandExecutor playerExecutor;
+    private CommandExecutor consoleExecutor;
+    private CommandExecutor entityExecutor;
+    private CommandExecutor blockExecutor;
+    private CommandExecutor proxiedExecutor;
+    private CompletionHandler handler;
+    private SenderTypes[] senderTypes;
+    private CommandPermission permission;
+    private Position argumentPosition = Position.LAST;
+    private Position abstractArgumentPosition = Position.LAST;
+    private Position abstractSubCommandPosition = Position.LAST;
+    private List<CommandArgument> arguments;
+    private List<AbstractCommandArgument> abstractArguments;
+    private List<SubCommand> subCommands;
+    private List<AbstractSubCommand> abstractSubCommands;
+
+    /**
+     * Constructs a new SimpleCommandArgument with the specified argument.
+     *
+     * @param argument the argument to be associated with this SimpleCommandArgument.
+     */
+    public SimpleCommandArgument(@NotNull Argument argument) {
+        this.argument = argument;
+    }
+
+    /**
+     * Constructs a new SimpleCommandArgument with the specified argument name and type.
+     *
+     * @param name the name of the argument.
+     * @param type the type of the argument.
+     */
+    public SimpleCommandArgument(@NotNull String name, @NotNull ArgumentType<?> type) {
+        this(new Argument(name, type));
+    }
+
+    /**
+     * Constructs a new SimpleCommandArgument with the specified argument and completion handler.
+     *
+     * @param argument the argument to be associated with this SimpleCommandArgument.
+     * @param handler  the completion handler to be associated with this SimpleCommandArgument.
+     */
+    public SimpleCommandArgument(@NotNull Argument argument, @NotNull CompletionHandler handler) {
+        this.argument = argument;
+        this.handler = handler;
+    }
+
+    /**
+     * Constructs a new SimpleCommandArgument with the specified argument name, type, and completion handler.
+     *
+     * @param name    the name of the argument.
+     * @param type    the type of the argument.
+     * @param handler the completion handler to be associated with this SimpleCommandArgument.
+     */
+    public SimpleCommandArgument(@NotNull String name, @NotNull ArgumentType<?> type, CompletionHandler handler) {
+        this(new Argument(name, type), handler);
+    }
+
+    /**
+     * Sets the default executor for this subcommand.
+     * This executor is used if no other specific executor is matched for the sender type.
+     *
+     * @param executor the {@link CommandExecutor} to be executed by default.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument execute(@NotNull CommandExecutor executor) {
+        this.defaultExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the default executor for this subcommand, along with the sender types it applies to.
+     *
+     * @param executor    the {@link CommandExecutor} to be executed by default.
+     * @param senderTypes the {@link SenderTypes} that the executor applies to.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument execute(@NotNull CommandExecutor executor, SenderTypes... senderTypes) {
+        this.defaultExecutor = executor;
+        this.senderTypes = senderTypes;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a {@link Player}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for players.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument playerExecute(@NotNull CommandExecutor executor) {
+        this.playerExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a {@link ConsoleCommandSender}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for console senders.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument consoleExecute(@NotNull CommandExecutor executor) {
+        this.consoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is an {@link Entity}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for entities.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument entityExecute(@NotNull CommandExecutor executor) {
+        this.entityExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a {@link BlockCommandSender}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for block senders.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument blockExecute(@NotNull CommandExecutor executor) {
+        this.blockExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a proxied sender.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for proxied senders.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument proxiedExecute(@NotNull CommandExecutor executor) {
+        this.proxiedExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the sender types for this argument.
+     *
+     * @param senderTypes the {@link SenderTypes} that this argument applies to.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument senderTypes(SenderTypes... senderTypes) {
+        this.senderTypes = senderTypes;
+        return this;
+    }
+
+    /**
+     * Sets the permission required for executing this argument.
+     *
+     * @param permission the {@link CommandPermission} required for executing this argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument permission(@NotNull CommandPermission permission) {
+        this.permission = permission;
+        return this;
+    }
+
+    /**
+     * Sets the argument position in the command.
+     *
+     * @param position the position of the argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument argumentPosition(Position position) {
+        this.argumentPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the abstract argument position in the command.
+     *
+     * @param position the position of the abstract argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument abstractArgumentPosition(Position position) {
+        this.abstractArgumentPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the abstract subcommand position in the command.
+     *
+     * @param position the position of the abstract subcommand.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument abstractSubCommandPosition(Position position) {
+        this.abstractSubCommandPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the completion handler for this argument.
+     *
+     * @param handler the {@link CompletionHandler} for this argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument completionHandler(CompletionHandler handler) {
+        this.handler = handler;
+        return this;
+    }
+
+    /**
+     * Sets the subcommands for this argument.
+     *
+     * @param subCommands the list of {@link SubCommand} for this argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument subCommands(@NotNull List<SubCommand> subCommands) {
+        this.subCommands = subCommands;
+        return this;
+    }
+
+    /**
+     * Sets the abstract subcommands for this argument.
+     *
+     * @param abstractSubCommands the list of {@link AbstractSubCommand} for this argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument abstractSubCommands(@NotNull List<AbstractSubCommand> abstractSubCommands) {
+        this.abstractSubCommands = abstractSubCommands;
+        return this;
+    }
+
+    /**
+     * Sets the arguments for this argument.
+     *
+     * @param arguments the list of {@link CommandArgument} for this argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument arguments(@NotNull List<CommandArgument> arguments) {
+        this.arguments = arguments;
+        return this;
+    }
+
+    /**
+     * Sets the abstract arguments for this argument.
+     *
+     * @param abstractArguments the list of {@link AbstractCommandArgument} for this argument.
+     * @return the current {@link SimpleCommandArgument} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleCommandArgument abstractArguments(@NotNull List<AbstractCommandArgument> abstractArguments) {
+        this.abstractArguments = abstractArguments;
+        return this;
+    }
+
+    /**
+     * Builds and returns the {@link CommandArgument} based on the configuration.
+     *
+     * @return the constructed {@link CommandArgument}.
+     */
+    @ApiStatus.NonExtendable
+    public CommandArgument build() {
+        CommandArgument arg = CommandArgument.of(argument);
+
+        if (senderTypes != null) arg.senderTypes(ExecutableSender.types(senderTypes));
+        if (defaultExecutor != null) arg.defaultExecute(defaultExecutor);
+        if (playerExecutor != null) arg.playerExecute(playerExecutor);
+        if (consoleExecutor != null) arg.consoleExecute(consoleExecutor);
+        if (entityExecutor != null) arg.entityExecute(entityExecutor);
+        if (blockExecutor != null) arg.blockExecute(blockExecutor);
+        if (proxiedExecutor != null) arg.proxiedExecute(proxiedExecutor);
+
+        if (handler != null) arg.completion(handler);
+
+        if (permission != null) arg.permission(permission);
+
+        if (argumentPosition == Position.LAST) {
+            if (abstractSubCommandPosition == Position.LAST) {
+                if (subCommands != null) subCommands.forEach(arg::subCommand);
+                if (abstractSubCommands != null) abstractSubCommands.forEach(arg::subCommand);
+            } else {
+                if (abstractSubCommands != null) abstractSubCommands.forEach(arg::subCommand);
+                if (subCommands != null) subCommands.forEach(arg::subCommand);
+            }
+            if (abstractArgumentPosition == Position.LAST) {
+                if (arguments != null) arguments.forEach(arg::argument);
+                if (abstractArguments != null) abstractArguments.forEach(arg::argument);
+            } else {
+                if (abstractArguments != null) abstractArguments.forEach(arg::argument);
+                if (arguments != null) arguments.forEach(arg::argument);
+            }
+        } else {
+            if (abstractArgumentPosition == Position.LAST) {
+                if (arguments != null) arguments.forEach(arg::argument);
+                if (abstractArguments != null) abstractArguments.forEach(arg::argument);
+            } else {
+                if (abstractArguments != null) abstractArguments.forEach(arg::argument);
+                if (arguments != null) arguments.forEach(arg::argument);
+            }
+            if (abstractSubCommandPosition == Position.LAST) {
+                if (subCommands != null) subCommands.forEach(arg::subCommand);
+                if (abstractSubCommands != null) abstractSubCommands.forEach(arg::subCommand);
+            } else {
+                if (abstractSubCommands != null) abstractSubCommands.forEach(arg::subCommand);
+                if (subCommands != null) subCommands.forEach(arg::subCommand);
+            }
+        }
+
+        return arg;
+    }
+
+    /**
+     * Gets the argument.
+     *
+     * @return the argument.
+     */
+    @NotNull
+    @ApiStatus.NonExtendable
+    public Argument argument() {
+        return argument;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/arguments/ColorArgumentType.java b/src/main/java/dev/vansen/commandutils/argument/arguments/ColorArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e5314e72f4fa10eeee5dceaffe9409036f5384b
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/arguments/ColorArgumentType.java
@@ -0,0 +1,173 @@
+package dev.vansen.commandutils.argument.arguments;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import com.mojang.brigadier.suggestion.Suggestion;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import dev.vansen.commandutils.argument.arguments.color.ArgumentColors;
+import io.papermc.paper.command.brigadier.MessageComponentSerializer;
+import io.papermc.paper.command.brigadier.argument.CustomArgumentType;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * A custom argument type for parsing color values.
+ */
+@SuppressWarnings({"unused", "unchecked", "ConstantConditions"})
+public final class ColorArgumentType implements CustomArgumentType.Converted<TextColor, String> {
+    private final @NotNull String tooltip;
+    private final @Nullable TextColor color;
+    private boolean haveTooltip = true;
+
+    /**
+     * Creates a new ColorArgumentType with a custom tooltip and color.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @param color   The color of the tooltip.
+     */
+    public ColorArgumentType(@NotNull String tooltip, @Nullable TextColor color) {
+        this.tooltip = tooltip;
+        this.color = color;
+    }
+
+    /**
+     * Creates a new ColorArgumentType with a custom tooltip and a default color (166, 233, 255).
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     */
+    public ColorArgumentType(@NotNull String tooltip) {
+        this(tooltip, TextColor.color(166, 233, 255));
+    }
+
+    /**
+     * Creates a new ColorArgumentType with default tooltip ("Click to choose <color>") and color (166, 233, 255).
+     */
+    public ColorArgumentType() {
+        this("Click to choose <color>");
+    }
+
+    /**
+     * Returns a new ColorArgumentType with a default tooltip and color.
+     *
+     * @return A new ColorArgumentType instance.
+     */
+    public static @NotNull ColorArgumentType color() {
+        return new ColorArgumentType();
+    }
+
+    /**
+     * Returns a new ColorArgumentType with a custom tooltip.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @return A new ColorArgumentType instance.
+     */
+    public static @NotNull ColorArgumentType color(String tooltip) {
+        return new ColorArgumentType(tooltip);
+    }
+
+    /**
+     * Returns a new ColorArgumentType with a custom tooltip and color.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @param color   The color of the tooltip.
+     * @return A new ColorArgumentType instance.
+     */
+    public static @NotNull ColorArgumentType color(@NotNull String tooltip, @NotNull TextColor color) {
+        return new ColorArgumentType(tooltip, color);
+    }
+
+    /**
+     * Returns whether the player argument type has a tooltip.
+     *
+     * @return True if the player argument type has a tooltip, false otherwise.
+     */
+    public boolean hasTooltip() {
+        return haveTooltip;
+    }
+
+    /**
+     * Sets the suggestions to not have a tooltip.
+     *
+     * @return The current ColorArgumentType instance.
+     */
+    public ColorArgumentType withoutTooltip() {
+        haveTooltip = false;
+        return this;
+    }
+
+    /**
+     * Sets the suggestions to have a tooltip.
+     *
+     * @return The current ColorArgumentType instance.
+     */
+    public ColorArgumentType withTooltip() {
+        haveTooltip = true;
+        return this;
+    }
+
+    @Override
+    public @NotNull TextColor convert(@NotNull String nativeType) throws CommandSyntaxException {
+        try {
+            if (ArgumentColors.COLOR_MAP.containsKey(nativeType.toLowerCase())) {
+                return Objects.requireNonNull(TextColor.fromHexString(ArgumentColors.COLOR_MAP.get(nativeType)));
+            } else {
+                return Objects.requireNonNull(TextColor.fromHexString(nativeType));
+            }
+        } catch (@NotNull Exception e) {
+            throw new SimpleCommandExceptionType(MessageComponentSerializer.message().serialize(Component.text("Invalid color, Double quote the hex code or use a valid color name!"))).create();
+        }
+    }
+
+    @Override
+    public @NotNull ArgumentType<String> getNativeType() {
+        return StringArgumentType.string();
+    }
+
+    @Override
+    public <S> @NotNull CompletableFuture<Suggestions> listSuggestions(@NotNull CommandContext<S> context, @NotNull SuggestionsBuilder builder) {
+        try {
+            if (!haveTooltip) {
+                ArgumentColors.COLOR_MAP.keySet()
+                        .parallelStream()
+                        .filter(name -> name.startsWith(builder.getInput().substring(builder.getInput().lastIndexOf(" ") + 1)))
+                        .forEach(builder::suggest);
+                return builder.buildFuture();
+            }
+            ArgumentColors.COLOR_MAP.keySet()
+                    .parallelStream()
+                    .filter(name -> name.startsWith(builder.getInput().substring(builder.getInput().lastIndexOf(" ") + 1)))
+                    .forEach(name -> builder.suggest(name, MessageComponentSerializer.message()
+                            .serializeOrNull(MiniMessage.miniMessage().deserializeOrNull("<color:" + color.asHexString() + ">" + tooltip.replaceAll("<color>", name)))));
+            return builder.buildFuture();
+        } catch (@NotNull Exception e) {
+            try {
+                Field resultField = builder.getClass().getDeclaredField("result");
+                resultField.setAccessible(true);
+                List<Suggestion> result = (List<Suggestion>) resultField.get(builder);
+                result.clear();
+            } catch (Exception ex) {
+                ComponentLogger.logger("CommandUtils")
+                        .error("Failed to clear suggestions", e);
+                return Suggestions.empty();
+            }
+            ArgumentColors.COLOR_MAP.keySet()
+                    .parallelStream()
+                    .forEach(name -> builder.suggest(name, MessageComponentSerializer.message()
+                            .serializeOrNull(MiniMessage.miniMessage().deserializeOrNull("<color:" + color.asHexString() + ">" + tooltip.replaceAll("<color>", name)))));
+            return builder.buildFuture();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/arguments/CommandBlockModeArgumentType.java b/src/main/java/dev/vansen/commandutils/argument/arguments/CommandBlockModeArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b8c131fa81d645a3cb1a375a51dabd826b866aa
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/arguments/CommandBlockModeArgumentType.java
@@ -0,0 +1,182 @@
+package dev.vansen.commandutils.argument.arguments;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import io.papermc.paper.command.brigadier.MessageComponentSerializer;
+import io.papermc.paper.command.brigadier.argument.CustomArgumentType;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.stream.Stream;
+
+@SuppressWarnings({"unused"})
+public class CommandBlockModeArgumentType implements CustomArgumentType<String, String> {
+    private final @NotNull String tooltip;
+    private final @NotNull TextColor color;
+    private boolean haveTooltip = true;
+    private boolean ignoreCase = true;
+    private boolean giveAsLowerCase = true;
+
+    /**
+     * Creates a new CommandBlockModeArgumentType with a custom tooltip and color.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @param color   The color of the tooltip.
+     */
+    public CommandBlockModeArgumentType(@NotNull String tooltip, @NotNull TextColor color) {
+        this.tooltip = tooltip;
+        this.color = color;
+    }
+
+    /**
+     * Creates a new CommandBlockModeArgumentType with a custom tooltip and a default color (166, 233, 255).
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     */
+    public CommandBlockModeArgumentType(@NotNull String tooltip) {
+        this(tooltip, TextColor.color(166, 233, 255));
+    }
+
+    /**
+     * Creates a new CommandBlockModeArgumentType with default tooltip ("Click to choose <color>") and color (166, 233, 255).
+     */
+    public CommandBlockModeArgumentType() {
+        this("Click to choose <color>");
+    }
+
+    /**
+     * Returns a new CommandBlockModeArgumentType with a default tooltip and color.
+     *
+     * @return A new CommandBlockModeArgumentType instance.
+     */
+    public static @NotNull CommandBlockModeArgumentType mode() {
+        return new CommandBlockModeArgumentType();
+    }
+
+    /**
+     * Returns a new CommandBlockModeArgumentType with a custom tooltip.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @return A new CommandBlockModeArgumentType instance.
+     */
+    public static @NotNull CommandBlockModeArgumentType mode(String tooltip) {
+        return new CommandBlockModeArgumentType(tooltip);
+    }
+
+    /**
+     * Returns a new CommandBlockModeArgumentType with a custom tooltip and color.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @param color   The color of the tooltip.
+     * @return A new CommandBlockModeArgumentType instance.
+     */
+    public static @NotNull CommandBlockModeArgumentType mode(@NotNull String tooltip, @NotNull TextColor color) {
+        return new CommandBlockModeArgumentType(tooltip, color);
+    }
+
+    /**
+     * Returns whether the player argument type has a tooltip.
+     *
+     * @return True if the player argument type has a tooltip, false otherwise.
+     */
+    public boolean hasTooltip() {
+        return haveTooltip;
+    }
+
+    /**
+     * Sets the suggestions to not have a tooltip.
+     *
+     * @return The current CommandBlockModeArgumentType instance.
+     */
+    public CommandBlockModeArgumentType withoutTooltip() {
+        haveTooltip = false;
+        return this;
+    }
+
+    /**
+     * Sets the suggestions to have a tooltip.
+     *
+     * @return The current CommandBlockModeArgumentType instance.
+     */
+    public CommandBlockModeArgumentType withTooltip() {
+        haveTooltip = true;
+        return this;
+    }
+
+    /**
+     * Sets the parser to ignore case, i.e. only "chain" is accepted, doing "Chain" or anything won't work.
+     *
+     * @return The current CommandBlockModeArgumentType instance.
+     */
+    public CommandBlockModeArgumentType doNotIgnoreCase() {
+        ignoreCase = false;
+        return this;
+    }
+
+    /**
+     * Sets the parser to ignore case, i.e. "chain" and "Chain" are both valid.
+     *
+     * @return The current CommandBlockModeArgumentType instance.
+     */
+    public CommandBlockModeArgumentType ignoreCase() {
+        ignoreCase = true;
+        return this;
+    }
+
+    /**
+     * Sets the parser to give the input as normal, i.e. "Chain" is given as "Chain" instead of "chain".
+     *
+     * @return The current CommandBlockModeArgumentType instance.
+     */
+    public CommandBlockModeArgumentType asNormal() {
+        giveAsLowerCase = false;
+        return this;
+    }
+
+    /**
+     * Sets the parser to give the input as lowercase, i.e. "Chain" is given as "chain" instead of "Chain".
+     *
+     * @return The current CommandBlockModeArgumentType instance.
+     */
+    public CommandBlockModeArgumentType asLowercase() {
+        giveAsLowerCase = true;
+        return this;
+    }
+
+    @Override
+    public @NotNull String parse(StringReader reader) throws CommandSyntaxException {
+        String input = reader.readString();
+        if (ignoreCase) input = input.toLowerCase();
+        if (!input.equals("chain") && !input.equals("repeat") && !input.equals("impulse")) {
+            throw new SimpleCommandExceptionType(MessageComponentSerializer.message().serialize(Component.text("Invalid command block mode! Valid modes: chain, repeat, impulse"))).create();
+        }
+        if (giveAsLowerCase) input = input.toLowerCase();
+        return giveAsLowerCase ? input : reader.readString();
+    }
+
+    @Override
+    public @NotNull ArgumentType<String> getNativeType() {
+        return StringArgumentType.word();
+    }
+
+    @Override
+    public <S> @NotNull CompletableFuture<Suggestions> listSuggestions(final @NotNull CommandContext<S> context, final @NotNull SuggestionsBuilder builder) {
+        Stream.of("chain", "repeat", "impulse")
+                .filter(mode -> mode.startsWith(builder.getInput().substring(builder.getInput().lastIndexOf(" ") + 1)))
+                .forEach(mode -> {
+                    if (!haveTooltip) builder.suggest(mode);
+                    else
+                        builder.suggest(mode, MessageComponentSerializer.message().serialize(Component.text(tooltip.replaceAll("<mode>", mode))
+                                .color(color)));
+                });
+        return builder.buildFuture();
+    }
+}
diff --git a/src/main/java/dev/vansen/commandutils/argument/arguments/PlayerArgumentType.java b/src/main/java/dev/vansen/commandutils/argument/arguments/PlayerArgumentType.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2123e8185b73f7b2858e8277c7be4b43fdf5ac5
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/arguments/PlayerArgumentType.java
@@ -0,0 +1,183 @@
+package dev.vansen.commandutils.argument.arguments;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.StringArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import com.mojang.brigadier.suggestion.Suggestion;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import io.papermc.paper.command.brigadier.MessageComponentSerializer;
+import io.papermc.paper.command.brigadier.argument.CustomArgumentType;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * A custom argument type for parsing player names.
+ */
+@SuppressWarnings({"unused", "unchecked", "ConstantConditions"})
+public final class PlayerArgumentType implements CustomArgumentType.Converted<Player, String> {
+    private final @NotNull String tooltip;
+    private final @Nullable TextColor color;
+    private boolean haveTooltip = true;
+
+    /**
+     * Creates a new PlayerArgumentType with a custom tooltip and color.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @param color   The color of the tooltip.
+     */
+    public PlayerArgumentType(@NotNull String tooltip, @Nullable TextColor color) {
+        this.tooltip = tooltip;
+        this.color = color;
+    }
+
+    /**
+     * Creates a new PlayerArgumentType with a custom tooltip and a default color.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     */
+    public PlayerArgumentType(@NotNull String tooltip) {
+        this(tooltip, TextColor.color(166, 233, 255));
+    }
+
+    /**
+     * Creates a new PlayerArgumentType with default tooltip ("Click to choose <player>") and color (166, 233, 255).
+     */
+    public PlayerArgumentType() {
+        this("Click to choose <player>", TextColor.color(166, 233, 255));
+    }
+
+    /**
+     * Returns a new PlayerArgumentType with a default tooltip and color.
+     *
+     * @return A new PlayerArgumentType instance.
+     */
+    public static @NotNull PlayerArgumentType player() {
+        return new PlayerArgumentType();
+    }
+
+    /**
+     * Returns a new PlayerArgumentType with a custom tooltip.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @return A new PlayerArgumentType instance.
+     */
+    public static @NotNull PlayerArgumentType player(@NotNull String tooltip) {
+        return new PlayerArgumentType(tooltip);
+    }
+
+    /**
+     * Returns a new PlayerArgumentType with a custom tooltip and color.
+     *
+     * @param tooltip The tooltip to display when providing suggestions.
+     * @param color   The color of the tooltip.
+     * @return A new PlayerArgumentType instance.
+     */
+    public static @NotNull PlayerArgumentType player(@NotNull String tooltip, @NotNull TextColor color) {
+        return new PlayerArgumentType(tooltip, color);
+    }
+
+    /**
+     * Returns whether the player argument type has a tooltip.
+     *
+     * @return True if the player argument type has a tooltip, false otherwise.
+     */
+    public boolean hasTooltip() {
+        return haveTooltip;
+    }
+
+    /**
+     * Sets the suggestions to not have a tooltip.
+     *
+     * @return The current PlayerArgumentType instance.
+     */
+    public PlayerArgumentType withoutTooltip() {
+        haveTooltip = false;
+        return this;
+    }
+
+    /**
+     * Sets the suggestions to have a tooltip.
+     *
+     * @return The current PlayerArgumentType instance.
+     */
+    public PlayerArgumentType withTooltip() {
+        haveTooltip = true;
+        return this;
+    }
+
+    @Override
+    public @NotNull Player convert(@NotNull String nativeType) throws CommandSyntaxException {
+        if (nativeType.length() < 3) {
+            throw new SimpleCommandExceptionType(MessageComponentSerializer.message().serialize(Component
+                    .text("Too short player name! Enter a name within 3-16 characters"))).create();
+        }
+        if (nativeType.length() > 16) {
+            throw new SimpleCommandExceptionType(MessageComponentSerializer.message().serialize(Component
+                    .text("Too long player name! Enter a name within 3-16 characters"))).create();
+        }
+        if (Bukkit.getPlayerExact(nativeType) == null) {
+            throw new SimpleCommandExceptionType(MessageComponentSerializer.message().serialize(Component.text("Invalid player ")
+                    .append(Component.text(
+                            nativeType + "!"
+                    ))
+                    .color(TextColor.fromHexString("#ff576d")))).create();
+        }
+
+        return Objects.requireNonNull(Bukkit.getPlayerExact(nativeType));
+    }
+
+    @Override
+    public @NotNull ArgumentType<String> getNativeType() {
+        return StringArgumentType.string();
+    }
+
+    @Override
+    public <S> @NotNull CompletableFuture<Suggestions> listSuggestions(@NotNull CommandContext<S> context, @NotNull SuggestionsBuilder builder) {
+        try {
+            if (!haveTooltip) {
+                Bukkit.getOnlinePlayers()
+                        .parallelStream()
+                        .filter(player -> player.getName().startsWith(builder.getInput().substring(builder.getInput().lastIndexOf(" ") + 1)))
+                        .forEach(player -> builder.suggest(player.getName()));
+                return builder.buildFuture();
+            }
+            Bukkit.getOnlinePlayers()
+                    .parallelStream()
+                    .filter(player -> player.getName().startsWith(builder.getInput().substring(builder.getInput().lastIndexOf(" ") + 1)))
+                    .forEach(player -> builder.suggest(player.getName(), MessageComponentSerializer.message()
+                            .serialize(Component.text(tooltip.replaceAll("<player>", player.getName()))
+                                    .color(color))));
+            return builder.buildFuture();
+        } catch (@NotNull Exception e) {
+            try {
+                Field resultField = builder.getClass().getDeclaredField("result");
+                resultField.setAccessible(true);
+                List<Suggestion> result = (List<Suggestion>) resultField.get(builder);
+                result.clear();
+            } catch (Exception ex) {
+                ComponentLogger.logger("CommandUtils")
+                        .error("Failed to clear suggestions", e);
+                return Suggestions.empty();
+            }
+            Bukkit.getOnlinePlayers()
+                    .parallelStream()
+                    .forEach(player -> builder.suggest(player.getName(), MessageComponentSerializer.message()
+                            .serialize(Component.text(tooltip.replaceAll("<player>", player.getName()))
+                                    .color(color))));
+            return builder.buildFuture();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/arguments/color/ArgumentColors.java b/src/main/java/dev/vansen/commandutils/argument/arguments/color/ArgumentColors.java
new file mode 100644
index 0000000000000000000000000000000000000000..4d63997c8902a0e74667986435419c50bd54dc77
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/arguments/color/ArgumentColors.java
@@ -0,0 +1,284 @@
+package dev.vansen.commandutils.argument.arguments.color;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.stream.Collectors;
+
+@SuppressWarnings({"unused"})
+public class ArgumentColors {
+
+    /**
+     * A map of color names to their hex values, check {@link #defaultColors()} for default colors and {@link #addColor(String, String)} for adding custom colors
+     */
+    public static ConcurrentMap<String, String> COLOR_MAP = new ConcurrentHashMap<>(1024, 0.75f);
+
+    static {
+        defaultColors();
+    }
+
+    /**
+     * Adds default colors to the color map, this should be called before any other colors are added (which should be done by the static initializer)
+     */
+    public static void defaultColors() {
+        if (!COLOR_MAP.isEmpty()) return;
+        addColor(
+                Map.entry("black", "#000000"),
+                Map.entry("dark_blue", "#0000aa"),
+                Map.entry("dark_green", "#00aa00"),
+                Map.entry("dark_aqua", "#00aaaa"),
+                Map.entry("dark_red", "#aa0000"),
+                Map.entry("dark_purple", "#aa00aa"),
+                Map.entry("gold", "#ffaa00"),
+                Map.entry("gray", "#aaaaaa"),
+                Map.entry("dark_gray", "#555555"),
+                Map.entry("blue", "#5555ff"),
+                Map.entry("green", "#55ff55"),
+                Map.entry("aqua", "#55ffff"),
+                Map.entry("red", "#ff5555"),
+                Map.entry("light_purple", "#ff55ff"),
+                Map.entry("yellow", "#ffff55"),
+                Map.entry("white", "#ffffff"),
+                Map.entry("navy", "#001f3f"),
+                Map.entry("teal", "#39cccc"),
+                Map.entry("olive", "#3d9970"),
+                Map.entry("maroon", "#85144b"),
+                Map.entry("lime", "#01ff70"),
+                Map.entry("orange", "#ff851b"),
+                Map.entry("fuchsia", "#f012be"),
+                Map.entry("silver", "#dddddd"),
+                Map.entry("indigo", "#4b0082"),
+                Map.entry("pink", "#ffc0cb"),
+                Map.entry("cyan", "#00ffff"),
+                Map.entry("beige", "#f5f5dc"),
+                Map.entry("peach", "#ffdab9"),
+                Map.entry("lavender", "#e6e6fa"),
+                Map.entry("mint", "#98ff98"),
+                Map.entry("coral", "#ff7f50"),
+                Map.entry("amber", "#ffbf00"),
+                Map.entry("charcoal", "#36454f"),
+                Map.entry("chocolate", "#d2691e"),
+                Map.entry("crimson", "#dc143c"),
+                Map.entry("khaki", "#f0e68c"),
+                Map.entry("magenta", "#ff00ff"),
+                Map.entry("plum", "#dda0dd"),
+                Map.entry("scarlet", "#ff2400"),
+                Map.entry("turquoise", "#40e0d0"),
+                Map.entry("emerald", "#50c878"),
+                Map.entry("ruby", "#e0115f"),
+                Map.entry("jade", "#00a86b"),
+                Map.entry("sapphire", "#0f52ba"),
+                Map.entry("bronze", "#cd7f32"),
+                Map.entry("goldenrod", "#daa520"),
+                Map.entry("steel_blue", "#4682b4"),
+                Map.entry("salmon", "#fa8072"),
+                Map.entry("ivory", "#fffff0"),
+                Map.entry("honeydew", "#f0fff0"),
+                Map.entry("periwinkle", "#ccccff"),
+                Map.entry("azure", "#f0ffff"),
+                Map.entry("powder_blue", "#b0e0e6"),
+                Map.entry("rosy_brown", "#bc8f8f"),
+                Map.entry("pale_green", "#98fb98"),
+                Map.entry("orchid", "#da70d6"),
+                Map.entry("midnight_blue", "#191970"),
+                Map.entry("slate_gray", "#708090"),
+                Map.entry("sea_green", "#2e8b57"),
+                Map.entry("forest_green", "#228b22"),
+                Map.entry("dim_gray", "#696969"),
+                Map.entry("cadet_blue", "#5f9ea0"),
+                Map.entry("firebrick", "#b22222"),
+                Map.entry("golden_yellow", "#ffdf00"),
+                Map.entry("steel", "#b0c4de"),
+                Map.entry("violet", "#ee82ee"),
+                Map.entry("eggshell", "#f0ead6"),
+                Map.entry("apricot", "#fbceb1"),
+                Map.entry("mustard", "#ffdb58"),
+                Map.entry("blush", "#de5d83"),
+                Map.entry("sepia", "#704214"),
+                Map.entry("cerulean", "#007ba7"),
+                Map.entry("vermilion", "#e34234"),
+                Map.entry("chartreuse", "#7fff00"),
+                Map.entry("prussian_blue", "#003153"),
+                Map.entry("spring_green", "#00ff7f"),
+                Map.entry("golden_rod", "#daa520"),
+                Map.entry("burnt_orange", "#cc5500"),
+                Map.entry("eggplant", "#614051"),
+                Map.entry("ultramarine", "#3f00ff"),
+                Map.entry("carmine", "#960018"),
+                Map.entry("heliotrope", "#df73ff"),
+                Map.entry("persian_blue", "#1c39bb"),
+                Map.entry("tangerine", "#f28500"),
+                Map.entry("celadon", "#ace1af"),
+                Map.entry("mauve", "#e0b0ff"),
+                Map.entry("cerise", "#de3163"),
+                Map.entry("cobalt", "#0047ab"),
+                Map.entry("pearl", "#eae0c8"),
+                Map.entry("amethyst", "#9966cc"),
+                Map.entry("antique_white", "#faebd7"),
+                Map.entry("bistre", "#3d2b1f"),
+                Map.entry("cerulean_blue", "#2a52be"),
+                Map.entry("cinnamon", "#d2691e"),
+                Map.entry("copper", "#b87333"),
+                Map.entry("cornflower_blue", "#6495ed"),
+                Map.entry("denim", "#1560bd"),
+                Map.entry("electric_lime", "#ccff00"),
+                Map.entry("feldspar", "#d19275"),
+                Map.entry("gunmetal", "#2a3439"),
+                Map.entry("indigo_dye", "#00416a"),
+                Map.entry("iris", "#5a4fcf"),
+                Map.entry("lapis_lazuli", "#26619c"),
+                Map.entry("mahogany", "#c04000"),
+                Map.entry("mint_green", "#98ff98"),
+                Map.entry("neon_carrot", "#ffa343"),
+                Map.entry("ocean_blue", "#4f42b5"),
+                Map.entry("onyx", "#353839"),
+                Map.entry("parchment", "#f1e9d2"),
+                Map.entry("pastel_pink", "#dea5a4"),
+                Map.entry("peacock", "#33a1c9"),
+                Map.entry("persian_red", "#cc3333"),
+                Map.entry("pine_green", "#01796f"),
+                Map.entry("razzmatazz", "#e3256b"),
+                Map.entry("saffron", "#f4c430"),
+                Map.entry("sandy_brown", "#f4a460"),
+                Map.entry("sepia_tone", "#704214"),
+                Map.entry("smoky_black", "#100c08"),
+                Map.entry("taupe", "#483c32"),
+                Map.entry("teal_green", "#006d5b"),
+                Map.entry("ultramarine_blue", "#4166f5"),
+                Map.entry("verdigris", "#43b3ae"),
+                Map.entry("veronica", "#a020f0"),
+                Map.entry("viridian", "#40826d"),
+                Map.entry("wild_blue_yonder", "#a2add0"),
+                Map.entry("zinnwaldite", "#ebc2af"),
+                Map.entry("wheat", "#f5deb3"),
+                Map.entry("lemon_chiffon", "#fffacd"),
+                Map.entry("moonstone", "#3aa8c1"),
+                Map.entry("acid_green", "#b0bf1a"),
+                Map.entry("aero_blue", "#c0e8d5"),
+                Map.entry("alabaster", "#f2f0e6"),
+                Map.entry("alice_blue", "#f0f8ff"),
+                Map.entry("alloy_orange", "#c46210"),
+                Map.entry("almond", "#efdecd"),
+                Map.entry("asparagus", "#87a96b"),
+                Map.entry("atomic_tangerine", "#ff9966"),
+                Map.entry("azureish_white", "#dbe9f4"),
+                Map.entry("banana_yellow", "#ffe135"),
+                Map.entry("bittersweet", "#fe6f5e"),
+                Map.entry("black_coral", "#54626f"),
+                Map.entry("blue_bell", "#a2a2d0"),
+                Map.entry("blue_gray", "#6699cc"),
+                Map.entry("blue_sapphire", "#126180"),
+                Map.entry("bright_ube", "#d19fe8"),
+                Map.entry("bubble_gum", "#ffc1cc"),
+                Map.entry("burnt_sienna", "#e97451"),
+                Map.entry("byzantine", "#bd33a4"),
+                Map.entry("candy_pink", "#e4717a"),
+                Map.entry("cardinal_red", "#c41e3a"),
+                Map.entry("carmine_pink", "#eb4c42"),
+                Map.entry("carrot_orange", "#ed9121"),
+                Map.entry("celestial_blue", "#4997d0"),
+                Map.entry("champagne", "#f7e7ce"),
+                Map.entry("cherry_blossom", "#ffb7c5"),
+                Map.entry("chili_red", "#e23d28"),
+                Map.entry("china_rose", "#a8516e"),
+                Map.entry("citrine", "#e4d00a"),
+                Map.entry("clover_green", "#009b77"),
+                Map.entry("cool_gray", "#8c92ac"),
+                Map.entry("cotton_candy", "#ffbcd9"),
+                Map.entry("crayola_yellow", "#fce883"),
+                Map.entry("cyber_grape", "#58427c"),
+                Map.entry("cyber_yellow", "#ffd300"),
+                Map.entry("dark_byzantium", "#5d3954"),
+                Map.entry("dark_olive", "#556b2f"),
+                Map.entry("deep_pink", "#ff1493"),
+                Map.entry("ecru", "#c2b280"),
+                Map.entry("electric_blue", "#7df9ff"),
+                Map.entry("fawn", "#e5aa70"),
+                Map.entry("fern_green", "#4f7942"),
+                Map.entry("frostbite", "#e936a7"),
+                Map.entry("gamboge", "#e49b0f"),
+                Map.entry("ghost_white", "#f8f8ff"),
+                Map.entry("glaucous", "#6082b6"),
+                Map.entry("golden_poppy", "#fcc200"),
+                Map.entry("granite_gray", "#676767"),
+                Map.entry("honey_gold", "#d4af37"),
+                Map.entry("hunter_green", "#355e3b"),
+                Map.entry("iceberg", "#71a6d2"),
+                Map.entry("isabelline", "#f4f0ec"),
+                Map.entry("jasmine", "#f8de7e"),
+                Map.entry("jelly_bean", "#da614e"),
+                Map.entry("jungle_green", "#29ab87"),
+                Map.entry("kelly_green", "#4cbb17"),
+                Map.entry("lavender_gray", "#c4c3d0"),
+                Map.entry("lemon_curry", "#cca01d"),
+                Map.entry("lilac_luster", "#ae98aa"),
+                Map.entry("linen", "#faf0e6"),
+                Map.entry("lust", "#e62020"),
+                Map.entry("manatee", "#979aaa"),
+                Map.entry("mango_tango", "#ff8243"),
+                Map.entry("midnight_green", "#004953"),
+                Map.entry("mountbatten_pink", "#997a8d"),
+                Map.entry("munsell_red", "#f2003c"),
+                Map.entry("nadeshiko_pink", "#f6adc6"),
+                Map.entry("naples_yellow", "#fada5e"),
+                Map.entry("neon_blue", "#4666ff"),
+                Map.entry("olive_drab", "#6b8e23"),
+                Map.entry("onyx_black", "#353839"),
+                Map.entry("ou_crimson", "#990000"),
+                Map.entry("peach_puff", "#ffdab9"),
+                Map.entry("pewter_blue", "#8ba8b7"),
+                Map.entry("quartz", "#51484f"),
+                Map.entry("redwood", "#a45a52"));
+    }
+
+    /**
+     * Adds a color to the color map.
+     *
+     * @param name the name of the color
+     * @param hex  the hex code of the color
+     */
+    public static void addColor(String name, String hex) {
+        COLOR_MAP.put(name, hex);
+    }
+
+    /**
+     * Adds multiple colors to the color map from one or more maps.
+     *
+     * @param maps one or more maps containing color names and hex codes
+     */
+    @SafeVarargs
+    public static void addColor(@NotNull Map<String, String>... maps) {
+        Arrays.stream(maps).forEach(map -> COLOR_MAP.putAll(map));
+    }
+
+    /**
+     * Adds multiple colors to the color map from one or more entries.
+     *
+     * @param entries one or more entries containing color names and hex codes
+     */
+    @SafeVarargs
+    public static void addColor(@NotNull Map.Entry<String, String>... entries) {
+        addColor(Arrays.stream(entries)
+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));
+    }
+
+    /**
+     * Removes one or more colors from the color map.
+     *
+     * @param names the names of the colors to remove
+     */
+    public static void removeClear(@NotNull String... names) {
+        Arrays.stream(names)
+                .forEach(COLOR_MAP::remove);
+    }
+
+    /**
+     * Clears all colors from the color map.
+     */
+    public static void clearColors() {
+        COLOR_MAP.clear();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/arguments/custom/CustomArgument.java b/src/main/java/dev/vansen/commandutils/argument/arguments/custom/CustomArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f45e6abb2fcddbf2554ee573d56d9e50d4fd000
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/arguments/custom/CustomArgument.java
@@ -0,0 +1,67 @@
+package dev.vansen.commandutils.argument.arguments.custom;
+
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import dev.vansen.commandutils.completer.SuggestionsBuilderWrapper;
+import dev.vansen.commandutils.exceptions.CmdSyntaxException;
+import io.papermc.paper.command.brigadier.argument.CustomArgumentType;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Class representing a argument, which is a custom argument type.
+ * This may be used to easily parse the value, or convert the native value to the target type.
+ *
+ * @param <T> the target type,
+ * @param <N>
+ */
+@SuppressWarnings({"unused"})
+public abstract class CustomArgument<T, N> implements CustomArgumentType.Converted<T, N> {
+    private final ArgumentType<N> nativeType;
+
+    /**
+     * Creates a new custom argument with the specified native type.
+     *
+     * @param nativeType the native type of the argument
+     */
+    public CustomArgument(@NotNull ArgumentType<N> nativeType) {
+        this.nativeType = nativeType;
+    }
+
+    @Override
+    public @NotNull ArgumentType<N> getNativeType() {
+        return nativeType;
+    }
+
+    @Override
+    public @NotNull T convert(@NotNull N nativeValue) throws CommandSyntaxException {
+        return parseOrConvert(nativeValue);
+    }
+
+    /**
+     * Parses or converts the native value to the target type.
+     * This may be used to validate the native value, or to convert it to the target type.
+     *
+     * @param nativeValue the native value to parse or convert
+     * @return the parsed or converted value
+     * @throws CmdSyntaxException if the native value is invalid to parse or convert
+     */
+    public abstract @NotNull T parseOrConvert(@NotNull N nativeValue) throws CommandSyntaxException;
+
+    @Override
+    public <S> @NotNull CompletableFuture<Suggestions> listSuggestions(@NotNull CommandContext<S> context, @NotNull SuggestionsBuilder builder) {
+        return suggest(new SuggestionsBuilderWrapper(builder));
+    }
+
+    /**
+     * Suggests possible values for the custom argument.
+     *
+     * @param wrapper the suggestions builder wrapper
+     * @return a {@link CompletableFuture} that will be completed with the {@link Suggestions} for tab completion.
+     */
+    public abstract @NotNull CompletableFuture<Suggestions> suggest(@NotNull SuggestionsBuilderWrapper wrapper);
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/finder/ArgumentFinder.java b/src/main/java/dev/vansen/commandutils/argument/finder/ArgumentFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0aa07ea79e45abfdbb117df40db8f4d2d9e661f
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/finder/ArgumentFinder.java
@@ -0,0 +1,220 @@
+package dev.vansen.commandutils.argument.finder;
+
+import dev.vansen.commandutils.command.CommandWrapper;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectList;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * A utility class for finding the value of a specific argument in a command context.
+ * <p>
+ * Note, this checks for specific types of arguments, it is generally recommended to use {@link CommandWrapper#arg(String, Class)} if you want basically any type of argument.
+ */
+@SuppressWarnings({"unused", "unchecked"})
+public class ArgumentFinder<T> {
+    private static final ObjectArrayList<Class<?>> arguments = ObjectArrayList.of();
+    private final @NotNull AtomicReference<T> value = new AtomicReference<>();
+    private final @NotNull CommandWrapper context;
+    private final @NotNull String arg;
+
+    /**
+     * Creates a new instance of the ArgumentFinder class.
+     *
+     * @param context the command context
+     * @param arg     the argument to find and parse
+     */
+    public ArgumentFinder(@NotNull CommandWrapper context, @NotNull String arg) {
+        this.context = context;
+        this.arg = arg;
+    }
+
+    /**
+     * Creates a new instance of the ArgumentFinder class.
+     *
+     * @param <T>     the type of the argument value
+     * @param context the command context
+     * @param arg     the argument to find and parse
+     * @return a new instance of the ArgumentFinder class
+     */
+    public static <T> ArgumentFinder<T> of(@NotNull CommandWrapper context, @NotNull String arg) {
+        return new ArgumentFinder<>(context, arg);
+    }
+
+    /**
+     * Adds a new class type to the list of available arguments.
+     *
+     * @param types the class types to add
+     */
+    public static void addArgument(@NotNull Class<?>... types) {
+        arguments.addAll(ObjectList.of(types));
+    }
+
+    /**
+     * Tries to parse the argument as a string.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryString() {
+        try {
+            value.set((T) context.argString(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as an integer.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryInt() {
+        try {
+            value.set((T) (Integer) context.argInt(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a floating-point number.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryFloat() {
+        try {
+            value.set((T) (Float) context.argFloat(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a double-precision floating-point number.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryDouble() {
+        try {
+            value.set((T) (Double) context.argDouble(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a boolean value.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryBoolean() {
+        try {
+            value.set((T) (Boolean) context.argBoolean(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a long integer.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryLong() {
+        try {
+            value.set((T) (Long) context.argLong(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a game mode.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryGameMode() {
+        try {
+            value.set((T) context.argGameMode(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as an item stack.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryItemStack() {
+        try {
+            value.set((T) context.argItemStack(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a player.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryPlayer() {
+        try {
+            value.set((T) context.argPlayer(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a color.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryColor() {
+        try {
+            value.set((T) context.argColor(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument as a world.
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryWorld() {
+        try {
+            value.set((T) context.argWorld(arg));
+        } catch (Exception ignored) {
+        }
+        return this;
+    }
+
+    /**
+     * Tries to parse the argument in all of the {@link #arguments}
+     *
+     * @return this ArgumentFinder instance
+     */
+    public ArgumentFinder<T> tryCustoms() {
+        arguments.forEach(clazz -> {
+            try {
+                value.set((T) context.arg(arg, clazz));
+            } catch (Exception ignored) {
+            }
+        });
+        return this;
+    }
+
+    /**
+     * Returns the parsed value of the argument, if it was successfully parsed.
+     *
+     * @return the parsed value of the argument, or null if no value was parsed
+     */
+    public T get() {
+        return value.get();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/argument/finder/ArgumentString.java b/src/main/java/dev/vansen/commandutils/argument/finder/ArgumentString.java
new file mode 100644
index 0000000000000000000000000000000000000000..38e4ada48df8057a635c892ce43951118df94144
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/argument/finder/ArgumentString.java
@@ -0,0 +1,87 @@
+package dev.vansen.commandutils.argument.finder;
+
+import com.mojang.brigadier.arguments.*;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.argument.arguments.ColorArgumentType;
+import dev.vansen.commandutils.argument.arguments.CommandBlockModeArgumentType;
+import dev.vansen.commandutils.argument.arguments.PlayerArgumentType;
+import dev.vansen.commandutils.exceptions.UnknownArgumentException;
+import io.papermc.paper.command.brigadier.argument.ArgumentTypes;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * A utility class for finding arguments from strings ({@link #fromString(String)})
+ * <p>
+ * Note, this checks for specific types of arguments, it is generally recommended to use {@link CommandArgument#of(String, ArgumentType)} if you want to use other types of arguments.
+ */
+public class ArgumentString {
+
+    /**
+     * A list of all argument types that can be parsed.
+     * <p>
+     * Supports: string, greedy, word, int, float, double, boolean, long, player, entity, blockpos, blockstate, color, commandblockmode, players, entities, namedcolor, world, gamemode, itemstack, uuid
+     */
+    @NotNull
+    public static List<String> types = ObjectArrayList.of(
+            "string",
+            "greedy",
+            "word",
+            "int",
+            "float",
+            "double",
+            "boolean",
+            "long",
+            "player",
+            "entity",
+            "blockpos",
+            "blockstate",
+            "color",
+            "commandblockmode",
+            "players",
+            "entities",
+            "namedcolor",
+            "world",
+            "gamemode",
+            "itemstack",
+            "uuid"
+    );
+
+    /**
+     * Gets an argument type from a string.
+     * View more details at {@link #types}
+     *
+     * @param string the string to get the argument type from
+     * @return the argument type
+     * @throws UnknownArgumentException if the string is not a valid argument type
+     */
+    @NotNull
+    public static ArgumentType<?> fromString(@NotNull String string) {
+        return switch (string.toLowerCase()) {
+            case "string" -> StringArgumentType.string();
+            case "greedy" -> StringArgumentType.greedyString();
+            case "word" -> StringArgumentType.word();
+            case "int" -> IntegerArgumentType.integer();
+            case "float" -> FloatArgumentType.floatArg();
+            case "double" -> DoubleArgumentType.doubleArg();
+            case "boolean" -> BoolArgumentType.bool();
+            case "long" -> LongArgumentType.longArg();
+            case "player" -> PlayerArgumentType.player();
+            case "entity" -> ArgumentTypes.entity();
+            case "blockpos" -> ArgumentTypes.blockPosition();
+            case "blockstate" -> ArgumentTypes.blockState();
+            case "color" -> ColorArgumentType.color();
+            case "commandblockmode" -> CommandBlockModeArgumentType.mode();
+            case "players" -> ArgumentTypes.players();
+            case "entities" -> ArgumentTypes.entities();
+            case "namedcolor" -> ArgumentTypes.namedColor();
+            case "world" -> ArgumentTypes.world();
+            case "gamemode" -> ArgumentTypes.gameMode();
+            case "itemstack" -> ArgumentTypes.itemStack();
+            case "uuid" -> ArgumentTypes.uuid();
+            default -> throw new UnknownArgumentException(string, types);
+        };
+    }
+}
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/BukkitInfo.java b/src/main/java/dev/vansen/commandutils/bukkit/BukkitInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee4b92702fa774f6e2eaa4d0b706d1bb7936a610
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/BukkitInfo.java
@@ -0,0 +1,212 @@
+package dev.vansen.commandutils.bukkit;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * Represents information about a Bukkit command.
+ */
+@SuppressWarnings("unused")
+public class BukkitInfo {
+    private String name;
+    private @Nullable String description;
+    private @Nullable String permission;
+    private @Nullable String[] aliases;
+    private @NotNull String args = "";
+
+    /**
+     * Creates a new instance of BukkitInfo.
+     *
+     * @return a new instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public static BukkitInfo info() {
+        return new BukkitInfo();
+    }
+
+    /**
+     * Creates a new instance of BukkitInfo with the specified name.
+     *
+     * @param name the name of the command
+     * @return a new instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public static BukkitInfo info(@NotNull String name) {
+        return new BukkitInfo().name(name);
+    }
+
+    /**
+     * Sets the name of the command.
+     *
+     * @param name the name of the command
+     * @return this instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public BukkitInfo name(@NotNull String name) {
+        this.name = name;
+        return this;
+    }
+
+    /**
+     * Sets the description of the command.
+     *
+     * @param description the description of the command
+     * @return this instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public BukkitInfo description(@NotNull String description) {
+        this.description = description;
+        return this;
+    }
+
+    /**
+     * Sets the permission required to execute the command.
+     *
+     * @param permission the permission required to execute the command
+     * @return this instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public BukkitInfo permission(@NotNull String permission) {
+        this.permission = permission;
+        return this;
+    }
+
+    /**
+     * Sets the aliases for the command.
+     *
+     * @param aliases the aliases for the command
+     * @return this instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public BukkitInfo aliases(@NotNull String... aliases) {
+        this.aliases = aliases;
+        return this;
+    }
+
+    /**
+     * Sets the aliases for the command.
+     *
+     * @param aliases the aliases for the command
+     * @return this instance of BukkitInfo
+     */
+
+    @NotNull
+    @CanIgnoreReturnValue
+    public BukkitInfo aliases(@NotNull List<String> aliases) {
+        this.aliases = aliases.toArray(new String[0]);
+        return this;
+    }
+
+    /**
+     * Sets the arguments for the command.
+     * <p>
+     * The format of the arguments is a string that describes the required and optional arguments of the command.
+     * The format is as follows:
+     * <p>
+     * "&lt;required_arg_name&gt; [optional_arg_name]"
+     * <p>
+     * Where:
+     * <ul>
+     *     <li><code>required_arg_name</code> is the name of a required argument. This argument must be provided when the
+     *     command is executed.</li>
+     *     <li><code>optional_arg_name</code> is the name of an optional argument. This argument may be provided when the
+     *     command is executed, but it is not required.</li>
+     * </ul>
+     * <p>
+     * For example, if a command has two arguments, one required and one optional, the args string would be:
+     * <p>
+     * "&lt;required_arg_name&gt; [optional_arg_name]"
+     * <p>
+     * If a command has multiple required arguments, they should be separated by spaces:
+     * <p>
+     * "&lt;required_arg_name1&gt; &lt;required_arg_name2&gt; [optional_arg_name]"
+     * <p>
+     * If the command has no arguments, you can choose to not provide an args string.
+     * <p>
+     * This args string will be used further for argument parsing and validation. It is used to determine the expected
+     * arguments of the command and to validate the actual arguments provided when the command is executed.
+     * <p>
+     * Also, you can use any argument name you want, just make sure not to conflict with other argument names.
+     *
+     * @param args the arguments for the command
+     * @return this instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public BukkitInfo args(@NotNull String args) {
+        this.args = args;
+        return this;
+    }
+
+    /**
+     * Sets the arguments for the command using a BukkitParams instance.
+     *
+     * @param args the BukkitParams instance containing the arguments for the command
+     * @return this instance of BukkitInfo
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public BukkitInfo args(@NotNull BukkitParams args) {
+        this.args = args.args();
+        return this;
+    }
+
+    /**
+     * Gets the name of the command.
+     *
+     * @return the name of the command
+     */
+    @NotNull
+    public String name() {
+        return name;
+    }
+
+    /**
+     * Gets the description of the command.
+     *
+     * @return the description of the command
+     */
+    @Nullable
+    public String description() {
+        return description;
+    }
+
+    /**
+     * Gets the permission required to execute the command.
+     *
+     * @return the permission required to execute the command
+     */
+    @Nullable
+    public String permission() {
+        return permission;
+    }
+
+    /**
+     * Gets the aliases for the command.
+     *
+     * @return the aliases for the command
+     */
+    @Nullable
+    public String[] aliases() {
+        return aliases;
+    }
+
+    /**
+     * Gets the arguments for the command.
+     *
+     * @return the arguments for the command
+     */
+    @NotNull
+    public String args() {
+        return args;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/BukkitParams.java b/src/main/java/dev/vansen/commandutils/bukkit/BukkitParams.java
new file mode 100644
index 0000000000000000000000000000000000000000..5bf415326d3ed533c444f5053e01d09539b9a016
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/BukkitParams.java
@@ -0,0 +1,156 @@
+package dev.vansen.commandutils.bukkit;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class for building parameter strings for Bukkit commands.
+ */
+@SuppressWarnings({"unused", "UnusedReturnValue"})
+public class BukkitParams {
+    private final StringBuilder args = new StringBuilder();
+
+    /**
+     * Creates a new instance of BukkitParams.
+     *
+     * @return a new instance of BukkitParams
+     */
+    public static BukkitParams of() {
+        return new BukkitParams();
+    }
+
+    /**
+     * Creates a new instance of BukkitParams with the specified arguments.
+     * Please do not have a space at the end of the arguments.
+     *
+     * @param args the arguments to append
+     * @return a new instance of BukkitParams
+     * @see #ofWithSpace(String)
+     */
+    public static BukkitParams of(@NotNull String args) {
+        BukkitParams params = new BukkitParams();
+        params.args.append(args).append(" ");
+        return params;
+    }
+
+    /**
+     * Creates a new instance of BukkitParams with the specified arguments.
+     * Please do have a space at the end of the arguments.
+     *
+     * @param args the arguments to append
+     * @return a new instance of BukkitParams
+     * @see #of(String)
+     */
+    public static BukkitParams ofWithSpace(@NotNull String args) {
+        BukkitParams params = new BukkitParams();
+        params.args.append(args);
+        return params;
+    }
+
+    /**
+     * Creates a new instance of BukkitParams with the specified arguments.
+     *
+     * @param args the arguments to append
+     * @return a new instance of BukkitParams
+     */
+    public static BukkitParams of(@NotNull String... args) {
+        return new BukkitParams().params(args);
+    }
+
+    /**
+     * Creates a new instance of BukkitParams with the specified arguments.
+     *
+     * @param required whether the arguments are required
+     * @param args     the arguments to append
+     * @return a new instance of BukkitParams
+     */
+    public static BukkitParams of(boolean required, @NotNull String... args) {
+        return new BukkitParams().params(required, args);
+    }
+
+    /**
+     * Appends a required parameter to the parameter string.
+     *
+     * @param param the name of the required parameter
+     * @return this instance for chaining
+     */
+    public BukkitParams required(@NotNull String param) {
+        args.append("<").append(param).append(">").append(" ");
+        return this;
+    }
+
+    /**
+     * Appends an optional parameter to the parameter string.
+     *
+     * @param param the name of the optional parameter
+     * @return this instance for chaining
+     */
+    public BukkitParams optional(@NotNull String param) {
+        args.append("[").append(param).append("]").append(" ");
+        return this;
+    }
+
+    /**
+     * Appends a parameter to the parameter string with the specified requirement.
+     *
+     * @param param    the name of the parameter
+     * @param required whether the parameter is required
+     * @return this instance for chaining
+     */
+    public BukkitParams param(@NotNull String param, boolean required) {
+        if (required) required(param);
+        else optional(param);
+        return this;
+    }
+
+    /**
+     * Appends a required parameter to the parameter string.
+     *
+     * @param param the name of the required parameter
+     * @return this instance for chaining
+     */
+    public BukkitParams param(@NotNull String param) {
+        return required(param);
+    }
+
+    /**
+     * Appends multiple parameters to the parameter string.
+     *
+     * @param params the names of the parameters
+     * @return this instance for chaining
+     */
+    public BukkitParams params(@NotNull String... params) {
+        for (String param : params) {
+            required(param);
+        }
+        return this;
+    }
+
+    /**
+     * Appends multiple parameters to the parameter string.
+     *
+     * @param required whether the parameters are required
+     * @param params   the names of the parameters
+     * @return this instance for chaining
+     */
+    public BukkitParams params(boolean required, @NotNull String... params) {
+        if (required) {
+            for (String param : params) {
+                required(param);
+            }
+        } else {
+            for (String param : params) {
+                optional(param);
+            }
+        }
+        return this;
+    }
+
+    /**
+     * Returns the built parameter string.
+     *
+     * @return the parameter string
+     */
+    public String args() {
+        return args.toString();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/CommandManager.java b/src/main/java/dev/vansen/commandutils/bukkit/CommandManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc7e2586bd1d197a291d6de97ee0ce3adf61a165
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/CommandManager.java
@@ -0,0 +1,111 @@
+package dev.vansen.commandutils.bukkit;
+
+import dev.vansen.commandutils.CommandUtils;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.bukkit.argument.ArgumentParser;
+import dev.vansen.commandutils.bukkit.argument.BukkitArgument;
+import dev.vansen.commandutils.bukkit.command.BukkitCommands;
+import dev.vansen.commandutils.bukkit.tabcompletion.AsyncTabCompleter;
+import dev.vansen.commandutils.bukkit.tabcompletion.TabCompleter;
+import dev.vansen.commandutils.info.CommandInfo;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * A utility class for registering Bukkit commands.
+ *
+ * @author [Your Name]
+ * @since [Version]
+ */
+@SuppressWarnings("unused")
+public class CommandManager {
+
+    /**
+     * Registers a Bukkit command with the specified info.
+     *
+     * @param command the command to register
+     * @param info    the command info
+     */
+    public static void register(@NotNull BukkitCommands command, @NotNull BukkitInfo info) {
+        CommandUtils registrar = CommandUtils.command(info.name())
+                .info(CommandInfo.info()
+                        .description(info.description())
+                        .aliases(info.aliases())
+                        .permission(info.permission()));
+        if (info.args().isEmpty() || new ArgumentParser(info.args()).length() == 0) {
+            registrar.defaultExecute(context -> command.execute(new BukkitArgument(context, info.args())));
+            if (new ArgumentParser(info.args()).hasArgs()) {
+                CommandArgument argument = CommandArgument.greedy("args");
+                registrar.argument(argument.defaultExecute(context -> command.execute(new BukkitArgument(context, info.args()))));
+                complete(argument, command, info);
+            }
+        } else {
+            CommandArgument argument = CommandArgument.greedy("args");
+            registrar.defaultExecute(context -> {
+                if (context.inputWithoutCommand().isEmpty() || new ArgumentParser(info.args())
+                        .length() > context.inputWithoutCommand().trim().split(" ").length) {
+                    context.response("<red>Not enough arguments! Usage: /" + info.name() + " " + info.args());
+                }
+            });
+            registrar.argument(CommandArgument.greedy("args")
+                    .defaultExecute(context -> {
+                        if (context.inputWithoutCommand().isEmpty() || new ArgumentParser(info.args())
+                                .length() > context.inputWithoutCommand().split(" ").length) {
+                            context.response("<red>Not enough arguments! Usage: /" + info.name() + " " + info.args());
+                            return;
+                        }
+                        command.execute(new BukkitArgument(context, info.args()));
+                    }));
+            complete(argument, command, info);
+        }
+        registrar.register();
+    }
+
+    /**
+     * Registers a Bukkit command with the specified name.
+     *
+     * @param command the command to register
+     * @param name    the command name
+     */
+    public static void register(@NotNull BukkitCommands command, @NotNull String name) {
+        register(command, BukkitInfo.info()
+                .name(name));
+    }
+
+    /**
+     * Registers a Bukkit command with the specified name and args.
+     *
+     * @param command the command to register
+     * @param name    the command name
+     * @param args    the command args
+     */
+    public static void register(@NotNull BukkitCommands command, @NotNull String name, @NotNull String args) {
+        register(command, BukkitInfo.info()
+                .name(name)
+                .args(args));
+    }
+
+    private static void complete(@NotNull CommandArgument argument, @NotNull BukkitCommands command, @NotNull BukkitInfo info) {
+        argument.completion((context, wrapper) -> {
+            if (command instanceof TabCompleter completer) {
+                List<String> suggestions = completer.tabComplete(new BukkitArgument(context, info.args()), wrapper);
+                if (suggestions == null) return wrapper.build();
+                suggestions.stream()
+                        .filter(string -> string.toLowerCase().startsWith(wrapper.helper().currentArg().toLowerCase()))
+                        .forEach(wrapper::suggest);
+                return wrapper.build();
+            } else if (command instanceof AsyncTabCompleter completer) {
+                CompletableFuture<List<String>> suggestions = completer.tabComplete(new BukkitArgument(context, info.args()), wrapper);
+                if (suggestions == null) return wrapper.build();
+                return suggestions.thenComposeAsync(strings -> {
+                    strings.stream()
+                            .filter(string -> string.toLowerCase().startsWith(wrapper.helper().currentArg().toLowerCase()))
+                            .forEach(wrapper::suggest);
+                    return wrapper.build();
+                });
+            } else return wrapper.build();
+        });
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/argument/ArgumentParser.java b/src/main/java/dev/vansen/commandutils/bukkit/argument/ArgumentParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..735fa2db620fe6802cdff6ae0a49bf59732d696b
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/argument/ArgumentParser.java
@@ -0,0 +1,77 @@
+package dev.vansen.commandutils.bukkit.argument;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * A utility class for parsing and accessing command arguments.
+ */
+@SuppressWarnings("unused")
+public class ArgumentParser {
+    private final ConcurrentMap<String, Integer> argMap = new ConcurrentHashMap<>();
+    private final ConcurrentMap<String, Boolean> argRequiredMap = new ConcurrentHashMap<>();
+    private final String args;
+
+    /**
+     * Constructs a new ArgumentParser object.
+     *
+     * @param args The arguments to be parsed.
+     */
+    public ArgumentParser(@NotNull String args) {
+        this.args = args;
+        parse();
+    }
+
+    /**
+     * Parses the arguments and populates the internal maps, only public for external libraries expanding upon.
+     */
+    public void parse() {
+        String[] argArray = args.split("\\s+");
+        for (int i = 0; i < argArray.length; i++) {
+            String arg = argArray[i];
+            if (!arg.startsWith("[") && !arg.startsWith("<") && !arg.endsWith("]") && !arg.endsWith(">")) continue;
+            argMap.put(arg.replaceAll("[<>\\[\\]]", ""), i + 1);
+            if (arg.startsWith("<") && arg.endsWith(">")) argRequiredMap.put(arg.replaceAll("[<>\\[\\]]", ""), true);
+        }
+    }
+
+    /**
+     * Retrieves the index of the specified argument.
+     *
+     * @param argName The name of the argument to retrieve.
+     * @return The index of the argument, or -1 if not found.
+     */
+    public int index(@NotNull String argName) {
+        return argMap.getOrDefault(argName, -1);
+    }
+
+    /**
+     * Checks if the specified argument is required.
+     *
+     * @param argName The name of the argument to check.
+     * @return True if the argument is required, false otherwise.
+     */
+    public boolean required(@NotNull String argName) {
+        return argRequiredMap.getOrDefault(argName, false);
+    }
+
+    /**
+     * Retrieves the required number of arguments.
+     *
+     * @return The required number of arguments.
+     */
+    public int length() {
+        return argRequiredMap.size();
+    }
+
+    /**
+     * Checks if there are any arguments.
+     *
+     * @return True if there are arguments, false otherwise.
+     */
+    public boolean hasArgs() {
+        return !args.isEmpty();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/argument/BukkitArgument.java b/src/main/java/dev/vansen/commandutils/bukkit/argument/BukkitArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..88d7bd4262db69ad189ca81f7c07effd39a12acc
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/argument/BukkitArgument.java
@@ -0,0 +1,241 @@
+package dev.vansen.commandutils.bukkit.argument;
+
+import dev.vansen.commandutils.argument.arguments.color.ArgumentColors;
+import dev.vansen.commandutils.command.CommandWrapper;
+import dev.vansen.commandutils.exceptions.CmdException;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.checkerframework.checker.optional.qual.MaybePresent;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+/**
+ * Class for accessing arguments in a command.
+ */
+@SuppressWarnings("unused")
+public class BukkitArgument {
+    private final @NotNull CommandWrapper context;
+    private final @NotNull ArgumentParser parser;
+
+    /**
+     * Constructs a new BukkitArgument.
+     *
+     * @param context The command context.
+     * @param args    The arguments.
+     */
+    public BukkitArgument(@NotNull CommandWrapper context, @NotNull String args) {
+        this.context = context;
+        this.parser = new ArgumentParser(args);
+    }
+
+    /**
+     * Retrieves the argument of the specified name.
+     *
+     * @param arg The index of the argument to retrieve.
+     * @return The argument at the specified index, or an empty string if the index is out of bounds or the argument is empty.
+     */
+    public @NotNull String arg(@NotNull String arg) {
+        return context.arg(parser.index(arg));
+    }
+
+    /**
+     * Retrieves the argument at the specified index.
+     * This is 1 index based, so index 0 is the command itself, index 1 is the first argument
+     *
+     * @param index The index of the argument to retrieve.
+     * @return The argument at the specified index.
+     */
+    public @NotNull String argOf(int index) {
+        return context.arg(index);
+    }
+
+    /**
+     * Retrieves the argument at the specified index, or a default value if it is empty.
+     * This is 1 index based, so index 0 is the command itself, index 1 is the first argument
+     *
+     * @param index The index of the argument to retrieve.
+     * @param def   The default value to return if the argument is empty.
+     * @return The argument at the specified index, or the default value if it is empty.
+     */
+    public @NotNull String argOfOr(int index, @NotNull String def) {
+        return context.arg(index).isEmpty() ? def : context.arg(index);
+    }
+
+    /**
+     * Retrieves the argument at the specified index, or a default value if it is empty.
+     * This is 1 index based, so index 0 is the command itself, index 1 is the first argument
+     *
+     * @param index The index of the argument to retrieve.
+     * @param def   The default value to return if the argument is empty.
+     * @return The argument at the specified index, or the default value if it is empty.
+     */
+    public @NotNull String argOfOrDefault(int index, @NotNull String def) {
+        return argOfOr(index, def);
+    }
+
+    /**
+     * Retrieves the argument at the specified index.
+     * This is 0 index based, so index 0 is the first argument, index 1 is the second argument, ect
+     *
+     * @param index The index of the argument to retrieve.
+     * @return The argument at the specified index.
+     */
+    public @NotNull String argOfIndex(int index) {
+        return context().inputWithoutCommand().split("\\s+")[index];
+    }
+
+    /**
+     * Retrieves the argument at the specified index, or a default value if it is empty.
+     * This is 0 index based, so index 0 is the first argument, index 1 is the second argument, ect
+     *
+     * @param index The index of the argument to retrieve.
+     * @param def   The default value to return if the argument is empty.
+     * @return The argument at the specified index, or the default value if it is empty.
+     */
+    public @NotNull String argOfIndexOr(int index, @NotNull String def) {
+        return context().inputWithoutCommand().split("\\s+")[index].isEmpty() ? def : context().inputWithoutCommand().split("\\s+")[index];
+    }
+
+    /**
+     * Retrieves the argument at the specified index, or a default value if it is empty.
+     * This is 0 index based, so index 0 is the first argument, index 1 is the second argument, ect
+     *
+     * @param index The index of the argument to retrieve.
+     * @param def   The default value to return if the argument is empty.
+     * @return The argument at the specified index, or the default value if it is empty.
+     */
+    public @NotNull String argOfIndexOrDefault(int index, @NotNull String def) {
+        return argOfIndexOr(index, def);
+    }
+
+    /**
+     * Retrieves the argument of the specified name, or a default value if it is empty.
+     *
+     * @param arg The index of the argument to retrieve.
+     * @param def The default value to return if the argument is empty.
+     * @return The argument of the specified name, or the default value if it is empty.
+     */
+    public @NotNull String argOr(@NotNull String arg, @NotNull String def) {
+        return context.arg(parser.index(arg)).isEmpty() ? def : context.arg(parser.index(arg));
+    }
+
+    /**
+     * Retrieves the argument of the specified name, or a default value if it is empty.
+     *
+     * @param arg The index of the argument to retrieve.
+     * @param def The default value to return if the argument is empty.
+     * @return The argument of the specified name, or the default value if it is empty.
+     */
+    public @NotNull String argOrDefault(@NotNull String arg, @NotNull String def) {
+        return argOr(arg, def);
+    }
+
+    /**
+     * Checks if the specified argument is a valid color.
+     *
+     * @param argName The name of the argument to check.
+     * @return True if the argument is a color, false otherwise.
+     */
+    public boolean parseColor(@NotNull String argName) {
+        if (ArgumentColors.COLOR_MAP.containsKey(arg(argName).toLowerCase())) {
+            return TextColor.fromHexString(ArgumentColors.COLOR_MAP.getOrDefault(arg(argName), "")) != null;
+        } else {
+            return TextColor.fromHexString(arg(argName)) != null;
+        }
+    }
+
+    /**
+     * Checks if the specified argument is a valid player.
+     *
+     * @param argName The name of the argument to check.
+     * @return True if the argument is a player, false otherwise.
+     */
+    public boolean parsePlayer(@NotNull String argName) {
+        return Bukkit.getPlayer(arg(argName)) != null;
+    }
+
+    /**
+     * Checks if the specified argument is a valid color.
+     * Else throws an exception.
+     *
+     * @param argName The name of the argument to check.
+     */
+    public void parseColorOrThrow(@NotNull String argName) {
+        if (!parseColor(argName)) {
+            throw new CmdException("Invalid color: " + arg(argName), context.sender());
+        }
+    }
+
+    /**
+     * Checks if the specified argument is a valid player.
+     * Else throws an exception.
+     *
+     * @param argName The name of the argument to check.
+     */
+    public void parsePlayerOrThrow(@NotNull String argName) {
+        if (!parsePlayer(argName)) {
+            throw new CmdException("Invalid player: " + arg(argName), context.sender());
+        }
+    }
+
+    /**
+     * Retrieves the color of the specified argument.
+     * It is recommended to not use this before doing {@link #parseColor(String)} to avoid errors.
+     *
+     * @param argName The name of the argument to retrieve.
+     * @return The color of the argument.
+     */
+    @MaybePresent
+    @NotNull
+    public Optional<TextColor> color(@NotNull String argName) {
+        if (ArgumentColors.COLOR_MAP.containsKey(arg(argName).toLowerCase())) {
+            return Optional.ofNullable(TextColor.fromHexString(ArgumentColors.COLOR_MAP.get(arg(argName))));
+        } else {
+            return Optional.ofNullable(TextColor.fromHexString(arg(argName)));
+        }
+    }
+
+    /**
+     * Retrieves the player of the specified argument.
+     * It is recommended to not use this before doing {@link #parsePlayer(String)} to avoid errors.
+     *
+     * @param argName The name of the argument to retrieve.
+     * @return The player of the argument.
+     */
+    @MaybePresent
+    @NotNull
+    public Optional<Player> player(@NotNull String argName) {
+        return Optional.ofNullable(Bukkit.getPlayer(arg(argName)));
+    }
+
+    /**
+     * Retrieves the command context.
+     *
+     * @return The command context.
+     */
+    public @NotNull CommandWrapper context() {
+        return context;
+    }
+
+    /**
+     * Returns a copied collection of the command arguments, allowing for safe manipulation and querying of the arguments.
+     *
+     * @return a copied collection of the command arguments
+     */
+    public @NotNull ArrayList<String> copied() {
+        return new ArrayList<>(List.of(context.inputWithoutCommand().split("\\s+")));
+    }
+
+    /**
+     * Retrieves the argument parser used to parse the arguments.
+     *
+     * @return The argument parser.
+     */
+    public @NotNull ArgumentParser parser() {
+        return parser;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/command/BukkitCommands.java b/src/main/java/dev/vansen/commandutils/bukkit/command/BukkitCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..8165d9d10e139d65c42900610e21c2c7e4322830
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/command/BukkitCommands.java
@@ -0,0 +1,12 @@
+package dev.vansen.commandutils.bukkit.command;
+
+import dev.vansen.commandutils.bukkit.argument.BukkitArgument;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A class that provides the executor for a command.
+ */
+@SuppressWarnings("unused")
+public interface BukkitCommands {
+    void execute(@NotNull BukkitArgument argument);
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/package-info.java b/src/main/java/dev/vansen/commandutils/bukkit/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..23d0e511abe79fca9c0e066e6843571a1be22824
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/package-info.java
@@ -0,0 +1,12 @@
+/**
+ * Utility for working with CommandUtils while having a bukkit-based experience.
+ * <p>
+ * Classes in this package tend to provide a bukkit-like command system, rather related to brigadier entirely.
+ * <p>
+ * Note so, We do not provide an <b>exact</b> Bukkit-like command system because the original Bukkit API has several limitations and design flaws that we aim to improve upon.
+ * <p>
+ * By creating a new, modern command system that is built on top of CommandUtils, we can take advantage of design principles to create a more robust, flexible, and maintainable API.
+ * <p>
+ * This allows us to provide a better developer experience and more efficient command processing, while still maintaining a familiar and intuitive API for users who are already familiar with the Bukkit command system.
+ */
+package dev.vansen.commandutils.bukkit;
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/tabcompletion/AsyncTabCompleter.java b/src/main/java/dev/vansen/commandutils/bukkit/tabcompletion/AsyncTabCompleter.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c6e83319ebc1d7a6b41ae6782cb2e095755e9bb
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/tabcompletion/AsyncTabCompleter.java
@@ -0,0 +1,28 @@
+package dev.vansen.commandutils.bukkit.tabcompletion;
+
+import dev.vansen.commandutils.bukkit.argument.BukkitArgument;
+import dev.vansen.commandutils.completer.SuggestionsBuilderWrapper;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * An asynchronous tab completer that provides suggestions for a command.
+ * <p>
+ * This interface is designed to handle asynchronous tab completion, allowing
+ * for more complex and time-consuming operations to be performed without
+ * blocking the main thread.
+ * <p>
+ * Note that this is not simply a matter of calling {@link CompletableFuture#join()}
+ * or {@link CompletableFuture#get()} on a future. Instead, this interface is
+ * designed to allow for true asynchronous tab completion, where the completer
+ * can perform its work in the background without blocking the main thread.
+ */
+@SuppressWarnings("unused")
+public interface AsyncTabCompleter {
+
+    @Nullable
+    CompletableFuture<List<String>> tabComplete(@NotNull BukkitArgument argument, @NotNull SuggestionsBuilderWrapper wrapper);
+}
diff --git a/src/main/java/dev/vansen/commandutils/bukkit/tabcompletion/TabCompleter.java b/src/main/java/dev/vansen/commandutils/bukkit/tabcompletion/TabCompleter.java
new file mode 100644
index 0000000000000000000000000000000000000000..64ee6fa64a4f6c5fe85e78a4fc6a4c5be89144e7
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/bukkit/tabcompletion/TabCompleter.java
@@ -0,0 +1,18 @@
+package dev.vansen.commandutils.bukkit.tabcompletion;
+
+import dev.vansen.commandutils.bukkit.argument.BukkitArgument;
+import dev.vansen.commandutils.completer.SuggestionsBuilderWrapper;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * A tab completer that provides suggestions for a command.
+ */
+@SuppressWarnings("unused")
+public interface TabCompleter {
+
+    @Nullable
+    List<String> tabComplete(@NotNull BukkitArgument argument, @NotNull SuggestionsBuilderWrapper wrapper);
+}
diff --git a/src/main/java/dev/vansen/commandutils/command/BooleanChecker.java b/src/main/java/dev/vansen/commandutils/command/BooleanChecker.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ed56d2a98b2fbd1db953a59914677b1466fa33e
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/command/BooleanChecker.java
@@ -0,0 +1,17 @@
+package dev.vansen.commandutils.command;
+
+/**
+ * An interface representing a boolean check.
+ * <p>
+ * Implementations of this interface should provide a single method, {@link #check()},
+ * which returns a boolean value indicating the result of the check.
+ */
+@FunctionalInterface
+public interface BooleanChecker {
+    /**
+     * Performs the boolean check and returns the result.
+     *
+     * @return the result of the check
+     */
+    boolean check();
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/command/CheckType.java b/src/main/java/dev/vansen/commandutils/command/CheckType.java
new file mode 100644
index 0000000000000000000000000000000000000000..1cf329641a5e6bc68879107f94fcbc50e93dd0d6
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/command/CheckType.java
@@ -0,0 +1,39 @@
+package dev.vansen.commandutils.command;
+
+import org.bukkit.entity.Player;
+
+/**
+ * An enumeration representing different types of checks that can be performed on the command sender.
+ * These checks determine whether the command sender meets certain conditions.
+ */
+public enum CheckType {
+    /**
+     * Represents a check to ensure the sender is a {@link Player}.
+     */
+    PLAYER,
+
+    /**
+     * Represents a check to ensure the sender is the console.
+     */
+    CONSOLE,
+
+    /**
+     * Represents a check to ensure the sender is a remote console.
+     */
+    REMOTE_CONSOLE,
+
+    /**
+     * Represents a check to ensure the sender is an entity (such as a mob).
+     */
+    ENTITY,
+
+    /**
+     * Represents a check to ensure the sender is a command block.
+     */
+    COMMAND_BLOCK,
+
+    /**
+     * Represents a check to ensure the sender is a proxied sender.
+     */
+    PROXIED_SENDER
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/command/CommandExecutor.java b/src/main/java/dev/vansen/commandutils/command/CommandExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..a0789b648088e907208568acaa936ec6fc3f3c49
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/command/CommandExecutor.java
@@ -0,0 +1,17 @@
+package dev.vansen.commandutils.command;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a command executor responsible for handling the execution logic of commands.
+ */
+@FunctionalInterface
+public interface CommandExecutor {
+
+    /**
+     * Executes the command with the given context.
+     *
+     * @param context the {@link CommandWrapper} containing context information for the command.
+     */
+    void execute(@NotNull CommandWrapper context);
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/command/CommandRequirement.java b/src/main/java/dev/vansen/commandutils/command/CommandRequirement.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ec14d3ad34182ad0dd3b0e526cd6b864c9ba76c
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/command/CommandRequirement.java
@@ -0,0 +1,57 @@
+package dev.vansen.commandutils.command;
+
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+
+@SuppressWarnings({"unused"})
+public record CommandRequirement(CommandSourceStack context) {
+
+    /**
+     * Gets the sender.
+     *
+     * @return the sender.
+     */
+    public CommandSender sender() {
+        return context.getSender();
+    }
+
+    /**
+     * Gets the player, this shouldn't throw an exception, since it's likely the sender is a player.
+     *
+     * @return the player.
+     */
+    public Player player() {
+        return (Player) sender();
+    }
+
+    /**
+     * Gets the entity, this shouldn't throw an exception, since it's likely the sender is an entity.
+     *
+     * @return the entity.
+     */
+    public Entity entity() {
+        return context.getExecutor();
+    }
+
+    /**
+     * Gets the location of the sender.
+     *
+     * @return the location.
+     */
+    public Location location() {
+        return context.getLocation();
+    }
+
+    /**
+     * Gets the world of the sender.
+     *
+     * @return the world.
+     */
+    public World world() {
+        return location().getWorld();
+    }
+}
diff --git a/src/main/java/dev/vansen/commandutils/command/CommandWrapper.java b/src/main/java/dev/vansen/commandutils/command/CommandWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..c579aaf89b7057bdea617a7804227bdeab432254
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/command/CommandWrapper.java
@@ -0,0 +1,2043 @@
+package dev.vansen.commandutils.command;
+
+import com.mojang.brigadier.context.CommandContext;
+import dev.vansen.commandutils.exceptions.CmdException;
+import dev.vansen.commandutils.messages.MessageTypes;
+import dev.vansen.commandutils.messages.SendType;
+import dev.vansen.commandutils.sender.SenderTypes;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.bukkit.*;
+import org.bukkit.command.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.PlayerInventory;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * A wrapper class for managing and accessing command context information within a command execution.
+ * Provides utility methods to interact with command arguments, check the type of command sender,
+ * and handle exceptions.
+ */
+@SuppressWarnings({"unused"})
+public record CommandWrapper(CommandContext<CommandSourceStack> context) {
+
+    /**
+     * Constructs a new {@link CommandWrapper} with the given command context.
+     *
+     * @param context the command context to be wrapped
+     */
+    public CommandWrapper(@NotNull CommandContext<CommandSourceStack> context) {
+        this.context = context;
+    }
+
+    /**
+     * Retrieves the {@link Player} who executed the command.
+     *
+     * @return the player who executed the command.
+     * @throws ClassCastException if the sender is not an instance of {@link Player}.
+     */
+    @NotNull
+    public Player player() {
+        return (Player) context.getSource().getSender();
+    }
+
+    /**
+     * Retrieves the {@link CommandSender} who executed the command.
+     *
+     * @return the sender of the command.
+     */
+    @NotNull
+    public CommandSender sender() {
+        return context.getSource().getSender();
+    }
+
+    /**
+     * Retrieves the {@link Entity} who executed the command.
+     *
+     * @return the entity who executed the command.
+     */
+    @Nullable
+    public Entity entity() {
+        return context.getSource().getExecutor();
+    }
+
+    /**
+     * Retrieves the {@link ConsoleCommandSender} who executed the command.
+     *
+     * @return the console command sender who executed the command, can be null if the sender is not a console.
+     */
+    @Nullable
+    public ConsoleCommandSender console() {
+        return context.getSource().getSender() instanceof ConsoleCommandSender sender ? sender : null;
+    }
+
+    /**
+     * Retrieves the {@link RemoteConsoleCommandSender} who executed the command.
+     *
+     * @return the remote console command sender who executed the command, can be null if the sender is not a remote console.
+     */
+    @Nullable
+    public RemoteConsoleCommandSender remoteConsole() {
+        return context.getSource().getSender() instanceof RemoteConsoleCommandSender sender ? sender : null;
+    }
+
+    /**
+     * Retrieves the {@link BlockCommandSender} who executed the command.
+     *
+     * @return the block command sender who executed the command, can be null if the sender is not a command block.
+     */
+    @Nullable
+    public BlockCommandSender block() {
+        return context.getSource().getExecutor() instanceof BlockCommandSender sender ? sender : null;
+    }
+
+    /**
+     * Retrieves the {@link ProxiedCommandSender} who executed the command.
+     *
+     * @return the proxied command sender who executed the command, can be null if the sender is not a proxied command.
+     */
+    @Nullable
+    public ProxiedCommandSender proxied() {
+        return context.getSource().getExecutor() instanceof ProxiedCommandSender sender ? sender : null;
+    }
+
+    /**
+     * Retrieves the {@link Player} with the given name.
+     *
+     * @param name the name of the player.
+     * @return the player with the given name, can be null if the player does not exist.
+     */
+    @Nullable
+    public Player player(@NotNull String name) {
+        return Bukkit.getPlayer(name);
+    }
+
+    /**
+     * Checks if a player with the given name exists.
+     *
+     * @param name the name of the player.
+     * @return true if the player exists, false otherwise.
+     */
+    public boolean playerExists(@NotNull String name) {
+        return Bukkit.getPlayer(name) != null;
+    }
+
+    /**
+     * Retrieves the {@link OfflinePlayer} with the given name.
+     *
+     * @param name the name of the player.
+     * @return the offline player with the given name
+     */
+    @NotNull
+    public OfflinePlayer offlinePlayer(@NotNull String name) {
+        return Bukkit.getOfflinePlayer(name);
+    }
+
+    /**
+     * Sends responses to the command sender as rich messages.
+     *
+     * @param messages the messages to send
+     */
+    public void response(@Nullable String... messages) {
+        Arrays.stream(messages)
+                .filter(Objects::nonNull)
+                .forEach(message -> sender().sendRichMessage(message));
+    }
+
+    /**
+     * Sends responses to the command sender as component messages.
+     *
+     * @param messages the messages to send
+     */
+    public void response(@Nullable Component... messages) {
+        Arrays.stream(messages)
+                .filter(Objects::nonNull)
+                .forEach(message -> sender().sendMessage(message));
+    }
+
+    /**
+     * Sends responses to the command sender as rich messages.
+     *
+     * @param messages the messages to send
+     */
+    public void response(@NotNull Iterable<String> messages) {
+        messages.forEach(message -> sender().sendRichMessage(message));
+    }
+
+    /**
+     * Sends responses to the command sender as component messages.
+     *
+     * @param messages the messages to send
+     */
+    public void responseComponent(@NotNull Iterable<Component> messages) {
+        messages.forEach(message -> sender().sendMessage(message));
+    }
+
+    /**
+     * Sends responses to the command sender as action bar messages.
+     *
+     * @param messages the messages to send
+     */
+    public void actionBar(@Nullable String... messages) {
+        if (!isPlayer()) return;
+        Arrays.stream(messages)
+                .filter(Objects::nonNull)
+                .forEach(message -> sender().sendActionBar(MiniMessage.miniMessage().deserializeOrNull(message)));
+    }
+
+    /**
+     * Sends responses to the command sender as action bar component messages.
+     *
+     * @param messages the messages to send
+     */
+    public void actionBar(@Nullable Component... messages) {
+        if (!isPlayer()) return;
+        Arrays.stream(messages)
+                .filter(Objects::nonNull)
+                .forEach(message -> sender().sendActionBar(message));
+    }
+
+    /**
+     * Sends responses to the command sender as action bar messages.
+     *
+     * @param messages the messages to send
+     */
+    public void actionBar(@NotNull Iterable<String> messages) {
+        if (!isPlayer()) return;
+        messages.forEach(message -> sender().sendActionBar(MiniMessage.miniMessage().deserializeOrNull(message)));
+    }
+
+    /**
+     * Sends responses to the command sender as action bar component messages.
+     *
+     * @param messages the messages to send
+     */
+    public void actionBarComponent(@NotNull Iterable<Component> messages) {
+        if (!isPlayer()) return;
+        messages.forEach(message -> sender().sendActionBar(message));
+    }
+
+    /**
+     * Sends a response to the command sender as a message type.
+     *
+     * @param message the message to send
+     */
+    public void response(@Nullable MessageTypes message) {
+        if (message == null) return;
+        message.messages()
+                .forEach(m -> {
+                    if (message.type() == SendType.BOTH) {
+                        sender().sendRichMessage(m);
+                        sender().sendActionBar(MiniMessage.miniMessage().deserializeOrNull(m));
+                    } else if (message.type() == SendType.ACTION_BAR) {
+                        sender().sendActionBar(MiniMessage.miniMessage().deserializeOrNull(m));
+                    } else sender().sendRichMessage(m);
+                });
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to the specified type.
+     *
+     * @param arg   the name of the argument.
+     * @param clazz the class of the argument type.
+     * @param <T>   the type of the argument.
+     * @return the argument value converted to the specified type.
+     */
+    @NotNull
+    public <T> T arg(@NotNull String arg, @NotNull Class<T> clazz) {
+        return context.getArgument(arg, clazz);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to the specified type.
+     * If the argument does not exist, or inconvertible, the default value is returned.
+     *
+     * @param arg          the name of the argument.
+     * @param clazz        the class of the argument type.
+     * @param defaultValue the default value to return if the argument does not exist.
+     * @param <T>          the type of the argument.
+     * @return the argument value converted to the specified type or the default value if the argument does not exist.
+     */
+    @NotNull
+    public <T> T arg(@NotNull String arg, @NotNull Class<T> clazz, @NotNull T defaultValue) {
+        try {
+            return arg(arg, clazz);
+        } catch (Exception e) {
+            return defaultValue;
+        }
+    }
+
+    /**
+     * Helper method to get arguments safely for the user.
+     * Automatically parses the input to get the arguments in the command.
+     *
+     * @param index The index of the argument to retrieve (0-based), 0 is being the command itself (i.e. /example).
+     * @return The argument at the given index, or an empty string if not available.
+     */
+    public String arg(int index) {
+        String[] args = input().split(" ");
+        if (index < args.length) {
+            return args[index];
+        }
+        return ""; // Return empty if the argument does not exist
+    }
+
+    /**
+     * Helper method to get input as a list.
+     *
+     * @return A list of strings containing the input in the command, separated by spaces.
+     */
+    public List<String> inputAsList() {
+        return Arrays.asList(input().split(" "));
+    }
+
+    /**
+     * Helper method to get input as an array.
+     *
+     * @return An array of strings containing the input in the command, separated by spaces.
+     */
+    public String[] inputAsArray() {
+        return input().split(" ");
+    }
+
+    /**
+     * Helper method to get input as a stream.
+     *
+     * @return A stream of strings containing the input in the command, separated by spaces.
+     */
+    public Stream<String> inputAsStream() {
+        return Arrays.stream(input().split(" "));
+    }
+
+    /**
+     * Helper method to get input as a set.
+     *
+     * @return A set of strings containing the input in the command, separated by spaces.
+     */
+    public Set<String> inputAsSet() {
+        return new HashSet<>(inputAsList());
+    }
+
+    /**
+     * Helper method to get arguments after a given index.
+     * Automatically parses the input to get the arguments in the command.
+     *
+     * @param index The index of the argument to start retrieving from (0-based), 0 is being the command itself (i.e. /example).
+     * @return A string containing the arguments after the given index, separated by spaces.
+     */
+    public String argsAfter(int index) {
+        String[] args = input().split(" ");
+        if (index < args.length) {
+            return String.join(" ", Arrays.copyOfRange(args, index + 1, args.length));
+        }
+        return ""; // Return empty if the argument does not exist
+    }
+
+    /**
+     * Helper method to check if a flag exists in the input.
+     *
+     * @param flag The flag to check.
+     * @return True if the flag exists, false otherwise.
+     */
+    public boolean hasFlag(@NotNull String flag) {
+        return inputAsList()
+                .contains(flag);
+    }
+
+    /**
+     * Helper method to check if a flag exists multiple times in the input.
+     *
+     * @param flag The flag to check.
+     * @return True if the flag exists multiple times, false otherwise.
+     */
+    public boolean hasFlagMultipleTimes(@NotNull String flag) {
+        AtomicInteger count = new AtomicInteger();
+        inputAsStream()
+                .forEach(arg -> {
+                    if (arg.equals(flag)) count.incrementAndGet();
+                });
+        return count.get() > 1;
+    }
+
+    /**
+     * Helper method to get the number of times a flag exists in the input.
+     *
+     * @param flag The flag to check.
+     * @return The number of times the flag exists in the input.
+     */
+    public int numberOfFlags(@NotNull String flag) {
+        AtomicInteger count = new AtomicInteger();
+        inputAsStream()
+                .forEach(arg -> {
+                    if (arg.equals(flag)) count.incrementAndGet();
+                });
+        return count.get();
+    }
+
+    /**
+     * Helper method to get the value of a flag, like "/example --flag some_value".
+     *
+     * @param flag The flag to get the value of.
+     * @return The value of the flag, or an empty string if the flag does not exist.
+     */
+    public String parameterForFlag(@NotNull String flag) {
+        String[] args = input().split(" ");
+        for (int i = 0; i < args.length; i++) {
+            if (args[i].equals(flag)) {
+                return args[i + 1];
+            }
+        }
+        return "";
+    }
+
+    /**
+     * Helper method to check if multiple flags exist in the input.
+     *
+     * @param flags The flags to check.
+     * @return True if any of the flags exist, false otherwise.
+     */
+    public boolean hasFlags(@NotNull String... flags) {
+        return Arrays.stream(flags)
+                .anyMatch(this::hasFlag);
+    }
+
+    /**
+     * Helper method to check if multiple flags exist in the input.
+     *
+     * @param flags The flags to check.
+     * @return True if any of the flags exist, false otherwise.
+     */
+    public boolean hasFlags(@NotNull Collection<String> flags) {
+        return flags.stream()
+                .anyMatch(this::hasFlags);
+    }
+
+    /**
+     * Helper method to check if any flag exists in the input that starts with a hyphen or double hyphen (- or --).
+     *
+     * @return True if any flag exists, false otherwise.
+     */
+    public boolean hasFlags() {
+        return inputAsStream()
+                .anyMatch(arg -> arg.startsWith("--") || arg.startsWith("-"));
+    }
+
+    /**
+     * Helper method to get all flags starting with any of the given prefixes.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return A list of strings containing the flags starting with the given prefix.
+     */
+    public List<String> flagsStarting(@NotNull String... prefixes) {
+        return inputAsStream()
+                .filter(arg -> Arrays.stream(prefixes)
+                        .anyMatch(arg::startsWith))
+                .toList();
+    }
+
+    /**
+     * Helper method to get all flags ending with a given suffix.
+     *
+     * @param suffix The suffix of the flags to retrieve.
+     * @return A list of strings containing the flags ending with the given suffix.
+     */
+    public List<String> flagsEnding(@NotNull String suffix) {
+        return inputAsStream()
+                .filter(arg -> arg.endsWith(suffix))
+                .toList();
+    }
+
+    /**
+     * Helper method to get all flags containing a given substring.
+     *
+     * @param substring The substring of the flags to retrieve.
+     * @return A list of strings containing the flags containing the given substring.
+     */
+    public List<String> flagsContaining(@NotNull String substring) {
+        return inputAsStream()
+                .filter(arg -> arg.contains(substring))
+                .collect(Collectors.toList());
+    }
+
+    /**
+     * Helper method to get the input without flags that starts with a hyphen or double hyphen (- or --).
+     *
+     * @return A string containing the input without flags.
+     */
+    public String inputWithoutFlags() {
+        return String.join(" ", inputAsStream()
+                .filter(arg -> !arg.startsWith("--") && !arg.startsWith("-"))
+                .toArray(String[]::new));
+    }
+
+    /**
+     * Helper method to get the input without flags that starts with any of the given prefixes.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return A string containing the input without flags.
+     */
+    public String inputWithoutFlags(@NotNull String... prefixes) {
+        return String.join(" ", inputAsStream()
+                .filter(arg -> Arrays.stream(prefixes).noneMatch(arg::startsWith))
+                .toArray(String[]::new));
+    }
+
+    /**
+     * Helper method to get the input without flags that starts with any of the given prefixes.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return A string containing the input without flags.
+     */
+    public String inputWithoutFlags(@NotNull Collection<String> prefixes) {
+        return inputWithoutFlags(prefixes.toArray(new String[0]));
+    }
+
+    /**
+     * Helper method to get the input without the command itself.
+     *
+     * @return A string containing the input without the command itself.
+     */
+    public String inputWithoutCommand() {
+        return String.join(" ", inputAsStream()
+                .skip(1)
+                .toArray(String[]::new));
+    }
+
+    /**
+     * Helper method to get the number of flags.
+     *
+     * @return The number of flags in the command.
+     */
+    public int flagCount() {
+        return flagsStarting("--").size() + flagsStarting("-").size();
+    }
+
+    /**
+     * Helper method to get the number of flags starting with a given prefix.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return The number of flags starting with the given prefix.
+     */
+    public int flagCount(@NotNull String... prefixes) {
+        return flagsStarting(prefixes).size();
+    }
+
+    /**
+     * Helper method to get the first flag.
+     *
+     * @return The first flag in the command, or an empty string if not found.
+     */
+    public String firstFlag() {
+        try {
+            return flagsStarting("--")
+                    .getFirst();
+        } catch (@NotNull NoSuchElementException e) {
+            try {
+                return flagsStarting("-")
+                        .getFirst();
+            } catch (@NotNull NoSuchElementException ignored) {
+                return "";
+            }
+        }
+    }
+
+    /**
+     * Helper method to get the first flag starting with a given prefix.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return The first flag starting with the given prefix, or an empty string if not found.
+     */
+    public String firstFlag(@NotNull String... prefixes) {
+        try {
+            return flagsStarting(prefixes)
+                    .getFirst();
+        } catch (@NotNull NoSuchElementException ignored) {
+            return "";
+        }
+    }
+
+    /**
+     * Helper method to get the first flag starting with a given prefix.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return The first flag starting with the given prefix, or an empty string if not found.
+     */
+    public String firstFlag(@NotNull Collection<String> prefixes) {
+        return firstFlag(prefixes.toArray(new String[0]));
+    }
+
+    /**
+     * Helper method to get the last flag.
+     *
+     * @return The last flag in the command, or an empty string if not found.
+     */
+    public String lastFlag() {
+        try {
+            return flagsStarting("--")
+                    .getLast();
+        } catch (@NotNull NoSuchElementException e) {
+            try {
+                return flagsStarting("-")
+                        .getLast();
+            } catch (@NotNull NoSuchElementException ignored) {
+                return "";
+            }
+        }
+    }
+
+    /**
+     * Helper method to get the last flag starting with a given prefix.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return The last flag starting with the given prefix, or an empty string if not found.
+     */
+    public String lastFlag(@NotNull String... prefixes) {
+        try {
+            return flagsStarting(prefixes)
+                    .getLast();
+        } catch (@NotNull NoSuchElementException ignored) {
+            return "";
+        }
+    }
+
+    /**
+     * Helper method to get the last flag starting with a given prefix.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return The last flag starting with the given prefix, or an empty string if not found.
+     */
+    public String lastFlag(@NotNull Collection<String> prefixes) {
+        return lastFlag(prefixes.toArray(new String[0]));
+    }
+
+    /**
+     * Helper method to get the number of flags starting with a given prefix.
+     *
+     * @param prefixes The prefixes of the flags to retrieve.
+     * @return The number of flags starting with the given prefix.
+     */
+    public int flagCount(@NotNull Collection<String> prefixes) {
+        return flagCount(prefixes.toArray(new String[0]));
+    }
+
+    /**
+     * Helper method to get the number of arguments.
+     *
+     * @return The number of arguments in the command.
+     */
+    public int argCount() {
+        return input().split(" ").length;
+    }
+
+    /**
+     * Helper method to get the number of arguments after a given index.
+     *
+     * @param index The index of the argument to start retrieving from (0-based), 0 is being the command itself (i.e. /example).
+     * @return The number of arguments after the given index.
+     */
+    public int argCountAfter(int index) {
+        String[] args = input().split(" ");
+        if (index < args.length) {
+            return args.length - index - 1;
+        }
+        return 0;
+    }
+
+    /**
+     * Helper method to get the arguments between two indices.
+     *
+     * @param start The index of the first argument to include (0-based), 0 is being the command itself (i.e. /example).
+     * @param end   The index of the last argument to include (0-based), 0 is being the command itself (i.e. /example).
+     * @return A string containing the arguments between the two indices.
+     */
+    public String argsBetween(int start, int end) {
+        String[] args = input().split(" ");
+        if (start < args.length && end < args.length) {
+            return String.join(" ", Arrays.copyOfRange(args, start, end));
+        }
+        return "";
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a boolean.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a boolean.
+     */
+    public boolean argBoolean(@NotNull String arg) {
+        return context.getArgument(arg, Boolean.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a string.
+     */
+    public String argString(@NotNull String arg) {
+        return context.getArgument(arg, String.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string, then splits it into an array and returns the first value.
+     * <p>
+     * For example, if there's a greedy string argument, and the user enters "a b c", argStringFirst("arg") will return "a".
+     * <p>
+     * This works for non-greedy string arguments as well.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a string.
+     */
+    public String argStringFirst(@NotNull String arg) {
+        return argStringAt(arg, 0);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string, then splits it into an array and returns the value at the given index.
+     * <p>
+     * For example, if there's a greedy string argument, and the user enters "a b c", argStringAt("arg", 1) will return "b".
+     * <p>
+     * This only works for greedy string arguments, Using it on a non-greedy string argument will result in undefined behavior, and may throw an exception.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a string.
+     */
+    public String argStringAt(@NotNull String arg, int index) {
+        return context.getArgument(arg, String.class).split(" ")[index];
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a string.
+     */
+    public String argBlockMode(@NotNull String arg) {
+        return argString(arg);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to an integer.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to an integer.
+     */
+    public int argInt(@NotNull String arg) {
+        return context.getArgument(arg, Integer.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a double.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a double.
+     */
+    public double argDouble(@NotNull String arg) {
+        return context.getArgument(arg, Double.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a float.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a float.
+     */
+    public float argFloat(@NotNull String arg) {
+        return context.getArgument(arg, Float.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a long.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a long.
+     */
+    public long argLong(@NotNull String arg) {
+        return context.getArgument(arg, Long.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a world.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a world.
+     */
+    public World argWorld(@NotNull String arg) {
+        return context.getArgument(arg, World.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a game mode.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a game mode.
+     */
+    public GameMode argGameMode(@NotNull String arg) {
+        return arg(arg, GameMode.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to an item stack.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to an item stack.
+     */
+    public ItemStack argItemStack(@NotNull String arg) {
+        return context.getArgument(arg, ItemStack.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a player.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a player.
+     */
+    public Player argPlayer(@NotNull String arg) {
+        return context.getArgument(arg, Player.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a color.
+     *
+     * @param arg the name of the argument.
+     * @return the argument value converted to a color.
+     */
+    public TextColor argColor(@NotNull String arg) {
+        return context.getArgument(arg, TextColor.class);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a boolean.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a boolean, or the default value if not present or invalid.
+     */
+    public boolean argBoolean(@NotNull String arg, boolean def) {
+        return arg(arg, Boolean.class, def);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a string, or the default value if not present or invalid.
+     */
+    public String argString(@NotNull String arg, @Nullable String def) {
+        try {
+            return argString(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string.
+     * If the argument is not present or invalid, returns the default value.
+     * <p>
+     * View more details at {@link #argStringFirst(String)}
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a string, or the default value if not present or invalid.
+     */
+    public String argStringFirst(@NotNull String arg, @Nullable String def) {
+        try {
+            return argStringFirst(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string.
+     * If the argument is not present or invalid, returns the default value.
+     * <p>
+     * View more details at {@link #argStringAt(String, int)}
+     *
+     * @param arg   the name of the argument.
+     * @param index the index of the argument to retrieve.
+     * @param def   the default value to return if the argument is not present.
+     * @return the argument value converted to a string, or the default value if not present or invalid.
+     */
+    public String argStringAt(@NotNull String arg, int index, @Nullable String def) {
+        try {
+            return argStringAt(arg, index);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a string.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a string, or the default value if not present or invalid.
+     */
+    public String argBlockMode(@NotNull String arg, @Nullable String def) {
+        try {
+            return argBlockMode(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to an integer.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to an integer, or the default value if not present or invalid.
+     */
+    public int argInt(@NotNull String arg, int def) {
+        return arg(arg, Integer.class, def);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a double.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a double, or the default value if not present or invalid.
+     */
+    public double argDouble(@NotNull String arg, double def) {
+        return arg(arg, Double.class, def);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a float.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a float, or the default value if not present or invalid.
+     */
+    public float argFloat(@NotNull String arg, float def) {
+        return arg(arg, Float.class, def);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a long.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a long, or the default value if not present or invalid.
+     */
+    public long argLong(@NotNull String arg, long def) {
+        return arg(arg, Long.class, def);
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a world.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a world, or the default value if not present or invalid.
+     */
+    public World argWorld(@NotNull String arg, @Nullable World def) {
+        try {
+            return argWorld(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a game mode.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a game mode, or the default value if not present or invalid.
+     */
+    public GameMode argGameMode(@NotNull String arg, @Nullable GameMode def) {
+        try {
+            return argGameMode(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to an item stack.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to an item stack, or the default value if not present or invalid.
+     */
+    public ItemStack argItemStack(@NotNull String arg, @Nullable ItemStack def) {
+        try {
+            return argItemStack(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a player.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a player, or the default value if not present or invalid.
+     */
+    public Player argPlayer(@NotNull String arg, @Nullable Player def) {
+        try {
+            return argPlayer(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves a command argument by its name and converts it to a text color.
+     * If the argument is not present or invalid, returns the default value.
+     *
+     * @param arg the name of the argument.
+     * @param def the default value to return if the argument is not present.
+     * @return the argument value converted to a text color, or the default value if not present or invalid.
+     */
+    public TextColor argColor(@NotNull String arg, @Nullable TextColor def) {
+        try {
+            return argColor(arg);
+        } catch (Exception e) {
+            return def;
+        }
+    }
+
+    /**
+     * Retrieves the plain sender type of the given context.
+     *
+     * @return the plain sender type, can be "player", "console", "remote_console", "entity", "command_block", "proxied_sender" or "unknown".
+     */
+    public String plainSender() {
+        return switch (senderType()) {
+            case PLAYER -> "player";
+            case CONSOLE -> "console";
+            case REMOTE_CONSOLE -> "remote_console";
+            case ENTITY -> "entity";
+            case COMMAND_BLOCK -> "command_block";
+            case PROXIED -> "proxied_sender";
+            default -> "unknown";
+        };
+    }
+
+    /**
+     * Retrieves the friendly sender type of the given context.
+     *
+     * @return the friendly sender type, can be "Player", "Console", "Remote Console", "Entity", "Command Block", "Proxied Command Sender" or "Unknown".
+     */
+    public String friendlySender() {
+        return switch (senderType()) {
+            case PLAYER -> "Player";
+            case CONSOLE -> "Console";
+            case REMOTE_CONSOLE -> "Remote Console";
+            case ENTITY -> "Entity";
+            case COMMAND_BLOCK -> "Command Block";
+            case PROXIED -> "Proxied Command Sender";
+            default -> "Unknown";
+        };
+    }
+
+    /**
+     * Retrieves the sender type as a human-readable string.
+     *
+     * @return the sender type as a human-readable string.
+     */
+    public String senderTypeString() {
+        return switch (senderType()) {
+            case PLAYER -> "Sent by a player";
+            case CONSOLE -> "Sent from the console";
+            case REMOTE_CONSOLE -> "Sent from a remote console";
+            case ENTITY -> "Sent by an entity";
+            case COMMAND_BLOCK -> "Sent by a command block";
+            case PROXIED -> "Sent by a proxied command sender";
+            default -> "Unknown sender type";
+        };
+    }
+
+    /**
+     * Retrieves the sender type as a short code.
+     *
+     * @return the sender type as a short code, can be "P", "C", "R", "E", "B", "X" or "?".
+     */
+    public String senderTypeCode() {
+        return switch (senderType()) {
+            case PLAYER -> "P";
+            case CONSOLE -> "C";
+            case REMOTE_CONSOLE -> "R";
+            case ENTITY -> "E";
+            case COMMAND_BLOCK -> "B";
+            case PROXIED -> "X";
+            default -> "?";
+        };
+    }
+
+    /**
+     * Retrieves a description of the sender type.
+     *
+     * @return a description of the sender type.
+     */
+    public String senderTypeDescription() {
+        return switch (senderType()) {
+            case PLAYER -> "A player is a human user who is interacting with the game.";
+            case CONSOLE -> "The console is the main interface for administering the game.";
+            case REMOTE_CONSOLE -> "A remote console is a console that is accessed from a remote location.";
+            case ENTITY -> "An entity is a non-player character (such as mobs) in the game.";
+            case COMMAND_BLOCK -> "A command block is a block that can execute commands.";
+            case PROXIED -> "A proxied sender is a command sender that is proxied through /execute, or similar.";
+            default -> "Unknown sender type";
+        };
+    }
+
+    /**
+     * Checks if the sender is a player.
+     *
+     * @return true if the sender is a player, false otherwise.
+     */
+    public boolean isPlayer() {
+        return senderType() == SenderTypes.PLAYER;
+    }
+
+    /**
+     * Checks if the sender is the console.
+     *
+     * @return true if the sender is the console, false otherwise.
+     */
+    public boolean isConsole() {
+        return senderType() == SenderTypes.CONSOLE;
+    }
+
+    /**
+     * Checks if the sender is a remote console.
+     *
+     * @return true if the sender is a remote console, false otherwise.
+     */
+    public boolean isRemoteConsole() {
+        return senderType() == SenderTypes.REMOTE_CONSOLE;
+    }
+
+    /**
+     * Checks if the sender is an entity.
+     *
+     * @return true if the sender is an entity, false otherwise.
+     */
+    public boolean isEntity() {
+        return senderType() == SenderTypes.ENTITY;
+    }
+
+    /**
+     * Checks if the sender is a command block.
+     *
+     * @return true if the sender is a command block, false otherwise.
+     */
+    public boolean isBlock() {
+        return senderType() == SenderTypes.COMMAND_BLOCK;
+    }
+
+    /**
+     * Checks if the sender is a proxied command sender.
+     *
+     * @return true if the sender is a proxied command sender, false otherwise.
+     */
+    public boolean isProxied() {
+        return senderType() == SenderTypes.PROXIED;
+    }
+
+    /**
+     * Retrieves the sender type of the command sender.
+     *
+     * @return the sender type.
+     */
+    public SenderTypes senderType() {
+        if (sender() instanceof Player) return SenderTypes.PLAYER;
+        if (sender() instanceof ConsoleCommandSender) return SenderTypes.CONSOLE;
+        if (sender() instanceof RemoteConsoleCommandSender) return SenderTypes.REMOTE_CONSOLE;
+        if (sender() instanceof Entity) return SenderTypes.ENTITY;
+        if (sender() instanceof BlockCommandSender) return SenderTypes.COMMAND_BLOCK;
+        if (sender() instanceof ProxiedCommandSender) return SenderTypes.PROXIED;
+        return SenderTypes.UNKNOWN;
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the message to include in the exception
+     * @throws CmdException if the predicate is true
+     */
+    public void throwIf(@NotNull Predicate<CommandWrapper> predicate, @NotNull String message) {
+        if (predicate.test(this)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the message to include in the exception
+     * @throws CmdException if the predicate is true
+     */
+    public void throwIf(@NotNull BooleanChecker predicate, @NotNull String message) {
+        if (predicate.check()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the message to include in the exception
+     * @throws CmdException if the predicate is false
+     */
+    public void throwIfNot(@NotNull Predicate<CommandWrapper> predicate, @NotNull String message) {
+        if (!predicate.test(this)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the message to include in the exception
+     * @throws CmdException if the predicate is false
+     */
+    public void throwIfNot(@NotNull BooleanChecker predicate, @NotNull String message) {
+        if (!predicate.check()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given component message if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the component message to include in the exception
+     * @throws CmdException if the predicate is true
+     */
+    public void throwIf(@NotNull Predicate<CommandWrapper> predicate, @NotNull Component message) {
+        if (predicate.test(this)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given component message if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the component message to include in the exception
+     * @throws CmdException if the predicate is true
+     */
+    public void throwIf(@NotNull BooleanChecker predicate, @NotNull Component message) {
+        if (predicate.check()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given component message if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the component message to include in the exception
+     * @throws CmdException if the predicate is false
+     */
+    public void throwIfNot(@NotNull Predicate<CommandWrapper> predicate, @NotNull Component message) {
+        if (!predicate.test(this)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given component message if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param message   the component message to include in the exception
+     * @throws CmdException if the predicate is false
+     */
+    public void throwIfNot(@NotNull BooleanChecker predicate, @NotNull Component message) {
+        if (!predicate.check()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given runnable if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is true
+     * @throws CmdException if the predicate is true
+     */
+    public void throwAndRunIf(@NotNull Predicate<CommandWrapper> predicate, @NotNull Runnable runnable) {
+        if (predicate.test(this)) {
+            runnable.run();
+            check(c -> false);
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given runnable if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is true
+     * @throws CmdException if the predicate is true
+     */
+    public void throwAndRunIf(@NotNull BooleanChecker predicate, @NotNull Runnable runnable) {
+        if (predicate.check()) {
+            runnable.run();
+            check(c -> false);
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given runnable if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is false
+     * @throws CmdException if the predicate is false
+     */
+    public void throwAndRunIfNot(@NotNull Predicate<CommandWrapper> predicate, @NotNull Runnable runnable) {
+        if (!predicate.test(this)) {
+            runnable.run();
+            check(c -> false);
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given runnable if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is false
+     * @throws CmdException if the predicate is false
+     */
+    public void throwAndRunIfNot(@NotNull BooleanChecker predicate, @NotNull Runnable runnable) {
+        if (!predicate.check()) {
+            runnable.run();
+            check(c -> false);
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given objects are not equal.
+     *
+     * @param obj1    the first object to compare
+     * @param obj2    the second object to compare
+     * @param message the message to include in the exception
+     * @throws CmdException if the objects are not equal
+     */
+    public void throwIfNotEqual(@NotNull Object obj1, @NotNull Object obj2, @NotNull String message) {
+        if (!obj1.equals(obj2)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given objects are not equal.
+     *
+     * @param obj1    the first object to compare
+     * @param obj2    the second object to compare
+     * @param message the message to include in the exception
+     * @throws CmdException if the objects are not equal
+     */
+    public void throwIfNotEqual(@NotNull Object obj1, @NotNull Object obj2, @NotNull Component message) {
+        if (!obj1.equals(obj2)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given runnable throws an exception.
+     *
+     * @param runnable the runnable to run
+     * @param message  the message to include in the exception
+     * @throws CmdException if the runnable throws an exception
+     */
+    public void throwIfThrows(@NotNull Runnable runnable, @NotNull String message) {
+        try {
+            runnable.run();
+        } catch (@NotNull Exception e) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given runnable throws an exception.
+     *
+     * @param runnable the runnable to run
+     * @param message  the message to include in the exception
+     * @throws CmdException if the runnable throws an exception
+     */
+    public void throwIfThrows(@NotNull Runnable runnable, @NotNull Component message) {
+        try {
+            runnable.run();
+        } catch (@NotNull Exception e) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given collection is empty.
+     *
+     * @param collection the collection to check
+     * @param message    the message to include in the exception
+     * @throws CmdException if the collection is empty
+     */
+    public void throwIfEmpty(@Nullable Collection<?> collection, @NotNull String message) {
+        if (collection == null || collection.isEmpty()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given string is empty.
+     *
+     * @param string  the string to check
+     * @param message the message to include in the exception
+     * @throws CmdException if the string is empty
+     */
+    public void throwIfEmpty(@Nullable String string, @NotNull String message) {
+        if (string == null || string.isEmpty()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given object is null.
+     *
+     * @param obj     the object to check
+     * @param message the message to include in the exception
+     * @throws CmdException if the object is null
+     */
+    public void throwIfNull(@Nullable Object obj, @NotNull String message) {
+        if (obj == null) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given component message if the given object is null.
+     *
+     * @param obj     the object to check
+     * @param message the component message to include in the exception
+     * @throws CmdException if the object is null
+     */
+    public void throwIfNull(@Nullable Object obj, @NotNull Component message) {
+        if (obj == null) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given message if the given object is not null.
+     *
+     * @param obj     the object to check
+     * @param message the message to include in the exception
+     * @throws CmdException if the object is not null
+     */
+    public void throwIfNotNull(@Nullable Object obj, @NotNull String message) {
+        if (obj != null) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Throws a {@link CmdException} with the given component message if the given object is not null.
+     *
+     * @param obj     the object to check
+     * @param message the component message to include in the exception
+     * @throws CmdException if the object is not null
+     */
+    public void throwIfNotNull(@Nullable Object obj, @NotNull Component message) {
+        if (obj != null) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Retrieves the entire input string of the command.
+     *
+     * @return the input string of the command.
+     */
+    @NotNull
+    public String input() {
+        return context.getInput();
+    }
+
+    /**
+     * Runs the given runnable if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is true
+     */
+    public void runIf(@NotNull Predicate<CommandWrapper> predicate, @NotNull Runnable runnable) {
+        if (predicate.test(this)) {
+            runnable.run();
+        }
+    }
+
+    /**
+     * Runs the given runnable if the given predicate is true.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is true
+     */
+    public void runIf(@NotNull BooleanChecker predicate, @NotNull Runnable runnable) {
+        if (predicate.check()) {
+            runnable.run();
+        }
+    }
+
+    /**
+     * Runs the given runnable if the command throws an exception.
+     *
+     * @param runnable the runnable to run (the one that throws the exception)
+     * @param ifError  the runnable to run if the command does not throw an exception
+     */
+    public void ifThrows(@NotNull Runnable runnable, @NotNull Runnable ifError) {
+        try {
+            runnable.run();
+        } catch (Exception e) {
+            ifError.run();
+        }
+    }
+
+    /**
+     * Runs the given runnable if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is false
+     */
+    public void runIfNot(@NotNull Predicate<CommandWrapper> predicate, @NotNull Runnable runnable) {
+        if (!predicate.test(this)) {
+            runnable.run();
+        }
+    }
+
+    /**
+     * Runs the given runnable if the given predicate is false.
+     *
+     * @param predicate the predicate to evaluate
+     * @param runnable  the runnable to run if the predicate is false
+     */
+    public void runIfNot(@NotNull BooleanChecker predicate, @NotNull Runnable runnable) {
+        if (!predicate.check()) {
+            runnable.run();
+        }
+    }
+
+    /**
+     * Checks whether the command sender meets the specified condition.
+     *
+     * @param type the type of check to be performed.
+     * @throws CmdException if the check fails.
+     */
+    public void check(@NotNull CheckType type) {
+        SenderTypes.valueOf(type.name()).check(this);
+    }
+
+    /**
+     * Checks whether the command sender meets the specified condition and runs the given runnable if not.
+     *
+     * @param type the type of check to be performed.
+     * @param task the runnable to run if the check fails.
+     * @throws CmdException if the check fails.
+     */
+    public void check(@NotNull CheckType type, @NotNull Runnable task) {
+        if (!(type == CheckType.PLAYER && isPlayer() ||
+                type == CheckType.CONSOLE && isConsole() ||
+                type == CheckType.REMOTE_CONSOLE && isRemoteConsole() ||
+                type == CheckType.ENTITY && isEntity() ||
+                type == CheckType.COMMAND_BLOCK && isBlock() ||
+                type == CheckType.PROXIED_SENDER && isProxied())) {
+            task.run();
+            check(c -> false);
+        }
+    }
+
+    /**
+     * Checks whether the command sender meets the specified condition and throws a custom exception if not.
+     *
+     * @param type    the type of check to be performed.
+     * @param message the custom message to be sent if the check fails.
+     * @throws CmdException if the check fails.
+     */
+    public void check(@NotNull CheckType type, @NotNull String message) {
+        SenderTypes.valueOf(type.name()).check(this, message);
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, a CmdException is thrown.
+     *
+     * @param check the custom check to add
+     * @throws CmdException if the check fails
+     */
+    public void check(@NotNull Predicate<CommandWrapper> check) {
+        if (!check.test(this)) {
+            throw new CmdException((Component) null, null);
+        }
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, a CmdException is thrown.
+     *
+     * @param check the custom check to add
+     * @throws CmdException if the check fails
+     */
+    public void check(@NotNull BooleanChecker check) {
+        if (!check.check()) {
+            throw new CmdException((Component) null, null);
+        }
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, a CmdException is thrown.
+     *
+     * @param check   the custom check to add
+     * @param message the custom message to be sent if the check fails
+     * @throws CmdException if the check fails
+     */
+    public void check(@NotNull Predicate<CommandWrapper> check, @NotNull String message) {
+        if (!check.test(this)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, a CmdException is thrown.
+     *
+     * @param check   the custom check to add
+     * @param message the custom message to be sent if the check fails
+     * @throws CmdException if the check fails
+     */
+    public void check(@NotNull BooleanChecker check, @NotNull String message) {
+        if (!check.check()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, a CmdException is thrown.
+     *
+     * @param check   the custom check to add
+     * @param message the custom message to be sent if the check fails
+     * @throws CmdException if the check fails
+     */
+    public void check(@NotNull Predicate<CommandWrapper> check, @NotNull Component message) {
+        if (!check.test(this)) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, a CmdException is thrown.
+     *
+     * @param check   the custom check to add
+     * @param message the custom message to be sent if the check fails
+     * @throws CmdException if the check fails
+     */
+    public void check(@NotNull BooleanChecker check, @NotNull Component message) {
+        if (!check.check()) {
+            throw new CmdException(message, sender());
+        }
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, the specified task is executed.
+     *
+     * @param check the custom check to add
+     * @param task  the task to execute if the check fails
+     */
+    public void check(@NotNull Predicate<CommandWrapper> check, @NotNull Runnable task) {
+        if (!check.test(this)) {
+            task.run();
+            check(() -> false);
+        }
+    }
+
+    /**
+     * Adds a custom check to the command.
+     * If the check fails, the specified task is executed.
+     *
+     * @param check the custom check to add
+     * @param task  the task to execute if the check fails
+     */
+    public void check(@NotNull BooleanChecker check, @NotNull Runnable task) {
+        if (!check.check()) {
+            task.run();
+            check(() -> false);
+        }
+    }
+
+    /**
+     * Runs the specified runnable after the specified task.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param runnable the runnable to run after the task
+     */
+    public void runBothRunnable(@NotNull Runnable task, @NotNull Runnable runnable) {
+        task.run();
+        runnable.run();
+    }
+
+    /**
+     * Runs the specified task and then runs the specified function.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param function the function to run after the task
+     * @return the result of the function
+     */
+    public <T> T runAndThenGet(@NotNull Runnable task, @NotNull Supplier<T> function) {
+        task.run();
+        return function.get();
+    }
+
+    /**
+     * Runs the specified task.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task the task to run
+     */
+    public void run(@NotNull Runnable task) {
+        task.run();
+    }
+
+    /**
+     * Runs the specified task asynchronously.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task the task to run
+     */
+    public void runAsync(@NotNull Runnable task) {
+        CompletableFuture.runAsync(task);
+    }
+
+    /**
+     * Runs the specified task asynchronously.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param runnable the runnable to run after the task
+     */
+    public void runBothRunnableAsync(@NotNull Runnable task, @NotNull Runnable runnable) {
+        CompletableFuture.runAsync(() -> {
+            task.run();
+            runnable.run();
+        });
+    }
+
+    /**
+     * Runs the specified task asynchronously.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param executor the executor to run the task on
+     */
+    public void runAsync(@NotNull Runnable task, @NotNull Executor executor) {
+        CompletableFuture.runAsync(task, executor);
+    }
+
+    /**
+     * Runs the specified task asynchronously.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param runnable the runnable to run after the task
+     * @param executor the executor to run the task on
+     */
+    public void runBothRunnableAsync(@NotNull Runnable task, @NotNull Runnable runnable, @NotNull Executor executor) {
+        CompletableFuture.runAsync(() -> {
+            task.run();
+            runnable.run();
+        }, executor);
+    }
+
+    /**
+     * Runs the both of the runnable in different threads.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param runnable the runnable to run after the task
+     * @param executor the executor to run the task on
+     */
+    public void runBothRunnableAsync(@NotNull Runnable task, @NotNull Runnable runnable, @NotNull Executor executor, @NotNull Executor executor2) {
+        CompletableFuture.runAsync(task, executor);
+        CompletableFuture.runAsync(runnable, executor2);
+    }
+
+    /**
+     * Runs the specified task asynchronously and waits for it to complete.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task the task to run
+     */
+    public void runAsyncJoin(@NotNull Runnable task) {
+        CompletableFuture.runAsync(task).join();
+    }
+
+    /**
+     * Runs the specified task asynchronously and waits for it to complete.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param executor the executor to run the task on
+     */
+    public void runAsyncJoin(@NotNull Runnable task, @NotNull Executor executor) {
+        CompletableFuture.runAsync(task, executor).join();
+    }
+
+    /**
+     * Runs the both of the runnable in different threads and waits for them to complete.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param runnable the runnable to run after the task
+     */
+    public void runBothRunnableAsyncJoin(@NotNull Runnable task, @NotNull Runnable runnable) {
+        CompletableFuture.runAsync(task).join();
+        CompletableFuture.runAsync(runnable).join();
+    }
+
+    /**
+     * Runs the both of the runnable in different threads and waits for them to complete.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task     the task to run
+     * @param runnable the runnable to run after the task
+     * @param executor the executor to run the task and runnable on
+     */
+    public void runBothRunnableAsyncJoin(@NotNull Runnable task, @NotNull Runnable runnable, @NotNull Executor executor) {
+        CompletableFuture.runAsync(task, executor).join();
+        CompletableFuture.runAsync(runnable, executor).join();
+    }
+
+    /**
+     * Runs the both of the runnable in different threads and waits for them to complete.
+     * Somewhat useful for people who like to have one line of code
+     *
+     * @param task      the task to run
+     * @param runnable  the runnable to run after the task
+     * @param executor  the executor to run the task on
+     * @param executor2 the executor to run the runnable on
+     */
+    public void runBothRunnableAsyncJoin(@NotNull Runnable task, @NotNull Runnable runnable, @NotNull Executor executor, @NotNull Executor executor2) {
+        CompletableFuture.runAsync(task, executor).join();
+        CompletableFuture.runAsync(runnable, executor2).join();
+    }
+
+    /**
+     * Checks whether the command sender is of the specified types.
+     *
+     * @param types the types of sender to check
+     * @return true if the command sender is of the specified types, false otherwise
+     */
+    public boolean canExecute(@NotNull SenderTypes... types) {
+        return Arrays.stream(types)
+                .anyMatch(type -> senderType() == type);
+    }
+
+    /**
+     * Retrieves the location of the player (if the sender is a player).
+     *
+     * @return the location of the player.
+     * @throws ClassCastException if the sender is not a player
+     */
+    public Location location() {
+        return player().getLocation();
+    }
+
+    /**
+     * Retrieves the world of the player (if the sender is a player).
+     *
+     * @return the world of the player.
+     * @throws ClassCastException if the sender is not a player
+     */
+    public World world() {
+        return player().getWorld();
+    }
+
+    /**
+     * Teleports the player (if the sender is a player).
+     * Not recommended, use {@link #teleportAsync(Location)} instead.
+     *
+     * @return if the teleportation was successful
+     * @throws ClassCastException if the sender is not a player
+     */
+    public boolean teleport(@NotNull Location location) {
+        return player().teleport(location);
+    }
+
+    /**
+     * Teleports the player asynchronously (if the sender is a player).
+     *
+     * @return if the teleportation was successful
+     * @throws ClassCastException if the sender is not a player
+     */
+    public CompletableFuture<Boolean> teleportAsync(@NotNull Location location) {
+        return player().teleportAsync(location);
+    }
+
+    /**
+     * Retrieves the name of the player (if the sender is a player).
+     *
+     * @return the name of the player
+     * @throws ClassCastException if the sender is not a player
+     */
+    public String name() {
+        return player().getName();
+    }
+
+    /**
+     * Retrieves the name of the player (if the sender is a player).
+     *
+     * @return the name of the player
+     * @throws ClassCastException if the sender is not a player
+     */
+    public String playerName() {
+        return name();
+    }
+
+    /**
+     * Retrieves the UUID of the player (if the sender is a player).
+     *
+     * @return the UUID of the player
+     * @throws ClassCastException if the sender is not a player
+     */
+    public UUID uuid() {
+        return player().getUniqueId();
+    }
+
+    /**
+     * Retrieves the UUID of the player (if the sender is a player).
+     *
+     * @return the UUID of the player
+     * @throws ClassCastException if the sender is not a player
+     */
+    public UUID playerUuid() {
+        return uuid();
+    }
+
+    /**
+     * Retrieves the inventory of the player (if the sender is a player).
+     *
+     * @return the inventory of the player
+     * @throws ClassCastException if the sender is not a player
+     */
+    public PlayerInventory inventory() {
+        return player().getInventory();
+    }
+
+    /**
+     * Adds an item to the player's inventory.
+     *
+     * @param item the item to add
+     */
+    public void add(@NotNull ItemStack item) {
+        player().getInventory().addItem(item);
+    }
+
+    /**
+     * Retrieves the game mode of the player (if the sender is a player).
+     *
+     * @return the game mode of the player
+     * @throws ClassCastException if the sender is not a player
+     */
+    public GameMode gameMode() {
+        return player().getGameMode();
+    }
+
+    /**
+     * Sets the game mode of the player (if the sender is a player).
+     *
+     * @param mode the game mode to set
+     * @throws ClassCastException if the sender is not a player
+     */
+    public void gameMode(@NotNull GameMode mode) {
+        player().setGameMode(mode);
+    }
+
+    /**
+     * Checks whether the player is flying (if the sender is a player).
+     *
+     * @return true if the player is flying, false otherwise
+     * @throws ClassCastException if the sender is not a player
+     */
+    public boolean flying() {
+        return player().isFlying();
+    }
+
+    /**
+     * Sets whether the player is flying (if the sender is a player).
+     *
+     * @param value the value to set
+     * @throws ClassCastException if the sender is not a player
+     */
+    public void flying(boolean value) {
+        player().setFlying(value);
+    }
+
+    /**
+     * Toggles the flying state of the player (if the sender is a player).
+     * Enables flying if the player is not flying, and disables flying if the player is flying.
+     *
+     * @throws ClassCastException if the sender is not a player
+     */
+    public void flyIfNot() {
+        flying(!flying());
+    }
+
+    /**
+     * Checks whether the command sender is of the specified types.
+     *
+     * @param types the types of sender to check
+     * @return true if the command sender is of the specified types, false otherwise
+     */
+    public boolean canExecute(@NotNull ExecutableSender types) {
+        return canExecute(types.types());
+    }
+
+    /**
+     * Retrieves the underlying {@link CommandContext} of the command.
+     *
+     * @return the command context of the command.
+     */
+    @Override
+    @NotNull
+    public CommandContext<CommandSourceStack> context() {
+        return context;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/command/ExecutableSender.java b/src/main/java/dev/vansen/commandutils/command/ExecutableSender.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2d076645e97c1317b83ca4f84d96ce6d7c4859c
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/command/ExecutableSender.java
@@ -0,0 +1,57 @@
+package dev.vansen.commandutils.command;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dev.vansen.commandutils.sender.SenderTypes;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * Represents sender(s) that can execute the default executor.
+ */
+@SuppressWarnings("unused")
+public final class ExecutableSender {
+
+    private static SenderTypes[] senderTypes;
+
+    /**
+     * Creates a new instance of the ExecutableSender class.
+     */
+    public ExecutableSender(@NotNull SenderTypes[] senderTypes) {
+        ExecutableSender.senderTypes = senderTypes;
+    }
+
+    /**
+     * Sets the types of senders that are allowed to execute the command.
+     *
+     * @param types the types of senders that are allowed to execute the command.
+     * @return this ExecutableSender instance.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public static ExecutableSender types(@NotNull SenderTypes... types) {
+        return new ExecutableSender(types);
+    }
+
+    /**
+     * Sets the types of senders that are allowed to execute the command from a list.
+     *
+     * @param types the list of types of senders that are allowed to execute the command.
+     * @return this ExecutableSender instance.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public static ExecutableSender types(@NotNull List<SenderTypes> types) {
+        return new ExecutableSender(types.toArray(new SenderTypes[0]));
+    }
+
+    /**
+     * Returns the types of senders that are allowed to execute the command.
+     *
+     * @return the types of senders that are allowed to execute the command.
+     */
+    @NotNull
+    public SenderTypes[] types() {
+        return senderTypes;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/command/Position.java b/src/main/java/dev/vansen/commandutils/command/Position.java
new file mode 100644
index 0000000000000000000000000000000000000000..607fc96f566c3bd4ee907171ea85cdde5609e4c3
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/command/Position.java
@@ -0,0 +1,15 @@
+package dev.vansen.commandutils.command;
+
+/**
+ * An enumeration for specifying the position.
+ */
+public enum Position {
+    /**
+     * Represents the first position.
+     */
+    FIRST,
+    /**
+     * Represents the last position.
+     */
+    LAST
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/completer/CompletionHandler.java b/src/main/java/dev/vansen/commandutils/completer/CompletionHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..7920844f9e64fe9cf10d11b0952f88c34659c41b
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/completer/CompletionHandler.java
@@ -0,0 +1,29 @@
+package dev.vansen.commandutils.completer;
+
+import com.mojang.brigadier.suggestion.Suggestions;
+import dev.vansen.commandutils.command.CommandWrapper;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * An interface for handling tab completion in commands.
+ * Implementations of this interface should define how suggestions are generated based on the command context
+ * and the provided {@link SuggestionsBuilderWrapper}.
+ */
+@SuppressWarnings("unused")
+@FunctionalInterface
+public interface CompletionHandler {
+
+    /**
+     * Generates completion suggestions based on the provided command context and suggestions builder.
+     * Note, this method will be called with a different SuggestionsBuilderWrapper each time, so storing the SuggestionsBuilderWrapper for future use is not recommended.
+     *
+     * @param context the {@link CommandWrapper} containing context information for the command.
+     * @param wrapper the {@link SuggestionsBuilderWrapper} used to build and provide suggestions.
+     * @return a {@link CompletableFuture} that will be completed with the {@link Suggestions} for tab completion.
+     * The future will contain the suggestions generated based on the provided context and wrapper.
+     */
+    @NotNull
+    CompletableFuture<Suggestions> complete(@NotNull CommandWrapper context, @NotNull SuggestionsBuilderWrapper wrapper);
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/completer/Suggestion.java b/src/main/java/dev/vansen/commandutils/completer/Suggestion.java
new file mode 100644
index 0000000000000000000000000000000000000000..e43da8f45a642431267bde6991b1d206bd644904
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/completer/Suggestion.java
@@ -0,0 +1,133 @@
+package dev.vansen.commandutils.completer;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.mojang.brigadier.Message;
+import io.papermc.paper.command.brigadier.MessageComponentSerializer;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Represents a suggestion with text and optional tooltip information.
+ */
+@SuppressWarnings({"unused"})
+public final class Suggestion {
+
+    /**
+     * The text of the suggestion.
+     */
+    private final @NotNull String text;
+
+    /**
+     * The tooltip associated with the suggestion, if any.
+     */
+    private Message tooltip;
+
+    /**
+     * Creates a new suggestion with the given text.
+     *
+     * @param text the text of the suggestion
+     */
+    public Suggestion(@NotNull String text) {
+        this.text = text;
+    }
+
+    /**
+     * Creates a new suggestion with the given text and tooltip.
+     *
+     * @param text    the text of the suggestion
+     * @param tooltip the tooltip associated with the suggestion
+     */
+    public Suggestion(@NotNull String text, @NotNull String tooltip) {
+        this.text = text;
+        this.tooltip = MessageComponentSerializer.message().serializeOrNull(MiniMessage.miniMessage().deserializeOrNull(tooltip));
+    }
+
+    /**
+     * Creates a new suggestion with the given text and tooltip.
+     *
+     * @param text    the text of the suggestion
+     * @param tooltip the tooltip associated with the suggestion
+     */
+    public Suggestion(@NotNull String text, @NotNull Component tooltip) {
+        this.text = text;
+        this.tooltip = MessageComponentSerializer.message().serializeOrNull(tooltip);
+    }
+
+    /**
+     * Creates a new suggestion with the given text and tooltip.
+     *
+     * @param text    the text of the suggestion
+     * @param tooltip the tooltip associated with the suggestion
+     */
+    public Suggestion(@NotNull String text, @NotNull Message tooltip) {
+        this.text = text;
+        this.tooltip = tooltip;
+    }
+
+    /**
+     * Factory method to create a new instance of {@link Suggestion}.
+     *
+     * @param text the text of the suggestion
+     * @return a new {@link Suggestion} instance
+     */
+    @CanIgnoreReturnValue
+    public Suggestion of(@NotNull String text) {
+        return new Suggestion(text);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link Suggestion}.
+     *
+     * @param text    the text of the suggestion
+     * @param tooltip the tooltip associated with the suggestion
+     * @return a new {@link Suggestion} instance
+     */
+    @CanIgnoreReturnValue
+    public Suggestion of(@NotNull String text, @NotNull String tooltip) {
+        return new Suggestion(text, tooltip);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link Suggestion}.
+     *
+     * @param text    the text of the suggestion
+     * @param tooltip the tooltip associated with the suggestion
+     * @return a new {@link Suggestion} instance
+     */
+    @CanIgnoreReturnValue
+    public Suggestion of(@NotNull String text, @NotNull Component tooltip) {
+        return new Suggestion(text, tooltip);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link Suggestion}.
+     *
+     * @param text    the text of the suggestion
+     * @param tooltip the tooltip associated with the suggestion
+     * @return a new {@link Suggestion} instance
+     */
+    @CanIgnoreReturnValue
+    public Suggestion of(@NotNull String text, @NotNull Message tooltip) {
+        return new Suggestion(text, tooltip);
+    }
+
+    /**
+     * Returns the text of the suggestion.
+     *
+     * @return the text of the suggestion
+     */
+    public @NotNull String text() {
+        return text;
+    }
+
+    /**
+     * Returns the tooltip associated with the suggestion, if any.
+     *
+     * @return the tooltip associated with the suggestion, or null if none
+     */
+    public @Nullable Message tooltip() {
+        return tooltip;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/completer/SuggestionsBuilderWrapper.java b/src/main/java/dev/vansen/commandutils/completer/SuggestionsBuilderWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e282492573dcc285fc6fbebf19dd88d6ab50ef1
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/completer/SuggestionsBuilderWrapper.java
@@ -0,0 +1,407 @@
+package dev.vansen.commandutils.completer;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.mojang.brigadier.context.StringRange;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import dev.vansen.commandutils.completer.info.SuggestionsHelper;
+import io.papermc.paper.command.brigadier.MessageComponentSerializer;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.stream.StreamSupport;
+
+/**
+ * A wrapper class for {@link SuggestionsBuilder} to simplify and enhance the process of
+ * building tab completion suggestions.
+ * This class provides methods to add suggestions and build the completion results.
+ */
+@SuppressWarnings({"unused"})
+public record SuggestionsBuilderWrapper(@NotNull SuggestionsBuilder builder) {
+
+    /**
+     * Constructs a new {@link SuggestionsBuilderWrapper} with the specified {@link SuggestionsBuilder}.
+     *
+     * @param builder the {@link SuggestionsBuilder} instance to wrap. This should not be null.
+     */
+    public SuggestionsBuilderWrapper {
+    }
+
+    /**
+     * Adds suggestions to the list of completions.
+     *
+     * @param suggestions the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull String... suggestions) {
+        Arrays.stream(suggestions)
+                .forEach(builder::suggest);
+        return this;
+    }
+
+    /**
+     * Adds suggestions to the list of completions with an associated tooltip.
+     *
+     * @param suggestions the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull Map<String, String> suggestions) {
+        suggestions.forEach((suggestion, tooltip) -> builder.suggest(suggestion, MessageComponentSerializer.message().serializeOrNull(MiniMessage.miniMessage().deserializeOrNull(tooltip))));
+        return this;
+    }
+
+    /**
+     * Adds suggestions to the list of completions with an associated tooltip.
+     *
+     * @param suggestions the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @SafeVarargs
+    @NotNull
+    @CanIgnoreReturnValue
+    public final SuggestionsBuilderWrapper suggest(@NotNull Map<String, Component>... suggestions) {
+        Arrays.stream(suggestions)
+                .forEach(map -> map.forEach((suggestion, tooltip) -> builder.suggest(suggestion, MessageComponentSerializer.message().serializeOrNull(tooltip))));
+        return this;
+    }
+
+    /**
+     * Adds multiple suggestions to the list of completions.
+     *
+     * @param suggestions the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull Iterable<String> suggestions) {
+        suggestions.forEach(builder::suggest);
+        return this;
+    }
+
+    /**
+     * Adds multiple suggestions to the list of completions with an associated tooltip.
+     *
+     * @param suggestions the suggestions to be added.
+     * @param tooltip     the tooltip to be shown with the suggestion.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull Iterable<Suggestion> suggestions, @NotNull String tooltip) {
+        suggestions.forEach(suggestion -> builder.suggest(suggestion.text(), MessageComponentSerializer.message().serializeOrNull(MiniMessage.miniMessage().deserializeOrNull(tooltip))));
+        return this;
+    }
+
+    /**
+     * Adds multiple suggestions to the list of completions with an associated tooltip.
+     *
+     * @param suggestions the suggestions to be added.
+     * @param tooltip     the tooltip to be shown with the suggestion.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull Iterable<Suggestion> suggestions, @NotNull Component tooltip) {
+        suggestions.forEach(suggestion -> builder.suggest(suggestion.text(), MessageComponentSerializer.message().serializeOrNull(tooltip)));
+        return this;
+    }
+
+    /**
+     * Adds a suggestion to the list of completions with an associated tooltip.
+     *
+     * @param suggestion the text to be suggested.
+     * @param tooltip    the tooltip to be shown with the suggestion.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull String suggestion, @NotNull String tooltip) {
+        builder.suggest(suggestion, MessageComponentSerializer.message().serializeOrNull(MiniMessage.miniMessage().deserializeOrNull(tooltip)));
+        return this;
+    }
+
+    /**
+     * Adds a suggestion to the list of completions with an associated tooltip.
+     *
+     * @param suggestion the text to be suggested.
+     * @param tooltip    the tooltip to be shown with the suggestion.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull String suggestion, @NotNull Component tooltip) {
+        builder.suggest(suggestion, MessageComponentSerializer.message().serializeOrNull(tooltip));
+        return this;
+    }
+
+    /**
+     * Adds a suggestion to the list of completions with an associated tooltip.
+     *
+     * @param suggestion the suggestion to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull Suggestion suggestion) {
+        Optional.ofNullable(suggestion.tooltip())
+                .ifPresentOrElse(
+                        tooltip -> builder.suggest(suggestion.text(), tooltip),
+                        () -> builder.suggest(suggestion.text()));
+        return this;
+    }
+
+    /**
+     * Adds multiple suggestions to the list of completions.
+     *
+     * @param suggestions the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(@NotNull Suggestion... suggestions) {
+        Arrays.stream(suggestions)
+                .forEach(this::suggest);
+        return this;
+    }
+
+    /**
+     * Adds a suggestion to the list of completions.
+     *
+     * @param value the suggestion to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(int value) {
+        builder.suggest(value);
+        return this;
+    }
+
+    /**
+     * Adds a suggestion to the list of completions with an associated tooltip.
+     *
+     * @param value   the suggestion to be added.
+     * @param tooltip the tooltip to be shown with the suggestion.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggest(int value, @NotNull String tooltip) {
+        builder.suggest(value, MessageComponentSerializer.message().serializeOrNull(MiniMessage.miniMessage().deserializeOrNull(tooltip)));
+        return this;
+    }
+
+    /**
+     * Adds list of suggestions to the list of completions if the current argument is equal to the specified value, or the current argument is empty.
+     *
+     * @param values the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggestIfCurrentStartsWith(@NotNull Iterable<String> values) {
+        if (helper().currentArgOr().isEmpty()) {
+            values.forEach(builder::suggest);
+            return this;
+        }
+        StreamSupport.stream(values.spliterator(), true)
+                .filter(this::startsWithCurrent)
+                .forEach(builder::suggest);
+        return this;
+    }
+
+    /**
+     * Adds list of suggestions to the list of completions if the current argument is equal to the specified value, or the current argument is empty.
+     *
+     * @param values the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggestIfCurrentStartsWith(@NotNull String... values) {
+        return suggestIfCurrentStartsWith(Arrays.asList(values));
+    }
+
+    /**
+     * Adds list of suggestions to the list of completions if the current argument is equal to the specified value, or the current argument is empty.
+     *
+     * @param values the suggestions to be added.
+     * @return this instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SuggestionsBuilderWrapper suggestIfCurrentStartsWith(@NotNull Iterable<String> values, @NotNull String tooltip) {
+        if (helper().currentArgOr().isEmpty()) {
+            values.forEach(builder::suggest);
+            return this;
+        }
+        StreamSupport.stream(values.spliterator(), true)
+                .filter(this::startsWithCurrent)
+                .forEach(suggestion -> suggest(suggestion, tooltip));
+        return this;
+    }
+
+    /**
+     * Checks if the specified value is the current argument or the current argument is empty.
+     *
+     * @param value the value to check
+     * @return true if the value is the current argument or the current argument is empty
+     */
+    public boolean isCurrent(@NotNull String value) {
+        return equalsOrEmpty(helper().currentArgOr(), value);
+    }
+
+    /**
+     * Checks if the specified value starts with the current argument or the current argument is empty.
+     *
+     * @param value the value to check
+     * @return true if the value starts with the current argument or the current argument is empty
+     */
+    public boolean startsWithCurrent(@NotNull String value) {
+        return startsWithOrEmpty(helper().currentArgOr(), value);
+    }
+
+    /**
+     * Checks if the specified value equals the check value or the value is empty.
+     *
+     * @param value the value to check
+     * @param check the check value
+     * @return true if the value equals the check value or the value is empty
+     */
+    public boolean equalsOrEmpty(@NotNull String value, @NotNull String check) {
+        return value.equals(check) || value.isEmpty();
+    }
+
+    /**
+     * Checks if the specified value starts with the check value or the value is empty.
+     *
+     * @param value the value to check
+     * @param check the check value
+     * @return true if the value starts with the check value or the value is empty
+     */
+    public boolean startsWithOrEmpty(@NotNull String value, @NotNull String check) {
+        return value.startsWith(check) || value.isEmpty();
+    }
+
+    /**
+     * Checks if the specified value starts with the check value and is not empty.
+     *
+     * @param value the value to check
+     * @param check the check value
+     * @return true if the value starts with the check value and is not empty
+     */
+    public boolean startsWithNotEmpty(@NotNull String value, @NotNull String check) {
+        return value.startsWith(check) && !value.isEmpty();
+    }
+
+    /**
+     * Returns the starting position of the suggestions.
+     *
+     * @return the starting position of the suggestions
+     */
+    public int start() {
+        return builder.getStart();
+    }
+
+    /**
+     * Returns the remaining text.
+     *
+     * @return the remaining text
+     */
+    public String remaining() {
+        return builder.getRemaining();
+    }
+
+    /**
+     * Returns the entire input text.
+     *
+     * @return the input text
+     */
+    public String input() {
+        return builder.getInput();
+    }
+
+    /**
+     * Returns the suggestions helper for this suggestions builder.
+     *
+     * @return the suggestions helper
+     */
+    public SuggestionsHelper helper() {
+        return new SuggestionsHelper(this);
+    }
+
+    /**
+     * Returns a new {@link SuggestionsBuilderWrapper} with the specified starting position.
+     *
+     * @param start the starting position
+     * @return a new {@link SuggestionsBuilderWrapper} with the specified starting position
+     */
+    @NotNull
+    public SuggestionsBuilderWrapper offset(int start) {
+        return new SuggestionsBuilderWrapper(builder.createOffset(start));
+    }
+
+    /**
+     * Returns an {@link CompletableFuture} containing an empty {@link Suggestions}.
+     *
+     * @return an {@link CompletableFuture} containing an empty {@link Suggestions}
+     */
+    @NotNull
+    public CompletableFuture<Suggestions> empty() {
+        return Suggestions.empty();
+    }
+
+    /**
+     * Returns an empty {@link Suggestions}.
+     *
+     * @return an empty {@link Suggestions}
+     */
+    @NotNull
+    public Suggestions emptyFuture() {
+        return new Suggestions(StringRange.at(0), new ArrayList<>());
+    }
+
+    /**
+     * Builds and returns the suggestions as a {@link Suggestions}.
+     * This will usually only work if the call is from CompletableFuture.
+     *
+     * @return a {@link Suggestions}.
+     */
+    @NotNull
+    public Suggestions buildFuture() {
+        return builder.build();
+    }
+
+    /**
+     * Builds and returns the suggestions as a {@link CompletableFuture}.
+     * This future will be completed with the suggestions once they are available.
+     *
+     * @return a {@link CompletableFuture} containing the {@link Suggestions}.
+     */
+    @NotNull
+    public CompletableFuture<Suggestions> build() {
+        return builder.buildFuture();
+    }
+
+    /**
+     * Returns the underlying {@link SuggestionsBuilder}.
+     * This would generally not be needed, but it is provided for convenience in-case you need to access the builder directly (likely for advanced usage).
+     *
+     * @return the underlying {@link SuggestionsBuilder}
+     */
+    @Override
+    @NotNull
+    public SuggestionsBuilder builder() {
+        return builder;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/completer/info/SuggestionsHelper.java b/src/main/java/dev/vansen/commandutils/completer/info/SuggestionsHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8d68bbbb80f81a25b68540c1728941b79fbcf75
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/completer/info/SuggestionsHelper.java
@@ -0,0 +1,167 @@
+package dev.vansen.commandutils.completer.info;
+
+import dev.vansen.commandutils.completer.SuggestionsBuilderWrapper;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A utility class for accessing argument details from a SuggestionsBuilderWrapper.
+ */
+@SuppressWarnings("unused")
+public final class SuggestionsHelper {
+    private final @NotNull String input;
+    private final @NotNull String inputWithoutCommand;
+    private final @NotNull List<String> arguments;
+
+    public SuggestionsHelper(@NotNull SuggestionsBuilderWrapper wrapper) {
+        this.input = wrapper.input().trim();
+        this.inputWithoutCommand = String.join(" ", Arrays.stream(input.split(" "))
+                .skip(1)
+                .toArray(String[]::new));
+        this.arguments = List.of(Arrays.stream(input.split(" "))
+                .skip(1)
+                .toArray(String[]::new));
+    }
+
+    /**
+     * Gets the arguments before the cursor.
+     *
+     * @return all arguments before the cursor as a string
+     */
+    public @NotNull String previousArgs() {
+        String[] args = input.split(" ");
+        if (args.length < 2) return "";
+        return String.join(" ", Arrays.copyOfRange(args, 1, args.length - 1));
+    }
+
+    /**
+     * Gets the last argument before the cursor.
+     * Returns an empty string if there is no previous argument.
+     *
+     * @return the last argument before the cursor
+     */
+    public @NotNull String previousArg() {
+        if (inputWithoutCommand.lastIndexOf(" ") == -1) return "";
+        return inputWithoutCommand.substring(inputWithoutCommand.lastIndexOf(" ", inputWithoutCommand.lastIndexOf(" ") - 1) + 1, inputWithoutCommand.lastIndexOf(" "));
+    }
+
+    /**
+     * Gets the last argument before the cursor, or the specified default value if there is no previous argument.
+     *
+     * @param defaultValue the default value to return if there is no previous argument
+     * @return the last argument before the cursor, or the default value
+     */
+    public @NotNull String previousArgOr(@NotNull String defaultValue) {
+        if (inputWithoutCommand.lastIndexOf(" ") == -1) return defaultValue;
+        return inputWithoutCommand.substring(inputWithoutCommand.lastIndexOf(" ", inputWithoutCommand.lastIndexOf(" ") - 1) + 1, inputWithoutCommand.lastIndexOf(" "));
+    }
+
+    /**
+     * Gets the current argument being typed.
+     *
+     * @return the current argument
+     */
+    public @NotNull String currentArg() {
+        if (inputWithoutCommand.lastIndexOf(" ") == -1) return inputWithoutCommand;
+        return inputWithoutCommand.substring(inputWithoutCommand.lastIndexOf(" ") + 1);
+    }
+
+    /**
+     * Gets the current argument being typed, or an empty string if there is no current argument (not typed yet).
+     *
+     * @return the current argument, or an empty string
+     */
+    public @NotNull String currentArgOr() {
+        if (inputWithoutCommand.lastIndexOf(" ") == -1) return "";
+        return inputWithoutCommand.substring(inputWithoutCommand.lastIndexOf(" ") + 1);
+    }
+
+    /**
+     * Gets the current argument being typed, or the specified default value if there is no current argument (not typed yet).
+     *
+     * @param defaultValue the default value
+     * @return the current argument, or the specified default value
+     */
+    public @NotNull String currentArgOr(@NotNull String defaultValue) {
+        if (inputWithoutCommand.lastIndexOf(" ") == -1) return defaultValue;
+        return inputWithoutCommand.substring(inputWithoutCommand.lastIndexOf(" ") + 1);
+    }
+
+    /**
+     * Gets the total number of arguments provided.
+     *
+     * @return the count of arguments
+     */
+    public int argCount() {
+        return arguments.size();
+    }
+
+    /**
+     * Gets the argument at the specified index.
+     *
+     * @param index the index
+     * @return the argument at the index, or an empty string if out of bounds
+     */
+    public @NotNull String argAt(int index) {
+        return index >= 0 && index < arguments.size() ? arguments.get(index) : "";
+    }
+
+    /**
+     * Gets the arguments before the specified index.
+     *
+     * @param index the index
+     * @return the arguments before the index as a string
+     */
+    public @NotNull String argsBefore(int index) {
+        if (index < 0) return "";
+        if (index >= arguments.size()) return String.join(" ", arguments.subList(0, arguments.size()));
+        return String.join(" ", arguments.subList(0, index));
+    }
+
+    /**
+     * Gets the arguments between the specified indices.
+     *
+     * @param start the start index
+     * @param end   the end index
+     * @return the arguments between the indices as a string
+     */
+    public @NotNull String argsBetween(int start, int end) {
+        if (start < 0 || end < 0) return "";
+        if (start >= arguments.size() || end >= arguments.size()) return "";
+        return String.join(" ", arguments.subList(start, end));
+    }
+
+    /**
+     * Checks if the specified index has an argument.
+     *
+     * @param index the index
+     * @return true if the index has an argument, false otherwise
+     */
+    public boolean hasArg(int index) {
+        return index >= 0 && index < arguments.size();
+    }
+
+    /**
+     * Checks if the argument at the specified index is empty.
+     *
+     * @param index the index
+     * @return true if the argument is empty, false otherwise
+     */
+    public boolean isEmptyAt(int index) {
+        return argAt(index).isEmpty();
+    }
+
+    /**
+     * Gets the arguments after the specified index.
+     *
+     * @param index the index
+     * @return the arguments after the index as a string
+     */
+    public @NotNull String argsAfter(int index) {
+        if (index < 0) return "";
+        if (index >= arguments.size()) return "";
+        return String.join(" ", arguments.subList(index, arguments.size()));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/exceptions/APINotFoundException.java b/src/main/java/dev/vansen/commandutils/exceptions/APINotFoundException.java
new file mode 100644
index 0000000000000000000000000000000000000000..81e1ec58a9f2046e8d4aef29e0f1a126ce36de3a
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/exceptions/APINotFoundException.java
@@ -0,0 +1,14 @@
+package dev.vansen.commandutils.exceptions;
+
+/**
+ * An exception that is thrown when the command API is not set.
+ */
+public class APINotFoundException extends RuntimeException {
+
+    /**
+     * Creates a new APINotFoundException exception.
+     */
+    public APINotFoundException() {
+        super("Command API not set! Use CommandAPI.set(plugin) or CommandAPI.set(lifecycle event manager) to set the Command API.");
+    }
+}
diff --git a/src/main/java/dev/vansen/commandutils/exceptions/CmdException.java b/src/main/java/dev/vansen/commandutils/exceptions/CmdException.java
new file mode 100644
index 0000000000000000000000000000000000000000..bdd29a8f7b9f4dcbdd12902e7f40fa53ae69f499
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/exceptions/CmdException.java
@@ -0,0 +1,98 @@
+package dev.vansen.commandutils.exceptions;
+
+import dev.vansen.commandutils.messages.MessageTypes;
+import dev.vansen.commandutils.messages.SendType;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer;
+import org.bukkit.command.CommandException;
+import org.bukkit.command.CommandSender;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * Represents an exception that occurs during command execution.
+ * This class extends {@link CommandException} and is used to send a custom error message
+ * to a {@link CommandSender}.
+ */
+public final class CmdException extends CommandException {
+
+    /**
+     * The sender of the command to which the exception message will be sent.
+     */
+    private final @Nullable CommandSender sender;
+
+    /**
+     * The message to be sent to the command sender.
+     */
+    private @Nullable Component message;
+
+    /**
+     * The type of message to be sent to the command sender, this will only be used if the constructor is called with a message type.
+     */
+    private @Nullable SendType type;
+
+    /**
+     * The messages to be sent to the command sender, this will only be used if the constructor is called with a message type.
+     */
+    private @Nullable List<String> messages;
+
+    /**
+     * Constructs a new {@link CmdException} with the specified message and sender.
+     *
+     * @param message the detail message of the exception.
+     * @param sender  the {@link CommandSender} to whom the error message should be sent.
+     */
+    public CmdException(@Nullable String message, @Nullable CommandSender sender) {
+        super(message);
+        this.sender = sender;
+    }
+
+    /**
+     * Constructs a new {@link CmdException} with the specified message and sender.
+     *
+     * @param message the detail message of the exception.
+     * @param sender  the {@link CommandSender} to whom the error message should be sent.
+     */
+    public CmdException(@Nullable Component message, @Nullable CommandSender sender) {
+        super(PlainTextComponentSerializer.plainText().serializeOrNull(message));
+        this.message = message;
+        this.sender = sender;
+    }
+
+    /**
+     * Constructs a new {@link CmdException} with the specified message type and sender.
+     *
+     * @param message the message type of the exception.
+     * @param sender  the {@link CommandSender} to whom the error message should be sent.
+     */
+    public CmdException(@NotNull MessageTypes message, @Nullable CommandSender sender) {
+        super(message.messages().getFirst());
+        this.sender = sender;
+        this.type = message.type();
+        this.messages = message.messages();
+    }
+
+    /**
+     * Sends the exception message to the command sender.
+     * This method sends the message using the {@link CommandSender#sendRichMessage(String)} or {@link CommandSender#sendMessage(Component)} or {@link CommandSender#sendActionBar(Component)}.
+     */
+    public void send() {
+        if (sender == null) return;
+        if (type != null && messages != null) {
+            switch (type) {
+                case MESSAGE -> messages.forEach(sender::sendRichMessage);
+                case ACTION_BAR ->
+                        messages.forEach(message -> sender.sendActionBar(MiniMessage.miniMessage().deserializeOrNull(message)));
+                case BOTH -> messages.forEach(message -> {
+                    sender.sendRichMessage(message);
+                    sender.sendActionBar(MiniMessage.miniMessage().deserializeOrNull(message));
+                });
+            }
+        }
+        if (message != null) sender.sendMessage(message);
+        else if (getMessage() != null) sender.sendRichMessage(getMessage());
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/exceptions/CmdSyntaxException.java b/src/main/java/dev/vansen/commandutils/exceptions/CmdSyntaxException.java
new file mode 100644
index 0000000000000000000000000000000000000000..c5f627ed128f607d4b9152ff5140a8973217578d
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/exceptions/CmdSyntaxException.java
@@ -0,0 +1,29 @@
+package dev.vansen.commandutils.exceptions;
+
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+import io.papermc.paper.command.brigadier.MessageComponentSerializer;
+import net.kyori.adventure.text.Component;
+import org.jetbrains.annotations.NotNull;
+
+@SuppressWarnings({"unused"})
+public class CmdSyntaxException extends CommandSyntaxException {
+
+    /**
+     * Creates a new syntax exception with the given message.
+     *
+     * @param message the message to include in the exception
+     */
+    public CmdSyntaxException(@NotNull String message) {
+        super(new SimpleCommandExceptionType(MessageComponentSerializer.message().serializeOrNull(Component.text(message))), MessageComponentSerializer.message().serializeOrNull(Component.text(message)));
+    }
+
+    /**
+     * Creates a new syntax exception with the given message.
+     *
+     * @param message the message to include in the exception
+     */
+    public CmdSyntaxException(@NotNull Component message) {
+        super(new SimpleCommandExceptionType(MessageComponentSerializer.message().serializeOrNull(message)), MessageComponentSerializer.message().serializeOrNull(message));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/exceptions/UnknownArgumentException.java b/src/main/java/dev/vansen/commandutils/exceptions/UnknownArgumentException.java
new file mode 100644
index 0000000000000000000000000000000000000000..54e9c622b224667439ae6e9e3cca0b12314f1965
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/exceptions/UnknownArgumentException.java
@@ -0,0 +1,20 @@
+package dev.vansen.commandutils.exceptions;
+
+import dev.vansen.commandutils.argument.finder.ArgumentString;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * Exception thrown when an unknown argument is provided to a command (View {@link ArgumentString#types} for a list of valid arguments)
+ */
+public class UnknownArgumentException extends RuntimeException {
+
+    /**
+     * Creates a new UnknownArgumentException.
+     */
+    public UnknownArgumentException(@NotNull String argument, @NotNull List<String> validArguments) {
+        super(String.format("Unknown argument '%s'. Did you mean one of: %s?", argument, validArguments.stream().map(arg -> "* " + arg).collect(Collectors.joining("\n"))));
+    }
+}
diff --git a/src/main/java/dev/vansen/commandutils/info/Aliases.java b/src/main/java/dev/vansen/commandutils/info/Aliases.java
new file mode 100644
index 0000000000000000000000000000000000000000..36fd01380f1297c7cd8892177fc4e89e9e7240b0
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/info/Aliases.java
@@ -0,0 +1,61 @@
+package dev.vansen.commandutils.info;
+
+import java.util.List;
+
+/**
+ * Represents a collection of aliases for a command.
+ */
+@SuppressWarnings("unused")
+public final class Aliases {
+    /**
+     * The list of aliases for the command.
+     */
+    private final List<String> aliases;
+
+    /**
+     * Creates a new Aliases instance from an array of strings.
+     *
+     * @param aliases The aliases for the command.
+     */
+    public Aliases(String... aliases) {
+        this.aliases = List.of(aliases);
+    }
+
+    /**
+     * Creates a new Aliases instance from a list of strings.
+     *
+     * @param aliases The aliases for the command.
+     */
+    public Aliases(List<String> aliases) {
+        this.aliases = aliases;
+    }
+
+    /**
+     * Returns a new Aliases instance from an array of strings.
+     *
+     * @param aliases The aliases for the command.
+     * @return A new Aliases instance.
+     */
+    public static Aliases of(String... aliases) {
+        return new Aliases(aliases);
+    }
+
+    /**
+     * Returns a new Aliases instance from a list of strings.
+     *
+     * @param aliases The aliases for the command.
+     * @return A new Aliases instance.
+     */
+    public static Aliases of(List<String> aliases) {
+        return new Aliases(aliases);
+    }
+
+    /**
+     * Returns the list of aliases for the command.
+     *
+     * @return The list of aliases.
+     */
+    public List<String> getAliases() {
+        return aliases;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/info/CommandInfo.java b/src/main/java/dev/vansen/commandutils/info/CommandInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..00d8b244d936855cf5d88d712ff315fc27a0c1e5
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/info/CommandInfo.java
@@ -0,0 +1,143 @@
+package dev.vansen.commandutils.info;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dev.vansen.commandutils.permission.CommandPermission;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * Provides information about a command, including its description, aliases, and required permissions.
+ * This class is used to configure and retrieve metadata about commands.
+ */
+@SuppressWarnings("unused")
+public final class CommandInfo {
+    private @Nullable String description;
+    private @Nullable List<String> aliases;
+    private @Nullable CommandPermission permission;
+
+    /**
+     * Creates a new {@link CommandInfo} instance.
+     *
+     * @return a new {@link CommandInfo} instance.
+     */
+    @NotNull
+    public static CommandInfo info() {
+        return new CommandInfo();
+    }
+
+    /**
+     * Sets the description of the command.
+     *
+     * @param description the description of the command.
+     * @return this {@link CommandInfo} instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandInfo description(@Nullable String description) {
+        if (description == null) return this;
+        this.description = description;
+        return this;
+    }
+
+    /**
+     * Sets the aliases of the command using an array of strings.
+     *
+     * @param aliases the aliases of the command.
+     * @return this {@link CommandInfo} instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandInfo aliases(@Nullable String... aliases) {
+        if (aliases == null) return this;
+        this.aliases = List.of(aliases);
+        return this;
+    }
+
+    /**
+     * Sets the aliases of the command using a list of strings.
+     *
+     * @param aliases the list of aliases for the command.
+     * @return this {@link CommandInfo} instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandInfo aliases(@Nullable List<String> aliases) {
+        if (aliases == null) return this;
+        this.aliases = aliases;
+        return this;
+    }
+
+    /**
+     * Sets the aliases of the command using an {@link Aliases} instance.
+     *
+     * @param aliases the aliases of the command.
+     * @return this {@link CommandInfo} instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandInfo aliases(@Nullable Aliases aliases) {
+        if (aliases == null) return this;
+        this.aliases = aliases.getAliases();
+        return this;
+    }
+
+    /**
+     * Sets the required permission for the command.
+     *
+     * @param permission the {@link CommandPermission} required to execute the command.
+     * @return this {@link CommandInfo} instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandInfo permission(@Nullable CommandPermission permission) {
+        if (permission == null) return this;
+        this.permission = permission;
+        return this;
+    }
+
+    /**
+     * Sets the required permission for the command.
+     *
+     * @param permission the {@link CommandPermission} required to execute the command.
+     * @return this {@link CommandInfo} instance for method chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public CommandInfo permission(@Nullable String permission) {
+        if (permission == null) return this;
+        this.permission = CommandPermission.permission(permission);
+        return this;
+    }
+
+    /**
+     * Gets the description of the command.
+     *
+     * @return the description of the command, or {@code null} if not set.
+     */
+    @Nullable
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * Gets the list of aliases for the command.
+     *
+     * @return the list of aliases, or {@code null} if not set.
+     */
+    @Nullable
+    public List<String> getAliases() {
+        return aliases;
+    }
+
+    /**
+     * Gets the required permission for the command.
+     *
+     * @return the {@link CommandPermission} required to execute the command, or {@code null} if not set.
+     */
+    @Nullable
+    public CommandPermission getPermission() {
+        return permission;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/messages/MessageTypes.java b/src/main/java/dev/vansen/commandutils/messages/MessageTypes.java
new file mode 100644
index 0000000000000000000000000000000000000000..f716b36c6572cecad9aae8112c70116089380676
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/messages/MessageTypes.java
@@ -0,0 +1,65 @@
+package dev.vansen.commandutils.messages;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+@SuppressWarnings("unused")
+public enum MessageTypes {
+    PLAYER_EXCEPTION(List.of("<color:#ff4060>You must be a player to execute this command!</color>"), SendType.MESSAGE),
+    CONSOLE_EXCEPTION(List.of("<color:#ff4060>You must execute this command from the console!</color>"), SendType.MESSAGE),
+    REMOTE_CONSOLE_EXCEPTION(List.of("<color:#ff4060>You must execute this command as a remote console!</color>"), SendType.MESSAGE),
+    ENTITY_EXCEPTION(List.of("<color:#ff4060>You must be an entity to execute this command!</color>"), SendType.MESSAGE),
+    COMMAND_BLOCK_EXCEPTION(List.of("<color:#ff4060>This can only be executed by a command block!</color>"), SendType.MESSAGE),
+    PROXIED_SENDER_EXCEPTION(List.of("<color:#ff4060>You must be a proxied command sender to execute this command!</color>"), SendType.MESSAGE),
+    NOT_ALLOWED_PLAYER(List.of("<color:#ff4060>You are not allowed to execute this as a player!</color>"), SendType.MESSAGE),
+    NOT_ALLOWED_CONSOLE(List.of("<color:#ff4060>You are not allowed to execute this from the console!</color>"), SendType.MESSAGE),
+    NOT_ALLOWED_REMOTE_CONSOLE(List.of("<color:#ff4060>You are not allowed to execute this as a remote console!</color>"), SendType.MESSAGE),
+    NOT_ALLOWED_ENTITY(List.of("<color:#ff4060>You are not allowed to execute this as an entity!</color>"), SendType.MESSAGE),
+    NOT_ALLOWED_COMMAND_BLOCK(List.of("<color:#ff4060>You are not allowed to execute this from a command block!</color>"), SendType.MESSAGE),
+    NOT_ALLOWED_PROXIED_SENDER(List.of("<color:#ff4060>You are not allowed to execute this as a proxied command sender!</color>"), SendType.MESSAGE);
+
+    private @NotNull List<String> messages;
+    private @NotNull SendType type;
+
+    MessageTypes(@NotNull List<String> messages, @NotNull SendType type) {
+        this.messages = messages;
+        this.type = type;
+    }
+
+    /**
+     * The messages that will be sent to the command sender.
+     *
+     * @return the messages that will be sent
+     */
+    public @NotNull List<String> messages() {
+        return messages;
+    }
+
+    /**
+     * Sets the messages that will be sent to the command sender.
+     *
+     * @param messages the messages to set
+     */
+    public void messages(@NotNull List<String> messages) {
+        this.messages = messages;
+    }
+
+    /**
+     * The type of message that will be sent to the command sender.
+     *
+     * @return the type of message that will be sent
+     */
+    public @NotNull SendType type() {
+        return type;
+    }
+
+    /**
+     * Sets the type of message that will be sent to the command sender.
+     *
+     * @param type the type of message to set
+     */
+    public void type(@NotNull SendType type) {
+        this.type = type;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/messages/SendType.java b/src/main/java/dev/vansen/commandutils/messages/SendType.java
new file mode 100644
index 0000000000000000000000000000000000000000..10f7ec6c3769c4c68bcc95add4ccaae3ce2e556f
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/messages/SendType.java
@@ -0,0 +1,23 @@
+package dev.vansen.commandutils.messages;
+
+/**
+ * Represents the different types of messages that can be sent to a sender.
+ * The default is MESSAGE.
+ */
+public enum SendType {
+
+    /**
+     * Represents a message that is sent as a message to the sender.
+     */
+    MESSAGE,
+
+    /**
+     * Represents a message that is sent as an action bar to the sender.
+     */
+    ACTION_BAR,
+
+    /**
+     * Represents a message that is sent as both a message and an action bar to the sender.
+     */
+    BOTH
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/permission/CommandPermission.java b/src/main/java/dev/vansen/commandutils/permission/CommandPermission.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a1aca7ab9aa87d2951737e920ab2691ddb69e14
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/permission/CommandPermission.java
@@ -0,0 +1,91 @@
+package dev.vansen.commandutils.permission;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Represents a command permission that can either be a specific permission string or an operator (OP) level.
+ * Command permissions determine what actions a user can perform based on their permissions or OP level.
+ */
+@SuppressWarnings("unused")
+public final class CommandPermission {
+
+    /**
+     * A predefined {@link CommandPermission} representing operator (OP) permissions.
+     */
+    public static final CommandPermission OP = new CommandPermission(2);
+    private final @Nullable String permission;
+    private final int opLevel;
+
+    /**
+     * Constructs a {@link CommandPermission} with a specific permission string.
+     * This type of permission is typically used for more granular control over command access.
+     *
+     * @param permission the permission string required to execute the command.
+     */
+    public CommandPermission(@Nullable String permission) {
+        this.permission = permission;
+        this.opLevel = -1;
+    }
+
+    /**
+     * Constructs a {@link CommandPermission} with a specific operator (OP) level.
+     * This type of permission is used to represent commands that are only accessible by users with a certain OP level.
+     *
+     * @param opLevel the OP level required to execute the command.
+     */
+    public CommandPermission(int opLevel) {
+        this.permission = null;
+        this.opLevel = opLevel;
+    }
+
+    /**
+     * Factory method to create a {@link CommandPermission} based on a permission string.
+     *
+     * @param permission the permission string required to execute the command.
+     * @return a new {@link CommandPermission} instance with the specified permission string.
+     */
+    @NotNull
+    public static CommandPermission permission(@Nullable String permission) {
+        return new CommandPermission(permission);
+    }
+
+    /**
+     * Factory method to create a {@link CommandPermission} based on an operator (OP) level.
+     *
+     * @param opLevel the OP level required to execute the command.
+     * @return a new {@link CommandPermission} instance with the specified operator (OP) level.
+     */
+    @NotNull
+    public static CommandPermission op(int opLevel) {
+        return new CommandPermission(opLevel);
+    }
+
+    /**
+     * Gets the permission string associated with this {@link CommandPermission}.
+     *
+     * @return the permission string, or {@code null} if this permission is based on OP level.
+     */
+    @Nullable
+    public String getPermission() {
+        return permission;
+    }
+
+    /**
+     * Gets the OP level associated with this {@link CommandPermission}.
+     *
+     * @return the OP level, or -1 if this permission is based on a permission string.
+     */
+    public int getOpLevel() {
+        return opLevel;
+    }
+
+    /**
+     * Determines if this {@link CommandPermission} is an OP-level permission.
+     *
+     * @return {@code true} if the permission is based on OP level; {@code false} otherwise.
+     */
+    public boolean isOpPermission() {
+        return opLevel >= 0;
+    }
+}
diff --git a/src/main/java/dev/vansen/commandutils/sender/SenderTypes.java b/src/main/java/dev/vansen/commandutils/sender/SenderTypes.java
new file mode 100644
index 0000000000000000000000000000000000000000..532fb7953b347ee4bfd7e6c077250b4f62e16ecf
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/sender/SenderTypes.java
@@ -0,0 +1,139 @@
+package dev.vansen.commandutils.sender;
+
+import dev.vansen.commandutils.command.CommandWrapper;
+import dev.vansen.commandutils.exceptions.CmdException;
+import dev.vansen.commandutils.messages.MessageTypes;
+import org.bukkit.command.BlockCommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.ProxiedCommandSender;
+import org.bukkit.command.RemoteConsoleCommandSender;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+
+public enum SenderTypes {
+
+    /**
+     * Represents a player sender {@link Player}.
+     */
+    PLAYER {
+        @Override
+        public void check(CommandWrapper context) {
+            if (!context.isPlayer()) {
+                throw new CmdException(MessageTypes.PLAYER_EXCEPTION, context.sender());
+            }
+        }
+
+        @Override
+        public void check(CommandWrapper context, String message) {
+            if (!context.isPlayer()) {
+                throw new CmdException(message, context.sender());
+            }
+        }
+    },
+
+    /**
+     * Represents a console sender {@link ConsoleCommandSender}.
+     */
+    CONSOLE {
+        @Override
+        public void check(CommandWrapper context) {
+            if (!context.isConsole()) {
+                throw new CmdException(MessageTypes.CONSOLE_EXCEPTION, context.sender());
+            }
+        }
+
+        @Override
+        public void check(CommandWrapper context, String message) {
+            if (!context.isConsole()) {
+                throw new CmdException(message, context.sender());
+            }
+        }
+    },
+
+    /**
+     * Represents a remote console sender {@link RemoteConsoleCommandSender}.
+     */
+    REMOTE_CONSOLE {
+        @Override
+        public void check(CommandWrapper context) {
+            if (!context.isConsole()) {
+                throw new CmdException(MessageTypes.REMOTE_CONSOLE_EXCEPTION, context.sender());
+            }
+        }
+
+        @Override
+        public void check(CommandWrapper context, String message) {
+            if (!context.isConsole()) {
+                throw new CmdException(message, context.sender());
+            }
+        }
+    },
+
+    /**
+     * Represents an entity sender {@link Entity}.
+     */
+    ENTITY {
+        @Override
+        public void check(CommandWrapper context) {
+            if (!context.isEntity()) {
+                throw new CmdException(MessageTypes.ENTITY_EXCEPTION, context.sender());
+            }
+        }
+
+        @Override
+        public void check(CommandWrapper context, String message) {
+            if (!context.isEntity()) {
+                throw new CmdException(message, context.sender());
+            }
+        }
+    },
+
+    /**
+     * Represents a command block sender {@link BlockCommandSender}.
+     */
+    COMMAND_BLOCK {
+        @Override
+        public void check(CommandWrapper context) {
+            if (!context.isBlock()) {
+                throw new CmdException(MessageTypes.COMMAND_BLOCK_EXCEPTION, context.sender());
+            }
+        }
+
+        @Override
+        public void check(CommandWrapper context, String message) {
+            if (!context.isBlock()) {
+                throw new CmdException(message, context.sender());
+            }
+        }
+    },
+
+    /**
+     * Represents a proxied sender {@link ProxiedCommandSender}.
+     */
+    PROXIED {
+        @Override
+        public void check(CommandWrapper context) {
+            if (!context.isProxied()) {
+                throw new CmdException(MessageTypes.PROXIED_SENDER_EXCEPTION, context.sender());
+            }
+        }
+
+        @Override
+        public void check(CommandWrapper context, String message) {
+            if (!context.isProxied()) {
+                throw new CmdException(message, context.sender());
+            }
+        }
+    },
+
+    /**
+     * Represents an unknown command sender.
+     */
+    UNKNOWN;
+
+    public void check(CommandWrapper context) {
+    }
+
+    public void check(CommandWrapper context, String message) {
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/subcommand/AbstractSubCommand.java b/src/main/java/dev/vansen/commandutils/subcommand/AbstractSubCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..10ef4c94bbb9c1e00cb638f3e835488870ea802f
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/subcommand/AbstractSubCommand.java
@@ -0,0 +1,176 @@
+package dev.vansen.commandutils.subcommand;
+
+import dev.vansen.commandutils.argument.AbstractCommandArgument;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.command.CommandWrapper;
+import dev.vansen.commandutils.command.ExecutableSender;
+import dev.vansen.commandutils.command.Position;
+import dev.vansen.commandutils.permission.CommandPermission;
+import dev.vansen.commandutils.sender.SenderTypes;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+/**
+ * This is generally not recommended to use, since it limits the ability to nest arguments, and it is generally recommended to use {@link SimpleSubCommand} since it allows easier subcommand management, and saves alot of time in coding.
+ */
+public abstract class AbstractSubCommand {
+
+    private final String name;
+
+    public AbstractSubCommand(@NotNull String name) {
+        this.name = name;
+    }
+
+    public SenderTypes[] senderTypes() {
+        return null;
+    }
+
+    public void execute(@NotNull CommandWrapper context) {
+    }
+
+    public void playerExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void consoleExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void remoteConsoleExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void entityExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void blockExecute(@NotNull CommandWrapper context) {
+    }
+
+    public void proxiedExecute(@NotNull CommandWrapper context) {
+    }
+
+    public CommandPermission permission() {
+        return null;
+    }
+
+    public List<CommandArgument> arguments() {
+        return List.of();
+    }
+
+    public List<AbstractCommandArgument> abstractArguments() {
+        return List.of();
+    }
+
+    public List<SubCommand> subCommands() {
+        return List.of();
+    }
+
+    public List<AbstractSubCommand> abstractSubCommands() {
+        return List.of();
+    }
+
+    @NotNull
+    public Position argumentPosition() {
+        return Position.LAST; // adds argument at the last.
+    }
+
+    @NotNull
+    public Position abstractArgumentPosition() {
+        return Position.LAST; // adds abstract arguments at the last.
+    }
+
+    @NotNull
+    public Position abstractSubCommandPosition() {
+        return Position.LAST; // adds abstract subcommands at the last.
+    }
+
+    @ApiStatus.NonExtendable
+    public SubCommand build() {
+        SubCommand sub = SubCommand.of(name);
+
+        try {
+            Method executeMethod = this.getClass().getDeclaredMethod("execute", CommandWrapper.class);
+            Method superExecuteMethod = AbstractSubCommand.class.getDeclaredMethod("execute", CommandWrapper.class);
+            if (!executeMethod.equals(superExecuteMethod)) {
+                if (senderTypes() != null) {
+                    sub.defaultExecute(this::execute, ExecutableSender.types(senderTypes()));
+                } else {
+                    sub.defaultExecute(this::execute);
+                }
+            }
+
+            Method playerExecuteMethod = this.getClass().getDeclaredMethod("playerExecute", CommandWrapper.class);
+            Method superPlayerExecuteMethod = AbstractSubCommand.class.getDeclaredMethod("playerExecute", CommandWrapper.class);
+            if (!playerExecuteMethod.equals(superPlayerExecuteMethod)) {
+                sub.playerExecute(this::playerExecute);
+            }
+
+            Method consoleExecuteMethod = this.getClass().getDeclaredMethod("consoleExecute", CommandWrapper.class);
+            Method superConsoleExecuteMethod = AbstractSubCommand.class.getDeclaredMethod("consoleExecute", CommandWrapper.class);
+            if (!consoleExecuteMethod.equals(superConsoleExecuteMethod)) {
+                sub.consoleExecute(this::consoleExecute);
+            }
+
+            Method remoteConsoleExecuteMethod = this.getClass().getDeclaredMethod("remoteConsoleExecute", CommandWrapper.class);
+            Method superRemoteConsoleExecuteMethod = AbstractSubCommand.class.getDeclaredMethod("remoteConsoleExecute", CommandWrapper.class);
+            if (!remoteConsoleExecuteMethod.equals(superRemoteConsoleExecuteMethod)) {
+                sub.remoteConsoleExecute(this::remoteConsoleExecute);
+            }
+
+            Method entityExecuteMethod = this.getClass().getDeclaredMethod("entityExecute", CommandWrapper.class);
+            Method superEntityExecuteMethod = AbstractSubCommand.class.getDeclaredMethod("entityExecute", CommandWrapper.class);
+            if (!entityExecuteMethod.equals(superEntityExecuteMethod)) {
+                sub.entityExecute(this::entityExecute);
+            }
+
+            Method blockExecuteMethod = this.getClass().getDeclaredMethod("blockExecute", CommandWrapper.class);
+            Method superBlockExecuteMethod = AbstractSubCommand.class.getDeclaredMethod("blockExecute", CommandWrapper.class);
+            if (!blockExecuteMethod.equals(superBlockExecuteMethod)) {
+                sub.blockExecute(this::blockExecute);
+            }
+
+            Method proxiedExecuteMethod = this.getClass().getDeclaredMethod("proxiedExecute", CommandWrapper.class);
+            Method superProxiedExecuteMethod = AbstractSubCommand.class.getDeclaredMethod("proxiedExecute", CommandWrapper.class);
+            if (!proxiedExecuteMethod.equals(superProxiedExecuteMethod)) {
+                sub.proxiedExecute(this::proxiedExecute);
+            }
+        } catch (NoSuchMethodException ignored) {
+        }
+
+        if (permission() != null) sub.permission(permission());
+
+        if (argumentPosition() == Position.LAST) {
+            if (abstractSubCommandPosition() == Position.LAST) {
+                subCommands().forEach(sub::subCommand);
+                abstractSubCommands().forEach(sub::subCommand);
+            } else {
+                abstractSubCommands().forEach(sub::subCommand);
+                subCommands().forEach(sub::subCommand);
+            }
+            if (abstractArgumentPosition() == Position.LAST) {
+                arguments().forEach(sub::argument);
+                abstractArguments().forEach(sub::argument);
+            } else {
+                abstractArguments().forEach(sub::argument);
+                arguments().forEach(sub::argument);
+            }
+        } else {
+            if (abstractArgumentPosition() == Position.LAST) {
+                arguments().forEach(sub::argument);
+                abstractArguments().forEach(sub::argument);
+            } else {
+                abstractArguments().forEach(sub::argument);
+                arguments().forEach(sub::argument);
+            }
+            if (abstractSubCommandPosition() == Position.LAST) {
+                subCommands().forEach(sub::subCommand);
+                abstractSubCommands().forEach(sub::subCommand);
+            } else {
+                abstractSubCommands().forEach(sub::subCommand);
+                subCommands().forEach(sub::subCommand);
+            }
+        }
+
+        return sub;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/subcommand/SimpleSubCommand.java b/src/main/java/dev/vansen/commandutils/subcommand/SimpleSubCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..bd2e7c205c3e7d777072e916b80556b9a66f55cf
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/subcommand/SimpleSubCommand.java
@@ -0,0 +1,322 @@
+package dev.vansen.commandutils.subcommand;
+
+import dev.vansen.commandutils.argument.AbstractCommandArgument;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.command.CommandExecutor;
+import dev.vansen.commandutils.command.ExecutableSender;
+import dev.vansen.commandutils.command.Position;
+import dev.vansen.commandutils.permission.CommandPermission;
+import dev.vansen.commandutils.sender.SenderTypes;
+import org.bukkit.command.BlockCommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * Represents a subcommand in a command.
+ * Subcommands are individual command branches with their own execution logic and arguments.
+ */
+@SuppressWarnings("unused")
+public class SimpleSubCommand {
+    private final String name;
+    private CommandExecutor defaultExecutor;
+    private CommandExecutor playerExecutor;
+    private CommandExecutor consoleExecutor;
+    private CommandExecutor remoteConsoleExecutor;
+    private CommandExecutor entityExecutor;
+    private CommandExecutor blockExecutor;
+    private CommandExecutor proxiedExecutor;
+    private CommandPermission permission;
+    private List<CommandArgument> arguments;
+    private List<AbstractCommandArgument> abstractArguments;
+    private List<SubCommand> subCommands;
+    private List<AbstractSubCommand> abstractSubCommands;
+    private Position argumentPosition;
+    private Position abstractArgumentPosition;
+    private Position abstractSubCommandPosition;
+    private SenderTypes[] senderTypes;
+
+    /**
+     * Constructs a new SimpleSubCommand with the specified name.
+     *
+     * @param name the name of the subcommand.
+     */
+    public SimpleSubCommand(@NotNull String name) {
+        this.name = name;
+    }
+
+    /**
+     * Sets the default executor for this subcommand.
+     * This executor is used if no other specific executor is matched for the sender type.
+     *
+     * @param executor the {@link CommandExecutor} to be executed by default.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand execute(@NotNull CommandExecutor executor) {
+        this.defaultExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the default executor for this subcommand, along with the sender types it applies to.
+     *
+     * @param executor    the {@link CommandExecutor} to be executed by default.
+     * @param senderTypes the {@link SenderTypes} that the executor applies to.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    public SimpleSubCommand execute(@NotNull CommandExecutor executor, SenderTypes... senderTypes) {
+        this.defaultExecutor = executor;
+        this.senderTypes = senderTypes;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a {@link Player}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for players.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand playerExecute(@NotNull CommandExecutor executor) {
+        this.playerExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a {@link ConsoleCommandSender}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for console senders.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand consoleExecute(@NotNull CommandExecutor executor) {
+        this.consoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a {@link org.bukkit.command.RemoteConsoleCommandSender}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for console senders.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand remoteConsoleExecute(@NotNull CommandExecutor executor) {
+        this.remoteConsoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is an {@link Entity}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for entities.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand entityExecute(@NotNull CommandExecutor executor) {
+        this.entityExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a {@link BlockCommandSender}.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for block senders.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand blockExecute(@NotNull CommandExecutor executor) {
+        this.blockExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for this subcommand, but only if the sender is a proxied sender.
+     *
+     * @param executor the {@link CommandExecutor} to be executed for proxied senders.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand proxiedExecute(@NotNull CommandExecutor executor) {
+        this.proxiedExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the permission required for executing this subcommand.
+     *
+     * @param permission the {@link CommandPermission} required for executing this subcommand.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand permission(@NotNull CommandPermission permission) {
+        this.permission = permission;
+        return this;
+    }
+
+    /**
+     * Sets the arguments for this subcommand.
+     *
+     * @param arguments the list of {@link CommandArgument} for this subcommand.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand arguments(@NotNull List<CommandArgument> arguments) {
+        this.arguments = arguments;
+        return this;
+    }
+
+    /**
+     * Sets the abstract arguments for this subcommand.
+     *
+     * @param abstractArguments the list of {@link AbstractCommandArgument} for this subcommand.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand abstractArguments(@NotNull List<AbstractCommandArgument> abstractArguments) {
+        this.abstractArguments = abstractArguments;
+        return this;
+    }
+
+    /**
+     * Sets the subcommands for this subcommand.
+     *
+     * @param subCommands the list of {@link SubCommand} to be used as subcommands.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand subCommands(@NotNull List<SubCommand> subCommands) {
+        this.subCommands = subCommands;
+        return this;
+    }
+
+    /**
+     * Sets the abstract subcommands for this subcommand.
+     *
+     * @param abstractSubCommands the list of {@link AbstractSubCommand} to be used as abstract subcommands.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand abstractSubCommands(@NotNull List<AbstractSubCommand> abstractSubCommands) {
+        this.abstractSubCommands = abstractSubCommands;
+        return this;
+    }
+
+    /**
+     * Sets the position of the arguments for this subcommand.
+     *
+     * @param position the {@link Position} of the arguments.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand argumentPosition(@NotNull Position position) {
+        this.argumentPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the position of the abstract arguments for this subcommand.
+     *
+     * @param position the {@link Position} of the abstract arguments.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand abstractArgumentPosition(@NotNull Position position) {
+        this.abstractArgumentPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the position of the abstract subcommands for this subcommand.
+     *
+     * @param position the {@link Position} of the abstract subcommands.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand abstractSubCommandPosition(@NotNull Position position) {
+        this.abstractSubCommandPosition = position;
+        return this;
+    }
+
+    /**
+     * Sets the sender types allowed to execute this subcommand.
+     *
+     * @param senderTypes the allowed {@link SenderTypes} for this subcommand.
+     * @return the current {@link SimpleSubCommand} instance for chaining.
+     */
+    @ApiStatus.NonExtendable
+    public SimpleSubCommand senderTypes(SenderTypes... senderTypes) {
+        this.senderTypes = senderTypes;
+        return this;
+    }
+
+    /**
+     * Builds and returns a {@link SubCommand} with the specified configurations set on this {@link SimpleSubCommand}.
+     *
+     * @return a fully configured {@link SubCommand} instance.
+     */
+    @ApiStatus.NonExtendable
+    public SubCommand build() {
+        SubCommand subCommand = SubCommand.of(name);
+
+        if (senderTypes != null) subCommand.senderTypes(ExecutableSender.types(senderTypes));
+        if (defaultExecutor != null) subCommand.defaultExecute(defaultExecutor);
+        if (playerExecutor != null) subCommand.playerExecute(playerExecutor);
+        if (consoleExecutor != null) subCommand.consoleExecute(consoleExecutor);
+        if (remoteConsoleExecutor != null) subCommand.remoteConsoleExecute(remoteConsoleExecutor);
+        if (entityExecutor != null) subCommand.entityExecute(entityExecutor);
+        if (blockExecutor != null) subCommand.blockExecute(blockExecutor);
+        if (proxiedExecutor != null) subCommand.proxiedExecute(proxiedExecutor);
+
+        if (permission != null) subCommand.permission(permission);
+
+        if (argumentPosition == Position.LAST) {
+            if (abstractSubCommandPosition == Position.LAST) {
+                if (subCommands != null) subCommands.forEach(subCommand::subCommand);
+                if (abstractSubCommands != null) abstractSubCommands.forEach(subCommand::subCommand);
+            } else {
+                if (abstractSubCommands != null) abstractSubCommands.forEach(subCommand::subCommand);
+                if (subCommands != null) subCommands.forEach(subCommand::subCommand);
+            }
+            if (abstractArgumentPosition == Position.LAST) {
+                if (arguments != null) arguments.forEach(subCommand::argument);
+                if (abstractArguments != null) abstractArguments.forEach(subCommand::argument);
+            } else {
+                if (abstractArguments != null) abstractArguments.forEach(subCommand::argument);
+                if (arguments != null) arguments.forEach(subCommand::argument);
+            }
+        } else {
+            if (abstractArgumentPosition == Position.LAST) {
+                if (arguments != null) arguments.forEach(subCommand::argument);
+                if (abstractArguments != null) abstractArguments.forEach(subCommand::argument);
+            } else {
+                if (abstractArguments != null) abstractArguments.forEach(subCommand::argument);
+                if (arguments != null) arguments.forEach(subCommand::argument);
+            }
+            if (abstractSubCommandPosition == Position.LAST) {
+                if (subCommands != null) subCommands.forEach(subCommand::subCommand);
+                if (abstractSubCommands != null) abstractSubCommands.forEach(subCommand::subCommand);
+            } else {
+                if (abstractSubCommands != null) abstractSubCommands.forEach(subCommand::subCommand);
+                if (subCommands != null) subCommands.forEach(subCommand::subCommand);
+            }
+        }
+
+        return subCommand;
+    }
+
+    /**
+     * Gets the name of this subcommand.
+     *
+     * @return the name of this subcommand.
+     */
+    @ApiStatus.NonExtendable
+    public String name() {
+        return name;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/vansen/commandutils/subcommand/SubCommand.java b/src/main/java/dev/vansen/commandutils/subcommand/SubCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..bf758a71cd1326a4f76b96a839d6711f2a6cc8a3
--- /dev/null
+++ b/src/main/java/dev/vansen/commandutils/subcommand/SubCommand.java
@@ -0,0 +1,741 @@
+package dev.vansen.commandutils.subcommand;
+
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import dev.vansen.commandutils.CommandUtils;
+import dev.vansen.commandutils.argument.AbstractCommandArgument;
+import dev.vansen.commandutils.argument.Argument;
+import dev.vansen.commandutils.argument.ArgumentNester;
+import dev.vansen.commandutils.argument.CommandArgument;
+import dev.vansen.commandutils.argument.finder.ArgumentString;
+import dev.vansen.commandutils.command.CommandExecutor;
+import dev.vansen.commandutils.command.*;
+import dev.vansen.commandutils.completer.CompletionHandler;
+import dev.vansen.commandutils.completer.SuggestionsBuilderWrapper;
+import dev.vansen.commandutils.exceptions.CmdException;
+import dev.vansen.commandutils.messages.MessageTypes;
+import dev.vansen.commandutils.permission.CommandPermission;
+import dev.vansen.commandutils.sender.SenderTypes;
+import io.papermc.paper.command.brigadier.CommandSourceStack;
+import org.bukkit.command.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+
+/**
+ * Represents a subcommand in a command.
+ * Subcommands are individual command branches with their own execution logic and arguments.
+ */
+@SuppressWarnings({"unused"})
+public final class SubCommand {
+
+    private final LiteralArgumentBuilder<CommandSourceStack> builder;
+    private final List<RequiredArgumentBuilder<CommandSourceStack, ?>> argumentStack = new ArrayList<>();
+    private boolean nest = true;
+    private CommandExecutor defaultExecutor;
+    private CommandExecutor playerExecutor;
+    private CommandExecutor consoleExecutor;
+    private CommandExecutor remoteConsoleExecutor;
+    private CommandExecutor entityExecutor;
+    private CommandExecutor blockExecutor;
+    private CommandExecutor proxiedExecutor;
+    private SenderTypes[] senderTypes = null;
+
+    /**
+     * Constructs a new subcommand with the specified name.
+     *
+     * @param name the name of the subcommand.
+     */
+    public SubCommand(@NotNull String name) {
+        this.builder = LiteralArgumentBuilder.literal(name);
+    }
+
+    /**
+     * Factory method to create a new instance of {@link SubCommand}.
+     *
+     * @param name the name of the subcommand.
+     * @return a new {@link SubCommand} instance.
+     */
+    @NotNull
+    public static SubCommand of(@NotNull String name) {
+        return new SubCommand(name);
+    }
+
+    private void execute() {
+        builder.executes(context -> {
+            CommandSender sender = context.getSource().getSender();
+            CommandWrapper wrapped = new CommandWrapper(context);
+            boolean done = false;
+
+            try {
+                switch (sender) {
+                    case Player player when playerExecutor != null -> {
+                        done = true;
+                        playerExecutor.execute(wrapped);
+                    }
+                    case ConsoleCommandSender consoleCommandSender when consoleExecutor != null -> {
+                        done = true;
+                        consoleExecutor.execute(wrapped);
+                    }
+                    case RemoteConsoleCommandSender remoteConsoleCommandSender when remoteConsoleExecutor != null -> {
+                        done = true;
+                        remoteConsoleExecutor.execute(wrapped);
+                    }
+                    case BlockCommandSender blockCommandSender when blockExecutor != null -> {
+                        done = true;
+                        blockExecutor.execute(wrapped);
+                    }
+                    default -> {
+                        switch (context.getSource().getExecutor()) {
+                            case Entity entity when entityExecutor != null -> {
+                                done = true;
+                                entityExecutor.execute(wrapped);
+                            }
+                            case ProxiedCommandSender proxiedCommandSender when proxiedExecutor != null -> {
+                                done = true;
+                                proxiedExecutor.execute(wrapped);
+                            }
+                            case null, default -> {
+                            }
+                        }
+                    }
+                }
+                if (!done) {
+                    Optional.ofNullable(defaultExecutor)
+                            .ifPresent(executor -> {
+                                if (senderTypes == null) executor.execute(wrapped);
+                                else if (Arrays.stream(senderTypes)
+                                        .anyMatch(type -> type == wrapped.senderType()))
+                                    executor.execute(wrapped);
+                                else {
+                                    switch (wrapped.senderType()) {
+                                        case PLAYER -> wrapped.response(MessageTypes.NOT_ALLOWED_PLAYER);
+                                        case CONSOLE -> wrapped.response(MessageTypes.NOT_ALLOWED_CONSOLE);
+                                        case REMOTE_CONSOLE ->
+                                                wrapped.response(MessageTypes.NOT_ALLOWED_REMOTE_CONSOLE);
+                                        case ENTITY -> wrapped.response(MessageTypes.NOT_ALLOWED_ENTITY);
+                                        case COMMAND_BLOCK -> wrapped.response(MessageTypes.NOT_ALLOWED_COMMAND_BLOCK);
+                                        case PROXIED -> wrapped.response(MessageTypes.NOT_ALLOWED_PROXIED_SENDER);
+                                    }
+                                }
+                            });
+                }
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+    }
+
+    private void executeIf() {
+        if (defaultExecutor != null || playerExecutor != null || consoleExecutor != null || remoteConsoleExecutor != null || entityExecutor != null || blockExecutor != null || proxiedExecutor != null) {
+            execute();
+        }
+    }
+
+    /**
+     * Sets the default executor for the command, which is called when the subcommand
+     * is executed without any arguments/other subcommands or when no other execution path is matched.
+     *
+     * @param executor the {@link CommandExecutor} to be executed by default.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand defaultExecute(@NotNull CommandExecutor executor) {
+        defaultExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the default executor for the command, which is called when the subcommand
+     * is executed without any arguments/other subcommands or when no other execution path is matched.
+     * If the command sender is not in the sender types, the executor is not called either.
+     *
+     * @param executor    the {@link CommandExecutor} to be executed by default.
+     * @param senderTypes the {@link SenderTypes} of the sender.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand defaultExecute(@NotNull CommandExecutor executor, @NotNull ExecutableSender senderTypes) {
+        defaultExecutor = executor;
+        this.senderTypes = senderTypes.types();
+        return this;
+    }
+
+    /**
+     * Sets the sender types for the command.
+     *
+     * @param types the {@link SenderTypes} of the sender.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand senderTypes(@NotNull ExecutableSender types) {
+        this.senderTypes = types.types();
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link Player}.
+     * If the sender is not a player, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a player.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand playerExecute(@NotNull CommandExecutor executor) {
+        playerExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link ConsoleCommandSender}.
+     * If the sender is not a console, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a console.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand consoleExecute(@NotNull CommandExecutor executor) {
+        consoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link RemoteConsoleCommandSender}.
+     * If the sender is not a remote console, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a remote console.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand remoteConsoleExecute(@NotNull CommandExecutor executor) {
+        remoteConsoleExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is an {@link Entity}.
+     * If the sender is not an entity, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is an entity.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand entityExecute(@NotNull CommandExecutor executor) {
+        entityExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link BlockCommandSender}.
+     * If the sender is not a command block, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a block.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand blockExecute(@NotNull CommandExecutor executor) {
+        blockExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Sets the executor for the command, but only if the {@link CommandSender} is a {@link ProxiedCommandSender}.
+     * If the sender is not a proxied sender, the executor is not called.
+     *
+     * @param executor the {@link CommandExecutor} to be executed if the sender is a proxied player.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand proxiedExecute(@NotNull CommandExecutor executor) {
+        proxiedExecutor = executor;
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param argument the {@link CommandArgument}
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull CommandArgument argument) {
+        argumentStack.add(argument.get());
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param argument the {@link AbstractCommandArgument}
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull AbstractCommandArgument argument) {
+        argumentStack.add(argument.build().get());
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param argument the {@link Argument}
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull Argument argument, @NotNull CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param argument the {@link Argument}
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull Argument argument, @NotNull CommandExecutor executor) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param argument the {@link Argument}
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull Argument argument, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(argument.name(), argument.type());
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        }).suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull ArgumentType<?> type, @NotNull String name) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CommandExecutor executor) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull ArgumentType<?> type, @NotNull String name, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        RequiredArgumentBuilder<CommandSourceStack, ?> arg = RequiredArgumentBuilder.argument(name, type);
+        arg.executes(context -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            try {
+                executor.execute(wrapped);
+                return 1;
+            } catch (CmdException e) {
+                e.send();
+                return 0;
+            }
+        }).suggests((context, builder) -> {
+            CommandWrapper wrapped = new CommandWrapper(context);
+            SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+            return handler.complete(wrapped, wrapper);
+        });
+        argumentStack.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull ArgumentType<?> type) {
+        return argument(type, name);
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull ArgumentType<?> type, CompletionHandler handler) {
+        return argument(type, name, handler);
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CommandExecutor executor) {
+        return argument(type, name, executor);
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull ArgumentType<?> type, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        return argument(type, name, executor, handler);
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type the type of the argument.
+     * @param name the name of the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull String type) {
+        return argument(type, ArgumentString.fromString(name));
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type    the type of the argument.
+     * @param name    the name of the argument.
+     * @param handler the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull String type, CompletionHandler handler) {
+        return argument(type, ArgumentString.fromString(name), handler);
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @return this {@link CommandUtils} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull String type, @NotNull CommandExecutor executor) {
+        return argument(type, ArgumentString.fromString(name), executor);
+    }
+
+    /**
+     * Adds an argument to the subcommand.
+     *
+     * @param type     the type of the argument.
+     * @param name     the name of the argument.
+     * @param executor the {@link CommandExecutor} to be executed when the argument is provided.
+     * @param handler  the {@link CompletionHandler} for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand argument(@NotNull String name, @NotNull String type, @NotNull CommandExecutor executor, CompletionHandler handler) {
+        return argument(type, ArgumentString.fromString(name), executor, handler);
+    }
+
+    /**
+     * Adds a subcommand to the subcommand.
+     * Subcommands are separate execution paths that have their own logic.
+     *
+     * @param subCommand the {@link SubCommand} to be added.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand subCommand(@NotNull SubCommand subCommand) {
+        builder.then(subCommand.get());
+        return this;
+    }
+
+    /**
+     * Adds a subcommand to the subcommand.
+     * Subcommands are separate execution paths that have their own logic.
+     *
+     * @param subCommand the {@link AbstractSubCommand} to be added.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand subCommand(@NotNull AbstractSubCommand subCommand) {
+        builder.then(subCommand.build().get());
+        return this;
+    }
+
+    /**
+     * Disables argument nesting for the subcommand.
+     * <p>
+     * Note, disabling this (may) have 2 or even more arguments in a single argument, which is not recommended.
+     * So it would be "/command [arg1 | arg2 | arg3]" instead of "/command arg1 arg2 arg3", there are other unexpected results as well, for example arguments not working.
+     * <p>
+     * Some cases where this would work would be using {@link CommandArgument} and {@link CommandArgument#argument(CommandArgument)}, but if disabled nesting in command arguments will lead to it not working.
+     *
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand noNest() {
+        nest = false;
+        return this;
+    }
+
+    /**
+     * Adds a completion handler to the last argument added to the subcommand.
+     *
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand completion(@NotNull CompletionHandler handler) {
+        argumentStack.getLast()
+                .suggests((context, builder) -> {
+                    CommandWrapper wrapped = new CommandWrapper(context);
+                    SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                    return handler.complete(wrapped, wrapper);
+                });
+        return this;
+    }
+
+    /**
+     * Adds a completion handler to the first or last argument added to the subcommand.
+     *
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand completion(@NotNull Position position, @NotNull CompletionHandler handler) {
+        switch (position) {
+            case Position.FIRST -> argumentStack.getFirst()
+                    .suggests((context, builder) -> {
+                        CommandWrapper wrapped = new CommandWrapper(context);
+                        SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                        return handler.complete(wrapped, wrapper);
+                    });
+            case Position.LAST -> argumentStack.getLast()
+                    .suggests((context, builder) -> {
+                        CommandWrapper wrapped = new CommandWrapper(context);
+                        SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                        return handler.complete(wrapped, wrapper);
+                    });
+        }
+        return this;
+    }
+
+    /**
+     * Adds a completion handler to the argument at the specified index.
+     *
+     * @param index   the index of the argument to add the completion handler to.
+     * @param handler the {@link CompletionHandler} completion handler for the argument.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand completion(int index, @NotNull CompletionHandler handler) {
+        argumentStack.get(index)
+                .suggests((context, builder) -> {
+                    CommandWrapper wrapped = new CommandWrapper(context);
+                    SuggestionsBuilderWrapper wrapper = new SuggestionsBuilderWrapper(builder);
+                    return handler.complete(wrapped, wrapper);
+                });
+        return this;
+    }
+
+    /**
+     * Adds a permission requirement to the subcommand.
+     *
+     * @param permission the {@link CommandPermission} to be added.
+     * @return this {@link SubCommand} instance for chaining.
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand permission(@NotNull CommandPermission permission) {
+        if (permission.isOpPermission()) {
+            builder.requires(consumer -> consumer.getSender().isOp());
+        } else if (permission.getPermission() != null) {
+            builder.requires(consumer -> consumer.getSender().hasPermission(permission.getPermission()));
+        }
+        return this;
+    }
+
+    /**
+     * The requirement of the subcommand, if the requirement is not met the subcommand will not execute, and not show in tab complete either.
+     *
+     * @param requirement the {@link Predicate} for the requirement
+     * @return this {@link SubCommand} instance for chaining
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand requirement(@NotNull Predicate<CommandRequirement> requirement) {
+        builder.requires(consumer -> requirement.test(new CommandRequirement(consumer)));
+        return this;
+    }
+
+    /**
+     * The requirement of the subcommand, if the requirement is not met the subcommand will not execute, and not show in tab complete either.
+     *
+     * @param checker the {@link BooleanChecker} for the requirement
+     * @return this {@link SubCommand} instance for chaining
+     */
+    @NotNull
+    @CanIgnoreReturnValue
+    public SubCommand requirement(@NotNull BooleanChecker checker) {
+        builder.requires(consumer -> checker.check());
+        return this;
+    }
+
+    /**
+     * Retrieves the {@link LiteralArgumentBuilder} for this subcommand.
+     *
+     * @return the {@link LiteralArgumentBuilder} representing the subcommand.
+     */
+    @NotNull
+    public LiteralArgumentBuilder<CommandSourceStack> get() {
+        executeIf();
+        if (nest) ArgumentNester.nest(argumentStack, builder);
+        return builder;
+    }
+}
\ No newline at end of file
